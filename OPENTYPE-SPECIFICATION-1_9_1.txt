Tell us about your PDF experience.

Microsoft Typography
documentation
Microsoft Typography group researches and develops font technologies and supports the
development of OpenType fonts by independent type vendors.

Microsoft Typography
Develop fonts, find existing fonts, and license fonts from registered vendors.

Microsoft Typography

Fonts and typefaces

What is Microsoft Typography?

Font library
Windows 10 font list
Redistribution FAQ
Registered font vendors
Register as a font vendor

OpenType font development

OpenType spec

What is OpenType font?

Latest (1.9.1)

Character design standards

OpenType font file

Font variations

Advanced typographic extensions

Glyph processing

OpenType layout common table formats

Word recognition

What is OpenType Font Variations?
OpenType Font Variations common table formats

ClearType

Legacy font technologies

What is ClearType?

What is TrueType?

Backwards compatibility

History of TrueType

ClearType font collection

Font tools
Visual OpenType Layout Tool (VOLT)
Microsoft Visual TrueType (VTT)
OpenType font signing tool

About Microsoft Typography
Article • 06/10/2020

Microsoft's Typography group researches and develops fonts and font technologies, and
supports the development of TrueType and OpenType fonts by independent type
vendors. Our goal is to make text highly legible, in any language, and on any device.
The purpose of the Microsoft Typography Web site is to explain the benefits and
features of OpenType and TrueType, the world's most popular digital font formats, used
by millions of computer users every day. We aim to bring you news of exciting
developments in digital typography. Developers will find an extensive collection of
articles and specifications to help them create TrueType and OpenType fonts, and
develop applications that use them.

History of typography at Microsoft
Fonts and software have always gone hand in hand, and at Microsoft in the early days
that was certainly the case. In the beginning there really wasn't a dedicated typography
group, but Microsoft was starting to make software that required fonts. One such
project was Windows. Windows needed bitmap fonts for the user interface and also to
represent printer-resident fonts on screen. Microsoft originally worked with Bitstream, a
company founded by former Linotype employees. Microsoft licensed bitmap fonts from
Bitstream, but made significant modifications to them. The first Windows user interface
font was "SysFixed" the fixed-pitch bitmap font included with Windows 1. Windows 2
added support for the proportional bitmap font "System". Later the bitmap fonts MS
Serif and MS Sans Serif were created. It soon became apparent, however, that outline
fonts would be the future, and Apple's TrueType outline font format was picked. It was at
that point, in the run up to the release of Windows 3.1, and the first typography group
"Systems Type and Text" (STAT) was formed, later the group was renamed the Windows
Accessory Group (WAG).
The basic charter of these groups was to acquire outlines, and produce fonts to ship
with Windows. Outlines were acquired from Monotype and Bigelow and Holmes, and
then the real work began -- implementing support for the format and "hinting" the
fonts so that they could be rendered on screen at small sizes. Not content with
producing a set of core fonts for Windows, the team set to work on producing a fontpack that would be sold alongside Windows 3.1. Microsoft hired industry veteran Robert
Norton to help source fonts for the packs. The Microsoft Font Pack, and a later Font
Pack 2, were incredibly successful, with a large proportion of new Windows users
licensing them.

As the company grew, the font group evolved into a service group for the entire
company, producing fonts for Office, Windows CE, games and other products. Microsoft
has employed in-house type designers in the past, the most prominent being Vincent
Connare, who designed Trebuchet and Comic Sans before leaving Microsoft in 1999, but
the company has traditionally relied on outside talent for type design. In 1997 Microsoft
Typography became part of the Windows International team, and the focus shifted to
the international space. A year or so later, half the team were spun off to form the
ClearType group, which later emerged as the Advanced Reading Technologies (ART)
team. The remaining people continued to produce fonts for Windows and other
products.
Currently the core team consists of five program managers, who work with a range of
vendors on a variety of font production projects, and who also manage the Microsoft
Typography Web site, the OpenType specification, and Microsoft's relationship with the
font design community. Alongside the team sits the Font Technology group, a team
responsible for complex-script shaping engines and the new font-management services
in Windows. The ART team remains active in research, maintaining the font rasterizers
and making showcase fonts, including the ClearType Collection fonts and more recently
Gabriola.

Font library
08/05/2025

A
Abadi MT
Agency FB
Aharoni Bold
Aldhabi
Algerian
Almanac MT
American Uncial
Andale Mono
Andalus
Andy
AngsanaUPC
Angsana New
Aparajita
Aptos
Arabic Transparent
Arabic Typesetting
Arial
Arial Black
Arial Narrow
Arial Narrow Special
Arial Nova
Arial Rounded MT
Arial Special
Arial Unicode MS
Augsburger Initials
Avenir Next LT Pro

B
Bahnschrift
Baskerville Old Face
Batang & BatangChe
Bauhaus 93
Beesknees ITC

Bell MT
Bembo
Berlin Sans FB
Bernard MT Condensed
Bickley Script
Biome
BIZ UDGothic
BIZ UDMincho Medium
Blackadder ITC
Bodoni MT
Bodoni MT Condensed
Bon Apetit MT
Bookman Old Style
Bookshelf Symbol
Book Antiqua
Bradley Hand ITC
Braggadocio
BriemScript
Britannic Bold
Broadway
BrowalliaUPC
Browallia New
Brush Script MT

C
Calibri
Californian FB
Calisto MT
Cambria
Candara
Cariadings
Castellar
Cavolini
Centaur
Century
Century Gothic
Century Schoolbook
Chiller
Colonna MT

Comic Sans MS
Consolas
Constantia
Contemporary Brush
Cooper Black
Copperplate Gothic
Corbel
CordiaUPC
Cordia New
Courier New
Curlz MT

D
Dante
DaunPenh
David
Daytona
Desdemona
DFKai-SB
DilleniaUPC
Directions MT
DokChampa
Dotum & DotumChe

E
Ebrima
Eckmann
Edda
Edwardian Script ITC
Elephant
Engravers MT
Enviro
Eras ITC
Estrangelo Edessa
EucrosiaUPC
Euphemia
Eurostile

F
FangSong
Felix Titling
Fine Hand
Fixed Miriam Transparent
Flexure
Footlight MT
Forte
Franklin Gothic
Franklin Gothic Medium
FrankRuehl
FreesiaUPC
Freestyle Script
French Script MT
Futura

G
Gabriola
Gadugi
Garamond
Garamond MT
Gautami
Georgia
Georgia Ref
Gigi
Gill Sans MT
Gill Sans MT Condensed
Gisha
Gloucester
Goudy Old Style
Goudy Stout
Gradl
Grotesque
Gulim & GulimChe
Gungsuh & GungsuhChe

H

Hadassah Friedlaender
Haettenschweiler
Harlow Solid Italic
Harrington
HGGothicE
HGMinchoE
HGSoeiKakugothicUB
High Tower Text
Holidays MT
HoloLens MDL2 Assets

I
Impact
Imprint MT Shadow
Informal Roman
IrisUPC
Iskoola Pota

J
JasmineUPC
Javanese Text
Jokerman
Juice ITC

K
KaiTi
Kalinga
Kartika
Keystrokes MT
Khmer UI
Kigelia
Kino MT
KodchiangUPC
Kokila
Kristen ITC
Kunstler Script

L
Lao UI
Latha
LCD
Leelawadee
Levenim MT
LilyUPC
Lucida Blackletter
Lucida Bright
Lucida Bright Math
Lucida Calligraphy
Lucida Console
Lucida Fax
Lucida Handwriting
Lucida Sans
Lucida Sans Typewriter
Lucida Sans Unicode

M
Magneto
Maiandra GD
Malgun Gothic
Mangal
Map Symbols
Marlett
Matisse ITC
Matura MT Script Capitals
McZee
Mead Bold
Meiryo
Mercurius Script MT Bold
Microsoft GothicNeo
Microsoft Himalaya
Microsoft JhengHei
Microsoft JhengHei UI
Microsoft New Tai Lue
Microsoft PhagsPa
Microsoft Sans Serif

Microsoft Tai Le
Microsoft Uighur
Microsoft YaHei
Microsoft YaHei UI
Microsoft Yi Baiti
MingLiU
MingLiU-ExtB
MingLiU_HKSCS
MingLiU_HKSCS-ExtB
Minion Web
Miriam
Miriam Fixed
Mistral
Modern Love
Modern No. 20
Mongolian Baiti
Monotype.com
Monotype Corsiva
Monotype Sorts
MoolBoran
MS Gothic
MS LineDraw
MS Mincho
MS Outlook
MS PMincho
MS Reference
MT Extra
MV Boli
Myanmar Text

N
Narkisim
News Gothic MT
New Caledonia
Niagara
Nirmala UI
Nyala

O
OCR-B-Digits
OCRB
OCR A Extended
Old English Text MT
Onyx

P
Palace Script MT
Palatino Linotype
Papyrus
Parade
Parchment
Parties MT
Peignot Medium
Pepita MT
Perpetua
Perpetua Titling MT
Placard Condensed
Plantagenet Cherokee
Playbill
PMingLiU
PMingLiU-ExtB
Poor Richard
Posterama
Pristina

Q
Quire Sans

R
Raavi
Rage Italic
Ransom
Ravie

RefSpecialty
Rockwell
Rockwell Nova
Rod
Runic MT Condensed

S
Sabon Next LT
Sagona
Sakkal Majalla
Script MT Bold
Segoe Chess
Segoe Print
Segoe Script
Segoe UI
Segoe UI Symbol
Selawik
Shonar Bangla
Showcard Gothic
Shruti
Signs MT
SimHei
Simplified Arabic Fixed
SimSun
SimSun-ExtB
NSimSun
Sitka
Skeena Indigenous
Snap ITC
Sports MT
STCaiyun
Stencil
STFangsong
STHupo
STKaiti
Stop
STXihei
STXingkai
STXinwei

STZhongsong
Sylfaen
Symbol

T
Tahoma
Tempo Grunge
Tempus Sans ITC
Temp Installer Font
The Hand
The Serif Hand
Times New Roman
Times New Roman Special
Tisa Offc Serif Pro
Traditional Arabic
Transport MT
Trebuchet MS
Tunga
Tw Cen MT

U
Univers
Urdu Typesetting
Utsaah

V
Vacation MT
Vani
Verdana
Verdana Ref
Vijaya
Viner Hand ITC
Vivaldi
Vixar ASCI
Vladimir Script
Vrinda

W
Walbaum
Webdings
Westminster
Wide Latin
Wingdings

Abadi MT font family
07/08/2025

Overview
Abadi, introduced in 1988 offers a versatile sans serif design whose style lies somewhere
between the humanist Gill Sans and the more rigidly lineal Helvetica. Subtle humanistic
characteristics give Abadi a friendly appeal and contribute as much to the typeface's legibility
as does its generous x-height. This legibility keeps the typeface usable in smaller point sizes.
Available weights, from light to extra bold, give Abadi a wide range of graphic applications,
from magazines, newspapers, packaging, advertising, to use even with television.
ﾉ

Expand table

Item

Description

File name

abadi.ttf
abadiexlt.ttf

Styles &
Weights

Abadi
Abadi Extra Light

Designers

Ong Chong Wah

Copyright

Typeface data Copyright © 1992-94 The Monotype Corporation. Copyright 1994
Microsoft Corporation. All rights reserved.

Font vendor

Agfa Monotype Corporation

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Download

N/A – Exclusively included with Microsoft products and services where applicable.

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this page.

Style & weight examples

Agency FB font family
Article • 04/04/2025

Overview
ATF Agency Gothic was designed by M.F. Benton in 1932 as a single titling face. In 1990
David Berlow saw potential in the squared forms of the narrow, monotone capitals. He
designed a lowercase and added a bold to produce Font Bureau Agency, an immediate
popular hit. Sensing further possibilities, he worked with Tobias Frere-Jones and
Jonathan Corum to expand Agency into a major series, offering five weights in five
widths for text & display settings.
ﾉ

Expand table

Item

Description

File name

Agencyr.ttf
Agencyb.ttf

Styles &
Weights

Agency FB
Agency FB Bold

Designers

The Font Bureau, Inc.

Copyright

Copyright (c) 1995, The Font Bureau, Inc. 1995, 1997, 1998. All rights reserved.

Font vendor

N/A

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Download

N/A – Exclusively included with Microsoft products and services where
applicable.

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this page.

Style & weight examples
Agency FB

Agency FB Bold

Feedback
Was this page helpful?

 Yes

 No

Aharoni Bold font family
Article • 04/04/2025

Overview
Aharoni Bold is a very square, bold Hebrew typeface with simple forms. It has only one
weight, and no italic or cursive style. Its shapes look geometric, and its included Latin
letters are derived from a very bold weight of a classic geometric Latin typeface. Like a
Latin geometric face, it gives the impression that all of its strokes are of equal weight,
although they get thinned down where needed to make angles and junctions clearly
delineated.
Aharoni was originally designed by Tuvia Aharoni in 1936 and manufactured by Ludwig
& Mayer. It was made into a computer typeface by Kivun Computers Ltd. in 1991–1993.
Aharoni Bold is suitable for headlines, posters, and large advertisements.
ﾉ

Expand table

Item

Description

File name

Ahronbd.ttf

Styles &
Weights

Aharoni Bold

Designers

N/A

Copyright

© 1991-1993 Kivun Computers Ltd. Portions © The Monotype Corporation

Font vendor

Glyph Systems

Script Tags

dlng:'Hebr'
slng:'Hebr', 'Latn'

Code pages

1255 Hebrew
437 US

Fixed pitch

False

Download

N/A – Exclusively included with Microsoft products and services where
applicable.

Licensing and redistribution info

Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
ﾉ

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

1.00

Windows 2000

1.00

Expand table

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Aharoni Bold

Feedback
Was this page helpful?

 Yes

 No

Aldhabi font family
Article • 04/04/2025

Overview
Aldhabi is a Arabic OpenType font intended for use at larger, display sizes and in
situations where an elegant, flowing style is appropriate. Unlike many other Arabic fonts
that attempt, with limited success, to implement specific historical styles of Arabic
calligraphy, Aldhabi represents a new synthesis of historical influences, technical
capabilities of current font and layout software, and the needs of contemporary use
(including the increasingly important area of text on screen).
At the same time, it avoids the kinds of compromises of the writing system that have
typically characterized most mechanical and digital Arabic typesetting.
The design of Aldhabi is inspired, in the first place, by the overall impact on the page of
an historical writing style known in Ottoman Turkish as zülf-ü aruz, the ‘way of curls’.
This flowing, undulating style is a precursor of the Ottoman diwani calligraphic style, and
also involves features in common with the Persian nastaliq style.
The design of Aldhabi does not attempt a typographic implementation of this historical
style but, rather, treats it as a source of inspiration for something new, synthesizing
features of zülf-ü aruz and other styles with a concern for legibility and comfort for
contemporary readers.
ﾉ

Expand table

Item

Description

File name

Aldhabi.ttf

Styles &
Weights

Aldhabi

Copyright

© 2015 Microsoft Corporation. All Rights Reserved.

Designers

Tim Holloway, Fiona Ross & John Hudson (ornaments, Titus Nemeth;
consultant, Mamoun Sakkal)

Font vendor

Microsoft Corp.

Script Tags

dlng:'Arab', 'Aran'
slng:'Arab', 'Aran', 'Latn'

Item

Description

Code pages

1252 Latin 1
1256 Arabic

Fixed pitch

False

Download

N/A – Exclusively included with Microsoft products and services where
applicable.

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
ﾉ

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Expand table

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples

Figure 1: Aldhabi is an Arabic typeface inspired by early Diwani calligraphy, distinct
for its ornate details and exaggerated cursive connections. The Arabic glyphs are
accompanied by a harmonized Latin design that provides support for occasional
English or other European language words in the larger context of Arabic text, as
well as transliteration of Arabic and Persian.

Figure 2: One of Aldhabi’s distinctive features is the ability to make numerous
cursive extensions simply by typing kashidas from the keyboard.

Feedback
Was this page helpful?

 Yes

 No

Algerian font family
Article • 09/28/2023

Overview
Algerian traces its origins to the British foundry, Stephenson Blake and Co., in 1911. In
the mid-1980s, URW digitized Algerian. The style in Algerian typifies the writing on signs
in Spain and countries/regions on the north coast of Africa, possibly reflecting the
influence of Arabic calligraphers and signmakers. More decorative than its Latin
counterpart, traditional Arabic calligraphy is characterized by an ornamental flavor used
to enhance individual characters and sometimes whole pages.
Description
File name

Alger.ttf

Styles & Weights

Algerian

Designers

URW Studio, 1985, (1911)

Copyright

URW Software, Copyright 1993 by URW

Font vendor

URW Type Foundry

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this page.

Style & weight examples

Almanac MT font family
Article • 03/30/2022

Overview
Designed by Steve Matteson, this is one of a set of versatile art fonts from Monotype. As
you may have guessed from the name this is an astrological font containing all the signs
of the zodiac and lots of other goodies as well. Great for instant illustrations, icons or
bullets.
Description
File name

Almanac.ttf

Styles &
Weights

Almanac MT

Designers

Steve Matteson

Copyright

Digitized data copyright (C) 1991-1995 Monotype Typography, Inc.. All rights
reserved. Monotype? is a trademark of Monotype Typography, Inc. which may be
registered in certain jurisdicions.

Font
vendor

Agfa Monotype Corporation

Script
Tags

N/A

Code
pages

Symbol Symbol Character Set

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples

Almanac MT

American Uncial font family
Article • 03/30/2022

Overview
Uncial letterforms go back to handwriting found in Latin and Greek manuscripts of the
fourth to the eighth centuries A.D., long before the evolution of the ornate English black
letter (particularly popular in the Middle Ages) or today's ubiquitous roman with its
serifs. The distinctive calligraphic style of Uncial letterforms has inspired quite a few
variations. For example, Hammer Uncial, designed in 1923, shows how lovely these
letterforms were in old manuscripts. Solemnis, which was drawn for the Berthold
foundry in 1954, offers a single case with a mixture of letters resembling uppercase and
lowercase characters. American Uncial was more recently made in Germany by URW.
American Uncial is comparable to the New Hammer Uncial made in 1953. Its rounded,
calligraphic strokes make it a beautiful face at large sizes. Avoid using it at small sizes,
however, or you will lose the contrast between the thick and thin elements of the
strokes.
Description
File name

Ameriunc.ttf

Styles & Weights

American Uncial

Designers

Victor Hammer, 1992, (1943)

Copyright

Data by URW. © 1993. Microsoft Corporation. All rights reserved.

Font vendor

URW Type Foundry

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
American Uncial

Andale Mono font family
Article • 03/30/2022

Overview
Andale Mono is a highly legible monospaced font designed with the needs of terminal
emulation and software development environments. Yes, this font was originally
distributed as part of the Internet Explorer 4.0 add-ons page as Monotype.com. We've
decided to revert to the font's original name, Andale.
Description
File name

Andalemo.ttf

Styles &
Weights

Andale Mono

Designers

Steven R. Matteson

Copyright

Digitized data copyright (C) 1993-1997 The Monotype Corporation. All rights
reserved.

Font vendor

Agfa Monotype Corporation

Script Tags

N/A

Description
Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
Mac Roman Macintosh Character Set (US Roman)
OEM OEM Character Set
869 IBM Greek
866 MS-DOS Russian
865 MS-DOS Nordic
863 MS-DOS Canadian French
861 MS-DOS Icelandic
860 MS-DOS Portuguese
857 IBM Turkish
855 IBM Cyrillic; primarily Russian
852 Latin 2
775 MS-DOS Baltic
737 Greek; former 437 G
850 WE/Latin 1
437 US

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples

Andalus font family
Article • 03/30/2022

Overview
Andalus is an Arabic display font. Its design is a modern interpretation of Kairawani
Kufic. This font is suitable for headlines, titles, posters, and any graphic design project
where artistic flavor is desired.
This font has shipped with Windows since Windows 3.1 (Arabic edition) as a
TrueType font.
Version 5.92 shipped with Windows 7, support for advance OpenType layout tables
to improve marks positioning and other typographic enhancements were added.
Version 5.99 shipped with Windows 8, we added traditional phrase-ligatures and
support for end-of-Ayat mark to make Andalus more user-friendly to native Arabic
language users.
Description
File name

Andlso.ttf

Styles &
Weights

Andalus

Copyright

Copyright 1993 Glyph Systems, Limited Partnership. Portions © 2011 The Monotype
Corporation. All Rights Reserved.

Designers

Mohammad Alagha, Mamoun Sakkal

Font
vendor

Glyph Systems, Monotype Corporation

Script Tags

dlng:'Arab'
slng:'Arab', 'Latn'

Code
pages

1252 Latin 1
1256 Arabic

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows

License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

1.01

Windows 2000

1.01

Style & weight examples

Figure 1: Andalus is an Arabic display font based on Kairawani Kufic calligraphy.

Figure 2: Traditional phrase-ligatures added in version 5.99

Andy font family
Article • 03/30/2022

Overview
Andy Bold is a casual typeface with a controlled spontaneity that still offers legibility
needed for long documents. Andy was designed by Steve Matteson using his friend
Andy Mead's handwriting as an inspirational source.
Description
File name

Andyb.ttf

Styles &
Weights

Andy Bold

Designers

Steve Matteson

Copyright

Digitized data copyright The Monotype Corporation 1991-1995. All rights reserved.
Andy? is a trademark of The Monotype Corporation which may be registered in
certain jurisdictions.

Font
vendor

Agfa Monotype Corporation

Script
Tags

N/A

Code
pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Andy Bold

AngsanaUPC font family
08/08/2025

Overview
Angsana UPC is a Thai font designed by Unity Progress and offered under license from
Microsoft.
ﾉ

Expand table

Item

Description

File name

Angsana.ttc

Styles &
Weights

AngsanaUPC
AngsanaUPC Bold
AngsanaUPC Bold Italic
AngsanaUPC Italic

Designers

N/A

Copyright

© 1992 Unity Progress. Portions © 2004 The Monotype Corporation. Portions © 2015
Microsoft Corporation. All Rights Reserved.

Font vendor
Script Tags

dlng:'Thai'
slng:'Thai', 'Latn'

Code pages

1252 Latin 1
874 Thai

Fixed pitch

False

Download

N/A – Exclusively included with Microsoft products and services where applicable.

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font

ﾉ

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows Server 2008

5.00

Windows Server 2003

2.20

Windows XP

2.20

Expand table

This typeface is also available within Office applications. For more information visit this page.

Style & weight examples
AngsanaUPC

Angsana New font family
08/08/2025

Overview
Angsana New is a Thai font designed by Unity Progress and offered under license from
Microsoft.
ﾉ

Expand table

Item

Description

File name

Angsana.ttc

Styles &
Weights

Angsana New
Angsana New Bold
Angsana New Bold Italic
Angsana New Italic

Designers

N/A

Copyright

© 1992 Unity Progress. Portions © 2004 The Monotype Corporation. Portions © 2015
Microsoft Corporation. All Rights Reserved.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Thai'
slng:'Thai', 'Latn'

Code pages

1252 Latin 1
874 Thai

Fixed pitch

False

Download

N/A – Exclusively included with Microsoft products and services where applicable.

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font

ﾉ

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows Server 2008

5.00

Windows Server 2003

2.20

Windows XP

2.20

Expand table

This typeface is also available within Office applications. For more information visit this page.

Style & weight examples
Angsana New

Aparajita font family
Article • 03/30/2022

Overview
This font is primarily meant for use in displaying Hindi text in documents. It is an
OpenType font, based on Unicode.
Description
File name

Aparaj.ttf
Aparajb.ttf
Aparajbi.ttf
Aparaji.ttf

Styles & Weights

Aparajita
Aparajita Bold
Aparajita Bold Italic
Aparajita Italic

Designers

N/A

Copyright

Copyright (c) 2011, Modular Infotech, Pune, INDIA. - Licenced to Microsoft

Font vendor

MODI

Script Tags

dlng:'Deva'
slng:'Deva', 'Latn'

Code pages

1252 Latin 1

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Aparajita

Aparajita Bold

Aparajita Bold Italic

Aparajita Italic

Aptos font family
07/25/2025

Overview
Aptos is a precise, contemporary sans serif typeface inspired by mid-20th-century Swiss
typography. Its clear-cut stroke endings emphasize order and restraint; the points where
curved strokes meet straight strokes are crisp and well defined, which makes the typeface
easily readable and reduces visual crowding.
Aptos expresses simplicity and rationality in a highly readable form, with “the austerity and
directness that is required in huge variety of Office documents created every day,” according to
designer Steve Matteson. Aptos can be used both for body text and headlines and for titles. Its
variety of weights are appropriate for different uses: Light, Semibold, and Black weights can
help create a hierarchy of information in PowerPoint and Word documents, while the
Condensed weights give Excel users a way to fit more information into spreadsheets and
tables. The Display versions are slightly narrower and more closely fitted, to give very large text
a crisp authority.
Type designer Steve Matteson designed Aptos for Microsoft as a new default Office font to
replace Calibri. It has six weights, from Light to Black, with complementary oblique styles. (In
this style of typeface, the italic doesn’t typically take on the cursive forms you’d expect in
handwriting or a traditional serif typeface; the letter shapes are oblique forms of the upright
letters. The italics of Aptos have been individually redrawn, rather than mechanically slanted.)
Aptos also has two Display weights, with their accompanying italic styles, and two Condensed
weights, with italics. Aptos offers extended support of the Latin, Greek, and Cyrillic alphabets,
and for Vietnamese.
ﾉ

Item

Description

File name

Aptos.ttfAptos-Black.ttf
Aptos-Black-Italic.ttf
Aptos-Bold.ttf
Aptos-Bold-Italic.ttf
Aptos-Display.ttf
Aptos-Display-Bold.ttf
Aptos-Display-Bold-Italic.ttf
Aptos-Display-Italic.ttf
Aptos ExtraBold
Aptos-ExtraBold-Italic.ttf
Aptos-Italic.ttf

Expand table

Item

Description
Aptos-Light.ttf
Aptos-Light-Italic.ttf
Aptos-Mono.ttf
Aptos-Mono-Bold.ttf
Aptos-Mono-Bold-Italic.ttf
Aptos-Mono-Italic.ttf
Aptos-Narrow.ttf
Aptos-Narrow-Bold.ttf
Aptos-Narrow-Bold-Italic.ttf
Aptos-Narrow-Italic.ttf
Aptos-SemiBold.ttf
Aptos-SemiBold-Italic.ttf
Aptos-Serif.ttf
Aptos-Serif-Bold.ttf
Aptos-Serif-Bold-Italic.ttf
Aptos-Serif-Italic.ttf

Styles & Weights

Aptos
Aptos Black
Aptos Black Italic
Aptos Bold
Aptos Bold Italic
Aptos Display
Aptos Display Bold
Aptos Display Bold Italic
Aptos Display Italic
Aptos ExtraBold
Aptos ExtraBold Italic
Aptos Italic
Aptos Light
Aptos Light Italic
Aptos Mono
Aptos Mono Bold
Aptos Mono Bold Italic
Aptos Mono Italic
Aptos Narrow
Aptos Narrow Bold
Aptos Narrow Bold Italic
Aptos Narrow Italic
Aptos SemiBold
Aptos SemiBold Italic
Aptos Serif
Aptos Serif Bold
Aptos Serif Bold Italic
Aptos Serif Italic

Copyright

© 2023 Microsoft Corporation. All Rights Reserved.

Item

Description

Designers

Steve Matteson

Font vendor

Microsoft Corp.

Script Tags

dlng:'Cyrl', 'Grek', 'Latn'
slng:'Cyrl', 'Grek', 'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
1258 Vietnamese

Fixed pitch

False

Download

Download Microsoft Aptos Fonts

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit Cloud fonts in
Office

.

Style & weight examples

Arabic Transparent font family
Article • 03/30/2022

Overview
Arabic Transparent is an Arabic font.
Description
File name

Artro.ttf
Artrbdo.ttf

Styles &
Weights

Arabic Transparent
Arabic Transparent Bold

Designers

N/A

Copyright

Portions (C) 1990 Compugraphic Corporation. Typeface Portions (C) The Monotype
Corporation plc. Data Portions (C) The Monotype Corporation plc./Type Solutions Inc.
1990-1992. All Rights Reserved.

Font
vendor

N/A

Script
Tags

N/A

Code
pages

1256 Arabic

Fixed

False

pitch

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Arabic Transparent

Arabic Transparent Bold

Arabic Typesetting font family
Article • 03/30/2022

Overview
Arabic Typesetting is an OpenType typeface designed as a modern interpretation of the
traditional Naskh style. This font is a testament to the quality achievable when applying
rigorous standards to modern digital typography.
This typeface is particularly well suited for traditional book typography, an area
neglected by digital type. The font provides fine typographic control by marrying the
latest OpenType technology to traditional calligraphic and typographic models. It
achieves maximum readability by opening bowls and counters, balancing the
proportions of stroke and white space in letters that typically cause problems at small
sizes, and by contextually differentiating similar forms. The font contains over 2,100
glyphs, including contextual alternates, ligatures, and language-specific forms. Great
care was taken in the design and digitization of all outlines. The graceful curves, the
dynamic of blunt and rounded terminals, and the contrast between thick and thin
strokes are consistent and lively throughout the typeface. In addition to providing all the
correct shapes for quality Arabic typesetting, the same care and consistency has been
applied in glyphs used for the many other languages, such as Farsi, Urdu, Sindhi, etc.,
that are written in variants of the Arabic script. This means that documents
incorporating several language will have a harmonious appearance. The Arabic glyphs
are accompanied by Latin letters designed to achieve a balance of color, weight and
proportion between the two scripts. Typically, the trend in co-ordinating Arabic and
Latin types has been to unhappily force the Arabic to match the proportions of the Latin.
Description
File name

Arabtype.ttf

Styles & Weights

Arabic Typesetting

Designers

Mamoun Sakkal, Paul C. Nelson and John Hudson

Copyright

© 2015 Microsoft Corporation. All Rights Reserved.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Arab'
slng:'Arab', 'Latn'

Description
Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1254 Turkish
1256 Arabic
1257 Windows Baltic
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.01

Windows Server 2008

5.01

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Arabic Typesetting

Arial font family
08/08/2025

Overview
A contemporary sans serif design, Arial contains more humanist characteristics than many of its
predecessors and as such is more in tune with the mood of the last decades of the twentieth
century. The overall treatment of curves is softer and fuller than in most industrial style sans
serif faces. Terminal strokes are cut on the diagonal which helps to give the face a less
mechanical appearance. Arial is an extremely versatile family of typefaces which can be used
with equal success for text setting in reports, presentations, magazines etc, and for display use
in newspapers, advertising and promotions.

Arial version history
Version 2.55 - This WGL4 version of Arial was first supplied with the Final Windows 95 euro
update that shipped on 4 November 1998. This version contains the euro.
Version 2.50 - This version of Arial is supplied with European versions of Windows 98. North
American users can add it by installing multilanguage support. This version contains the euro.
Version 2.45 - This Win ANSI version of Arial is supplied with the US version of Windows 98.
Version 2.01 - This special version of Arial is only supplied with the beta version of the
Windows 95 euro update patch.
Version 2.00 (Win ANSI) - This Win ANSI version of Arial is supplied with Windows 95.
Version 2.00 (WGL4) - This WGL4 version of Arial is supplied with Windows 95 and Windows
NT4. This version does not contain the euro.
Version 1.00 - This version was supplied with Windows 3.1 and Windows for Workgroups 3.11.
ﾉ

Item

Description

File name

Arial.ttf
Arialbd.ttf
Arialbi.ttf
Ariali.ttf

Expand table

Item

Description

Styles &

Arial

Weights

Arial Bold
Arial Bold Italic
Arial Italic

Designers

Monotype Type Drawing Office - Robin Nicholas, Patricia Saunders 1982

Copyright

© 2017 The Monotype Corporation. All Rights Reserved.
Hebrew OpenType Layout logic copyright © 2003 & 2007, Ralph Hancock & John Hudson.
This layout logic for Biblical Hebrew is open source software under the MIT License; see
embedded license description for details.

Font vendor

Agfa Monotype Corporation

Script Tags

dlng:'Armn', 'Cyrl', 'Grek', 'Latn'
slng:'Arab', 'Armn', 'Cyrl', 'Grek', 'Hebr', 'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1255 Hebrew
1256 Arabic
1257 Windows Baltic
1258 Vietnamese
OEM OEM Character Set
869 IBM Greek
866 MS-DOS Russian
865 MS-DOS Nordic
864 Arabic
863 MS-DOS Canadian French
862 Hebrew
861 MS-DOS Icelandic
860 MS-DOS Portuguese
857 IBM Turkish
855 IBM Cyrillic; primarily Russian
852 Latin 2
775 MS-DOS Baltic
737 Greek; former 437 G
708 Arabic; ASMO 708
850 WE/Latin 1
437 US

Fixed pitch

False

Download

N/A – Exclusively included with Microsoft products and services where applicable.

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
ﾉ

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.01

Windows XP SP2

3.00

Windows XP

2.95

Windows 2000

2.76

Windows 98 Second Edition

2.76

Windows 98

2.50

Windows 95

2.00

Windows 3.1

1.00

Windows Server 2008

5.01

Windows Server 2003

2.95

Windows NT Terminal Server 4.0

2.00

Windows NT Workstation 4.0 SP4

2.50

Windows NT Workstation 4.0

2.00

Windows NT Workstation 3.5

1.77

Expand table

This typeface is also available within Office applications. For more information visit this page.

Style & weight examples

Arial Black font family
Article • 03/30/2022

Overview
Arial Black is part of the extremely versatile Arial typeface family which can be used with
equal success for text setting in reports, presentations, magazines etc, and for display
use in newspapers, advertising and promotions. Only the regular weights ships with
Windows and supports the larger characters set. The Italic weight has ships with Office
applications.
Description
File name

Ariblk.ttf
AriBlkIt.ttf

Styles & Weights

Arial Black
Arial Black Italic

Designers

Robin Nicholas, Patricia Saunders

Copyright

© 2016 The Monotype Corporation. All Rights Reserved.

Font vendor

Agfa Monotype Corporation

Script Tags

dlng:'Cyrl', 'Grek', 'Latn'
slng:'Cyrl', 'Grek', 'Latn'

Description
Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
Mac Roman Macintosh Character Set (US Roman)
OEM OEM Character Set
869 IBM Greek
866 MS-DOS Russian
865 MS-DOS Nordic
863 MS-DOS Canadian French
861 MS-DOS Icelandic
860 MS-DOS Portuguese
857 IBM Turkish
855 IBM Cyrillic; primarily Russian
852 Latin 2
775 MS-DOS Baltic
737 Greek; former 437 G
850 WE/Latin 1
437 US

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Product name

Font version

Windows XP

2.35

Windows 2000

1.00

Windows Server 2008

5.00

Windows Server 2003

2.35

Style & weight examples

Arial Narrow font family
Article • 03/30/2022

Overview
Monotype Drawing Office 1982. A contemporary sans serif design, Arial contains more
humanist characteristics than many of its predecessors and as such is more in tune with
the mood of the last decades of the twentieth century. The overall treatment of curves is
softer and fuller than in most industrial-style sans serif faces. Terminal strokes are cut on
the diagonal which helps to give the face a less mechanical appearance. Arial is an
extremely versatile family of typefaces which can be used with equal success for text
setting in reports, presentations, magazines etc, and for display use in newspapers,
advertising and promotions.
Description
File name

ARIALN.ttf
ARIALNB.ttf
ARIALNBI.ttf
ARIALNI.ttf

Styles & Weights

Arial Narrow
Arial Narrow Bold
Arial Narrow Bold Italic
Arial Narrow Italic

Designers

Robin Nicholas, Patricia Saunders

Copyright

© 2006 The Monotype Corporation. All Rights Reserved.

Font vendor

Agfa Monotype Corporation

Script Tags

N/A

Description
Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
Mac Roman Macintosh Character Set (US Roman)
869 IBM Greek
866 MS-DOS Russian
865 MS-DOS Nordic
863 MS-DOS Canadian French
861 MS-DOS Icelandic
860 MS-DOS Portuguese
857 IBM Turkish
855 IBM Cyrillic; primarily Russian
852 Latin 2
775 MS-DOS Baltic
737 Greek; former 437 G
850 WE/Latin 1
437 US

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Arial Narrow

Arial Narrow Bold

Arial Narrow Bold Italic

Arial Narrow Italic

Arial Narrow Special font family
Article • 03/30/2022

Overview
A special set of Arial Narrow fonts used with various Microsoft applications
Description
File name

Msgeonr1.ttf
Msgeonb1.ttf
Msgeoni1.ttf
Msgeonr2.ttf
Msgeonb2.ttf
Msgeoni2.ttf

Styles &
Weights

Arial Narrow Special G1
Arial Narrow Special G1 Bold
Arial Narrow Special G1 Italic
Arial Narrow Special G2
Arial Narrow Special G2 Bold
Arial Narrow Special G2 Italic

Designers

Robin Nicholas

Copyright

Digitized data copyright The Monotype Corporation 1991-1995. All rights reserved.
Arial? is a trademark of The Monotype Corporation which may be registered in
certain jurisdictions.

Font
vendor

Agfa Monotype Corporation

Script
Tags

N/A

Code
pages

Symbol Symbol Character Set

Fixed

False

pitch

Licensing and redistribution info
Font redistribution FAQ for Windows

License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Arial Narrow Special G1

Arial Narrow Special G1 Bold

Arial Narrow Special G1 Italic

Arial Narrow Special G2

Arial Narrow Special G2 Bold

Arial Narrow Special G2 Italic

Arial Nova font family
Article • 03/30/2022

Overview
Arial Nova is a subtle redesign of the classic Arial family. It is suitable for document
paragraphs and headings. These fonts are designed for European languages written with
Latin, Greek and Cyrillic scripts.
Description
File name

ArialNova.ttf
ArialNova-Italic.ttf
ArialNova-Light.ttf
ArialNova-LightItalic.ttf
ArialNova-Bold.ttf
ArialNova-BoldItalic.ttf
ArialNovaCond-Light.ttf
ArialNovaCond-LightItalic.ttf
ArialNovaCond.ttf
ArialNovaCond-Italic.ttf
ArialNovaCond-Bold.ttf
ArialNovaCond-BoldItalic.ttf

Styles & Weights

Arial Nova
Arial Nova Italic
Arial Nova Light
Arial Nova Light Italic
Arial Nova Bold
Arial Nova Bold Italic
Arial Nova Cond Light
Arial Nova Cond Light Italic
Arial Nova Cond
Arial Nova Cond Italic
Arial Nova Cond Bold
Arial Nova Cond Bold Italic

Designers

Monotype Design Office

Copyright

© 2014 The Monotype Corporation. All Rights Reserved.

Font vendor

Monotype Imaging Inc.

Script Tags

dlng: 'Cyrl', 'Grek', 'Latn'
slng: 'Cyrl', 'Grek', 'Latn'

Description
Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Arial Nova

Arial Nova Italic

Arial Nova Light

Arial Nova Light Italic

Arial Nova Bold

Arial Nova Bold Italic

Arial Nova Cond Light

Arial Nova Cond Light Italic

Arial Nova Cond

Arial Nova Cond Italic

Arial Nova Cond Bold

Arial Nova Cond Bold Italic

Change list:
Windows 10 version 1507 released on July 29, 2015
Arial Nova font family was introduced as part of the Windows 10 Pan-European
Supplemental Fonts package.

Arial Rounded MT font family
Article • 03/30/2022

Overview
This font is a development of the widely used and versatile Arial typeface. Rounding the
ends of the strokes imparts a very different feel to the typeface, especially in the heavier
weights, where the rounding is more apparent. You'll find Arial Rounded MT Bold more
informal than its Arial counterpart.
Description
File name

Arlrdbd.ttf

Styles & Weights

Arial Rounded MT Bold

Designers

Robin Nicholas

Copyright

Copyright © 1993 , Monotype Typography ltd.

Font vendor

Agfa Monotype Corporation

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples

Arial Rounded MT Bold

Arial Special font family
Article • 03/30/2022

Overview
Arial Special fonts are included with Microsoft Encarta Virtual Globe 99, Expedia Streets
and Trips 2000, MapPoint 2000.
Description
File name

Msgeoar1.ttf
Msgeoab1.ttf
Msgeoax1.ttf
Msgeoai1.ttf
Msgeoar2.ttf
Msgeoab2.ttf
Msgeoax2.ttf
Msgeoai2.ttf

Styles &
Weights

Arial Special G1
Arial Special G1 Bold
Arial Special G1 Bold Italic
Arial Special G1 Italic
Arial Special G2
Arial Special G2 Bold
Arial Special G2 Bold Italic
Arial Special G2 Italic

Designers

Robin Nicholas

Copyright

Digitized data copyright The Monotype Corporation 1991-1995. All rights reserved.
Arial? is a trademark of The Monotype Corporation which may be registered in
certain jurisdictions.

Font
vendor

Agfa Monotype Corporation

Script
Tags

N/A

Code
pages

Symbol Symbol Character Set

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Arial Special G1

Arial Special G1 Bold

Arial Special G1 Bold Italic

Arial Special G1 Italic

Arial Special G2

Arial Special G2 Bold

Arial Special G2 Bold Italic

Arial Special G2 Italic

Arial Unicode MS font family
Article • 03/30/2022

Overview
Arial Unicode MS was originally commissioned by Microsoft Office as an extended
version of the Arial typeface to support a large set of international characters. The font
was included with Office but not Windows. Over time the Unicode standard grew to the
point where it was not possible to include all encoded characters in a single font file, so
today most applications rely on font linking or font fallback to provide appropriate
language support when a selected font doesn’t include the characters you need. We
stopped servicing and updating Arial Unicode and no longer install it as part of Office.
However, updated versions of the font are available from Monotype. Follow the links
below if you have dependencies on it.
Description
File name

Arialuni.ttf

Styles &
Weights

Arial Unicode MS

Designers

Original design: Robin Nicholas, Patricia Saunders. Extended glyphs: Monotype
Type Drawing Office, Monotype Typography.

Copyright

Digitized data copyright (C) 1993-2000 Agfa Monotype Corporation. All rights
reserved. Arial® is a trademark of The Monotype Corporation which may be
registered in certain jurisdictions.

Font vendor

Agfa Monotype Corporation

Script Tags

N/A

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1255 Hebrew
1256 Arabic
1257 Windows Baltic
1258 Vietnamese
874 Thai
932 JIS/Japan
936 Chinese: Simplified chars--PRC and Singapore

Description
949 Korean Wansung
950 Chinese: Traditional chars--Taiwan and Hong Kong SAR
1361 Korean Johab
Mac Roman Macintosh Character Set (US Roman)
OEM OEM Character Set
869 IBM Greek
866 MS-DOS Russian
865 MS-DOS Nordic
864 Arabic
863 MS-DOS Canadian French
862 Hebrew
861 MS-DOS Icelandic
860 MS-DOS Portuguese
857 IBM Turkish
855 IBM Cyrillic; primarily Russian
852 Latin 2
775 MS-DOS Baltic
737 Greek; former 437 G
708 Arabic; ASMO 708
850 WE/Latin 1
437 US
Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Arial Unicode MS

Augsburger Initials font family
Article • 03/30/2022

Overview
The basic Augsburger typeface, first issued by at least two German foundries in the last
century, contains the lower-case alphabet and numerals, as well as capital letters. The
Initial variation has been limited to caps. You are never likely to use more than a letter or
two at a time.
Description
File name

Augsburg.ttf

Styles &
Weights

Augsburger Initials

Designers

N/A

Copyright

©1992 The Font Bureau, Inc. Portions ©1992 Microsoft Corp. All rights
reserved.

Font vendor

Font Bureau, Inc.

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Augsburger Initials

Avenir Next LT Pro font family
Article • 03/30/2022

Overview
The Avenir® Next font family was designed by Adrian Frutiger in collaboration with
Monotype Type Director Akira Kobayashi. It was an expanded reworking of the original
font family (released as an OpenType font with both oldstyle and lining figures) and
received considerable acclaim upon its publication by Linotype in 2004.
Adrian Frutiger was destined for typographical greatness well before his entrance into
the world of commercial typeface production. Very creative from an early age, Frutiger
dabbled in sculpture and type design, in particular, alternatives to the stiff, formal
cursive taught at his native Swiss schools.
Arguably, Frutiger’s most famous font, the Univers® family, was produced as a reaction
to Paul Renner’s 1927 Futura® typeface. Frutiger did not feel comfortable with the
manner in which Futura sat upon the page, feeling it was too disciplined. Preferring a
more humanist approach to typeface creation, he persuaded his then-employer Charles
Peignot to allow him to create a new face based on different criteria.
Various other fonts followed after the Univers creation including Serifa®, Glypha® and
the self titled Frutiger®.
The Avenir (French for “future”) font was produced as another real alternative to the
Futura design and the original face was available in three weights with accompanying
italic variants. This limited variety led to the reworking of the type in the early twentyfirst century by Frutiger and Kobayashi. The Avenir Next design was subsequently
released in twenty-four different styles including Regular, Italic, Condensed and
Condensed Italic variants and published by Linotype in 2004. Legible and eminently
flexible, designers the world over have embraced the Avenir Next face for a wide variety
of different projects.
Since its release, the Avenir Next design has been immensely popular for an extensive
range of different applications. The font was instantly successful in print and with its
expanded range of characters and specific optimization, equally successful as an onscreen font. -- fonts.com
In 2019 we reviewed the set of fonts provided with Office identifying stylistic gaps. The
result of that effort was the addition of over a hundred new fonts, including classics like
Avenir Next LT Pro and Walbaum along with contemporary designs like The Hand,

Sagona and Modern Love. These new fonts are available in most Office applications and
have been used in a range of new templates.
Description
File name

AvenirNextLTPro-Regular.ttf
AvenirNextLTPro-Bold.ttf
AvenirNextLTPro-BoldIt.ttf
AvenirNextLTPro-It.ttf
AvenirNextLTPro-Light.ttf
AvenirNextLTPro-LightIt.ttf

Styles & Weights

Avenir Next LT Pro
Avenir Next LT Pro Bold
Avenir Next LT Pro Bold Italic
Avenir Next LT Pro Italic
Avenir Next LT Pro Light
Avenir Next LT Pro Light Italic

Copyright

Copyright © 2004 - 2017 Monotype GmbH. All rights reserved.

Designers

Adrian Frutiger, Akira Kobayashi

Font vendor

Monotype Corporation

Script Tags

dlng:'Latn'
slng:'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1254 Turkish
1257 Windows Baltic

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Avenir Next LT Pro

Avenir Next LT Pro Bold

Avenir Next LT Pro Bold Italic

Avenir Next LT Pro Italic

Avenir Next LT Pro Light

Avenir Next LT Pro Light Italic

Bahnschrift font family
Article • 03/30/2022

Overview

Description
File name

Bahnschrift.ttf

Styles & Weights

Variable font

Designer

Aaron Bell

Copyright

© 2019 Microsoft Corporation. All rights reserved.

Font vendor

Microsoft Corporation

Script Lang Tag 'dlng' and 'slng'**

Latn, Cyrl, Grek, Vi-Latn, mk-Cyrl, bg-Cyrl, sr-Cyrl

Code pages**

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
1258 Vietnamese
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Brief history of Bahnschrift design and
production
Bahnschrift is a brand new digitization of the famous DIN 1451 character design
standard and was released as a variable font for Windows in 2017.
DIN 1451 is a standardization for letterforms designs created by the German standards
body Deutsches Institut für Normung (German Institute for Standardization) in 1931,
and was intended for use on road signs and other technical implementations. The
design was particularly optimized for legibility, simplicity, and ease in replication. Over
the years, DIN has become a popular typeface for a wide range of design applications.

Figure: Example of DIN Mittelschrift (standard) and Engschrift (Condensed) on the
Autobahn. Photo by Tage Olsin (licensed under CC BY-SA 2.0).
The Microsoft Typography Team began development on a custom version of the font in
2013 in response to the ongoing interest in DIN among designers at Microsoft. Working
from the original spec (design and metrics), a Mittelschrift and Engschrift version were
created. This version was fairly limited in character set and was used internally for a few
projects, but wasn’t shipped for public use.
The current version of Bahnschrift began development in 2016. At the time, Google,
Apple, Adobe, and Microsoft partnered to develop a common implementation of
variable font technology and Bahnschrift was chosen to become Microsoft’s first variable
font. To prepare for the transition from static to variable, the Bahnschrift source was
completely rebuilt from the ground up by Aaron Bell of Saja Typeworks and was
expanded in weight, character set (adding Extended Latin, Greek, and Cyrillic) and
manual hinting to ensure high quality rendering on a wide range of devices.

Please enjoy using Bahnschrift in your projects!

Variation in Bahnschrift
Bahnschrift’s premiere feature is its implementation of Font Variations along two axis—
weight and width. With five pre-set ‘instances’ along the weight axis, and three
‘instances’ along the width axis, Bahnschrift can accommodate a wide range of styles
and applications even in applications that don’t fully support variable fonts.

Figure: Example of Bahnschrift’s pre-set styles within the width / weight axis space.
For those applications which do fully support variable fonts, Bahnschrift becomes a
virtual playground of weight and width. Find the SemiBold is too light? Make it a little
darker. Text slightly too wide for the text block? Make it a little narrower. With
Bahnschrift’s powerful variation technology, you can fully customize the design to create
exactly the style you need.

Figure: Pick the perfect version of Bahnschrift for your project.

Other features of Bahnschrift
Aside from the variable font technology, Bahnschrift also has some other tricks up its
sleeves.
1. Duplexing: The weight axis of Bahnschrift is fully duplexed—that is to say, the
width of each letter is exactly the same whether in Light, Bold, or any weight inbetween! This is pretty unusual in the world of fonts and makes Bahnschrift
particularly useful for tabular data where everything needs to align, or in
applications where line lengths are locked.

Figure: Character length is exactly the same across the weight axis, ensuring text lines
up perfectly!
2. Character sets: Bahnschrift includes support for over 200 Latin languages
(including Vietnamese!), Greek and Cyrillic (with localized forms for Macedonian,
Serbian, and Bulgarian).

Figure: Bahnschrift in Vietnamese, Greek, Russian, and Bulgarian.
3. Manual hinting: Bahnschrift is hand-hinted (special code added to each character)
to ensure that it can render sharply, and clearly, across a wide range of Windows
devices and point sizes.

Figure: All glyphs have manual hinting

About Aaron Bell & Saja Typeworks
Aaron Bell is the owner of Saja Typeworks , an independent type foundry based in Seattle,
WA. He previously obtained a MA in Typeface Design from the University of Reading and
worked on the Microsoft Typography team for 5.5 years. Aaron’s particular area of expertise
is in Latin and Korean letter design. He also works in Greek and Cyrillic design, and in manual
hinting for TTF fonts.

Changelist
Windows 10 version 1709 release on October 17, 2017
Bahnschrift is introduced as a new addition to the Windows font family.

Windows 10 version 1803 release on April 30, 2018
Width axes added in.
Fixes errors in spacing/kerning for a few characters.
Changes improved consistent spacing across the condensed through regular
width.

Windows 10 version 1809 release on November 13, 2018
Extending the character set to include Eastern and Central European languages
which includes extended Latin characters, Greek and Cyrillic.

Baskerville Old Face font family
Article • 03/30/2022

Overview
This face is based on one developed by the renowned 18th century typographer John
Baskerville. But tell-tale differences, including the characteristic squarish curves in the
capital C and G, identify it as the version first issued by the Fry type foundry, established
by the Fry family after they succeeded in the chocolate business. The face first appeared
in 1766 under the name of Isaac Moore, the foundry manager. Baskerville is known as
the first of the transitional romans, with its greater differentiation between thick and thin
strokes. This makes Baskerville look good in large sizes. No type library is complete
without at least one version of a Baskerville face.
Description
File name

Baskvill.ttf

Styles &
Weights

Baskerville Old Face

Designers

Isaac Moore, (John Baskerville), 1992, (1768)

Copyright

Typeface © 1992 Stephenson Blake (Holdings) Ltd. Data © 1992 URW. Portions ©
1992 Microsoft Corp. All rights reserved.

Font
vendor

URW Type Foundry

Script Tags

N/A

Code

1252 Latin 1

pages

Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Baskerville Old Face

Batang font family
Article • 03/30/2022

Overview
Batang is a Korean font that features a mincho (serif) stroke style.
Description
File name

Batang.ttc

Styles & Weights

Batang
BatangChe

Designers

N/A

Copyright

(c) Copyright HanYang I&C Co.,LTD. 2000

Font vendor
Script Tags

dlng:'Hang', 'Hani', 'Kore'
slng:'Cyrl', 'Grek', 'Hang', 'Hani', 'Hira', 'Kana', 'Kore', 'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
949 Korean Wansung
OEM OEM Character Set
869 IBM Greek
866 MS-DOS Russian
864 Arabic
863 MS-DOS Canadian French
862 Hebrew
861 MS-DOS Icelandic
860 MS-DOS Portuguese
857 IBM Turkish
855 IBM Cyrillic; primarily Russian
775 MS-DOS Baltic
708 Arabic; ASMO 708
850 WE/Latin 1
437 US

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

2.21

Windows 2000

2.20

Windows Server 2008

5.00

Windows Server 2003

2.21

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Batang

BatangChe

Bauhaus 93 font family
Article • 03/30/2022

Overview
Bauhaus 93 is a decorative font with simple geometric forms and even strokes that give
the font a clean and distinctive look.
Description
File name

Bauhs93.ttf

Styles & Weights

Bauhaus 93

Designers

N. N., 1993

Copyright

URW Software, Copyright 1993 by URW

Font vendor

URW Type Foundry

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Bauhaus 93

Beesknees ITC font family
Article • 03/30/2022

Overview
ITC Beesknees? was created in 1972 by David Farey, a British graphic and type designer.
Influences for Mr Farey's type designs tend to be American, and Beesknees is no
exception. He credits Pushpin Studio, Peter Max, Bob Zoell, and the Marx Brothers for
much of the inspiration in this design. Farey has long admired both the cinematic humor
and typographic titles of the Marx Brother films. Originally, the face was to be called
"Horse Feathers" or "Monkey Business" after the famous Marx Brothers films. "Monkey
Business" stuck for a short while, but it was later shortened to just "Business" and soon
thereafter became "Beesknees." Since it is a caps-only face, Mr Farey claims that in
reality it should have been named "Half-a bee," or perhaps "Knees." A former employee
of the Letraset design office, Mr Farey is the managing director of the London design
shop, Panache Graphics.
Description
File name

Beesknee.ttf

Styles &
Weights

Beesknees ITC

Designers

Dave Farey

Copyright

Copyright (c) International Typeface Corporation 1996. Portions Copyright (c)
Microsoft Corporation 1996. All rights reserved.

Font

ITC

vendor
Script

N/A

Tags
Code

1252 Latin 1

pages

Mac Roman Macintosh Character Set (US Roman)

Fixed

False

pitch

Licensing and redistribution info
Font redistribution FAQ for Windows

License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Beesknees ITC

Bell MT font family
Article • 03/30/2022

Overview
The original of this face was made 200 years ago and is thought by some to mark the
introduction of the "modern" faces. It was made for Bell's Type Foundry by Richard
Austin at about the time that the face we now know as Firmin Didot also appeared. Bell
did not have a bold weight at that time. This new TrueType version, made in 1992 by
Monotype Typography, tries to emulate the roughness that they imagine characterized
typefounding in the 1780s. The metal version was a favorite of many designers who
used it to bring some character to the text they were printing.
Description
File name

Bell.ttf
Bellb.ttf
Belli.ttf

Styles &
Weights

Bell MT
Bell MT Bold
Bell MT Italic

Designers

Monotype Type Drawing Office

Copyright

Typeface © The Monotype Corporation plc. Data © The Monotype Corporation plc,
Type Solutions Inc 1990-1992. All rights reserved.

Font
vendor

Agfa Monotype Corporation

Script
Tags

N/A

Code
pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows

License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Bell MT

Bell MT Bold

Bell MT Italic

Bembo font family
Article • 03/30/2022

Overview
The Bembo® design is an old-style humanist serif typeface originally cut by Francesco
Griffo in 1495 and revived by Stanley Morison in 1929. The original Morison typeface
contained only four weights and no italics.
The Bembo design was named after notable the Venetian poet, Cardinal and literary
theorist of the 16th century Pietro Bembo. The typeface originally used to publish Pietro
Bembo’s book “De Aetna”, a book about Bembo’s visit to Mount Etna. The Bembo
typeface was cut by Francesco Griffo, a Venetian goldsmith who had become a
punchcutter and worked for revered printer Aldus Manutius.
Being a punchcutter meant that Griffo spent his days punching out the shape of a
typeface into steel. A punchcutter was a very skilled job and the their interpretation of a
typeface design would be what was eventually printed; typeface designers had little
input into the punchcutter’s work once their design had passed out of their hands. In
the case of the Bembo typeface, Griffo could not have known how important in the
history of typeface design his new cut would be.
The resulting typeface which was a departure from the common pen-drawn calligraphy
of the day, and looked more similar to the style of the roman typefaces we are familiar
with today. In fact, the characteristics of many other well known typefaces such as
Garamond® and Times® Roman can be traced back to the Bembo typeface. The
calligraphic style that the serifs pronounce imparts a warm human feel to the typeface.
Notably, the ascenders of the lowercase lettering are taller than the uppercase; also the
c is slanted forwards and there is a returned curve on the final stem of the m, n and h.
Morison’s Bembo design was released for typesetting in 1929, whose redesign was the
result of adapting the Bembo typeface to the machine composition and typesetting
requirements of the day. Morison, a well-respected English typographer, was a
typographic consultant to the Monotype Corporation. He also consulted for the London
Times newspaper, creating the typeface Times New Roman® in a successful effort to
improve the paper’s readability. Morison was influential in a number of areas of
typography, pioneering the creation of a large number of typefaces for Monotype. The
Bembo font family lives on as tribute to the superlative typographical efforts of Stanley
Morison.

Biblical scholars, linguists, medievalists and classicists have all found use for the Bembo
font family. In more modern settings it has a place in movie and book titling, as well as
representational texts. The Bembo typeface is inherently easy to read and therefore is an
excellent book font and has proved itself time and time again. – fonts.com
Description
File name

bembo.ttf
bemboi.ttf

Styles & Weights

Bembo
Bembo Bold Italic

Copyright

Digitized data copyright The Monotype Corporation 1991-1995.

Designers

Francesco Griffo
Monotype Studio

Font vendor

Monotype Corporation

Script Tags

dlng:'Latn'
slng:'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1254 Turkish
1257 Windows Baltic

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Bembo

Bembo Bold Italic

Berlin Sans FB font family
Article • 03/30/2022

Overview
Berlin Sans is based on a brilliant alphabet from the late twenties, the first sans that
Lucian Bernhard ever designed, imaginative and little-known. Assisted by Matthew
Butterick, David Berlow expanded the single font into a series of four weights, all four
complete with Expert character sets, plus one dingbat font.
Description
File name

Brlnsr.ttf
Brlnsb.ttf
Brlnsdb.ttf

Styles &
Weights

Berlin Sans FB
Berlin Sans FB Bold
Berlin Sans FB Demi Bold

Designers

David Berlow

Copyright

Copyright (c) 1997 The Font Bureau, Inc. All rights reserved. Designed by David
Berlow.

Font vendor

The Font Bureau, Inc.

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font

This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Berlin Sans FB

Berlin Sans FB Bold

Berlin Sans FB Demi Bold

Bernard MT Condensed font family
Article • 03/30/2022

Overview
A great many splendid types, including one called Bernhard Antiqua Schmalfette
(schmalfette means "bold condensed" in German), came from the Bauer foundry. The
version is comparable to the schmalfette version from Bauer, but in fact first came from
Monotype in 1926 with its unique spelling as Bernard. Bernard MT Condensed is one of
a group of typefaces developed during the first 20 or 30 years of this century, yet it
retains some affinity with the organic forms of the art nouveau movement. Generally,
these typefaces are black, making them suitable for display and poster work. Although
both bold and condensed, Bernard MT Condensed maintains a pleasant period charm
due to its balanced chunky serifs and rounded strokes. Use it in situations where you
want to get attention while maintaining a casual tone.
Description
File name

Bernhc.ttf

Styles &
Weights

Bernard MT Condensed

Designers

Monotype Type Drawing Office

Copyright

Design and data by The Monotype Corporation. © 1993. Microsoft Corporation.
All rights reserved.

Font vendor

Agfa Monotype Corporation

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Bernard MT Condensed

Bickley Script font family
Article • 03/30/2022

Overview
Bickley Script: This elegant, semi-informal script style recreates a copperplate form of
handwriting. The capitals are for initialing and offer a flowing complement to the
lowercase letters which join to simulate handwriting. An asset to any work requiring
such a light, refined effect.
Description
File name

Bicklysc.ttf

Styles &
Weights

Bickley Script

Designers

Alan Meeks

Copyright

COPYRIGHT ESSELTE LETRASET LTD., 1990. Portions copyright Microsoft
Corporation 1999. All Rights reserved.

Font
vendor

N/A

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Bickley Script

Biome font family
Article • 03/30/2022

Overview
Carl Crossgrove describes his Biome typeface family as “both futuristic and organic, with
a sense of calm.” He recalls, “My first sketches showed a globular, amorphous alphabet
derived from superellipses. At the same time, I was sketching a rectangular, vaguely
calligraphic sans serif design, on which I made the notation ‘square, futuristic,
mechanical.’ The two threads eventually joined in one typeface, incorporating many of
these contrasting qualities.”
Biome (bi as in binary + ome as in home) grew out of a succession of unrelated
typographic experiments. Crossgrove says, “I wanted to see what resulted from
subtracting superellipses from each other.” After Crossgrove had synthesized several
abstract concepts and influences, he proceeded to survey futuristic or rectilinear
typefaces, including the Eurostile, Neuropol, Rogue Sans, Handel Gothic, and Korataki
designs.
He observes, “Some of these faces were drawn within an unbending rectangular grid,
others were developed primarily for display sizes, or were based on the ‘Grotesk’
character structure. I saw that by retaining a softer demeanor, with generous character
spacing, Biome would accommodate a wider range of sizes and applications.” He adds,
“I looked at mid-20th century modern furniture and architecture, automobile styling and
even leaf shapes.” After successive design refinements and blending, the simplified,
superelliptical design with a large x-height, squared bowls and soft diagonal terminals
emerged.
A senior type designer at Monotype Imaging, Crossgrove has been obsessed with letters
since learning to read at the age of two. Born in Mexico and raised in central
Connecticut, his fascination emerged in early chalk-drawn alphabets on his family’s
driveway and giant letters cut from paper. Later in his youth, Crossgrove dabbled in
display lettering that was influenced by comic book art, record album covers and the Art
Nouveau resurgence of the 1970s. As he grew older, he discovered classical type and
lettering, and his typographic interests deepened.
Crossgrove has drawn a variety of typefaces ranging from the Reliq and Origami display
designs to the Beorcana and Mundo Sans typeface families. His work for Monotype
Imaging also takes him into the realm of custom font development and non-Latin
scripts.

Biome’s soft corners and distinctive character shapes make the family a natural for
branding, packaging and advertising applications as well as movie titles, gaming and
other interactive graphics.
The name Biome? Biomes are climatically and geographically similar climatic conditions,
such as communities of plants, animals and soil organisms – basically an ecosystem.
Biome is an apt name for a typeface that melds design influences from the myriad
aspects of modern life. – fonts.com
In 2019 we reviewed the set of fonts provided with Office identifying stylistic gaps. The
result of that effort was the addition of over a hundred new fonts, including classics like
Avenir Next LT Pro and Walbaum along with contemporary designs like The Hand,
Sagona and Modern Love. These new fonts are available in most Office applications and
have been used in a range of new templates.
Description
File name

biome.ttf
biome-italic.ttf
biome-light.ttf
biome-lightitalic.ttf

Styles & Weights

Biome
Biome Italic
Biome Light
Biome Light Italic

Copyright

Copyright © 2012-2015, 2018 Monotype Imaging Inc. All rights reserved

Designers

Carl Crossgrove

Font vendor

Monotype Corporation

Script Tags

dlng:'Latn'
slng:'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1254 Turkish
1257 Windows Baltic

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows

License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Biome

Biome Italic

Biome Light

Biome Light Italic

BIZ UDGothic font family
Article • 03/30/2022

Overview
Description
File name

BIZ-UDGothicR.ttc
BIZ-UDGothicB.ttc

Styles & Weights

BIZ UDGothic
BIZ UDGothic Bold
BIZ UDPGothic
BIZ UDPGothic Bold

Designers

TypeBank Co., Ltd.

Copyright

Font © Copyright 2017 Morisawa Inc. All rights reserved.

Font vendor

Morisawa Inc.

Script Tags

dlng: 'Jpan', 'Hrkt', 'Hira', 'Kana'
slng: 'Jpan', 'Hrkt', 'Hira', Kana', 'Latn', 'Grek', 'Cyrl'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
932 JIS/Japan
Mac Roman Macintosh Character Set (US Roman)
OEM OEM Character Set
869 IBM Greek
866 MS-DOS Russian
865 MS-DOS Nordic
863 MS-DOS Canadian French
861 MS-DOS Icelandic
860 MS-DOS Portuguese
857 IBM Turkish
855 IBM Cyrillic; primarily Russian
852 Latin 2
775 MS-DOS Baltic
737 Greek; former 437 G
850 WE/Latin 1
437 US

Description
Fixed pitch

True & False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Style & weight examples

Change list:
Windows 10 version 1809 released on November 13, 2018
BIZ UDGothic font family was introduced as part of the Windows 10 Japanese
Supplemental Fonts package.

BIZ UDMincho Medium font family
Article • 03/30/2022

Overview
Description
File name

BIZ-UDMinchoM.ttc

Styles & Weights

BIZ UDMincho Medium
BIZ UDPMincho Medium

Designers

TypeBank Co., Ltd.

Copyright

Font © Copyright 2017 Morisawa Inc. All rights reserved.

Font vendor

Morisawa Inc.

Script Tags

dlng: 'Jpan', 'Hrkt', 'Hira', 'Kana'
slng: 'Jpan', 'Hrkt', 'Hira', Kana', 'Latn', 'Grek', 'Cyrl'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
932 JIS/Japan
Mac Roman Macintosh Character Set (US Roman)
OEM OEM Character Set
869 IBM Greek
866 MS-DOS Russian
865 MS-DOS Nordic
863 MS-DOS Canadian French
861 MS-DOS Icelandic
860 MS-DOS Portuguese
857 IBM Turkish
855 IBM Cyrillic; primarily Russian
852 Latin 2
775 MS-DOS Baltic
737 Greek; former 437 G
850 WE/Latin 1
437 US

Fixed pitch

True & False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Style & weight examples

Change list:
Windows 10 version 1809 released on November 13, 2018
BIZ UDMincho Medium was introduced as part of the Windows 10 Japanese
Supplemental Fonts package.

Blackadder ITC font family
Article • 03/30/2022

Overview
Blackadder ITC font is an elegant, yet menacing display face is perfect for theatrical uses
and scare tactics.
Description
File name

Itcblkad.ttf

Styles &
Weights

Blackadder ITC

Designers

Bob Anderton

Copyright

Copyright (c) International Typeface Corporation 1997. Portions Copyright (c)
Microsoft Corporation 1997. All rights reserved.

Font
vendor

ITC

Script
Tags

N/A

Code
pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed

False

pitch

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Blackadder ITC

Bodoni MT font family
Article • 03/30/2022

Overview
Bodoni MT is a classic version of the modern style serif first produced by Monotype.
Description
File name

Bod_r.ttf
Bod_blar.ttf
Bod_blai.ttf
Bod_b.ttf
Bod_bi.ttf
Bod_i.ttf

Styles &
Weights

Bodoni MT
Bodoni MT Black
Bodoni MT Black Italic
Bodoni MT Bold
Bodoni MT Bold Italic
Bodoni MT Italic

Designers

Monotype Type Drawing Office

Copyright

Digitized data copyright Monotype Typography, Ltd 1999. All rights reserved.
Monotype Bodoni? is a trademark of Monotype Typography, Ltd which may be
registered in certain jurisdictions.

Font
vendor

N/A

Script
Tags

N/A

Code
pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed

False

pitch

Licensing and redistribution info
Font redistribution FAQ for Windows

License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Bodoni MT

Bodoni MT Black

Bodoni MT Black Italic

Bodoni MT Bold

Bodoni MT Bold Italic

Bodoni MT Italic

Bodoni MT Condensed font family
Article • 03/30/2022

Overview
Bodoni MT Condensed is a classic version of the modern style serif first produced by
Monotype.
Description
File name

Bod_cr.ttf
Bod_cb.ttf
Bod_cbi.ttf
Bod_ci.ttf
Bod_pstc.ttf

Styles &
Weights

Bodoni MT Condensed
Bodoni MT Condensed Bold
Bodoni MT Condensed Bold Italic
Bodoni MT Condensed Italic
Bodoni MT Poster Compressed

Designers

Monotype Type Drawing Office

Copyright

Digitized data copyright (C) 1999 Monotype Typography, Inc. All rights
reserved.

Font vendor

N/A

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples

Bodoni MT Condensed

Bodoni MT Condensed Bold

Bodoni MT Condensed Bold Italic

Bodoni MT Condensed Italic

Bodoni MT Poster Compressed

Bon Apetit MT font family
Article • 03/30/2022

Overview
Designed by Carolyn Gibbs, this is one of a set of versatile art fonts from Monotype.
Pieces of pie, a cup of tea, ice cream, lots of pictures to make your mouth water. Great
for instant illustrations, icons or bullets.
Description
File name

Boa.ttf

Styles &
Weights

Bon Apetit MT

Designers

Carolyn Gibbs

Copyright

Digitized data copyright (C) 1991-1996 The Monotype Corporation, Inc. All rights
reserved. Bon Apetit? is a trademark of the Monotype Corporation, Inc., which may
be registered in certain jurisdiction

Font
vendor

Agfa Monotype Corporation

Script
Tags

N/A

Code
pages

Symbol Symbol Character Set

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Bon Apetit MT

Bookman Old Style font family
Article • 03/30/2022

Overview
The origins of Bookman Old Style lie in the typeface called Oldstyle Antique, designed
by A C Phemister circa 1858 for the Miller and Richard foundry in Edinburgh, Scotland.
Many American foundries made versions of this type which eventually became known as
Bookman. Monotype Bookman Old Style roman is based on earlier Lanston Monotype
and ATF models. The italic has been re drawn following the style of the Oldstyle Antique
italics of Miller and Richard. Although called 'Old Style', the near vertical stress of the
face puts it into the transitional category. A legible and robust text face.
Description
File name

Bookos.ttf
Bookosb.ttf
Bookosbi.ttf
Bookosi.ttf

Styles &
Weights

Bookman Old Style
Bookman Old Style Bold
Bookman Old Style Bold Italic
Bookman Old Style Italic

Designers

Ong Chong Wah

Copyright

Digitized data copyright The Monotype Corporation 1991-1995. All rights reserved.
Bookman Old Style? is a trademark of The Monotype Corporation which may be
registered in certain jurisdictions.

Font
vendor

N/A

Script
Tags

N/A

Description
Code
pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
Mac Roman Macintosh Character Set (US Roman)
869 IBM Greek
866 MS-DOS Russian
865 MS-DOS Nordic
863 MS-DOS Canadian French
861 MS-DOS Icelandic
860 MS-DOS Portuguese
857 IBM Turkish
855 IBM Cyrillic; primarily Russian
852 Latin 2
775 MS-DOS Baltic
737 Greek; former 437 G
850 WE/Latin 1
437 US

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Bookman Old Style

Bookman Old Style Bold

Bookman Old Style Bold Italic

Bookman Old Style Italic

Bookshelf Symbol font family
Article • 03/30/2022

Overview
A special set of fonts with symbols used by various Microsoft applications.
Description
File name

Bssym1.ttf
Bssym2.ttf
Bssym3.ttf
Bookshelf Symbol 7.ttf

Styles &
Weights

Bookshelf Symbol 1
Bookshelf Symbol 2
Bookshelf Symbol 3
Bookshelf Symbol 7

Designers

N/A

Copyright

Typeface © The Monotype Corporation plc. Data © The Monotype Corporation
plc/Type Solutions Inc. 1990-1992. All Rights Reserved

Font
vendor

Microsoft Corp.

Script
Tags

N/A

Code
pages

437 US

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font

This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Bookshelf Symbol 1

Bookshelf Symbol 2

Bookshelf Symbol 3

Bookshelf Symbol 7

Book Antiqua font family
Article • 03/30/2022

Overview
This is a roman typeface based on pen-drawn letters of the Italian Renaissance. Because
it is distinctive and gentle in appearance it can be used to give a document a different
feel than is given by the more geometrical designs of most text faces. It is also useful for
occasional lines, as in letter headings and compliments slips. Its beautiful italic has many
uses of its own.
Description
File name

Bkant.ttf

Styles &
Weights

Book Antiqua
Book Antiqua Bold
Book Antiqua Bold Italic
Book Antiqua Italic

Designers

Monotype Type Drawing Office

Copyright

Digitized data copyright The Monotype Corporation 1991-1995. All rights reserved.
Book Antiqua? is a trademark of The Monotype Corporation which may be registered
in certain jurisdictions.

Font

Agfa Monotype Corporation

vendor
Script
Tags

N/A

Description
Code
pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
Mac Roman Macintosh Character Set (US Roman)
869 IBM Greek
866 MS-DOS Russian
865 MS-DOS Nordic
863 MS-DOS Canadian French
861 MS-DOS Icelandic
860 MS-DOS Portuguese
857 IBM Turkish
855 IBM Cyrillic; primarily Russian
852 Latin 2
775 MS-DOS Baltic
737 Greek; former 437 G
850 WE/Latin 1
437 US

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Book Antiqua

Book Antiqua Bold

Book Antiqua Bold Italic

Book Antiqua Italic

Bradley Hand ITC font family
Article • 03/30/2022

Overview
ITC Bradley Hand? is an informal script face based on the handwriting of British designer
Richard Bradley. Warm and familiar, ITC Bradley Hand has a relaxed rhythm typical of
handwriting and lends a personal touch to computer generated copy. Bradley, who has
been a lettering artist, type designer and studio artist for close to 30 years, has devoted
much of his work to Christian literature, and has designed typefaces for scripture verses
placed on panels or walls. With ITC Bradley Hand, he has created a friendly, everyday
typeface that humanizes the look of digital text. Released in 1996, ITC Bradley Hand is
available in regular and bold weights.
Description
File name

Bradhitc.ttf

Styles &
Weights

Bradley Hand ITC

Designers

Richard Bradley

Copyright

Copyright (c) International Typeface Corporation 1996. Portions Copyright (c)
Microsoft Corporation 1996. All rights reserved.

Font
vendor

ITC

Script
Tags

N/A

Code
pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Bradley Hand ITC

Braggadocio font family
Article • 03/30/2022

Overview
This lighthearted display face was designed by the gentle Bill Woolley when he was a
young man. His brief was to make a face that would be welcomed with glad cries by the
manufacturers of printing inks. Braggadocio first appeared in about 1930, so it
antedates the more condensed Futura Black that is more usually a part of every
designer's type library. How much nicer his letter y is!
Description
File name

Bragga.ttf

Styles &
Weights

Braggadocio

Designers

W.A. Wooley

Copyright

Copyright (c) 1992 Monotype Corporation plc. All rights reserved. Portions ©
1992 Microsoft Corp.

Font vendor

Agfa Monotype Corporation

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Braggadocio

BriemScript font family
Article • 03/30/2022

Overview
G.S. Briem, who holds a doctorate from the Royal College of Art in London, is that rare
being: an Icelander. In the 1980s, Briem, a well-known lecturer in many art schools,
wrote a much-admired monograph on teaching handwriting in schools. Since then, his
approach has been widely adopted in many places around the world. BriemScript was
designed for the experimental teaching of italic handwriting in Iceland. Try it for informal
notes and memos.
Description
File name

Briemscr.ttf

Styles &
Weights

BriemScript

Designers

N/A

Copyright

©1992 Gunnlaugur SE Briem © 1992 Type Solutions, Inc. Portions © 1992
Microsoft Corp. All rights reserved.

Font vendor

N/A

Script Tags

N/A

Code pages

869 IBM Greek
437 US

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
BriemScript

Britannic Bold font family
Article • 03/30/2022

Overview
This interesting face always excites heated opinions. Some, like the writer, have always
put Britannic Bold firmly in the category called 'Monumentally Overrated'. Others swear
by it. In fact, a survey conducted at great expense (among three people) found that two
out of three thought Britannic Bold was magnificent. And it can't be all bad, having
started life at the renowned Stephenson Blake type foundry, and to have outlasted the
same foundry's Rothbury, which to most people is probably indistinguishable from
Britannic. State your opinion. And if you like Britannic Bold, try it.
Description
File name

Britanic.ttf

Styles &
Weights

Britannic Bold

Designers

URW Studio, (Stephenson Blake), 1985, (1901)

Copyright

Typeface © 1992 Stephenson Blake (Holdings) Ltd. Data © 1992 URW. Portions ©
1992 Microsoft Corp. All rights reserved.

Font
vendor

URW Type Foundry

Script Tags

N/A

Code

1252 Latin 1

pages

Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font

This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Britannic Bold

Broadway font family
Article • 03/30/2022

Overview
First released in 1929, Broadway exudes the atmosphere of the Roaring Twenties. Thick
black strokes on the left half of characters such as the 'B' and 'O' make the letterforms
abstract and ornamental. Where thick and thin strokes meet, the letterforms feature
angles rather than curves, similar to the way Art Deco treats natural forms. Broadway is
ideal for the design of decorative posters and display material. With no descenders in
the lowercase letterforms, Broadway accepts bold underlining without the usual trouble
of disappearing descenders. In addition, due to its high contrast, Broadway remains
visible on backgrounds of similar density, making it ideal for colorful work. For example,
green lettering on a blue background would be difficult to read if the font were Arial,
but the same colors would be easier to read with the text in Broadway.
Description
File name

Broadw.ttf

Styles &
Weights

Broadway

Designers

Morris Fuller Benton, 1928

Copyright

Data copyright © URW Software & Type GmbH, additional data copyright © The
Monotype Corporation. Copyright © 1994-2002 Microsoft Corporation. All rights
reserved.

Font
vendor

URW Type Foundry

Script
Tags

N/A

Code
pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows

License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Broadway

BrowalliaUPC font family
Article • 03/30/2022

Overview
Browallia UPC font is a Thai font designed by Unity Progress and offered under license
from Microsoft.
Description
File name

Browau.ttf
Browaub.ttf
Browauz.ttf
Browaui.ttf

Styles &
Weights

BrowalliaUPC
BrowalliaUPC Bold
BrowalliaUPC Bold Italic
BrowalliaUPC Italic

Designers

N/A

Copyright

© 1992 Unity Progress. Portions © 2004 The Monotype Corporation. Portions ©
2015 Microsoft Corporation. All Rights Reserved.

Font
vendor

MS

Script

dlng:'Thai'

Tags

slng:'Thai', 'Latn'

Code

1252 Latin 1

pages

874 Thai

Fixed

False

pitch

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows Server 2008

5.00

Windows Server 2003

2.20

Windows XP

2.20

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
BrowalliaUPC

BrowalliaUPC Bold

BrowalliaUPC Bold Italic

BrowalliaUPC Italic

Browallia New font family
Article • 03/30/2022

Overview
Browallia New font is a Thai font designed by Unity Progress and offered under license
from Microsoft.
Description
File name

Browa.ttf
Browab.ttf
Browaz.ttf
Browai.ttf

Styles &
Weights

Browallia New
Browallia New Bold
Browallia New Bold Italic
Browallia New Italic

Designers

N/A

Copyright

© 1992 Unity Progress. Portions © 2004 The Monotype Corporation. Portions ©
2015 Microsoft Corporation. All Rights Reserved.

Font
vendor

Microsoft Corp.

Script

dlng:'Thai'

Tags

slng:'Thai', 'Latn'

Code

1252 Latin 1

pages

874 Thai

Fixed

False

pitch

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows Server 2008

5.00

Windows Server 2003

2.20

Windows XP

2.20

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Browallia New

Browallia New Bold

Browallia New Bold Italic

Browallia New Italic

Brush Script MT font family
Article • 03/30/2022

Overview
This heavy, informal script looks as though it was written with a brush because its
lowercase letters join together. Use the uppercase letters primarily as initials, although
you might find it interesting to use all capitals of this typeface for some words.
Description
File name

Brushsci.ttf

Styles & Weights

Brush Script MT Italic

Designers

Smith, Robert E.

Copyright

Copyright © 1993 , Monotype Typography ltd.

Font vendor

Agfa Monotype Corporation

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples

Brush Script MT Italic

Calibri font family
Article • 03/15/2025

Overview
Calibri is an extremely readable sans serif text typeface, with three weights, each with its
accompanying italic. The font's letter forms are very traditional, like a serif typeface from
centuries past; but it has no serifs, and the rounded ends of its strokes give it a
comfortable, friendly feel that works well in long texts. Calibri is a general workhorse of
a typeface, usable in almost any situation, from headlines to small text.
Calibri was designed by type designer Lucas de Groot in 2004 and published in 2007 as
one of the typefaces in the Microsoft ClearType font collection. Like the other ClearType
typefaces, Calibri was aimed squarely at making reading long texts easier on a screen,
although it also works well in print. Calibri became the default font in Office in 2007.
The font's character set covers many languages and several writing systems; it also
includes small capital letters, several styles of numerals, and useful characters such a
directional arrows.​​
ﾉ

Menu

Description

Files

Calibri.ttf

Expand table

Calibrib.ttf
Calibrii.ttf
Calibriz.ttf
Calibril.ttf
Calibrili.ttf
Styles &
Weights

Calibri
Calibri Bold
Calibri Italic
Calibri Bold Italic
Calibri Light
Calibri Light Italic

Designers

Luc(as) de Groot (Standard Latin, Cyrillic, Greek, and Hebrew), Mamoun Sakkal
(Arabic); Armenian and Georgian (Ruben Tarumian)

Copyright

© 2018 Microsoft Corporation. All Rights Reserved.

Font vendor

Microsoft Corporation

Menu

Description

Script Tags

Calibri.ttf & Calibrib.ttf & Calibriz.ttf:
dlng: 'Arab', 'Armn', 'Cyrl', 'Geok', 'Geor', 'Grek', 'Hebr', 'Latn'
slng: 'Arab', 'Armn', 'Cyrl', 'Geok', 'Geor', 'Grek', 'Hebr', 'Latn'
Calibrii.ttf & Calibril.ttf & Calibrili.ttf:
dlng: 'Armn', 'Cyrl', 'Geok', 'Geor', 'Grek', 'Hebr', 'Latn'
slng: 'Armn', 'Cyrl', 'Geok', 'Geor', 'Grek', 'Hebr', 'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1255 Hebrew
1256 Arabic
1257 Windows Baltic
1258 Vietnamese
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Download

N/A – Exclusively included with Microsoft products and services where
applicable.

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
ﾉ

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Expand table

Product name

Font version

Windows Vista

5.00

Windows Server 2008

5.00

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Calibri

Feedback
Was this page helpful?

 Yes

 No

Californian FB font family
08/08/2025

Overview
In 1938 Goudy designed California Oldstyle & Italic, perhaps his most distinguished typeface,
for private use of the University of California Press. In 1958 Lanston reissued it generally as
Californian. Recently the roman was digitized for California by Carol Twombly; David Berlow
redrew it when preparing italic & expert sets. Bold was drawn by Jane Patterson for the Font
Bureau, who used it privately for four years before release.
ﾉ

Expand table

Item

Description

File name

Califr.ttf
Califb.ttf
Califi.ttf

Styles &
Weights

Californian FB
Californian FB Bold
Californian FB Italic

Designers

David Berlow

Copyright

Copyright (c) 1989, 1994, 1997, 1998, The Font Bureau, Inc. Designed by David Berlow
after Fred Goudy. All rights reserved.

Font vendor

The Font Bureau, Inc.

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Download

N/A – Exclusively included with Microsoft products and services where applicable.

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this page.

Style & weight examples
Californian FB

Californian FB Bold

Californian FB Italic

Calisto MT font family
08/08/2025

Overview
A typeface whose appeal as a text face lies in its very even colour on the page, while its robust
construction means that it can wrk equally well at display sizes. The slightly calligraphic
treatment of letter shapes and the classical proportions of the face give a clean elegance on
the page. Calisto is a graceful and interesting addition to the typographer's repertoire and will
prove particularly useful for book, magazine and advertizing work.
ﾉ

Expand table

Item

Description

File name

Calist.ttf
Calistb.ttf
Calistbi.ttf
Calisti.ttf

Styles &
Weights

Calisto MT
Calisto MT Bold
Calisto MT Bold Italic
Calisto MT Italic

Designers

Ron Carpenter

Copyright

Digitized data copyright (C) 1991-1997 The Monotype Corporation. All rights reserved.
Calisto? is a trademark of The Monotype Corporation which may be registered in certain
jurisdictions.

Font vendor

Agfa Monotype Corporation

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Download

N/A – Exclusively included with Microsoft products and services where applicable.

Licensing and redistribution info
Font redistribution FAQ for Windows

License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this page.

Style & weight examples
Calisto MT

Calisto MT Bold

Calisto MT Bold Italic

Calisto MT Italic

Cambria font family
10/11/2025

Overview
Cambria is a text typeface with serifs designed for reading long documents onscreen or in
print. The proportions of the letters are even and the spacing between letters is open, giving
the typeface an even texture in paragraphs of text. There is very little contrast between thick
and thin strokes in the horizontal direction, but a bit more in the vertical direction. Cambria’s
serifs are short and stubby. The italic is subdued and plays a secondary role to the upright
style.
Type designer Jelle Bosma designed Cambria to be a potential replacement for Times New
Roman. The two typefaces don’t look much alike, but they serve the same function as a
workhorse typeface suitable for use in text almost anywhere. Cambria was designed in 2004 as
part of the Microsoft ClearType font collection, to make reading onscreen easier and more
comfortable. Cambria also has an extensive set of mathematical characters and symbols,
making it one of the best typefaces for typesetting math. The Greek and Cyrillic has been
designed under close supervision of an international team of experts, who aimed to set a
historical new standard in multi-script type design.
ﾉ

Item

Description

File name

Cambria.ttc
Cambriab.ttf
Cambriaz.ttf
Cambriai.ttf

Styles & Weights

Cambria
Cambria Bold
Cambria Bold Italic
Cambria Italic
Cambria Math

Designers

Monotype Imaging and Tiro Typeworks

Copyright

© 2017 Microsoft Corporation. All rights reserved.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Armn', 'Cyrl', 'Grek', 'Latn'
slng:'Armn', 'Cyrl', 'Grek', 'Latn'

Expand table

Item

Description

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
1258 Vietnamese
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Download

N/A – Exclusively included with Microsoft products and services where applicable.

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts: These Microsoft fonts can be licensed from Tiro Typeworks
Monotype

or

for a range of uses, including individual device use outside of Microsoft

products, webfonts, app embedding, enterprise computing and server installations, and
hardware and software redistribution.

Products that supply this font
ﾉ

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows Server 2008

5.00

Office 2007

1.02

Office Mac 2008

2.00

Expand table

This typeface is also available within Office applications. For more information visit this page.

Style & weight examples
Cambria

Candara font family
08/08/2025

Overview
Candara is a casual humanist sans with verticals showing a graceful entasis on stems, highbranching arcades in the lowercase, large apertures in all open forms, and unique ogee curves
on diagonals. The resultant texture is lively but not intrusive, and makes for a friendly and
readable text. Candara is a very useful typeface for email or web pages as well as for
newsletters, booklets, and flyers.
There are almost no straight lines in Candara’s letters; instead, what appear to be long, straight
strokes actually curve slightly inward in the middle, an effect that architects call “entasis.” In
addition, diagonal strokes have a very slight double-S curve. At small sizes – or at a distance
when looking at a classical building – these features make the lines look straight, but when you
use Candara in a large headline, the subtle curves give it an unexpected elegance.
Candara’s italic is less architectural and more calligraphic in style than the upright letters, but
they work very well together.
ﾉ

Item

Description

File name

Candara.ttf
Candarab.ttf
Candaraz.ttf
Candarai.ttf
Candaral.ttf
Candarali.ttf

Styles & Weights

Candara
Candara Bold
Candara Bold Italic
Candara Italic
Candara Light
Candara Light Italic

Designers

Gary Munch

Copyright

© 2008 Microsoft Corporation. All Rights Reserved.

Font vendor

Microsoft Corp.

Expand table

Item

Description

Script Tags

dlng:'Cyrl', 'Grek', 'Latn'
slng:'Cyrl', 'Grek', 'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
1258 Vietnamese
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Download

N/A – Exclusively included with Microsoft products and services where applicable.

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
ﾉ

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows Server 2008

5.00

Office 2007

1.02

Office Mac 2008

2.00

Expand table

This typeface is also available within Office applications. For more information visit this page.

Style & weight examples

Change list:
Windows 10 version 1809 released on November 13, 2018
The following two styles were added to the Candara font family
Candara Light
Candara Light Italic
These styles were created by Monotype.

Windows 7
The fonts were extended to support the Vietnamese language.

Windows Vista

Candara was introduced as part of the ClearType font collection. Initially it was available in four
styles with a pan European language character set.
Candara
Candara Bold
Candara Bold Italic
Candara Italic

Cariadings font family
08/08/2025

Overview
Cariadings? is a decorative symbol font based by Geraldine Wade. It is based on simple lines,
symmetry and reference to nature. Cariadings' images are intended as typographic ornaments
that can be used as watermarks, border enhancements or icons. Designer: Geraldine Wade.
ﾉ

Expand table

Item

Description

File name

CariaDng.ttf

Styles & Weights

Cariadings

Designers

Geraldine Wade

Copyright

© 2006 Microsoft Corporation. All Rights Reserved.

Font vendor

N/A

Script Tags

N/A

Code pages

Symbol Symbol Character Set

Fixed pitch

False

Download

N/A – Exclusively included with Microsoft products and services where applicable.

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Cariadings

Castellar font family
08/08/2025

Overview
John Peters drew Castellar in 1957 for Monotype when phototypesetting was in its infancy, well
before the first laser printer appeared. This typeface, designed for titles, cannot, unlike
Monotype's Centaur, be used for anything else. If you print Castellar in too small a size on a
laser printer with a resolution of 300 dots per inch, watch out! And if that doesn't discourage
you from misusing the typeface, nothing will. Stay above 24 points, and you'll be safe.
ﾉ

Expand table

Item

Description

File name

Castelar.ttf

Styles &
Weights

Castellar

Designers

John Peters

Copyright

Copyright (C) 1992 Monotype Corporation plc. All rights reserved. Portions © 1992
Microsoft Corp. All rights reserved.

Font vendor

Monotype

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Download

N/A – Exclusively included with Microsoft products and services where applicable.

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples

Castellar

Cavolini font family
Article • 03/30/2022

Overview
Although made for small screen imaging, the Cavolini™ typeface has the personality and
strength to be practical for everything from small hard-copy text to digital banners.
Drawn by Carl Crossgrove, Cavolini has the charm and immediacy of handwriting, and
adds to this the design traits necessary for high levels of typographic clarity.
Cavolini’s large x-height, open character spacing, clearly defined apertures, and easily
differentiated forms enable high levels of legibility and readability at small sizes. The
family’s multiple designs of roman, bold and italic in regular and condensed proportions
also enable breadth of choice for creating emphasis, hierarchy, and typographic diversity
in a wide variety of environments. The design enjoys a generous x-height, while informal
strokes, a natural finish, and wide proportions, give Cavolini a casual and relaxed
affability. Small screen legibility is also enhanced through generous character spacing.
Cavolini takes advantage of a quality in handwriting that is not normally obvious: a
meandering, unstructured stress. Diagonals, verticals, crossbars (whichever letterform
component is likely to be written emphatically in an organic and fast way) is likely to be
slightly thicker, while there is very little stroke contrast overall.
Obsessed with letters since he learned to read at the age of two, Crossgrove’s early
fascination showed up as chalk drawn alphabets on his parent’s driveway and giant
letters cut from paper. During his youth, Crossgrove dabbled in display lettering and
was influenced by comic books, record album covers and the Art Nouveau resurgence
of the 1970s. As he grew older, he discovered classical type designs and lettering,
deepening his typographic interests. Today, Crossgrove is a senior designer in the
Monotype Studio. A variety of typefaces, ranging from the Reliq™, Origami™ and
Beorcana designs, to the Mundo Sans™ and Burlingame™ families are the result of
Crossgrove’s talent and skill. His work for Monotype also often takes him into the realm
of non-Latin scripts and font production
While Cavolini was developed for low resolution use, it has the personality and strength
to be an excellent choice for everything from packaging to correspondence – just about
anywhere a casual mien is desired. Cavolini will also thrive at small sizes in digital
environments as far ranging as vehicle interfaces and wearables. – fonts.com
In 2019 we reviewed the set of fonts provided with Office identifying stylistic gaps. The
result of that effort was the addition of over a hundred new fonts, including classics like

Avenir Next LT Pro and Walbaum along with contemporary designs like The Hand,
Sagona and Modern Love. These new fonts are available in most Office applications and
have been used in a range of new templates.
Description
File name

Cavolini.ttf
Cavolini-bold.ttf
Cavolini-bolditalic.ttf
Cavolini-italic.ttf

Styles & Weights

Cavolini
Cavolini Bold
Cavolini Bold Italic
Cavolini Italic

Copyright

Copyright © 2015, 2016 Monotype Imaging Inc. All rights reserved

Designers

Carl Crossgrove

Font vendor

Monotype Corporation

Script Tags

dlng:'Latn'
slng:'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1254 Turkish
1257 Windows Baltic

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples

Cavolini

Cavolini Bold

Cavolini Bold Italic

Cavolini Italic

Centaur font family
08/08/2025

Overview
Bruce Rogers, one of the giants of the United States typographic community, designed Centaur
in 1914 for the Metropolitan Museum to use for titles. Subsequently, various people reworked
Centaur into a text face. It cannot be disguised that, in the opinion of the writer, each version
has lost some of the vigor of the version that preceded it. This version is now issued by
Monotype Typography. Centaur is what is known as a Venetian face, characterized by oblique
stress, minimal contrast between thick and thin strokes, the slanted bar in the e, and heavy
serifs. You can stick with it for titles, but Centaur remains legible in much smaller sizes than
anybody ever dreamed of. At small sizes, Centaur is like any Venetian face in that you won't be
able to tell that it is Centaur.
ﾉ

Expand table

Item

Description

File name

Centaur.ttf

Styles &
Weights

Centaur

Designers

Bruce Rogers

Copyright

Typeface © The Monotype Corporation plc. Data © The Monotype Corporation plc/Type
Solutions Inc. 1990-91-92 All Rights Reserved. Portions © 1992 Microsoft Corp.

Font vendor

N/A

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Download

N/A – Exclusively included with Microsoft products and services where applicable.

Licensing and redistribution info
Font redistribution FAQ for Windows

License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this page.

Style & weight examples
Centaur

Century font family
08/08/2025

Overview
Another member of the Century family which was based on Century Expanded. Designed to
fulfill the need for a solid, legible face for printing schoolbooks. It is wider and heavier than
Century Expanded, there is also less contrast between thick and thin strokes. First cut by
Monotype in 1934 and based on versions from ATF and Lanston Monotype. The sturdy nature
of this typeface, coupled with its inherent legibility, has made it a popular choice for setting
books, newspapers and magazines. This version of Century has been adjusted for use in Asian
typography.
ﾉ

Expand table

Item

Description

File name

CENTURY.ttf

Styles &
Weights

Century

Designers

Morris Fuller Benton

Copyright

Digitized data copyright (C) 1992-1997 The Monotype Corporation. All rights reserved.
Century? is a trademark of The Monotype Corporation which may be registered in certain
jurisdictions.

Font vendor

N/A

Script Tags

N/A

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
Mac Roman Macintosh Character Set (US Roman)
869 IBM Greek
866 MS-DOS Russian
865 MS-DOS Nordic
863 MS-DOS Canadian French
861 MS-DOS Icelandic
860 MS-DOS Portuguese
857 IBM Turkish

Item

Description
855 IBM Cyrillic; primarily Russian
852 Latin 2
775 MS-DOS Baltic
737 Greek; former 437 G
850 WE/Latin 1
437 US

Fixed pitch

False

Download

N/A – Exclusively included with Microsoft products and services where applicable.

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this page.

Style & weight examples
Century

Century Gothic font family
08/08/2025

Overview
A design based on Monotype 20th Century, which was drawn by Sol Hess between 1936 and
1947. Century Gothic maintains the basic design of 20th Century but has an enlarged 'x' height
and has been modified to ensure satisfactory output from modern digital systems. The design
is influenced by the geometric style sans serif faces which were popular during the 1920's and
30's. Useful for headlines and general display work and for small quantities of text, particularly
in advertising.
ﾉ

Expand table

Item

Description

File name

Gothic.ttf
Gothicb.ttf
Gothicbi.ttf
Gothici.ttf

Styles &
Weights

Century Gothic
Century Gothic Bold
Century Gothic Bold Italic
Century Gothic Italic

Designers

Monotype Type Drawing Office

Copyright

Typeface © The Monotype Corporation plc. Data © The Monotype Corporation plc /
Type Solutions Inc. 1990-91 All Rights Reserved

Font vendor

Agfa Monotype Corporation

Script Tags

N/A

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
Mac Roman Macintosh Character Set (US Roman)
869 IBM Greek
866 MS-DOS Russian
865 MS-DOS Nordic
863 MS-DOS Canadian French

Item

Description
861 MS-DOS Icelandic
860 MS-DOS Portuguese
857 IBM Turkish
855 IBM Cyrillic; primarily Russian
852 Latin 2
775 MS-DOS Baltic
737 Greek; former 437 G
850 WE/Latin 1
437 US

Fixed pitch

False

Download

N/A – Exclusively included with Microsoft products and services where applicable.

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is also available within Office applications. For more information visit this page.

Style & weight examples
Century Gothic

Century Gothic Bold

Century Gothic Bold Italic

Century Gothic Italic

Century Schoolbook font family
08/08/2025

Overview
The first Century was cut by Linn Boyd Benton working with T. L. De Vinne for Century
magazine to replace the unsuitable face they had used previously. This was followed a few
years later, at the turn of the century, by Century Expanded. It was Morris Fuller Benton, who
made several other versions of Century, who also made several versions Schoolbook for ATF,
starting in about 1919. The best known appeared in 1924. This face does the job it was meant
to do very well. It is round, open, and sturdy, and although heavier in appearance than many
other serif fonts, it comes near the top of the list of no-nonsense text fonts that will withstand
a lot of punishment. Generations of children learned to read with this font.
ﾉ

Item

Description

File name

Censcbk.ttf
Schlbkb.ttf
Schlbkbi.ttf
Schlbki.ttf

Styles &
Weights

Century Schoolbook
Century Schoolbook Bold
Century Schoolbook Bold Italic

Expand table

Century Schoolbook Italic
Designers

Morris Fuller Benton

Copyright

Typeface © The Monotype Corporation plc. Data © The Monotype Corporation plc /
Type Solutions Inc. 1990-91 All Rights Reserved.

Font vendor

N/A

Script Tags

N/A

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
Mac Roman Macintosh Character Set (US Roman)
869 IBM Greek
866 MS-DOS Russian

Item

Description
865 MS-DOS Nordic
863 MS-DOS Canadian French
861 MS-DOS Icelandic
860 MS-DOS Portuguese
857 IBM Turkish
855 IBM Cyrillic; primarily Russian
852 Latin 2
775 MS-DOS Baltic
737 Greek; former 437 G
850 WE/Latin 1
437 US

Fixed pitch

False

Download

N/A – Exclusively included with Microsoft products and services where applicable.

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is also available within Office applications. For more information visit this page.

Style & weight examples
Century Schoolbook

Century Schoolbook Bold

Century Schoolbook Bold Italic

Century Schoolbook Italic

Chiller font family
Article • 03/30/2022

Overview
Chiller font, with its alarming, sudden presence, is on the cutting edge of modern
typographic style.
Description
File name

Chiller.ttf

Styles &
Weights

Chiller

Designers

Andrew Smith

Copyright

Copyright Esselte Corporation 1997. Portions Copyright Microsoft 1997. All
rights reserved.

Font vendor

ITC Corporation

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples

Chiller

Colonna MT font family
08/08/2025

Overview
Developed by Monotype in 1927, this inline roman face has some very elegant letterforms.
Colonna looks its best in larger sizes, consistent with its origins as an advertising face.
ﾉ

Expand table

Item

Description

File name

Colonna.ttf

Styles & Weights

Colonna MT

Designers

Monotype Design Studio

Copyright

Copyright © The Monotype Corporation plc. 1992. All rights reserved.

Font vendor

Agfa Monotype Corporation

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Download

N/A – Exclusively included with Microsoft products and services where applicable.

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this page.

Style & weight examples

Colonna MT

Comic Sans MS font family
08/08/2025

Overview
Comic Sans MS is the groovy script font which was first supplied with the Windows 95 Plus!
pack. Although it might be seen as a novelty typeface, which is great for titles, it's also
extremely readable on-screen at small sizes, making it a useful text face.
A note from Vincent Connare, Comic Sans' designer.
During 1994 I noticed that a large number of cartoon/comic style software titles were
under development at Microsoft. As Microsoft Creative Writer had a need for fun fonts, I
had an idea to make a lettering script similar to the lettering used by the major comic
books.
There was a consistent style used in comics, which was quite unlike the style of lettering
you see in newspaper cartoon strips. I also noticed that many people were inappropriately
using drafting lettering in comic speech balloons.
I started to make the font in October 1994. Initially it was picked up by the team working
on Microsoft 3D Movie Maker for use in speech balloons. As 3D Movie Maker progressed,
the programmers added sound so that the characters didn't use balloons. However, the
regular weight was still used for help pop-ups and dialog boxes.
Because the regular weight was cleanly hinted for the screen it was also included with the
Windows 95 OEM version, the Windows 95 Plus pack, Publisher and Microsoft Internet
Explorer. Hope you find the font fun.
Interesting fact - the euro has eyes.

Comic Sans MS version history
Version 2.10 - This version includes some minor table updates, but no new glyphs.
Version 2.00 - Comic Sans version 2.00 was added to our core fonts for the Web page on 4
March 1998. This WGL4 version includes the euro currency symbol.
Version 1.20 - Comic Sans MS version 1.20 was first supplied with Microsoft Internet Explorer 3,
and included as one of the original Microsoft core fonts for the Web. This version was also
supplied with Internet Explorer 4.

Version 1.10 - This version of Comic Sans MS was supplied with the Windows 95 Plus! pack.
ﾉ

Item

Description

File name

Comic.ttf

Expand table

Comicbd.ttf
Comicz.ttf
Comici.ttf
Styles & Weights

Comic Sans MS
Comic Sans MS Bold
Comic Sans MS Bold Italic
Comic Sans MS Italic

Designers

Vincent Connare

Copyright

© 2018 Microsoft Corporation. All Rights Reserved.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Cyrl', 'Grek', 'Latn'
slng:'Cyrl', 'Grek', 'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Download

N/A – Exclusively included with Microsoft products and services where applicable.

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
ﾉ

Expand table

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

2.10

Windows 2000

2.00

Windows Server 2008

5.00

Windows Server 2003

2.10

This typeface is also available within Office applications. For more information visit this page.

Style & weight examples
Comic Sans MS

Consolas font family
10/07/2025

Overview
Consolas is aimed for use in programming environments and other circumstances where a
monospaced font is specified. All characters have the same width, like old typewriters, making
it a good choice for personal and business correspondance. The improved Windows font
display allowed a design with proportions closer to normal text than traditional monospaced
fonts like Courier. This allows for more comfortably reading of extended text on screen.
OpenType features include hanging or lining numerals; slashed, dotted and normal zeros; and
alternative shapes for a number of lowercase letters. The look of text can be tuned to personal
taste by varying the number of bars and waves.
ﾉ

Item

Description

File name

Consola.ttf
Consolab.ttf
Consolaz.ttf
Consolai.ttf

Styles & Weights

Consolas
Consolas Bold
Consolas Bold Italic
Consolas Italic

Designers

Luc(as) de Groot

Copyright

© 2018 Microsoft Corporation. All rights reserved.

Trademark

Consolas is a trademark of the Microsoft group of companies.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Armn', 'Cyrl', 'Grek', 'Latn'
slng:'Armn', 'Cyrl', 'Grek', 'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
1258 Vietnamese

Expand table

Item

Description
Mac Roman Macintosh Character Set (US Roman)
OEM OEM Character Set
869 IBM Greek
866 MS-DOS Russian
865 MS-DOS Nordic
863 MS-DOS Canadian French
861 MS-DOS Icelandic
860 MS-DOS Portuguese
857 IBM Turkish
855 IBM Cyrillic; primarily Russian
852 Latin 2
775 MS-DOS Baltic
737 Greek; former 437 G
850 WE/Latin 1
437 US

Fixed pitch

True

Download

N/A – Exclusively included with Microsoft products and services where applicable.

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
ﾉ

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows Server 2008

5.00

Expand table

Product name

Font version

Office 2007

1.02

Office Mac 2008

2.00

This typeface is also available within Office applications. For more information visit this page.

Style & weight examples

Constantia font family
10/11/2025

Overview
Constantia font is a modulated wedge-serif typeface designed by John Hudson primarily for
continuous text in both electronic and paper publishing.
ﾉ

Item

Description

File name

Constan.ttf
Constanb.ttf
Constanz.ttf
Constani.ttf

Styles & Weights

Constantia
Constantia Bold
Constantia Bold Italic
Constantia Italic

Designers

John Hudson

Copyright

© 2012 Microsoft Corporation. All Rights Reserved.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Cyrl', 'Grek', 'Latn'

Expand table

slng:'Cyrl', 'Grek', 'Latn'
Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
1258 Vietnamese
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Download

N/A – Exclusively included with Microsoft products and services where applicable.

Licensing and redistribution info

Font redistribution FAQ for Windows
License Microsoft fonts: These Microsoft fonts can be licensed from Tiro Typeworks
Monotype

or

for a range of uses, including individual device use outside of Microsoft

products, webfonts, app embedding, enterprise computing and server installations, and
hardware and software redistribution.

Products that supply this font
ﾉ

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows Server 2008

5.00

Office 2007

1.02

Office Mac 2008

2.00

Expand table

This typeface is also available within Office applications. For more information visit this page.

Style & weight examples
Constantia

Constantia Bold

Constantia Bold Italic

Constantia Italic

Contemporary Brush font family
08/08/2025

Overview
Filmotype, introduced in the 1950s, was the first mass-produced machine that used
photographic techniques to replace hand lettering. That foundry quickly built up a large library
of faces of hand-lettered type by famous lettering artists of the time, created by people like
Tommy Thompson. As time passed, more and more genuine typefaces were brought into the
Filmotype library, supplementing the original hand-lettered faces. Here we have a strong,
generous pair of fonts that came from the Filmotype library. Nothing needs to be said about
these two that your eye will not tell you. A document written in Contemporary Brush is, at the
same time, both legible and informal. Although most informal faces do not want to be used for
large blocks of text, this face can stand it.
ﾉ

Expand table

Item

Description

File name

Conbrsh.ttf
Conbrshb.ttf

Styles &
Weights

Contemporary Brush
Contemporary Brush Bold

Designers

N/A

Copyright

Copyright 1989-1992 The Font Company. All rights reserved. Portions © 1992 Microsoft
Corp. All rights reserved.

Font vendor

The Font Company

Script Tags

N/A

Code pages

869 IBM Greek
437 US

Fixed pitch

False

Download

N/A – Exclusively included with Microsoft products and services where applicable.

Licensing and redistribution info
Font redistribution FAQ for Windows

License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Contemporary Brush

Contemporary Brush Bold

Cooper Black font family
08/08/2025

Overview
Popular since it was designed in 1921, Cooper Black has inspired many imitations. However,
although many type designers and manufacturers have tried to market similar designs, none
has outdone Cooper Black. The blunt and rounded forms, blurred serifs, and very small
counters make this a warm and friendly face. Its most distinctive features are the backward tilt
of the counters on the 'O' and 'Q', as well as the elliptical dots in the 'i' and 'j'. More than
anything else, its blackness draws attention to Cooper Black. The lack of contrast in the design
calls for using this font on a clearly divergent background.
ﾉ

Expand table

Item

Description

File name

Coopbl.ttf

Styles &
Weights

Cooper Black

Designers

Oswald Bruce Cooper, 1993, (1921)

Copyright

Data copyright © URW Software & Type GmbH., additional data copyright The Monotype
Corporation. Copyright 1994 Microsoft Corporation. All rights reserved.

Font vendor

URW Type Foundry

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Download

N/A – Exclusively included with Microsoft products and services where applicable.

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this page.

Style & weight examples
Cooper Black

Copperplate Gothic font family
08/08/2025

Overview
Originally designed in 1901, Copperplate Gothic was first released as a font family containing
several weights and condensed variations. The font name reflects the popularity of this
particular style of typeface during the time that copperplate engraving was a popular
technique for reproducing illustrated material; from about 1530 up to the 19th century.
Although a true lowercase has never been designed, Copperplate Gothic is ideal for all-capital
text typically set in small print. For example, it's very popular for use on business cards. Tiny
serifs lend Copperplate Gothic a distinctive feel. The design captures both the sturdiness of a
sans serif, as well as the elegance of typefaces with serifs.
ﾉ

Expand table

Item

Description

File name

Coprgtb.ttf
Coprgtl.ttf

Styles &
Weights

Copperplate Gothic Bold
Copperplate Gothic Light

Designers

N/A

Copyright

Data copyright © URW Software & Type GbmH., additional data copyright The Font
Bureau, Inc. Copyright 1994 Microsoft Corporation. All rights reserved.

Font vendor

N/A

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Download

N/A – Exclusively included with Microsoft products and services where applicable.

Licensing and redistribution info
Font redistribution FAQ for Windows

License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this page.

Style & weight examples
Copperplate Gothic Bold

Copperplate Gothic Light

Corbel font family
08/08/2025

Overview
Corbel is designed to give an uncluttered and clean appearance on screen. The letter forms are
open with soft, flowing curves. It is legible, clear and functional at small sizes. At larger sizes the
detailing and style of the shapes is more apparent resulting in a modern sans serif type with a
wide range of possible uses.
ﾉ

Item

Description

File name

Corbel.ttf
Corbelb.ttf
Corbelz.ttf
Corbeli.ttf
Corbell.ttf
Corbelli.ttf

Styles & Weights

Corbel
Corbel Bold
Corbel Bold Italic
Corbel Italic
Corbel Light
Corbel Light Italic

Designers

Jeremy Tankard

Copyright

© 2018 Microsoft Corporation. All rights reserved.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Cyrl', 'Grek', 'Latn'
slng:'Cyrl', 'Grek', 'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
1258 Vietnamese
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Expand table

Item

Description

Download

N/A – Exclusively included with Microsoft products and services where applicable.

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
ﾉ

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows Server 2008

5.00

Office 2007

1.02

Office Mac 2008

2.00

Expand table

This typeface is also available within Office applications. For more information visit this page.

Style & weight examples

Change list:
Windows 10 version 1809 released on November 13, 2018
The following two styles were added to the Corbel font family
Corbel Light
Corbel Light Italic These styles were created by Monotype.

Windows 7
The fonts were extended to support the Vietnamese language.

Windows Vista
Corbel was introduced as part of the ClearType font collection. Initially it was available in four
styles with a pan European language character set.
Corbel
Corbel Bold
Corbel Bold Italic
Corbel Italic

CordiaUPC font family
08/08/2025

Overview
Cordia is a typeface designed for typesetting the Thai language in the Thai script. It is an
“geometric” design, with simple, straight strokes combined with round curves. It has no
contrast between thick and thin strokes, even in the loops (small circles at the extremes of
some letters). It is suitable for body text with modern, futuristic appearance.
Cordia was designed by Unity Progress Corp in 1992. It has two weights, Regular and Bold, with
complementary slanted (italic) styles for each. The font includes capitals and lowercase letters
for the Latin alphabet. Cordia New is a newer version of the same typeface, with small
adjustments.
ﾉ

Item

Description

File name

Cordiau.ttf
Cordiaub.ttf
Cordiauz.ttf
Cordiaui.ttf

Styles &
Weights

CordiaUPC
CordiaUPC Bold
CordiaUPC Bold Italic

Expand table

CordiaUPC Italic
Designers

N/A

Copyright

© 1992 Unity Progress. Portions © 2004 The Monotype Corporation. Portions © 2019
Microsoft Corporation. All Rights Reserved.

Font vendor
Script Tags

dlng:'Thai'
slng:'Thai', 'Latn'

Code pages

1252 Latin 1
874 Thai

Download

N/A – Exclusively included with Microsoft products and services where applicable.

Licensing and redistribution info

Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
ﾉ

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows Server 2008

5.00

Windows Server 2003

2.20

Windows XP

2.20

Expand table

This typeface is also available within Office applications. For more information visit this page.

Style & weight examples
CordiaUPC

Cordia New font family
08/08/2025

Overview
Cordia is a typeface designed for typesetting the Thai language in the Thai script. It is an
“geometric” design, with simple, straight strokes combined with round curves. It has no
contrast between thick and thin strokes, even in the loops (small circles at the extremes of
some letters). It is suitable for body text with modern, futuristic appearance.
Cordia was designed by Unity Progress Corp in 1992. It has two weights, Regular and Bold, with
complementary slanted (italic) styles for each. The font includes capitals and lowercase letters
for the Latin alphabet. Cordia New is a newer version of the same typeface, with small
adjustments.
ﾉ

Item

Description

File name

Cordia.ttf
Cordiab.ttf
Cordiaz.ttf
Cordiai.ttf

Styles &
Weights

Cordia New
Cordia New Bold
Cordia New Bold Italic

Expand table

Cordia New Italic
Designers

N/A

Copyright

© 1992 Unity Progress. Portions © 2004 The Monotype Corporation. Portions © 2019
Microsoft Corporation. All Rights Reserved.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Thai'
slng:'Thai', 'Latn'

Code pages

1252 Latin 1
874 Thai

Fixed pitch

False

Download

N/A – Exclusively included with Microsoft products and services where applicable.

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
ﾉ

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows Server 2008

5.00

Windows Server 2003

2.20

Windows XP

2.20

Expand table

This typeface is also available within Office applications. For more information visit this page.

Style & weight examples
Cordia New

Courier New font family
08/08/2025

Overview
Designed as a typewriter face for IBM, Courier was re drawn by Adrian Frutiger for IBM
Selectric series. A typical fixed pitch design, monotone in weight and slab serif in concept. Used
to emulate typewriter output for reports, tabular work and technical documentation.

Courier New version history
Version 2.55 - This WGL4 version of Courier New was first supplied with the Final Windows 95
euro update that shipped on 4 November 1998. This version contains the euro.
Version 2.50 - This version of Courier New is supplied with European versions of Windows 98.
North American users can add it by installing multilanguage support. This version contains the
euro.
Version 2.45 - This Win ANSI version of Courier New is supplied with the US version of
Windows 98.
Version 2.01 - This special version of Courier New is only supplied with the beta version of the
Windows 95 euro update patch.
Version 2.00 (Win ANSI) - This Win ANSI version of Courier New is supplied with Windows 95.
Version 2.00 (WGL4) - This WGL4 version of Courier New is supplied with Windows 95 and
Windows NT4. This version does not contain the euro.
Version 1.00 - This version was supplied with Windows 3.1 and Windows for Workgroups 3.11.
ﾉ

Item

Description

File name

Cour.ttf
Courbd.ttf
Courbi.ttf
Couri.ttf

Styles &
Weights

Courier New
Courier New Bold

Expand table

Item

Description
Courier New Bold Italic
Courier New Italic

Designers

Howard Kettler

Copyright

© 2017 The Monotype Corporation. All Rights Reserved.
Hebrew OpenType Layout logic copyright © 2003 & 2007, Ralph Hancock & John Hudson.
This layout logic for Biblical Hebrew is open source software under the MIT License; see
embedded license description for details.

Font vendor

Agfa Monotype Corporation

Script Tags

dlng:'Armn', 'Cyrl', 'Grek', 'Latn'
slng:'Arab', 'Armn', 'Cyrl', 'Grek', 'Hebr', 'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1255 Hebrew
1256 Arabic
1257 Windows Baltic
1258 Vietnamese
OEM OEM Character Set
869 IBM Greek
866 MS-DOS Russian
865 MS-DOS Nordic
864 Arabic
863 MS-DOS Canadian French
862 Hebrew
861 MS-DOS Icelandic
860 MS-DOS Portuguese
857 IBM Turkish
855 IBM Cyrillic; primarily Russian
852 Latin 2
775 MS-DOS Baltic
737 Greek; former 437 G
708 Arabic; ASMO 708
850 WE/Latin 1
437 US

Fixed pitch

True

Download

N/A – Exclusively included with Microsoft products and services where applicable.

Licensing and redistribution info

Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
ﾉ

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP SP2

2.90

Windows XP

2.90

Windows 2000

2.76

Windows 98 Second Edition

2.76

Windows 98

2.50

Windows 95

2.00

Windows 3.1

1.00

Windows Server 2008

5.00

Windows Server 2003

2.90

Windows NT Terminal Server 4.0

2.00

Windows NT Workstation 4.0 SP4

2.50

Windows NT Workstation 4.0

2.00

Windows NT Workstation 3.5

1.77

Expand table

This typeface is also available within Office applications. For more information visit this page.

Style & weight examples

Curlz MT font family
08/08/2025

Overview
Curlz was designed by Steve Matteson and Carl Crossgrove in 1995. For a unique, festive touch,
add a little Curlz to posters, flyers, invitations, menus and tee shirts.
ﾉ

Expand table

Item

Description

File name

Curlz___.ttf

Styles &
Weights

Curlz MT

Designers

Steve Matteson and Carl Crossgrove

Copyright

Digitized data copyright The Monotype Corporation 1991-1995. All rights reserved. Curlz?
is a trademark of The Monotype Corporation which may be registered in certain
jurisdictions.

Font vendor

Agfa Monotype Corporation

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Download

N/A – Exclusively included with Microsoft products and services where applicable.

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Curlz MT

Dante font family
Article • 03/30/2022

Overview
Dante was first created as font of metal type in the mid-1950s. Unlike later typesetting
technologies, metal type made an actual impression into the paper during printing. In
other words, Dante was originally a typeface that was intended to be impressed into
paper – not onto it.
The first Dante fonts were the result of a collaboration between two exceptional men.
One was Giovanni Mardersteig, a printer, book designer and typeface artist of
remarkable skill and taste who was renowned for the work he produced at Officina
Bodoni and Stamperia Valdònega, his two printing offices in Italy. The other was Charles
Malin, one of the great punch-cutters of the twentieth century.
As a young man at the turn of the last century, Mardersteig developed a keen interest in
the typefaces and printing of Giambattista Bodoni. He was fortunate enough to obtain
permission to use Bodoni’s original types, for which punches and matrices were still
preserved. Charles Malin cut replacements for some of these original punches, and later
cut punches for nearly all the new typefaces Mardersteig created.
Dante was Mardersteig’s last and most successful design. By then he had gained a deep
knowledge of what makes a typeface lively, legible, and handsome. Working closely with
Malin had also taught him the nuances of letterform construction. For Dante, the two
worked closely to develop a design that was easy to read. For example, special care was
taken with the design of the serifs and top curves of the lowercase to create a subtle
horizontal stress, which helps the eye move smoothly across the page. After six years of
work, the fonts were first used in 1955 to publish Boccaccio’s Trattatello in Laude di
Dante – hence the typeface name.
At about the same time, Monotype persuaded Mardersteig to allow the company to
develop machine-set versions of Dante. Using the original punches of the hand-set type
as a model, Monotype’s design office was able to produce an exceptionally accurate
interpretation of the typeface. This is all the more remarkable when you consider that
the original was created without any of the character width and spacing restrictions
imposed by machine-set technology.
Monotype also wanted to enlarge the family from just the roman and italic of the
original. This proved to be a difficult sell. Mardersteig had no use for the additional
weights at his press and, more to the point, had little interest in drawing the additional

weights Monotype wanted. Mardersteig was not easily swayed, but the gentle
persistence of Monotype (and the help of then twenty-year old Matthew Carter)
eventually changed his mind.
Dante met with immediate success, and when Monotype began making
phototypesetting equipment the family was quickly released for these machines. Since
then, digital fonts have freed type design from virtually all of the restrictions imposed by
hot metal and phototype technologies. In the early 1990s, Monotype’s creative staff
took the opportunity to rework their Dante designs to more closely represent
Mardersteig’s originals.
Mardersteig designed his typefaces for letterpress printing. The ultimate triumph of
Dante is that it now serves the needs of digital typography with poise and elegance:
proof, once again, that when type is designed with a deep understanding of what it
takes to make a typeface distinctive, legible, and attractive, the result is likely to serve a
much wider range of applications than those for which it was first intended. – fonts.com
Description
File name

dante.ttf

Styles & Weights

Dante

Copyright

Digitized Data Copyright The Monotype Corporation 1998-2001.

Designers

Giovanni Mardersteig

Font vendor

Monotype Corporation

Script Tags

dlng:'Latn'
slng:'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1254 Turkish
1257 Windows Baltic

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Dante

DaunPenh font family
Article • 03/30/2022

Overview
DaunPenh is a font based from a major district in Phnom Penh, Cambodia.
Description
File name

Daunpenh.ttf

Styles & Weights

DaunPenh

Designers

OM Mony

Copyright

© 2006 OM Mony, portions © 2015 Microsoft Corporation, all rights reserved.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Khmr'
slng:'Khmr', 'Latn'

Code pages

1252 Latin 1

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Product name

Font version

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows Server 2008

5.00

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
DaunPenh

David font family
Article • 03/30/2022

Overview
David is a Hebrew font.
Description
File name

David.ttf
Davidbd.ttf
Davidtr.ttf

Styles &
Weights

David
David Bold
David Transparent

Designers

N/A

Copyright

© 1991-1993 Kivun Computers Ltd. Portions © The Monotype Corporation.
Hebrew OpenType Layout logic copyright © 2003 & 2007, Ralph Hancock & John
Hudson. This layout logic for Biblical Hebrew is open source software under the MIT
License; see embedded license description for details.

Font
vendor

Glyph Systems

Script
Tags

dlng:'Hebr'
slng:'Hebr', 'Latn'

Code
pages

1255 Hebrew
437 US

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

1.00

Windows 2000

1.00

Windows Server 2008

5.00

Windows Server 2003

1.00

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
David

David Bold

David Transparent

Daytona font family
Article • 03/30/2022

Overview
Inspiration for the Daytona™ typeface family came from a desire to provide the best
fonts for use in televised sporting events. Jim Wasco, the typeface’s designer, drew the
design as sturdy squared letters based on humanist shapes and proportions. Letters
were designed with legibility in mind, kept narrow for economy of space, and intercharacter spacing was established for easy reading.
The Daytona typeface got its moniker from the famous Daytona Speedway racetrack. “I
wanted to name the typeface something related to sporting competitions,” Wasco
explains. “I’ve always had an appreciation for racing cars. Being the type nerd that I am, I
love the graphics, logos, large numbers and advertisements. The name Daytona jumped
out at me as being the perfect name for this design.”
“I designed the letterforms to ensure high levels of legibility,” says Wasco. “For example,
the lowercase l has a curved foot terminal and the cap I has “serifs” to distinguish the
two designs.” An alternate two-story g has been added to the roman as an option for a
more legible design in situations that call for the need to distinguish the g from the
figure nine in applications such as automotive user interface designs and displays. The
default lowercase a in the Italic is a more legible two-story form, however, an alternate
single-story a has been added to give the user the choice to use a more traditional italic
script form. While efficient typographic communication was basic to the design brief,
the Daytona family was also drawn to be a friendly, approachable design. Its rounded
corners, open counters and simple characters shapes invite reading and foster
memorability.
When asked about the potential uses of Daytona, Wasco replied, “of course the family
can be used for all sports related typesetting. It would also, because of its high level of
legibility, be a good design for display usage in a user interface. This includes everything
from automotive digital dashboards to mobile phones and GPS devices.” Wasco also
drew a suite of condensed designs that are ideal for both print and on screen
applications where space is at a premium. While televised sporting events may have
initially been his initial target, the design considerations Wasco incorporated into the
Daytona family also enable it to perform well in a wide variety of other video and on
screen environments. – fonts.com

In 2019 we reviewed the set of fonts provided with Office identifying stylistic gaps. The
result of that effort was the addition of over a hundred new fonts, including classics like
Avenir Next LT Pro and Walbaum along with contemporary designs like The Hand,
Sagona and Modern Love. These new fonts are available in most Office applications and
have been used in a range of new templates.
Description
File name

daytona.ttf
daytonabold.ttf
daytonabolditalic.ttf
daytonaitalic.ttf
daytonapro-cond.ttf
daytonapro-condlight.ttf
daytonapro-light.ttf
daytonapro-lightitalic.ttf

Styles & Weights

Daytona
Daytona Bold
Daytona Bold Italic
Daytona Italic
Daytona Pro Condensed
Daytona Pro Condensed Light
Daytona Pro Light
Daytona Pro Light Italic

Copyright

Copyright © 2011-2014 Monotype Imaging Inc. All rights reserved

Designers

Jim Wasco

Font vendor

Monotype Corporation

Script Tags

dlng:'Latn'
slng:'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
1258 Vietnamese

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows

License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Daytona

Daytona Bold

Daytona Bold Italic

Daytona Italic

Daytona Pro Condensed

Daytona Pro Condensed Light

Daytona Pro Light

Daytona Pro Light Italic

DengXian font family
Article • 03/30/2022

Overview
DengXian
Description
File name

Deng.ttf
Dengl.ttf
Dengb.ttf

Styles & Weights

DengXian Light
DengXian
DengXian Bold

Designers

N/A

Copyright

Copyright(c) Beijing Founder Electronics Co.,Ltd.2012

Font vendor

N/A

Script Tags

dlng: 'Hans'
slng: 'Bopo', 'Cyrl', 'Hans', 'Hira', 'Hrkt', 'Jpan', 'Kana', 'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
936 Chinese: Simplified chars--PRC and Singapore

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Regular

Light

Bold

Change list:
Windows 10 version 1507 released on July 29, 2015
DengXian was introduced as part of the Windows 10 Chinese (Simplified) Supplemental
Fonts package.

Desdemona font family
Article • 03/30/2022

Overview
This handsome face originated in Vienna many years ago when high-waisted capital
alphabets were very fashionable. In the 1960s, John McConnell revived Desdemona
when he and Chris Dubber started Face Photosetting, one of the first of European ad
setting companies in London. Since then, Desdemona has appeared all over the world.
You are as likely to see it over a shop on the Olympic Peninsula in the state of
Washington as under the shadow of Olympus itself in Greece.
Description
File name

Desdemon.ttf

Styles &
Weights

Desdemona

Designers

David Berlow, designer

Copyright

Typeface © 1992 The Font Bureau, Inc., Portions © 1992 Microsoft Corp. All
rights reserved.

Font vendor

The Font Bureau, Inc.

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Desdemona

DFKai-SB font family
Article • 09/28/2023

Overview
DFKai-SB font is a serif style with Traditional Chinese support. DFKai-SB has graceful
strokes.
Description
File name

Kaiu.ttf

Styles & Weights

DFKai-SB

Designers

N/A

Copyright

(c) Copyright DynaLab Inc. 1992-1998

Font vendor

DYNA

Script Tags

dlng:'Bopo', 'Hant'
slng:'Bopo', 'Hans', 'Hant', 'Hira', 'Hrkt', 'Jpan', 'Kana', 'Latn'

Code pages

1252 Latin 1
950 Chinese: Traditional chars--Taiwan and Hong Kong SAR

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Product name

Font version

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

3.00

Windows Server 2008

5.00

Windows Server 2003

3.00

Style & weight examples
DFKai-SB

DilleniaUPC font family
Article • 03/30/2022

Overview
Dillenia UPC is a Thai font designed by Unity Progress and offered under license from
Microsoft.
Description
File name

Upcdl.ttf
Upcdb.ttf
Upcdbi.ttf
Upcdi.ttf

Styles &
Weights

DilleniaUPC
DilleniaUPC Bold
DilleniaUPC Bold Italic
DilleniaUPC Italic

Designers

N/A

Copyright

© 1992 Unity Progress. Portions © 2004 The Monotype Corporation. Portions ©
2015 Microsoft Corporation. All Rights Reserved.

Font
vendor

MS

Script

dlng:'Thai'

Tags

slng:'Thai', 'Latn'

Code

1252 Latin 1

pages

874 Thai

Fixed

False

pitch

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

2.20

Windows Server 2008

5.00

Windows Server 2003

2.20

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
DilleniaUPC

DilleniaUPC Bold

DilleniaUPC Bold Italic

DilleniaUPC Italic

Directions MT font family
Article • 03/30/2022

Overview
Designed by Steve Matteson, this is one of a set of versatile art fonts from Monotype.
When you need to tell someone where to go, and need an appropriate arrow, this is the
font for you. Almost every possible direction in various different styles. Great for instant
illustrations, icons or bullets.
Description
File name

Direct.ttf

Styles &
Weights

Directions MT

Designers

Steve Matteson

Copyright

Digitized data copyright (C) 1991-1995 Monotype Typography, Inc.. All rights
reserved. Monotype? is a trademark of Monotype Typography, Inc. which may be
registered in certain jurisdicions.

Font
vendor

Agfa Monotype Corporation

Script
Tags

N/A

Code
pages

Symbol Symbol Character Set

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples

Directions MT

DokChampa font family
Article • 03/30/2022

Overview
DokChampa is a Lao font.
Description
File name

Dokchamp.ttf

Styles &
Weights

DokChampa

Designers

Original design: Robin Nicholas, Patricia Saunders. Extended glyphs: Monotype Type
Drawing Office, Monotype Typography.

Copyright

© 2018 The Monotype Corporation. All Rights Reserved.

Font
vendor

Microsoft Corp.

Script
Tags

dlng:'Thai', 'Laoo'
slng:'Thai', 'Laoo', 'Latn'

Code
pages

1252 Latin 1
874 Thai
OEM OEM Character Set

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Product name

Font version

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows Server 2008

5.00

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
DokChampa

Dotum font family
Article • 03/30/2022

Overview
Dotum is a Korean font.
Description
File name

Gulim.ttc

Styles & Weights

Dotum
DotumChe

Designers

N/A

Copyright

© 2009 HanYang I&C Co., LTD.

Font vendor

HanYang System

Script Tags

dlng:'Hang', 'Hani', 'Kore'
slng:'Cyrl', 'Grek', 'Hang', 'Hani', 'Hira', 'Kana', 'Kore', 'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
949 Korean Wansung
OEM OEM Character Set
869 IBM Greek
866 MS-DOS Russian
864 Arabic
863 MS-DOS Canadian French
862 Hebrew
861 MS-DOS Icelandic
860 MS-DOS Portuguese
857 IBM Turkish
855 IBM Cyrillic; primarily Russian
775 MS-DOS Baltic
708 Arabic; ASMO 708
850 WE/Latin 1
437 US

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

2.21

Windows 2000

2.20

Windows Server 2008

5.00

Windows Server 2003

2.21

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Dotum

DotumChe

Ebrima font family
Article • 11/01/2022

Overview
Ebrima is a typeface designed for African languages. It includes coverage for Adlam,
Bamum, Ethiopic, N'Ko, Osmanya, Tifinagh, and Vai, as well as an extended character set
in the Latin alphabet with diacritical marks and signs used in languages throughout
Africa. Ebrima was created by Microsoft as the default font in Windows for rendering
African languages. Its Latin character set is based on the Segoe UI font. Ebrima has two
weights, Regular and Bold.
Description
File name

Ebrima.ttf
Ebrimabd.ttf

Styles & Weights

Ebrima
Ebrima Bold

Designers

N/A

Copyright

© 2018 Microsoft Corporation. All Rights Reserved.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Adlm', 'Bamu', 'Ethi', 'Nkoo', 'Osma', 'Tfng', 'Vaii'
slng:'Adlm', 'Bamu', 'Ethi', 'Latn', 'Nkoo', 'Osma', 'Tfng', 'Vaii'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1254 Turkish
1257 Windows Baltic

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Ebrima

Ebrima Bold

Eckmann font family
Article • 03/30/2022

Overview
The earliest renderings of this design, which pops up every 10 or 20 years, seem to
originate from a type foundry in Offenbach, Germany, outside Frankfurt, where the dogs
appear to have also originated. The shapes (of both the type and the sausages) are
unmistakable, but the type is still legible. Many other display types are not legible,
sacrificing legibility for the sake of noticeability. This design is both legible and
distinctive.
Description
File name

Eckmann.ttf

Styles &
Weights

Eckmann

Designers

Otto Eckmann, 1993, (1900)

Copyright

© Copyright by URW, 1992. Portions © 1992 Microsoft Corp. All rights
reserved.

Font vendor

N/A

Script Tags

N/A

Code pages

869 IBM Greek
437 US

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Eckmann

Edda font family
Article • 03/30/2022

Overview
An outline face, Edda may have originated at Schelte and Giesecke, a foundry that
operated in Germany. The Font Bureau has made additional characters for this issue.
There is nothing mean about the shapes of these letters. They look feminine, strong, and
yet light in character, making Edda welcome for many uses.
Description
File name

Edda.ttf

Styles &
Weights

Edda

Designers

David Berlow, designer

Copyright

Typeface © 1992 The Font Bureau, Inc., Portions © 1992 Microsoft Corp. All
rights reserved.

Font vendor

The Font Bureau, Inc.

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Edda

Edwardian Script ITC font family
Article • 03/30/2022

Overview
Unlike traditional calligraphic scripts which tend to suggest a flat-tipped writing
instrument, ITC Edwardian Script font was influenced by a more flexible steel-point pen.
This writing instrument can be pulled as well as pushed, which means that varying the
pressure, rather than the angle of the nib, produces thick and thin strokes. Great time
and care went into the design of ITC Edwardian Script.
Description
File name

Itcedscr.ttf

Styles &
Weights

Edwardian Script ITC

Designers

N/A

Copyright

Copyright (c) International Typeface Corporation 1997. Portions Copyright (c)
Microsoft Corporation 1997. All rights reserved.

Font
vendor

ITC

Script

N/A

Tags
Code
pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font

This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Edwardian Script ITC

Elephant font family
Article • 03/30/2022

Overview
Matthew Carter is one of the most-praised type designers of our time. His work ranges
from newspaper typefaces for Mergenthaler Linotype to the condensed sans typeface
now used more than any other in re-designed telephone books. His Galliard became
one of the most popular new text faces of the last 20 years. Now we have Elephant and
its italic, a careful re-working of a traditional English extra-bold serif style. Originally,
Elephant appeared in posters, often alternating from roman to italic on successive lines.
In Europe, faces of this kind still may be used in very small sizes for telephone numbers
in letterheads and business cards. Today, the best use of Elephant is for an eye-catching
word. Even a single quote will draw the reader's eye to where it is placed.
Description
File name

Elephnt.ttf
Elephnti.ttf

Styles &
Weights

Elephant
Elephant Italic

Designers

Matthew Carter

Copyright

© 1992 Carter & Cone Type Inc. © 1992 Type Solutions, Inc. Portions © 1992
Microsoft Corp. All rights reserved.

Font

N/A

vendor
Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Elephant

Elephant Italic

Engravers MT font family
Article • 03/30/2022

Overview
Some typographers claim that the first designs of Engravers MT came from America
rather than from one of these European foundries: Stephenson Blake and Co., Bauer, or
Schelter & Giesecke. It's difficult to be sure which design could be called the original,
but this face, introduced in 1924, is Monotype's contender to that claim. The metal
version was available in one size only: 6 points. Even so, the font's very thin hairlines
printed clearly, a tribute to the engraver's art. If you use Engravers MT in small sizes,
watch that your printer's resolution can similarly preserve the hairlines and sharpness
most loved in the original design.
Description
File name

Engr.ttf
Engrb.ttf

Styles &
Weights

Engravers MT
Engravers MT Bold

Designers

Monotype Type Drawing Office

Copyright

Design and data by The Monotype Corporation. © 1993-1999. Microsoft
Corporation. All rights reserved.

Font vendor

Agfa Monotype Corporation

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Engravers MT

Engravers MT Bold

Enviro font family
Article • 03/30/2022

Overview
Enviro is a lighthearted, sans serif typeface that evokes the style of the movie industry
during the 1920s and 30s. Although some of the letterforms are slighty abstract, the
Enviro font is legible and can be used for headlines where a different look is desired.
Description
File name

Enviro.ttf

Styles &
Weights

Enviro

Designers

F. Garland

Copyright

Copyright Esselte Corporation 1997. Portions Copyright Microsoft
Corporation1997. All rights reserved.

Font vendor

ITC Corporation

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Enviro

Eras ITC font family
Article • 03/30/2022

Overview
ITC Eras is a sans serif with unusual style, thanks to its slight forward slant and subtle
variations in stroke weights. As with most contemporary typefaces designed for film
typography, ITC Eras has a comparatively large lowercase x-height as well as excellent
letter fitting characteristics. The inspirations for ITC Eras are twofold: Greek stone-cut
lapidary letters, and Roman capitals. The result is at once a linear emphasis and a blend
of sharp angularity and broad curves. The combination of wide curves and close
letterspacing emphasizes the large open areas, the inner forms of the letters. ITC Eras is
not a precise, geometric face. It appears spontaneous, like a 'serif-less' written script,
particularly in its slight forward slant and its compound characters. This touch of style
enhances the commanding appearance of its capitals which can also function as a titling
face. French designer Albert Boton created ITC Eras in collaboration with the late Albert
Hollenstein, also of France.
Description
File name

Erasbd.ttf
Erasdemi.ttf
Eraslght.ttf
Erasmd.ttf
Erasult.ttf

Styles &
Weights

Eras Bold ITC
Eras Demi ITC
Eras Light ITC
Eras Medium ITC
Eras Ultra ITC

Designers

Albert Hollenstein, Albert Boton

Copyright

Typeface: Copyright ©1995 International Typeface Corporation. Data: Copyright ©
1995 Microsoft Corportation. All rights reserved.

Font
vendor

ITC

Script
Tags

N/A

Description
Code
pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Eras Bold ITC

Eras Demi ITC

Eras Light ITC

Eras Medium ITC

Eras Ultra ITC

Estrangelo Edessa font family
Article • 03/30/2022

Overview
Estrangelo Edessa is a Unicode encoded OpenType font file supporting the Syriac script.
The font contains TrueType character outlines and has been optimized for display on
screen at small sizes, within software user interface elements such as button descriptions
and dialog box text. The Syriac letter forms were designed by Paul Nelson and George
Kiraz. Some symbols, including numerical symbols are based on the monospaced
Courier type design.
Description
File name

Estre.ttf

Styles &
Weights

Estrangelo Edessa

Designers

N/A

Copyright

© 2015 Microsoft Corporation, portions © 2000 Syriac Computing Institute. All
Rights Reserved.

Script Tags

dlng:'Syrc', 'Syre'
slng:'Latn', 'Syrc', 'Syre'

Font vendor

Syriac Computing Institute

Code pages

1252 Latin 1

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

1.00

Windows Server 2008

5.00

Windows Server 2003

1.00

Style & weight examples
Estrangelo Edessa

EucrosiaUPC font family
Article • 03/30/2022

Overview
Eucrosia UPC is a Thai font designed by Unity Progress and offered under license from
Microsoft.
Description
File name

Upcel.ttf
Upceb.ttf
Upcebi.ttf
Upcei.ttf

Styles &
Weights

EucrosiaUPC
EucrosiaUPC Bold
EucrosiaUPC Bold Italic
EucrosiaUPC Italic

Designers

N/A

Copyright

© 1992 Unity Progress. Portions © 2004 The Monotype Corporation. Portions ©
2015 Microsoft Corporation. All Rights Reserved.

Font
vendor

MS

Script

dlng:'Thai'

Tags

slng:'Thai', 'Latn'

Code

1252 Latin 1

pages

874 Thai

Fixed

False

pitch

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

2.20

Windows Server 2008

5.00

Windows Server 2003

2.20

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
EucrosiaUPC

EucrosiaUPC Bold

EucrosiaUPC Bold Italic

EucrosiaUPC Italic

Euphemia font family
Article • 03/30/2022

Overview
Euphemia is a Unified Canadian Syllabics font.
Description
File name

Euphemia.ttf

Styles & Weights

Euphemia

Designers

Ross Mills

Copyright

Copyright © 2018 by Tiro Typeworks. All rights reserved.

Font vendor

Tiro Typeworks

Script Tags

dlng:'Cans'
slng:'Cans', 'Latn'

Code pages

1252 Latin 1

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Product name

Font version

Windows 7

See the Windows 7 page.

Windows Vista

5.00

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Euphemia

Eurostile font family
Article • 03/30/2022

Overview
Almost every graphic student has at one time or another tried their hand at a
geometrical type. Few have made anything remotely memorable. But in the early 1950s,
Novarese and Butti made Microgramma for the best known of the Italian foundries,
Nebiolo, in Turin. Microgramma came with a variety of weights and widths, which
enhanced its immediate popularity. But the original version of Microgramma had only
caps. So, a decade later, Aldo Novarese designed Eurostile, adding a lower-case
alphabet and some additional weights, like Compact. What you get here is the starter
kit.
Description
File name

Eurosti.ttf
Eurostib.ttf

Styles &
Weights

Eurostile
Eurostile Bold

Designers

Aldo Novarese, 2004, (1962)

Copyright

Typeface © 1992 Fonderia Caratteri Svizzera Walter Fruttiger A.G. Data © 1992 URW.
Portions © 1992 Microsoft Corp. All rights reserved.

Font

URW Type Foundry

vendor
Script
Tags

N/A

Code
pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Eurostile

Eurostile Bold

FangSong font family
Article • 03/30/2022

Overview
FangSong is a Simplified Chinese font.
Description
File name

Simfang.ttf

Styles & Weights

FangSong

Designers

N/A

Copyright

© Beijing ZhongYi Electronics Co., 1995-2005, All rights reserved

Font vendor
Script Tags

dlng:'Hans'
slng:'Bopo', 'Cyrl', 'Grek', 'Hani', 'Hans', 'Hira', 'Hrkt', 'Jpan', 'Kana', 'Latn'

Code pages

1252 Latin 1
936 Chinese: Simplified chars--PRC and Singapore

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Product name

Font version

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows Server 2008

5.00

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
FangSong

Felix Titling font family
Article • 03/30/2022

Overview
Felix Titling, Monotype Type Drawing Office 1934. A titling font consisting of capitals,
figures and punctuation. It is based closely on an alphabet developed by the Veronese
calligrapher and painter, Felice Feliciano, which appeared in 1463 in his treatise on
Roman inscriptions. The original is preserved in the Vatican library. It has the proportions
of an inscriptional letter and is somewhat geometric in character, designed to look at its
best in large sizes, where both its detailing and classic proportions can be seen to best
effect.
Description
File name

Felixti.ttf

Styles &
Weights

Felix Titling

Designers

Phillip Boydell

Copyright

Digitized data copyright The Monotype Corporation 1991-1995. All rights reserved.
Felix? Titling is a trademark of The Monotype Corporation which may be registered
in certain jurisdictions.

Font

Agfa Monotype Corporation

vendor
Script
Tags

N/A

Code
pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Felix Titling

Fine Hand font family
Article • 03/30/2022

Overview
Fine Hand: This refined typeface captures all the elegance of cultured handwriting and is
based on the actual handwriting of Richard Bradley, one of Britain?s most accomplished
calligraphers. Fine Hand includes many alternative letters that help communicate an
unrestrained, spontaneous appearance. The capitals are designed for initialing purposes
only.
Description
File name

Finehand.ttf

Styles &
Weights

Fine Hand

Designers

Richard Bradley

Copyright

COPYRIGHT ESSELTE LETRASET LTD., 1990. Portions copyright Microsoft
Corporation 1999. All Rights reserved.

Font
vendor

N/A

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Fine Hand

Fixed Miriam Transparent font family
Article • 03/30/2022

Overview
Fixed Miriam Transparent is a Hebrew font.
Description
File name

Mriamfx.ttf

Styles &
Weights

Fixed Miriam Transparent

Designers

N/A

Copyright

Typeface Portions © The Monotype Corporation plc. Data Portions © The Monotype
Corporation plc/Type Solutions Inc. 1990-1992. Portions © 1991-1993 Kivun
Computers Ltd. © 1992 Type Solutions, Inc.

Font
vendor

Glyph Systems

Script
Tags

N/A

Code
pages

1255 Hebrew

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Fixed Miriam Transparent

Flexure font family
Article • 03/30/2022

Overview
Flexure is a face from the new breed of type designers, a blurred mix of serif and sans
serif.
Description
File name

Flexure.ttf

Styles &
Weights

Flexure

Designers

T26

Copyright

Typeface (c) 1993 T26, Chicago, Illinois ? Stephen Farrell-designer. Data Copyright (c)
1995 by Microsoft Corporation. All rights reserved.

Font
vendor

N/A

Script
Tags

N/A

Code
pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed

False

pitch

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Flexure

Footlight MT font family
Article • 03/30/2022

Overview
Designed in 1985, this typeface earns its name due to the theatrical sparkle it imparts to
the text set in it. Footlight MT was first designed as an italic face, followed later by the
roman version, which is unusual in the typeface industry. Footlight MT is an informal, yet
lively and elegant typeface whose craftsmanship lends it an air of authority.
Description
File name

Ftltlt.ttf

Styles &
Weights

Footlight MT Light

Designers

Ong Chong Wah

Copyright

Footlight © The Monotype Corporation plc. Data © The Monotype Corporation
plc/Type Solutions Inc. 1990 - 1992 All rights reserved.

Font
vendor

Agfa Monotype Corporation

Script
Tags

N/A

Code
pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed

False

pitch

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font

This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Footlight MT Light

Forte font family
Article • 03/30/2022

Overview
Designed by an Austrian commercial artist who was trained as a compositor and later
taught typography and drawing in Vienna. The idea for this script face came from the
study of plants, individual letterforms being inspired by the long stems and furry heads
of the reed. Forte is a strong design which contrasts well with sans serif faces and
classical modern types. Use in advertising, flyers and labels.
Description
File name

Forte.ttf

Styles &
Weights

Forte

Designers

Carl Reissberger

Copyright

Digitized data copyright The Monotype Corporation 1991-1995. All rights reserved.
Forte? is a trademark of The Monotype Corporation which may be registered in
certain jurisdictions.

Font
vendor

Monotype

Script
Tags

N/A

Code

1252 Latin 1

pages

Mac Roman Macintosh Character Set (US Roman)

Fixed

False

pitch

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font

This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Forte

Franklin Gothic font family
Article • 03/30/2022

Overview
Designed in 1904 by Morris Fuller Benton for the American Type Founders company,
Franklin Gothic was originally conceived as only one weight. Over the next several years,
the ATF family was expanded to include italic, condensed, condensed shaded, extra
condensed and wide variants. For some unknown reason no light or intermediate
weights were ever created. In 1979, under license from ATF, International Typeface
Corporation created four new weights ? Book, Medium, Demi and Heavy ? in roman and
italic versions. Designed by Victor Caruso, these new designs matched the pure
characteristics of the original Franklin Gothic, adhering closely to the subtle thick and
thin pattern of the original ATF typeface while featuring a slightly enlarged lowercase xheight. This increased x-height ? which improved the typeface's appearance and
readability ? and the availability of larger family made ITC Franklin Gothic a preferred
choice when setting large blocks of sans serif text. Franklin Gothic was named by Morris
Fuller Benton in honor of Benjamin Franklin, whom Benton greatly admired for his
significant contributions to American history and culture, and to printing in particular.
Description
File name

Frabk.ttf
Frabkit.ttf
Fradm.ttf
Fradmcn.ttf
Fradmit.ttf
Frahv.ttf
Frahvit.ttf
Framd.ttf
Framdcn.ttf
Framdit.ttf

Styles &
Weights

Franklin Gothic Book
Franklin Gothic Book Italic
Franklin Gothic Demi
Franklin Gothic Demi Cond
Franklin Gothic Demi Italic
Franklin Gothic Heavy
Franklin Gothic Heavy Italic
Franklin Gothic Medium
Franklin Gothic Medium Cond
Franklin Gothic Medium Italic

Description
Designers

Victor Caruso

Copyright

ITC Franklin Gothic is a trademark of The International Typeface Corporation which
may be registered in certain jurisdictions. Portions copyright Microsoft Corporation.
All rights reserved.

Font

ITC

vendor
Script

N/A

Tags
Code
pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
Mac Roman Macintosh Character Set (US Roman)
869 IBM Greek
866 MS-DOS Russian
865 MS-DOS Nordic
863 MS-DOS Canadian French
861 MS-DOS Icelandic
860 MS-DOS Portuguese
857 IBM Turkish
855 IBM Cyrillic; primarily Russian
852 Latin 2
775 MS-DOS Baltic
737 Greek; former 437 G
850 WE/Latin 1
437 US

Fixed

False

pitch

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Franklin Gothic Book

Franklin Gothic Book Italic

Franklin Gothic Demi

Franklin Gothic Demi Cond

Franklin Gothic Demi Italic

Franklin Gothic Heavy

Franklin Gothic Heavy Italic

Franklin Gothic Medium

Franklin Gothic Medium Cond

Franklin Gothic Medium Italic

Franklin Gothic Medium font family
Article • 11/13/2021

Overview
Designed in 1902 by Morris Fuller Benton for the American Type Founders company,
Franklin Gothic still reigns as one of the most-widely used sans serif typefaces. Originally
issued in only one weight, the ATF version of Franklin Gothic was eventually expanded to
include five additional weights, but no light or intermediate weights were ever
developed. In 1979, under license from ATF, ITC developed four new weights in roman
and italic: book, medium, demi and heavy. Designed by Victor Caruso, ITC?s new
weights matched the original face?s characteristics, but featured a slightly enlarged
lowercase x-height. ITC Franklin Gothic also features a slightly condensed lowercase a-z
alphabet. In 1991, ITC commissioned the Font Bureau in Boston to create condensed,
compressed and extra compressed versions of ITC Franklin Gothic, which increased the
flexibility and usefulness of the design.

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.01

Windows Server 2008

5.01

FrankRuehl font family
Article • 03/30/2022

Overview
FrankRuehl font is the ubiquitous Hebrew font style. There are many fonts that belong
to this style, and all are based on an early 20th-century design by Raphael Frank.
Description
File name

Frank.ttf

Styles & Weights

FrankRuehl

Designers

N/A

Copyright

© 1991-1993 Kivun Computers Ltd. Portions © The Monotype Corporation

Font vendor

Glyph Systems

Script Tags

dlng:'Hebr'
slng:'Hebr', 'Latn'

Code pages

1255 Hebrew
437 US

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Product name

Font version

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

1.00

Windows 2000

1.00

Windows Server 2008

5.00

Windows Server 2003

1.00

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
FrankRuehl

FreesiaUPC font family
Article • 03/30/2022

Overview
Freesia UPC is a Thai font designed by Unity Progress and offered under license from
Microsoft.
Description
File name

Upcfl.ttf
Upcfb.ttf
Upcfbi.ttf
Upcfi.ttf

Styles &
Weights

FreesiaUPC
FreesiaUPC Bold
FreesiaUPC Bold Italic
FreesiaUPC Italic

Designers

N/A

Copyright

© 1992 Unity Progress. Portions © 2004 The Monotype Corporation. Portions ©
2015 Microsoft Corporation. All Rights Reserved.

Font
vendor

MS

Script

dlng:'Thai'

Tags

slng:'Thai', 'Latn'

Code

1252 Latin 1

pages

874 Thai

Fixed

False

pitch

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

2.20

Windows Server 2008

5.00

Windows Server 2003

2.20

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
FreesiaUPC

FreesiaUPC Bold

FreesiaUPC Bold Italic

FreesiaUPC Italic

Freestyle Script font family
Article • 03/30/2022

Overview
Freestyle Script is an informal display typeface which perfectly renders the spontaneous
qualities of hand-rendered brush lettering.
Description
File name

Freescpt.ttf

Styles &
Weights

Freestyle Script

Designers

Martin Wait

Copyright

Copyright Esselte Corporation 1997. Portions Copyright Microsoft
Corporation1997. All rights reserved.

Font vendor

ITC Corporation

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples

Freestyle Script

French Script MT font family
Article • 03/30/2022

Overview
French Script, Monotype Type Drawing Office 1989. A reproduction of the common
French scripts of the nineteenth century. Cut by Stephenson Blake in 1905, by the Inland
Type Foundry and later by American Type Founders. An upright script with flourished
capitals and joining lowercase. Use for invitations, greetings cards and announcements.
Description
File name

Frscript.ttf

Styles &
Weights

French Script MT

Designers

Monotype Design Studio

Copyright

Digitized data copyright The Monotype Corporation 1991-1995. All rights reserved.
French Script is a trademark of The Monotype Corporation which may be registered
in certain jurisdictions.

Font
vendor

Agfa Monotype Corporation

Script
Tags

N/A

Code
pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples

French Script MT

Futura font family
Article • 03/30/2022

Overview
Kabel and Futura are birds of a feather, and both fonts seem to have been fledged
between 1927 and 1930. Kabel was designed by Rudolph Koch for Klingspor, while
Futura was designed by Paul Renner for Bauer. Although it started life with some very
eccentric letters, particularly 'a' and 'g', the lower-case alphabet of Futura is now a shade
less eccentric and more polished. As a result of this and its wider base, Futura has
become the better known and more popular of the two families. The appealing spikiness
of both fonts, however, makes for clean-looking headlines and text as easy to read as
any sans serif face can be. By the way, if you think Futura looks like typefaces named
Intertype and Spartan, you're right. At different times, different type foundries have
marketed the same font under those names.
Description
File name

Futurab.ttf
Futura.ttf
Futurao.ttf

Styles &
Weights

Futura Bold
Futura Medium
Futura Oblique

Designers

Paul Renner, 1993, (1928)

Copyright

Typeface © 1992 Fundicion Tipografica Neufville, S.A., Data © 1992 URW. © 1992
Type Solutions, Inc. Portions © 1992 Microsoft Corp. All rights reserved.

Font
vendor

URW Type Foundry

Script
Tags

N/A

Code

869 IBM Greek

pages

437 US

Fixed

False

pitch

Licensing and redistribution info

Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Futura Bold

Futura Medium

Futura Oblique

Gabriola font family
10/11/2025

Overview
Gabriola is a display typeface designed by John Hudson. Named after Gabriola Island, in British
Columbia, Canada, it is primarily intended for use at larger sizes, but can also work well in short
passages of text. The Gabriola font can add elegance and grace to titles, subheads and other
situations in which a more decorative style of type is appropriate.
The design of Gabriola was inspired by an idea from music: that the same melody can be
played in multiple modes, each with its own expressive characteristics. Gabriola was developed
with advanced OpenType features and has been optimized for advanced ClearType rendering
to improve legibility on screen.
The advanced OpenType features in Gabriola makes it come alive. There are eight different
stylistic sets, allowing users to set the same text in different modes, from the plainest style to
the most elaborated and fanciful. Each style is distinctive, yet each harmonises with the others
around the dominant basic construction of the letters.
In addition to the stylistic sets, Gabriola contains very extensive contextual glyph substitutions
in each style, improving the fit of the letters and, in the more elaborate styles, avoiding ugly
collisions or over-use of ornament.
The goal of Gabriola is to make is easy for users to produce attractive decorative typography,
while using layout intelligence in the font to limit the possibilities to inadvertently produce
something that does not look good.
ﾉ

Item

Description

File name

Gabriola.ttf

Styles & Weights

Gabriola

Designers

John Hudson

Copyright

© 2008 Microsoft Corporation. All Rights Reserved.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Cyrl', 'Grek', 'Latn'
slng:'Cyrl', 'Grek', 'Latn'

Expand table

Item

Description

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Download

N/A – Exclusively included with Microsoft products and services where applicable.

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts: These Microsoft fonts can be licensed from Tiro Typeworks

for

a range of uses, including individual device use outside of Microsoft products, webfonts,
app embedding, enterprise computing and server installations, and hardware and
software redistribution.

Products that supply this font
ﾉ

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Expand table

This typeface is also available within Office applications. For more information visit this page.

Style & weight examples
Gabriola

Gadugi font family
Article • 03/30/2022

Overview
Description
File name

Gadugi.ttf
Gadugib.ttf

Styles & Weights

Gadugi
Gadugi Bold

Designers

N/A

Copyright

© 2018 Microsoft Corporation. All Rights Reserved.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Cher', 'Cans'
slng:'Cher', 'Cans', 'Latn'

Code pages

1252 Latin 1

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Gadugi

Gadugi Bold

Garamond font family
Article • 03/30/2022

Overview
Monotype Drawing Office 1922. This typeface is based on roman types cut by Jean
Jannon in 1615. Jannon followed the designs of Claude Garamond which had been cut
in the previous century. Garamond's types were, in turn, based on those used by Aldus
Manutius in 1495 and cut by Francesco Griffo. The italic is based on types cut in France
circa 1557 by Robert Granjon. Garamond is a beautiful typeface with an air of informality
which looks good in a wide range of applications. It works particularly well in books and
lengthy text settings.
Description
File name

GARA.ttf
GARABD.ttf
GARAIT.ttf

Styles &
Weights

Garamond
Garamond Bold
Garamond Italic

Designers

Claude Garamond

Copyright

Digitized data copyright Monotype Typography, Ltd 1991-1995. All rights reserved.
Monotype Garamond? is a trademark of Monotype Typography, Ltd which may be
registered in certain jurisdictions.

Font

Agfa Monotype Corporation

vendor
Script
Tags

N/A

Description
Code
pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
869 IBM Greek
866 MS-DOS Russian
865 MS-DOS Nordic
863 MS-DOS Canadian French
861 MS-DOS Icelandic
860 MS-DOS Portuguese
857 IBM Turkish
855 IBM Cyrillic; primarily Russian
852 Latin 2
775 MS-DOS Baltic
737 Greek; former 437 G
850 WE/Latin 1
437 US

Fixed

False

pitch

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Garamond

Garamond Bold

Garamond Italic

Garamond MT font family
Article • 03/30/2022

Overview
Based on Claude Garamond's elegant 16th-century typeface, this particular cut of
Garamond was developed in 1924 at Stempel AG, a German type foundry. This versatile
serif typeface has a small x-height, so more words fit on a line. Short ascenders and
descenders allow lines to be set closer together. Its italic (or Kursiv) style is particularly
graceful. The very readable and versatile Garamond works well for long blocks of text,
reports, magazines, books, manuals, correspondence, and slides.
Description
File name

Garamt.ttf
Garai.ttf

Styles &
Weights

Garamond MT
Garamond MT Italic

Designers

Monotype Design Studio

Copyright

Digitized data copyright Monotype Typography, Ltd 1991-1995. All rights reserved.
Monotype Garamond® is a trademark of Monotype Typography, Ltd which may be
registered in certain jurisdictions.

Font

Agfa Monotype Corporation

vendor
Script
Tags

N/A

Code
pages

869 IBM Greek
437 US

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Garamond MT

Garamond MT Italic

Gautami font family
Article • 03/30/2022

Overview
Gautami is an OpenType font for the Indic script-Telugu. It is based on Unicode, contains
TrueType outlines and has been designed for use as a UI font.
Description
File name

Gautami.ttf
Gautamib.ttf

Styles & Weights

Gautami
Gautami Bold

Designers

Raghunath Joshi (Type Director), Omkar Shende

Copyright

© 2015 Microsoft Corporation. All Rights Reserved.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Telu'
slng:'Telu'

Code pages

1252 Latin 1

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Product name

Font version

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.02

Windows XP

1.21

Windows Server 2008

5.02

Windows Server 2003

1.21

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Gautami

Gautami Bold

Georgia font family
Article • 04/04/2025

Overview
Although inspired by the need for - and providing - clarity at low resolutions on the
screen, Georgia is a typeface resonant with typographic personality. Even at small sizes
the face exudes a sense of friendliness; a feeling of intimacy many would argue has been
eroded from Times New Roman through overuse. This is as much testament to the skill
of the typeface's designer, Matthew Carter, as it is to any intrinsic quality of the face's
design, since the small pixel spaces of the screen can be a harrowing canvas for any type
designer. In Georgia, Carter has successfully managed to create a typeface family which
combines high legibility with character and charm.
At high resolutions and larger sizes on screen, it's evident that Georgia's ancestry is
essentially that of Didot and - most noticeably - of Scotch Roman. Carter acknowledges
the influence of Richard Austin's early nineteenth-century cut of Scotch Roman on the
design of his letterforms. At the time he started Georgia he had been working on a new
retail family called Miller, which is a version of Scotch Roman. Carter admits that he had
always admired Scotch, particularly in its early forms as cut by Richard Austin for Bell
and Miller. The influence of the Scotch model on Georgia is most clearly seen in the
horizontal top serifs of the lowercase b, d, h, k and l, and by the flat top of the lowercase
t, a typographic allusion to the typeface's roots in Didot.
To create a font tailored for on-screen display, Carter had to make several departures
from the Scotch mold. In Georgia, the uppercase characters are lightened, the x-height
is increased, the ascenders rise above the cap height, and the numerals, often cut with a
high degree of stress, have been evened out and made slightly non-aligning - a
characteristic that imparts a flavor of individuality to any page set in Georgia.
Georgia's accompanying italic is a graceful, flowing font, the design of which entirely
masks the difficulty of creating an italic for the screen. Unlike many contemporary fonts,
it is a true italic, containing such characters as the single-story lowercase a and g. The
bold weight of the typeface has been similarly carefully designed, to ensure that it is
always heavier than the regular weight; an important consideration at small sizes on the
screen, where it is often necessary to distinguish between the two.
Originally made available in September 1996, the Georgia typeface family was released
in an extended version in October 1997. The newer releases contain all the characters

necessary to typeset Eastern European languages, in addition to the Greek and Cyrillic
scripts.

Georgia version history
Version 2.05 - This version includes some minor table updates, but no new glyphs.
Version 2.00 - Georgia 2.00 which includes the euro, proper old-style figures and the full
WGL4 character set was added to the Windows 98 update Web font pack in August
1998.
Version 1.00 - Georgia 1.00 was added to our collection of Core fonts for the Web on 1
November 1996. It was also included in the Internet Explorer 4.0 supplemental font
pack.
ﾉ

Menu

Description

File name

Georgia.ttf
Georgiab.ttf
Georgiaz.ttf
Georgiai.ttf

Styles &

Georgia

Weights

Georgia Bold
Georgia Bold Italic
Georgia Italic

Designers

Matthew Carter

Copyright

© 2016 Microsoft Corporation. All Rights Reserved.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Cyrl', 'Grek', 'Latn'
slng:'Cyrl', 'Grek', 'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Expand table

Menu

Description

Download

N/A – Exclusively included with Microsoft products and services where
applicable.

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
ﾉ

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

2.12

Windows 2000

2.05

Windows Server 2008

5.00

Windows Server 2003

2.11

Expand table

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples

Feedback
Was this page helpful?

 Yes

 No

Georgia Pro font family
Article • 03/30/2022

Overview
Description
File name

GeorgiaPro-Regular.ttf
GeorgiaPro-Italic.ttf
GeorgiaPro-Light.ttf
GeorgiaPro-LightItalic.ttf
GeorgiaPro-SemiBold.ttf
GeorgiaPro-SemiBoldItalic.ttf
GeorgiaPro-Bold.ttf
GeorgiaPro-BoldItalic.ttf
GeorgiaPro-Black.ttf
GeorgiaPro-BlackItalic.ttf
GeorgiaPro-CondLight.ttf
GeorgiaPro-CondLightItalic.ttf
GeorgiaPro-CondRegular.ttf
GeorgiaPro-CondItalic.ttf
GeorgiaPro-CondSemiBold.ttf
GeorgiaPro-CondSemiBoldItalic.ttf
GeorgiaPro-CondBold.ttf
GeorgiaPro-CondBoldItalic.ttf
GeorgiaPro-CondBlack.ttf
GeorgiaPro-CondBlackItalic.ttf

Description
Styles & Weights

Georgia Pro
Georgia Pro Italic
Georgia Pro Light
Georgia Pro Light Italic
Georgia Pro Semibold
Georgia Pro Semibold Italic
Georgia Pro Bold
Georgia Pro Bold Italic
Georgia Pro Black
Georgia Pro Black Italic
Georgia Pro Cond Light
Georgia Pro Cond Light Italic
Georgia Pro Cond
Georgia Pro Cond Italic
Georgia Pro Cond Semibold
Georgia Pro Cond Semibold Italic
Georgia Pro Cond Bold
Georgia Pro Cond Bold Italic
Georgia Pro Cond Black
Georgia Pro Cond Black Italic

Designers

Matthew Carter, Monotype Imaging, The Font Bureau

Copyright

© 2018 Microsoft Corporation. All Rights Reserved.

Font vendor

Monotype Imaging Inc.

Script Tags

dlng: 'Cyrl', 'Grek', 'Latn'
slng: 'Cyrl', 'Grek', 'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Georgia Pro

Georgia Pro Italic

Georgia Pro Light

Georgia Pro Light Italic

Georgia Pro Semibold

Georgia Pro Semibold Italic

Georgia Pro Bold

Georgia Pro Bold Italic

Georgia Pro Black

Georgia Pro Black Italic

Georgia Pro Cond Light

Georgia Pro Cond Light Italic

Georgia Pro Cond

Georgia Pro Cond Italic

Georgia Pro Cond Semibold

Georgia Pro Cond Semibold Italic

Georgia Pro Cond Bold

Georgia Pro Cond Bold Italic

Georgia Pro Cond Black

Georgia Pro Cond Black Italic

Change list:
Windows 10 version 1507 released on July 29, 2015
Georgia Pro font family was introduced as part of the Windows 10 Pan-European
Supplemental Fonts package.

Georgia Ref font family
Article • 03/30/2022

Overview
Custom version of Georgia for use with Microsoft Reference.
Description
File name

Grgaref.ttf

Styles & Weights

Georgia Ref

Designers

Matthew Carter

Copyright

Typeface and data © 1996 Microsoft Corporation. All Rights Reserved

Font vendor

Microsoft Corp.

Script Tags

N/A

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Georgia Ref

Gigi font family
Article • 03/30/2022

Overview
The Gigi font's chic, informal style features an plethora of flourishes and swirls that give
it a charming and fresh handwritten quality.
Description
File name

Gigi.ttf

Styles &
Weights

Gigi

Designers

Jill Bell

Copyright

Copyright © Esselte Corporation 1997. Portions Copyright Microsoft Corporation
1997. All rights reserved.

Font vendor

ITC Corporation

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples

Gigi

Gill Sans MT font family
Article • 03/30/2022

Overview
Gill Sans is the famous set of humanist sans serif fonts originally designed by Eric Gill
and the Monotype Type Drawing Office, first appearing in 1928. Gill studied under the
renowned calligrapher, Edward Johnston, the designer of the London Underground sans
serif typeface. This influenced Gill who later experimented with sans serif designs, and in
due course produced a set of capital letters. These became Monotype series 231,
produced in 1923, and the forerunner of the extensive Gill Sans range now available. A
twentieth century sans serif that has a simplicity of form which does not reject
traditional forms and proportions, and gives the face a humanist feel. The lighter
weights are highly readable in text and suitable for magazine and book work, whereas
the heavier weights are best used for display in advertising, packaging, and labels.
Description
File name

Gil_____.ttf
Gilb____.ttf
Gilbi___.ttf
Gili____.ttf
Gilsanub.ttf
Gillubcd.ttf

Styles &
Weights

Gill Sans MT
Gill Sans MT Bold
Gill Sans MT Bold Italic
Gill Sans MT Italic
Gill Sans Ultra Bold
Gill Sans Ultra Bold Condensed

Designers

Eric Gill

Copyright

Digitized data copyright The Monotype Corporation 1991-1995. All rights reserved.
Gill Sans? is a trademark of The Monotype Corporation which may be registered in
certain jurisdictions.

Font

Agfa Monotype Corporation

vendor
Script
Tags

N/A

Description
Code
pages

1252 Latin 1
1250 Latin 2: Eastern Europe
Mac Roman Macintosh Character Set (US Roman)

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Gill Sans MT

Gill Sans MT Bold

Gill Sans MT Bold Italic

Gill Sans MT Italic

Gill Sans Ultra Bold

Gill Sans Ultra Bold Condensed

Gill Sans MT Condensed font family
Article • 03/30/2022

Overview
Monotype Type Drawing Office 1928. Gill studied under the renowned calligrapher,
Edward Johnston, the designer of the London Underground sans serif typeface. This
influenced Gill who later experimented with sans serif designs, and in due course
produced a set of capital letters. These became Monotype series 231, produced in 1923,
and the forerunner of the extensive Gill Sans range now available. A twentieth century
sans serif that has a simplicity of form which does not reject traditional forms and
proportions, and gives the face a humanist feel. The lighter weights are highly readable
in text and suitable for magazine and book work, whereas the heavier weights are best
used for display in advertising, packaging, and labels.
Description
File name

Gilc____.ttf
Gilcb___.ttf
Glsnecb.ttf

Styles &
Weights

Gill Sans MT Condensed
Gill Sans MT Condensed Bold
Gill Sans MT Ext Condensed Bold

Designers

Eric Gill

Copyright

Digitized data copyright © 1997 The Monotype Corporation, Inc. All rights reserved.
Gill Sans? is a trademark of The Monotype Corporation, Inc. which may be registered
in certain jurisdictions.

Font

Agfa Monotype Corporation

vendor
Script

N/A

Tags
Code

1252 Latin 1

pages

1250 Latin 2: Eastern Europe
Mac Roman Macintosh Character Set (US Roman)

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Gill Sans MT Condensed

Gill Sans MT Condensed Bold

Gill Sans MT Ext Condensed Bold

Gill Sans Nova font family
Article • 03/30/2022

Overview
Description
File name

GillSansNova.ttf
GillSansItNova.ttf
GillSansLightNova.ttf
GillSansLightItNova.ttf
GillSansBoNova.ttf
GillSansBoItNova.ttf
GillSansUltraBoNova.ttf
GillSansCondLightNova.ttf
GillSansCondLightItNova.ttf
GillSansCondNova.ttf
GillSansCondItNova.ttf
GillSansCondBoNova.ttf
GillSansCondBoItNova.ttf
GillSansCondExtraNova.ttf
GillSansCondExtraItNova.ttf
GillSansCondUltraBoNova.ttf

Styles & Weights

Gill Sans Nova
Gill Sans Nova Italic
Gill Sans Nova Light
Gill Sans Nova Light Italic
Gill Sans Nova Bold
Gill Sans Nova Bold Italic
Gill Sans Nova Ultra Bold
Gill Sans Nova Cond Lt
Gill Sans Nova Cond Lt Italic
Gill Sans Nova Cond
Gill Sans Nova Cond Italic
Gill Sans Nova Cond Bold
Gill Sans Nova Cond Bold Italic
Gill Sans Nova Cond XBd
Gill Sans Nova Cond XBd Italic
Gill Sans Nova Cond Ultra Bold

Designers

Monotype Design Office

Copyright

© 2014 The Monotype Corporation. All Rights Reserved.

Font vendor

Monotype Imaging Inc.

Description
Script Tags

dlng: 'Cyrl', 'Grek', 'Latn'
slng: 'Cyrl', 'Grek', 'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Gill Sans Nova

Gill Sans Nova Italic

Gill Sans Nova Light

Gill Sans Nova Light Italic

Gill Sans Nova Bold

Gill Sans Nova Bold Italic

Gill Sans Nova Ultra Bold

Gill Sans Nova Cond Lt

Gill Sans Nova Lt Italic

Gill Sans Nova Cond

Gill Sans Nova Cond Italic

Gill Sans Nova Cond Bold

Gill Sans Nova Cond Bold Italic

Gill Sans Nova XBd

Gill Sans Nova XBd Italic

Gill Sans Nova Cond Ultra Bold

Change list:
Windows 10 version 1507 released on July 29, 2015

Gill Sans Nova font family was introduced as part of the Windows 10 Pan-European
Supplemental Fonts package.

Gisha font family
Article • 03/30/2022

Overview
Gisha is a Hebrew font.
Description
File name

Gisha.ttf
Gishabd.ttf

Styles & Weights

Gisha
Gisha Bold

Designers

N/A

Copyright

© 2014 Microsoft Corporation. All Rights Reserved.

Font vendor

MS

Script Tags

dlng:'Hebr'
slng:'Hebr'

Code pages

1252 Latin 1
1255 Hebrew

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Product name

Font version

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Gisha

Gisha Bold

Gloucester font family
Article • 03/30/2022

Overview
The first hot-metal sizes of Gloucester Old Style were issued in 1911, derived from a
design created in 1896 by the distinguished American architect, Bertram Goodhue.
Intended to maximize legibility, the original design featured long ascenders, while the
descenders (considered of lesser importance) were very short. Popular as a text face in
the early 20th century, the extra-condensed variation proves particularly useful to
maintain legibility while packing more characters into a certain space.
Description
File name

Glecb.ttf

Styles &
Weights

Gloucester MT Extra Condensed

Designers

Monotype Type Drawing Office

Copyright

Typeface data Copyright 1992-94 The Monotype Corporation. Copyright 1994
Microsoft Corporation. All rights reserved.

Font
vendor

Agfa Monotype Corporation

Script Tags

N/A

Code
pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font

This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Gloucester MT Extra Condensed

Goudy Old Style font family
Article • 03/30/2022

Overview
Elegant, yet surprisingly hardy, Goudy Old Style has never gone out of fashion. Its
resemblance to classic Italian typefaces is coincidental. This Old Style is not an
adaptation of previous letterforms. With round curves and thin strokes, Goudy Old Style
brings a little gentle humanity to a document that might look too austere in a more
workaday face.
Description
File name

Goudos.ttf
Goudosb.ttf
Goudosi.ttf

Styles &
Weights

Goudy Old Style
Goudy Old Style Bold
Goudy Old Style Italic

Designers

Frederic William Goudy, 1993, (1915)

Copyright

Data by URW, Type Solutions, Inc. © 1993. Microsoft Corporation. All rights
reserved.

Font vendor

URW Type Foundry

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font

This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Goudy Old Style

Goudy Old Style Bold

Goudy Old Style Italic

Goudy Stout font family
Article • 03/30/2022

Overview
Drawn by Microsoft's Vincent Connare, this is a revival of an old decorative version of
Goudy.
Description
File name

Goudysto.ttf

Styles & Weights

Goudy Stout

Designers

Vincent Connare

Copyright

Copyright © 1995-2002 Microsoft Corporation. All rights reserved.

Font vendor

Microsoft Corp.

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Goudy Stout

Gradl font family
Article • 03/30/2022

Overview
We have called this face Gradl because it was one of many hand-drawn cap alphabets
made by M. J. Gradl. The Font Bureau added the lower-case alphabet and numerals in
the style we felt Gradl might have followed. Gradl started as a hand-drawn alphabet, and
we've resisted the temptation to smooth it out. There are already quite enough of the
mechanical designs that the computer can so easily duplicate. For a hand-drawn flavor,
try Gradl.
Description
File name

Gradl.ttf

Styles &
Weights

Gradl

Designers

N/A

Copyright

©1992 The Font Bureau, Inc. Portions © 1992 Microsoft Corp. All rights
reserved.

Font vendor

Font Bureau, Inc.

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Gradl

Grotesque font family
Article • 03/30/2022

Overview
Description
File name

grotesque.ttf
grotesqueb.ttf
grotesquel.ttf

Styles & Weights

Grotesque
Grotesque Bold
Grotesque Light

Copyright

Digitized data copyright The Monotype Corporation 1991-1995.

Designers

Monotype Studios

Font vendor

René Bieder

Script Tags

dlng:'Latn'
slng:'Latn'

Code pages

1252 Latin 1

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Grotesque

Grotesque Bold

Grotesque Light

Gulim font family
Article • 03/30/2022

Overview
Gulim font features plain strokes similar to sans serif designs, and works well for onscreen display such as user interfaces.
Description
File name

Gulim.ttc

Styles & Weights

Gulim
GulimChe

Designers

N/A

Copyright

© 2009 HanYang I&C Co., LTD.

Font vendor
Script Tags

dlng:'Hang', 'Hani', 'Kore'
slng:'Hang', 'Hani', 'Kore'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
949 Korean Wansung
OEM OEM Character Set
869 IBM Greek
866 MS-DOS Russian
865 MS-DOS Nordic
863 MS-DOS Canadian French
861 MS-DOS Icelandic
860 MS-DOS Portuguese
857 IBM Turkish
855 IBM Cyrillic; primarily Russian
852 Latin 2
775 MS-DOS Baltic
737 Greek; former 437 G
850 WE/Latin 1
437 US

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

2.21

Windows 2000

2.20

Windows Server 2008

5.00

Windows Server 2003

2.21

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Gulim

GulimChe

Gungsuh font family
Article • 03/30/2022

Overview
Gungsuh is a Korean font.
Description
File name

Batang.ttc

Styles & Weights

Gungsuh
GungsuhChe

Designers

N/A

Copyright

(c) Copyright HanYang I&C Co.,LTD. 2000

Font vendor

HanYang System

Script Tags

dlng:'Hang', 'Hani', 'Kore'
slng:'Hang', 'Hani', 'Kore'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
949 Korean Wansung
OEM OEM Character Set
869 IBM Greek
866 MS-DOS Russian
864 Arabic
863 MS-DOS Canadian French
862 Hebrew
861 MS-DOS Icelandic
860 MS-DOS Portuguese
857 IBM Turkish
855 IBM Cyrillic; primarily Russian
775 MS-DOS Baltic
708 Arabic; ASMO 708
850 WE/Latin 1
437 US

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

2.21

Windows 2000

2.20

Windows Server 2008

5.00

Windows Server 2003

2.21

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Gungsuh

GungsuhChe

Hadassah Friedlaender font family
Article • 03/30/2022

Overview
Description
File name

Hadasah.ttf
Hadasahb.ttf

Styles &

Hadassah Friedlaender

Weights

Hadassah Friedlaender Bold

Designers

Henri Friedlaender (1958), Yanek Iontef (2015)

Copyright

Designer: Henri Friedlaender (1958), Yanek Iontef (2014); Copyright © 2014 Henri
Friedlaender (1958), Yanek Iontef (2014), Microsoft Corporation (2015). All rights
reserved.

Font
vendor

Yanek Iontef

Script
Tags

dlng:'Hebr'
slng:'Hebr', 'Latn'

Code
pages

1252 Latin 1
1255 Hebrew

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Hadassah Friedlaender

Hadassah Friedlaender Bold

Haettenschweiler font family
Article • 03/30/2022

Overview
Haettenschweiler derives from a more condensed typeface, called Schmalfette Grotesk,
first shown in the early 1960s in a splendid book called Lettera by Walter
Haettenschweiler and Armin Haab. Schmalfette Grotesk was a very condensed, very bold
alphabet of all capitals - schmalfette means "bold condensed" in German, and grotesk
indicates it is without serifs. It was immediately picked up by designers at Paris Match
who cut up pictures of it to make headlines. Soon everybody wanted it. In due course,
extra-bold extra-condensed faces for families like Helvetica began to appear, looking
remarkably like the original Schmalfette. Photoscript had made a lowercase version
quite early on. Later, they made a less condensed version and called it Haettenschweiler
Extended as a tribute to a designer whose idea so greatly affected the graphic scene in
the second half of the century. Use this distinguished face in large sizes for headlines.
Description
File name

Hatten.ttf

Styles &
Weights

Haettenschweiler

Designers

N/A

Copyright

Data by Eraman Ltd., and Monotype Typography Inc. © 1995. Microsoft
Corporation. All rights reserved.

Font vendor

N/A

Script Tags

N/A

Description
Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
Mac Roman Macintosh Character Set (US Roman)
869 IBM Greek
866 MS-DOS Russian
865 MS-DOS Nordic
863 MS-DOS Canadian French
861 MS-DOS Icelandic
860 MS-DOS Portuguese
857 IBM Turkish
855 IBM Cyrillic; primarily Russian
852 Latin 2
775 MS-DOS Baltic
737 Greek; former 437 G
850 WE/Latin 1
437 US

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Haettenschweiler

Harlow Solid Italic font family
Article • 03/30/2022

Overview
Harlow Solid Italic font effectively captures the flavor of the 1930s and 40s with its
strong geometric letterforms.
Description
File name

Harlowsi.ttf

Styles & Weights

Harlow Solid Italic

Designers

N/A

Copyright

URW Software, Copyright 1993 by URW

Font vendor

N/A

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Harlow Solid Italic

Harrington font family
Article • 03/30/2022

Overview
This face was made during the late 19th century, the same period when these highwaisted art nouveau letters were fashionable. Harrington probably first appeared in the
list of fonts from Haddons, a type foundry in London. Unlike many of the other art
nouveau fonts, however, Harrington came with a full character set. For some years, the
need for a typeface of this kind has only been met by fonts like University Roman.
Harrington deserves to be seen once again, nearly a century after it first appeared.
Description
File name

Harngton.ttf

Styles &
Weights

Harrington

Designers

David Berlow, designer

Copyright

©1992. The Font Bureau, Inc. Portions © 1992 Microsoft Corp. All rights
reserved.

Font vendor

The Font Bureau, Inc.

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Harrington

HGGothicE font family
Article • 03/30/2022

Overview
Description
File name

HGGothicE.ttf
HGPGothicE.ttf
HGSGothicE.ttf

Styles & Weights

HGGothicE
HGPGothicE
HGSGothicE

Copyright

Copyright (C) RICOH Industrial Solutions Inc. All Rights Reserved.

Designers

N/A

Font vendor

RICOH Co.,Ltd.

Script Tags

N/A

Code pages

N/A

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is also available within Office applications. For more information visit this
page.

HGMinchoE font family
Article • 03/30/2022

Overview
Description
File name

HGMinE.ttf
HGPMinE.ttf
HGSMinE.ttf

Styles & Weights

HGMinchoE
HGPMinchoE
HGSMinchoE

Copyright

(C)2009 data:RICOH Co.,Ltd. typeface:RYOBI IMAGIX CO.

Designers

N/A

Font vendor

RICOH Co.,Ltd.

Script Tags

N/A

Code pages

N/A

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is also available within Office applications. For more information visit this
page.

HGSoeiKakugothicUB font family
Article • 03/30/2022

Overview
Description
File name

HGSoeiKakugothicUB.ttf
HGPSoeiKakugothicUB.ttf
HGSSoeiKakugothicUB.ttf

Styles & Weights

HGSoeiKakugothicUB
HGPSoeiKakugothicUB
HGSSoeiKakugothicUB

Copyright

Copyright (C) RICOH Industrial Solutions Inc. All Rights Reserved.

Designers

N/A

Font vendor

RICOH Co.,Ltd.

Script Tags

N/A

Code pages

N/A

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is also available within Office applications. For more information visit this
page.

High Tower Text font family
Article • 03/30/2022

Overview
In 1994 Tobias Frere-Jones completed Hightower for the Journal of the American
Institute of Graphic Arts. For as long as he had drawn letters, he had wrestled with the
problems posed by any modern rendition of the fifteenth century Venetian roman.
Dissatisfied with others' attempts to bring Nicholas Jenson's 1470 roman up to date,
Frere-Jones prepared his version of this calligraphic roman, and developing his own
personal italic; FB .
Description
File name

Htowert.ttf
Htowerti.ttf

Styles &
Weights

High Tower Text
High Tower Text Italic

Designers

Tobias Frere-Jones

Copyright

Copyright (c) 1996, Tobias Frere-Jones. Designed by Tobias Frere-Jones. Produced by
The Font Bureau, Inc. All rights reserved.

Font
vendor

The Font Bureau, Inc.

Script
Tags

N/A

Code

1252 Latin 1

pages

Mac Roman Macintosh Character Set (US Roman)

Fixed

False

pitch

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
High Tower Text

High Tower Text Italic

Holidays MT font family
Article • 03/30/2022

Overview
Designed by Carolyn Gibbs & Steve Matteson, this is one of a set of versatile art fonts
from Monotype. For readers from England this font's name will conjure up pictures of
suntan lotion, sunglasses and ice creams by the seaside. But in America that is a
vacation. This font is all about Halloween, Valentine's day, Easter etc., which American
readers refer to as holidays. Great for instant illustrations, icons or bullets.
Description
File name

Ho.ttf

Styles &
Weights

Holidays MT

Designers

Carolyn Gibbs and Steve Matteson

Copyright

Digitized data copyright (C) 1991-1995 The Monotype Corporation. All rights
reserved. Holidays? is a trademark of The Monotype Corporation which may be
registered in certain jurisdicions.

Font
vendor

Agfa Monotype Corporation

Script
Tags

N/A

Code

Symbol Symbol Character Set

pages
Fixed

False

pitch

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples

Holidays MT

HoloLens MDL2 Assets font family
Article • 03/30/2022

Overview
HoloLens MDL2 Assets is a system font that includes new icons.
Description
File name

Holomdl2.ttf

Styles & Weights

HoloLens MDL2 Assets

Designers

Microsoft Corporation

Copyright

© 2014 Microsoft Corporation. All Rights Reserved.

Font vendor

Microsoft Corporation

Script Tags

dlng:'Zsym'
slng:'Zsym'

Code pages

1252 Latin 1

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Style & weight examples

HoloLens MDL2 Assets (regular)

Change list:
Windows 10 version 1511 released on November 10, 2015
The HoloLens MDL2 Assets font was included as part of the desktop system fonts.

Impact font family
Article • 03/30/2022

Overview
Geoffrey Lee designed this face, first issued in 1965 by the famous Sheffield foundry,
Stephenson Blake. The mid-1960s marked the height of a fashion for bold condensed
faces that probably originated when Paris Match cut up prints of the Schmalfette
Grotesk font, which had been drawn by Walter Haettenschweiler. Because Impact was
less condensed than Schmalfette, designers often used the two fonts together as
companion faces. Even without Schmalfette, you can use Impact for, well, impact.

Impact version history
Version 2.35 - This version includes some minor table updates, but no new glyphs.
Version 2.30 - Impact version 2.30 extends the WGL4 version to include the euro
currency symbol.
Version 2.20 - Impact version 2.20 was one of our original Core fonts for the Web posted
on 1 March 1996. It is also supplied with Microsoft Internet Explorer 3.0 released on 13
August 1996 and Internet Explorer 4.
Description
File name

Impact.ttf

Styles &

Impact

Weights
Designers

Geoffrey Lee

Copyright

© 2011 The Monotype Corporation. All Rights Reserved. Impact is a trademark of
Stephenson Blake (Holdings) Ltd.

Font
vendor

Agfa Monotype Corporation

Script Tags

dlng:'Cyrl', 'Grek', 'Latn'
slng:'Cyrl', 'Grek', 'Latn'

Description
Code

1252 Latin 1

pages

1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
Mac Roman Macintosh Character Set (US Roman)
869 IBM Greek
866 MS-DOS Russian
865 MS-DOS Nordic
863 MS-DOS Canadian French
861 MS-DOS Icelandic
860 MS-DOS Portuguese
857 IBM Turkish
855 IBM Cyrillic; primarily Russian
852 Latin 2
775 MS-DOS Baltic
737 Greek; former 437 G
850 WE/Latin 1
437 US

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Product name

Font version

Windows XP

2.35

Windows 2000

2.30

Windows 98

2.20

Windows Server 2008

5.00

Windows Server 2003

2.35

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Impact

Imprint MT Shadow font family
Article • 03/30/2022

Overview
Imprint holds a special place in the Monotype typeface library. It was the first typeface
designed specifically for mechanical composition. Commissioned by E Jackson, E
Johnson, J Mason and G Meynell for a new periodical, entitled The Imprint, which they
were planning. Described later as "a modified old style with a Caslon old face motif". The
more archaic features of Caslon were dropped, the weight was increased but certain old
face characteristics were retained. The magazine for which Imprint had been
commissioned was short lived but the typeface became popular and widely used for
book setting. Imprint was also to influence many later book face designs.
Description
File name

Imprisha.ttf

Styles &
Weights

Imprint MT Shadow

Designers

Monotype Type Drawing Office

Copyright

Design and data by The Monotype Corporation. © 1993. Microsoft Corporation.
all rights reserved.

Font vendor

Agfa Monotype Corporation

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font

This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Imprint MT Shadow

Informal Roman font family
Article • 03/30/2022

Overview
The Informal Roman font is reminiscent of the sort of lettering that enjoyed widespread
popularity in the late 1940s through the early 1950s.
Description
File name

Infroman.ttf

Styles &
Weights

Informal Roman

Designers

Martin Weir

Copyright

Copyright © Esselte Corporation 1997. Portions Copyright Microsoft Corporation
1997. All rights reserved.

Font vendor

ITC Corporation

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Informal Roman

Ink Free font family
Article • 03/30/2022

Overview
Ink Free is a casual typeface design with irregular alignments and occasional
connections. We think it is a great font that can be use in a wide range of experiences
including whiteboard and OneNote.
Description
File name

Inkfree.ttf

Styles & Weights

Ink Free​

Designers

Steve Matteson

Copyright

Copyright © 2005-2018 Ascender Corporation. All rights reserved.

Font vendor

Monotype Imaging Inc.

Script Tags

dlng: 'Latn'
slng:'Latn'

Code pages

1252 Latin 1

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples

Change list:
Windows 10 version 1803 released on April 30, 2018
Ink Free was introduced as part of the desktop font collection.

IrisUPC font family
Article • 03/30/2022

Overview
Iris UPC is a Thai font designed by Unity Progress and offered under license from
Microsoft.
Description
File name

Upcil.ttf
Upcib.ttf
Upcibi.ttf
Upcii.ttf

Styles &
Weights

IrisUPC
IrisUPC Bold
IrisUPC Bold Italic
IrisUPC Italic

Designers

N/A

Copyright

© 1992 Unity Progress. Portions © 2004 The Monotype Corporation. Portions ©
2015 Microsoft Corporation. All Rights Reserved.

Font
vendor

MS

Script

dlng:'Thai'

Tags

slng:'Thai'

Code

1252 Latin 1

pages

874 Thai

Fixed

False

pitch

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

2.20

Windows Server 2008

5.00

Windows Server 2003

2.20

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
IrisUPC

IrisUPC Bold

IrisUPC Bold Italic

IrisUPC Italic

Iskoola Pota font family
Article • 03/30/2022

Overview
Iskoola Pota is a Sinhala font.
Description
File name

Iskpota.ttf
Iskpotab.ttf

Styles & Weights

Iskoola Pota
Iskoola Pota Bold

Designers

N/A

Copyright

© 2016 Microsoft Corporation. All Rights Reserved.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Sinh'
slng:'Sinh'

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Product name

Font version

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows Server 2008

5.00

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Iskoola Pota

Iskoola Pota Bold

JasmineUPC font family
Article • 03/30/2022

Overview
Jasmine UPC is a Thai font designed by Unity Progress and offered under license from
Microsoft.
Description
File name

Upcjl.ttf
Upcjb.ttf
Upcjbi.ttf
Upcji.ttf

Styles &
Weights

JasmineUPC
JasmineUPC Bold
JasmineUPC Bold Italic
JasmineUPC Italic

Designers

N/A

Copyright

© 1992 Unity Progress. Portions © 2004 The Monotype Corporation. Portions ©
2015 Microsoft Corporation. All Rights Reserved.

Font
vendor

MS

Script

dlng:'Thai'

Tags

slng:'Thai'

Code

1252 Latin 1

pages

874 Thai

Fixed

False

pitch

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

2.20

Windows Server 2008

5.00

Windows Server 2003

2.20

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
JasmineUPC

JasmineUPC Bold

JasmineUPC Bold Italic

JasmineUPC Italic

Javanese Text font family
Article • 03/30/2022

Overview
Javanese Text is added to Windows to support the Javanese writing script. This script is
used to write the Javanese language spoken in Indonesia and Suriname. Javanese Text is
a document font and the style of the design conforms with traditional Javanese
manuscript and metal type models.
Description
File name

Javatext.ttf

Styles & Weights

Javanese Text

Designers

John Hudson

Copyright

© 2018 Microsoft Corporation. All Rights Reserved.

Font vendor

Tiro Typeworks Ltd., for Microsoft Corporation.

Script Tags

dlng: 'Java'
slng: 'Java', 'Latn'

Code pages

1252 Latin 1

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Product name

Font version

Windows 8.1

See the Windows 8.1 page.

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Regular

Jokerman font family
Article • 03/30/2022

Overview
The Jokerman font is a wildly original and energetic typeface in every way. Fanciful
internal and external elements support a spirited troupe of casual letterforms that exude
excitement and spirit.
Description
File name

Jokerman.ttf

Styles &
Weights

Jokerman

Designers

Andrew Smith

Copyright

Copyright © Esselte Corporation 1997. Portions Copyright Microsoft Corporation
1997. All rights reserved.

Font vendor

ITC Corporation

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples

Jokerman

Juice ITC font family
Article • 03/30/2022

Overview
ITC Juice font was conceived and drawn by David Sagorski and represents the creative
ability and humor of this inventive designer. Sagorski was born in Kansas, but moved to
southern Florida where he studied at the Art Institute of Fort Lauderdale. This typeface
shows the clear influence of cartoon graphics of the 1960s and 1970s. While visions of
Gerald McBoing-Boing? or the Jetsons? may come to mind, such associations should
not be limited to 'period' or animated graphics. Released in 1995, ITC Juice has a subtle
sophistication underneath its funky exterior and is space-economical.
Description
File name

Juice___.ttf

Styles &
Weights

Juice ITC

Designers

David Sagorski

Copyright

Copyright (c) International Typeface Corporation 1996. Portions Copyright (c)
Microsoft Corporation 1996. All rights reserved.

Font
vendor

ITC

Script
Tags

N/A

Code
pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Juice ITC

KaiTi font family
Article • 03/30/2022

Overview
KaiTi is a Simplified Chinese font.
Description
File name

Simkai.ttf

Styles & Weights

KaiTi

Designers

N/A

Copyright

© Beijing ZhongYi Electronics Co., 1995-2005, All rights reserved

Font vendor

ZYEC

Script Tags

dlng:'Hans'
slng:'Bopo', 'Cyrl', 'Grek', 'Hani', 'Hans', 'Hira', 'Hrkt', 'Jpan', 'Kana', 'Latn'

Code pages

1252 Latin 1
936 Chinese: Simplified chars--PRC and Singapore

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Product name

Font version

Windows 7

See the Windows 7 page.

Windows Vista

5.01

Windows XP

2.00

Windows 2000

2.00

Windows Server 2008

5.01

Windows Server 2003

2.00

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
KaiTi

Kalinga font family
Article • 03/30/2022

Overview
Kalinga is a Oriya font.
Description
File name

Kalinga.ttf
Kalingab.ttf

Styles & Weights

Kalinga
Kalinga Bold

Designers

N/A

Copyright

© 2015 Microsoft Corporation, portions © Modular Infotech

Font vendor

MS

Script Tags

dlng:'Orya'
slng:'Orya', 'Latn'

Code pages

1252 Latin 1
874 Thai

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Product name

Font version

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.01

Windows Server 2008

5.01

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Kalinga

Kalinga Bold

Kartika font family
Article • 03/30/2022

Overview
Kartika is an OpenType font for the Indic script - Malayalam. It is based on Unicode,
contains TrueType outlines and has been designed for use as a UI font.
Description
File name

Kartika.ttf
Kartikab.ttf

Styles & Weights

Kartika
Kartika Bold

Designers

Raghunath Joshi (Type Director), Vikram Gaikwad

Copyright

© 2015 Microsoft Corporation. All Rights Reserved.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Mlym'
slng:'Mlym', 'Latn'

Code pages

1252 Latin 1

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Product name

Font version

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.02

Windows XP

1.06

Windows Server 2008

5.02

Windows Server 2003

1.06

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Kartika

Kartika Bold

Keystrokes MT font family
Article • 03/30/2022

Overview
Designed by Joshua Hadley, this is one of a versatile set of art fonts from Monotype. If
you need to illustrate any of the keys on your keyboard then this font will save you a lot
of work. It has drawings of all the keys you might need from both Macintosh and
standard keyboards. Great for instant illustrations, icons or bullets.
Description
File name

Key.ttf

Styles &
Weights

Keystrokes MT

Designers

Joshua Hadley

Copyright

Digitized data copyright (C) 1991-1995 The Monotype Corporation. All rights
reserved. Keystrokes? is a trademark of The Monotype Corporation which may be
registered in certain jurisdicions.

Font
vendor

Agfa Monotype Corporation

Script
Tags

N/A

Code
pages

Symbol Symbol Character Set

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples

Keystrokes MT

Khmer UI font family
Article • 03/30/2022

Overview
Khmer UI is a font from Cambodia.
Description
File name

KhmerUI.ttf
KhmerUIb.ttf

Styles & Weights

Khmer UI
Khmer UI Bold

Designers

N/A

Copyright

© 2015 Microsoft Corporation. All Rights Reserved.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Khmr'
slng:'Khmr', 'Latn'

Code pages

1252 Latin 1

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Product name

Font version

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Khmer UI

Khmer UI Bold

Kigelia font family
Article • 03/30/2022

Overview
Kigelia is a large typeface family that contains the most prominent writing systems in
Africa. Kigelia’s characters have a warm, open, sans serif style, with hardly any contrast
between thick strokes and thin strokes in the Light weight, a little contrast in the Regular
weight, and quite strong contrast in the Bold weight, in each script.
Type designers Mark Jamra and Neil Patel designed Kigelia, with consultation and
critiques from a wide variety of language experts and native speakers. The Kigelia font
has three weights, Light, Regular, and Bold. It has capitals and lowercase letters for the
Latin, Greek, and Cyrillic alphabets, including the International Phonetic Alphabet and
the African Reference Alphabet, as well as the characters needed to typeset the N’ko,
Adlam, Vai, Ge’ez, Tifinagh, and Osmanya scripts. Only the scripts that have a tradition of
an alternate cursive style are included in the complementary italic fonts. Kigelia Arabic is
added to the family as a companion font family to support African languages written
with Arabic script.
Description
File name

kigeliaarabic-light.ttf
kigeliaarabic-regular.ttf
kigelia-bold.ttf
kigelia-bolditalic.ttf
kigelia-italic.ttf
kigelia-light.ttf
kigelia-lightitalic.ttf
kigelia-regular.ttf

Styles & Weights

Kigelia Arabic Bold
Kigelia Arabic Light
Kigelia Arabic Regular
Kigelia Bold
Kigelia Bold Italic
Kigelia Italic
Kigelia Light
Kigelia Light Italic
Kigelia Regular

Designers

Mark Jamra and Neil Patel

Copyright

© 2018 by Jamra Patel LLC. All rights reserved.

Description
Font vendor

Jamra Patel

Script Tags

dlng:'Adlm', 'Arab', 'Ethi', 'Nkoo', 'Osma', 'Tfng', 'Vaii'
slng:'Adlm', 'Arab', 'Cyrl', 'Grek', 'Ethi', 'Latn', 'Nkoo', 'Osma', 'Tfng', 'Vaii'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1256 Arabic
1257 Windows Baltic
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows

Products that supply this font
This typeface is available within Office applications. For more information visit this page.

Style & weight examples
Kigelia Adlam

The Adlam alphabet was invented in Guinea in the 1980s by Abdoulaye Barry and
Ibrahima Barry for the Pular (Fulfulde) language spoken by the Fulani people of West
Africa. Adlam reads right-to-left and has upper- and lowercase letters in two variants:

connected and unconnected. The designers received feedback from Abdoulaye and
Ibrahima Barry throughout the design of this complement.

Kigelia Arabic

Kigelia Arabic contains a Modern Standard Arabic complement as well as African Ajami
characters and many typical African ligatures. Kigelia Arabic supports various African
languages written using the Arabic script, including Moroccan Darija, Algerian Darja,
Tunisian Arabic, Chadian Arabic, Hausa, Wolof, Soninke, Swahili, Manding, Tuareg,
Tachelhit-Shilha, Mogofin, Susu, Fulfulde, and Bravanese. The designers received advice
and feedback from Fallou Ngom, Lamine Diallo, Jesus Maclean, Kifah Abdulla, Kourosh
Beigpour, Dmitry Bondarev, Coleman Donaldson, Djibril Dramé, Darya Ogorodnikova,
and Mamoun Sakkal.

Kigelia Ge’ez

Kigelia has a full complement of the Ge’ez alphasyllabary, which serves the languages
Amharic, Tigrinya, Tigre, Harari, Gurage, Sebatbeit, Gamo-Gofa-Dawro, Basketo, and
Gumuz. The designers received feedback from Daniel Yacob and John Hudson.

Kigelia Latin, Greek and Cyrillic

Kigelia contains full complements of the International Phonetics Alphabet, the African
Reference Alphabet, additional characters for African languages, some localized variants,
“old-style” figures, set fractions, numerators, denominators, superiors, and scientific
inferiors. There are also Standard Greek and Standard Cyrillic complements. For this part
of Kigelia, the designers received consultation from Denis Jacquerye, Donald Osborn,
Gerry Leonidas, and Ksenya Samarskaya.

Kigelia N’ko

The N’ko alphabet was invented in 1949 in Guinea by Soulemana Kantè for the Manding
language in the regional languages Maninka, Dioula, Bambara, and Mandinka. The
designers received guidance on this script from Prof. Mamadi Diané, Boubacar Diakité
and Solo Farabado Cissé.

Kigelia Osmanya

Osmanya is a writing system invented between 1920 and 1922 by Osman Yusuf Kenadid
to transcribe the Somali language. Kigelia's Osmanya complement is valuable for
digitizing and preserving historical and cultural documents.

Kigelia Tifinagh

Kigelia’s Tifinagh complement contains all of the characters and code needed for the
North African languages and regional languages that use this ancient script. Stylistic sets
are included which provide the user with access to all of the documented regional
orthographic variants. The careful design of the Tifinagh glyphs and extensive kerning
make this design an excellent choice for extensive texts.

Kigelia Vai

Kigelia’s Vai complement contains all the glyphs needed by the Vai language community
in Liberia and Sierra Leone. The Vai syllabary was invented in 1833 by Mɔmɔlu Duwalu
Bukɛlɛ and this design preserves the liveliness and humanity of the original script. The
designers received feedback on this script from Tombekai Sherman and Charles Riley.

Kino MT font family
Article • 03/30/2022

Overview
This 1930 sans serif face has some odd angular insertions. It was designed with the spirit
to amaze, rather than to inform, which you may want to keep in mind when using this
typeface.
Description
File name

Kino.ttf

Styles & Weights

Kino MT

Designers

M. Dovey

Copyright

Copyright © The Monotype Corporation plc. 1992. All rights reserved

Font vendor

Agfa Monotype Corporation

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Kino MT

KodchiangUPC font family
Article • 03/30/2022

Overview
Kodchiang UPC is a Thai font designed by Unity Progress and offered under license from
Microsoft.
Description
File name

Upckl.ttf
Upckb.ttf
Upckbi.ttf
Upcki.ttf

Styles &
Weights

KodchiangUPC
KodchiangUPC Bold
KodchiangUPC Bold Italic
KodchiangUPC Italic

Designers

N/A

Copyright

© 1992 Unity Progress. Portions © 2004 The Monotype Corporation. Portions ©
2015 Microsoft Corporation. All Rights Reserved.

Font
vendor

MS

Script

dlng:'Thai'

Tags

slng:'Thai', 'Latn'

Code

1252 Latin 1

pages

874 Thai

Fixed

False

pitch

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

2.20

Windows Server 2008

5.00

Windows Server 2003

2.20

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
KodchiangUPC

KodchiangUPC Bold

KodchiangUPC Bold Italic

KodchiangUPC Italic

Kokila font family
Article • 03/30/2022

Overview
This font is primarily meant for use in displaying Hindi text in documents. It is an
OpenType font, based on Unicode.
Description
Files

Kokila.ttf
Kokilab.ttf
Kokilai.ttf
Kokilabi.ttf

Styles & Weights

Kokila
Kokila Bold
Kokila Italic
Kokila Bold Italic

Designers

N/A

Copyright

Copyright (c) 2011, Modular Infotech, Pune, INDIA. - Licenced to Microsoft

Font vendor

MODI

Script Tags

dlng: 'Deva'
slng: 'Deva', 'Latn'

Code pages

1252 Latin 1

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Kokila

Kokila Bold

Kokila Italic

Kokila Bold Italic

Kristen ITC font family
Article • 03/30/2022

Overview
ITC Kristen is a script font in the style of children's handwriting.
Description
File name

Itckrist.ttf

Styles &
Weights

Kristen ITC

Designers

George Ryan

Copyright

Copyright (c) International Typeface Corporation 1997. Portions Copyright (c)
Microsoft Corporation 1997. All rights reserved.

Font
vendor

ITC

Script
Tags

N/A

Code
pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Kristen ITC

Kunstler Script font family
Article • 03/30/2022

Overview
K?nstler Script is an elegant handwriting script font in the formal "copperplate"
engraving style.
Description
File name

Kunstler.ttf

Styles &
Weights

Kunstler Script

Designers

Hans Bohn, 1993, (1957)

Copyright

Typeface: URW Software, Copyright (c) 1995 by URW. Data: Copyright (c) 1995
Microsoft Corporation. All rights reserved.

Font
vendor

URW Type Foundry

Script Tags

N/A

Code
pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples

Kunstler Script

Lao UI font family
Article • 03/30/2022

Overview
Description
File name

Laoui.ttf
Laouib.ttf

Styles & Weights

Lao UI
Lao UI Bold

Designers

N/A

Copyright

© 2018 Microsoft Corporation. All Rights Reserved.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Laoo'
slng:'Laoo', 'Latn'

Code pages

1252 Latin 1

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Product name

Font version

Windows 7

See the Windows 7 page.

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Lao UI

Lao UI Bold

Latha font family
Article • 03/30/2022

Overview
Latha is a font for the Indic script-Tamil. It has been designed for use as a UI font. It is an
OpenType font, based on Unicode and contains TrueType outlines.
Description
File name

Latha.ttf
Lathab.ttf

Styles & Weights

Latha
Latha Bold

Designers

N/A

Copyright

© 2015 Microsoft Corporation. All Rights Reserved.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Taml'
slng:'Taml', 'Latn'

Code pages

1252 Latin 1

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Product name

Font version

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

1.21

Windows Server 2008

5.00

Windows Server 2003

1.21

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Latha

Latha Bold

LCD font family
Article • 03/30/2022

Overview
LCD stands for Liquid Crystal Display, the information display technology used in
products such as digital watches and clocks. An appropriate choice when a futuristic,
high-tech looking font is desired.
Description
File name

Lcd.ttf

Styles &
Weights

LCD

Designers

Alan Birch

Copyright

LCD is trademark of Esselte Letraset Ltd., 1990-1997, which may be registered in
certain jurisdiction. All rights reserved. Portions: Copyright (c) Microsoft Corporation.
All rights reserved.

Font
vendor

ITC Corporation

Script
Tags

N/A

Code
pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
LCD

Leelawadee font family
Article • 03/30/2022

Overview
Leelawadee is a Thai font.
Description
File name

Leelawad.ttf & Leelawdb.ttf

Styles & Weights

Leelawadee
Leelawadee Bold

Designers

N/A

Copyright

© 2016 Microsoft Corporation. All Rights Reserved.

Font vendor

1ASC

Script Tags

dlng:'Thai'
slng:'Thai', 'Latn'

Code pages

1252 Latin 1
874 Thai
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Product name

Font version

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows Server 2008

5.00

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Leelawadee

Leelawadee Bold

Leelawadee UI font family
Article • 03/30/2022

Overview
Leelawadee UI is a Thai font.
Description
File name

Leelawui.ttf
Leelauib.ttf
Leeluisl.ttf

Styles & Weights

Leelawadee UI
Leelawadee UI Bold
Leelawadee UI Semilight

Designers

N/A

Copyright

© 2015 Microsoft Corporation. All Rights Reserved.

Font vendor

MS

Script Tags

dlng:'Thai', 'Laoo', 'Bugi', 'Khmr'
slng:'Thai', 'Laoo', 'Bugi', 'Khmr', 'Latn'

Code pages

1252 Latin 1
874 Thai
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Product name

Font version

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Leelawadee UI

Leelawadee UI Bold

Leelawadee UI Semilight

Levenim MT font family
Article • 03/30/2022

Overview
The Levenim MT typeface was designed in Monotype Studios for Hebrew language. In
addition to Hebrew support the Levenim MT fonts also support Latin.
Description
File name

Lvnm.ttf
Lvnmbd.ttf

Styles &
Weights

Levenim MT
Levenim MT Bold

Designers

Monotype Studios

Copyright

© 2014 The Monotype Corporation. All Rights Reserved.
Hebrew OpenType Layout logic copyright © 2003 & 2007, Ralph Hancock & John
Hudson. This layout logic for Biblical Hebrew is open source software under the MIT
License; see embedded license description for details.

Font
vendor

Agfa Monotype Corporation

Script
Tags

dlng:'Hebr'
slng:'Hebr', 'Latn'

Code
pages

1255 Hebrew
437 US

Fixed

False

pitch

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

1.00

Windows 2000

1.00

Windows Server 2008

5.00

Windows Server 2003

1.00

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Levenim MT

Levenim MT Bold

LilyUPC font family
Article • 03/30/2022

Overview
Lily UPC is a Thai font designed by Unity Progress and offered under license from
Microsoft.
Description
File name

Upcll.ttf
Upclb.ttf
Upclbi.ttf
Upcli.ttf

Styles &
Weights

LilyUPC
LilyUPC Bold
LilyUPC Bold Italic
LilyUPC Italic

Designers

N/A

Copyright

© 1992 Unity Progress. Portions © 2004 The Monotype Corporation. Portions ©
2015 Microsoft Corporation. All Rights Reserved.

Font
vendor

MS

Script

dlng:'Thai'

Tags

slng:'Thai', 'Latn'

Code

1252 Latin 1

pages

874 Thai

Fixed

False

pitch

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

2.20

Windows Server 2008

5.00

Windows Server 2003

2.20

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
LilyUPC

LilyUPC Bold

LilyUPC Bold Italic

LilyUPC Italic

Lucida Blackletter font family
Article • 03/30/2022

Overview
Lucida Blackletter
Characteristics: A modern interpretation of a cursive blackletter style used for printing in
the 15th and 16th centuries. Uses: Use for signs, posters, menus, or any time you want a
font with an antique look. Guidelines Use enough line spacing so that ascenders and
descenders do not collide. Use all capital combinations sparingly; capitals were intended
to be combined with lowercase only. Tightly fitted by design, so do not tighten letter
spacing at text sizes. Spacing can be tightened at large display sizes. Combines well with
other Lucida fonts.
Description
File name

Lblack.ttf

Styles &
Weights

Lucida Blackletter

Designers

Charles Bigelow and Kris Holmes

Copyright

© 1991 Bigelow & Holmes Inc. All Rights Reserved. © 1990-1991 Type Solutions,
Inc. All Rights Reserved.

Font vendor

Bigelow & Holmes Inc.

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples

Lucida Blackletter

Lucida Bright font family
Article • 03/30/2022

Overview
Lucida Bright
Characteristics: Very easy to read. Text looks larger at smaller point sizes. Narrow
typeface so you can fit more words on a line. Uses: Use for manuals, magazines, and
when you need to use space effectively, such as in text columns in newspapers and
newsletters. Guidelines: At small point sizes (8 points or less) add a few units of letter
spacing. In wide columns of text, such as in books, use additional line spacing.
Complementary fonts include Lucida Sans; Lucida Icons for ornament and decoration;
Lucida Calligraphy combines well with Lucida Bright Italic.
Description
File name

Lbrite.ttf
Lbrited.ttf
Lbritedi.ttf
Lbritei.ttf
Lbrite.ttf

Styles &
Weights

Lucida Bright
Lucida Bright Demibold
Lucida Bright Demibold Italic
Lucida Bright Italic
Lucida Bright Regular

Designers

Charles Bigelow and Kris Holmes

Copyright

© 1991 Bigelow & Holmes Inc. Pat. Des. 289,421. All Rights Reserved. © 1990-1991
Type Solutions, Inc. All Rights Reserved.

Font
vendor

Bigelow & Holmes Inc.

Script
Tags

N/A

Code
pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Lucida Bright

Lucida Bright Demibold

Lucida Bright Demibold Italic

Lucida Bright Italic

Lucida Bright Regular

Lucida Bright Math font family
Article • 03/30/2022

Overview
Lucida Bright Math
Characteristics: Includes math symbols in a variety of forms, spread across three fonts.
These fonts contain a wide variety of mathematical symbols, including all of those
recommended for mathematical publishing (except for the Cyrillic alphabet). This is also
a superset of the character set used by the TeX math composition software. Uses: Use to
create math equations or whenever specialized symbols are required. Guidelines:
Combines well with Lucida Calligraphy for mathematical script characters, and Lucida
Blackletter for mathematical blackletter/fraktur characters. Many of the arrows and
geometric shapes in Lucida Arrows and Stars can also be used in mathematical setting.
Lucida Bright Math fonts also work well with the other Lucida fonts (such as Lucida
Bright), as well as with most popular text faces, such as Times New Roman, when
mathematical composition is needed.
Description
File name

Lmath2.ttf
Lmath3.ttf
Lmath1.ttf

Styles &

Lucida Bright Math Extension

Weights

Lucida Bright Math Italic
Lucida Bright Math Symbol

Designers

Charles Bigelow and Kris Holmes

Copyright

Copyright © 1991 by Bigelow & Holmes Inc. All rights reserved.© 1990-1991 Type
Solutions, Inc. All Rights Reserved.

Font
vendor

Bigelow & Holmes Inc.

Script Tags

N/A

Code

869 IBM Greek

pages

437 US

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Lucida Bright Math Extension

Lucida Bright Math Italic

Lucida Bright Math Symbol

Lucida Calligraphy font family
Article • 03/30/2022

Overview
Lucida Calligraphy
Characteristics: Script font developed from Chancery cursive. Very easy to read. Uses:
Announcements, invitations, greetings, menus, placards, information labels, posters,
heads, titles, text paragraphs, and personal notes and memos. Guidelines: Looks best in
text with 30% ? 50% extra line spacing. For example, when using 12 point text, use 18
points of line spacing. Use capitals with Lucida Bright Italic. Use plain Lucida Bright
capitals between initial and final Calligraphy capitals. Lucida Icons ampersands and
ornaments combine well with Lucida Calligraphy.
Description
File name

Lcallig.ttf

Styles &
Weights

Lucida Calligraphy Italic

Designers

Charles Bigelow and Kris Holmes

Copyright

© 1991 Bigelow & Holmes. All Rights Reserved. © 1990-1991 Type Solutions, Inc.
All Rights Reserved.

Font vendor

Bigelow & Holmes Inc.

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font

This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Lucida Calligraphy Italic

Lucida Console font family
Article • 03/30/2022

Overview
Lucida Console
Characteristics: Large x-height, making it readable at all sizes.
Uses: Wide range of uses including directories, tables, forms, memos, telefaxes, manuals,
heads, titles, posters, and displays.
Guidelines: At larger sizes (14 points or more), subtracting a few units of letter spacing
gives a tighter look. When using all capitals, you can use small amounts of additional
letter spacing. At larger sizes, space capitals more tightly. Complementary fonts include
Lucida Bright, Lucida Arrows, and Lucida Stars. Lucida Fax at smaller sizes and lower
resolutions. The ampersands, interrobangs, and circled Lucida Sans numerals in Lucida
Icons combine well.
Description
File name

Lucon.ttf

Styles & Weights

Lucida Console

Designers

N/A

Copyright

Copyright © 1993 Bigelow & Holmes Inc. All rights reserved.

Font vendor

Bigelow & Holmes

Script Tags

dlng:'Cyrl', 'Grek', 'Latn'
slng:'Cyrl', 'Grek', 'Latn'

Description
Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
869 IBM Greek
866 MS-DOS Russian
865 MS-DOS Nordic
863 MS-DOS Canadian French
861 MS-DOS Icelandic
860 MS-DOS Portuguese
857 IBM Turkish
855 IBM Cyrillic; primarily Russian
852 Latin 2
737 Greek; former 437 G
850 WE/Latin 1
437 US

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

1.65

Windows 2000

1.60

Product name

Font version

Windows 98

0.91

Windows Server 2008

5.00

Windows Server 2003

1.60

Style & weight examples
Lucida Console

Lucida Fax font family
Article • 03/30/2022

Overview
Lucida Fax
Characteristics: A slab-serif font designed for telefaxing. A large x-height and generous
spacing between letters makes it easy to read at small sizes. Also easy for children to
read. Uses: Educational printing and publishing. Use with printing methods that tend to
degrade quality such as newspapers, packaging, and labeling. Use when rendering fonts
at low resolution, or small sizes such as for dot-matrix printing and screen displays. Ideal
for creating documents (from simple memos to complex newsletters) for telefaxing.
Complementary fonts include Lucida Sans, Icons, Stars, and Arrows. Use Lucida Fax as a
small size version of Lucida Bright. For example, if you are using 10 point Lucida Bright,
try using 6 point Lucida Fax for notes and footnotes.
Description
File name

Lfaxd.ttf
Lfaxdi.ttf
Lfaxi.ttf
Lfax.ttf

Styles &
Weights

Lucida Fax Demibold
Lucida Fax Demibold Italic
Lucida Fax Italic
Lucida Fax Regular

Designers

Charles Bigelow and Kris Holmes

Copyright

© 1991 Bigelow & Holmes Inc. Pat. 289,422. All Rights Reserved. © 1990-1991 Type
Solutions, Inc. All Rights Reserved.

Font
vendor

Bigelow & Holmes Inc.

Script Tags

N/A

Code
pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Lucida Fax Demibold

Lucida Fax Demibold Italic

Lucida Fax Italic

Lucida Fax Regular

Lucida Handwriting font family
Article • 03/30/2022

Overview
Lucida Handwriting
Characteristics: A modern interpretation of a cursive blackletter style used for printing in
the 15th and 16th centuries. Uses: Use for signs, posters, menus, or any time you want a
font with an antique look. Guidelines Use enough line spacing so that ascenders and
descenders do not collide. Use all capital combinations sparingly; capitals were intended
to be combined with lowercase only. Tightly fitted by design, so do not tighten letter
spacing at text sizes. Spacing can be tightened at large display sizes. Combines well with
other Lucida fonts.
Description
File name

Lhandw.ttf

Styles &
Weights

Lucida Handwriting Italic

Designers

Charles Bigelow and Kris Holmes

Copyright

© 1991 Bigelow & Holmes Inc. All Rights Reserved. Pat. Pend. © 1990-1991 Type
Solutions, Inc. All Rights Reserved.

Font
vendor

Bigelow & Holmes Inc.

Script Tags

N/A

Code
pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Lucida Handwriting Italic

Lucida Sans font family
Article • 03/30/2022

Overview
Lucida Sans
Characteristics: Large x-height, making it readable at all sizes. Uses: Wide range of uses
including directories, tables, forms, memos, telefaxes, manuals, heads, titles, posters, and
displays. Guidelines: At larger sizes (14 points or more), subtracting a few units of letter
spacing gives a tighter look. When using all capitals, you can use small amounts of
additional letter spacing. At larger sizes, space capitals more tightly. Complementary
fonts include Lucida Bright, Lucida Arrows, and Lucida Stars. Lucida Fax at smaller sizes
and lower resolutions. The ampersands, interrobangs, and circled Lucida Sans numerals
in Lucida Icons combine well.
Description
File name

Lsansdi.ttf
Lsansd.ttf
Lsansi.ttf
Lsans.ttf

Styles &
Weights

Lucida Sans Demibold Italic
Lucida Sans Demibold Roman
Lucida Sans Italic
Lucida Sans Regular

Designers

Charles Bigelow and Kris Holmes

Copyright

© 1991 by Bigelow & Holmes Inc. All Rights Reserved. © 1990-1991 Type
Solutions, Inc. All Rights Reserved.

Font vendor

Bigelow & Holmes Inc.

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info

Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Lucida Sans Demibold Italic

Lucida Sans Demibold Roman

Lucida Sans Italic

Lucida Sans Regular

Lucida Sans Typewriter font family
Article • 03/30/2022

Overview
Lucida Sans Typewriter
Characteristics: Designed as a typeface for typewriters. Monospaced. Economical in
typesetting: At 10 points, it is equivalent to a 12-pitch typewriter font. Uses Memos,
telefaxes, commercial forms, invoices, packing lists, source-code listings, line-printer
emulations, terminal emulations, and any document in which you want the text to look
as if it were typed on a typewriter. Guidelines: In lines greater than 79 characters, add
extra line spacing of 20% of the font size. For example, when using 10 point text, add 2
points of line spacing. Complementary Fonts include Lucida Bright and Lucida Fax.
Lucida Arrows has eight arrowheads designed for use with the box-draw characters in
Lucida Sans Typewriter for constructing a variety of arrows.
Description
File name

Ltypeb.ttf
Ltypebo.ttf
Ltypeo.ttf
Ltype.ttf

Styles &
Weights

Lucida Sans Typewriter Bold
Lucida Sans Typewriter Bold Oblique
Lucida Sans Typewriter Oblique
Lucida Sans Typewriter Regular

Designers

Charles Bigelow and Kris Holmes

Copyright

© 1991 Bigelow & Holmes Inc. All Rights Reserved. © 1990-1991 Type Solutions,
Inc. All Rights Reserved.

Font vendor

Bigelow & Holmes Inc.

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info

Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Lucida Sans Typewriter Bold

Lucida Sans Typewriter Bold Oblique

Lucida Sans Typewriter Oblique

Lucida Sans Typewriter Regular

Lucida Sans Unicode font family
Article • 03/30/2022

Overview
Lucida Sans Unicode
Characteristics: Large x-height, making it readable at all sizes.
Uses: Wide range of uses including directories, tables, forms, memos, telefaxes, manuals,
heads, titles, posters, and displays.
Guidelines: At larger sizes (14 points or more), subtracting a few units of letter spacing
gives a tighter look. When using all capitals, you can use small amounts of additional
letter spacing. At larger sizes, space capitals more tightly. Complementary fonts include
Lucida Bright, Lucida Arrows, and Lucida Stars. Lucida Fax at smaller sizes and lower
resolutions. The ampersands, interrobangs, and circled Lucida Sans numerals in Lucida
Icons combine well.
Description
File name

L_10646.ttf

Styles &
Weights

Lucida Sans Unicode

Designers

n/a

Copyright

Copyright © 1993 Bigelow & Holmes Inc. All rights reserved. Pat. Des. 289,420.
Pats. Pend.

Font vendor

Bigelow & Holmes

Script Tags

dlng:'Cyrl', 'Grek', 'Hebr', 'Latn'
slng:'Cyrl', 'Grek', 'Hebr', 'Latn'

Description
Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1255 Hebrew
1257 Windows Baltic
Mac Roman Macintosh Character Set (US Roman)
869 IBM Greek
866 MS-DOS Russian
865 MS-DOS Nordic
863 MS-DOS Canadian French
862 Hebrew
861 MS-DOS Icelandic
860 MS-DOS Portuguese
857 IBM Turkish
855 IBM Cyrillic; primarily Russian
852 Latin 2
737 Greek; former 437 G
850 WE/Latin 1
437 US

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Product name

Font version

Windows XP

2.00

Windows 2000

2.00

Windows 98

0.98

Windows Server 2008

5.00

Windows Server 2003

2.00

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Lucida Sans Unicode

Magneto font family
Article • 03/30/2022

Overview
Leslie Cabarga turned to the geometric, streamlined scripts prepared by American
industrial designers for the inspiration of this series. In its three variation of letter
spacing, Magneto recalls the chrome-strip lettering laid along the rounded shapes of
refrigerator doors and automobile trunks in the forties and fifties; FB 1995.
Description
File name

Magnetob.ttf

Styles &
Weights

Magneto Bold

Designers

Leslie Cabarga

Copyright

(c) Copyright 1997, 1998 The Font Bureau, Inc. and Leslie Cabarga. All rights
reserved.

Font vendor

The Font Bureau, Inc.

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Magneto Bold

Maiandra GD font family
Article • 03/30/2022

Overview
Maiandra GD is a humanistic sans font inspired by Oswald Bruce Cooper's hand lettering
for an advertisement in 1909, which was based by Greek epigraphy.
Description
File name

Maian.ttf
Maiandb.ttf
Maiandit.ttf

Styles & Weights

Maiandra GD
Maiandra GD Demi Bold
Maiandra GD Italic

Designers

Dennis Pasternak

Copyright

(c) Copyright 1994-1997 Galapagos Design Group, Inc. All rights reserved.

Font vendor

N/A

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Maiandra GD

Maiandra GD Demi Bold

Maiandra GD Italic

Malgun Gothic font family
Article • 03/30/2022

Overview
Malgun Gothic is a Korean font developed by taking advantage of ClearType
technology, and it provides excellent reading experience particularly onscreen. Its
elements are created based on the typeface of Hunminjeongeum, and streamlined with
modern form of characters as well as upright and well-regulated strokes. The font is very
legible at small sizes with its moderate open counters, and its even inter-character
spacing and visual center line maximize the readability.
Description
File name

Malgunsl.ttf
Malgun.ttf
Malgunbd.ttf

Styles & Weights

Malgun Gothic Semilight
Malgun Gothic
Malgun Gothic Bold

Designers

Kyoung-bae Lee; Daekwon Kim

Copyright

© 2016 Microsoft Corporation. All Rights Reserved.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Hang', 'Hani', 'Kore'
slng:'Hang', 'Hani', 'Hira', 'Jpan', 'Kana', 'Kore', 'Latn'

Code pages

1252 Latin 1
1251 Cyrillic
1253 Greek
1257 Windows Baltic
949 Korean Wansung

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows Server 2008

5.00

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples

Change list:
Windows 10 version 1507 released on July 29, 2015
The Semilight weight was added to the Malgun Gothic font family

Windows Vista
Malgun Gothic was introduced. Initially it was available in two styles.
Malgun Gothic
Malgun Gothic Bold

Mangal font family
Article • 03/30/2022

Overview
Mangal is an OpenType font for the Indic script - Devanagari. It is based on Unicode,
contains TrueType outlines and has been designed for use as a UI font.
Description
Files

Mangal.ttf
MangalB.ttf

Styles & Weights

Mangal
Mangal Bold

Designers

Raghunath Joshi

Copyright

© 2015 Microsoft Corporation. All Rights Reserved.

Font vendor

Microsoft Corporation

Script Tags

dlng: 'Deva'
slng: 'Deva', 'Latn'

Code pages

1252 Latin 1

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Product name

Font version

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

1.20

Windows Server 2008

5.00

Windows Server 2003

1.20

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Mangal

Mangal Bold

Map Symbols font family
Article • 03/30/2022

Overview
A symbol font for use with map applications.
Description
File name

Mapsym.ttf

Styles & Weights

Map Symbols

Designers

N/A

Copyright

Copyright © 1995, MapInfo Corporation, Troy, New York. All Rights Reserved

Font vendor

N/A

Script Tags

N/A

Code pages

1252 Latin 1

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Map Symbols

Marlett font family
Article • 03/30/2022

Overview
Marlett is a TrueType font used by Microsoft Windows to draw scalable icons in menus.
Users can select these icons to be larger or smaller than the default size. Another use of
Marlett is in radio buttons, where 6 characters from Marlett are used to make the full
radio button. Marlett was designed and produced by the Windows 95 User Interface and
Microsoft Typography teams.
Description
File name

Marlett.ttf

Styles & Weights

Marlett

Designers

N/A

Copyright

© 2006 Microsoft Corporation. All Rights Reserved.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Zsym'
slng:'Zsym'

Code pages

Symbol Symbol Character Set

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Product name

Font version

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

1.01

Windows 2000

1.06

Windows 98

1.00

Windows 95

1.00

Windows Server 2008

5.00

Windows Server 2003

1.01

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Marlett

Matisse ITC font family
Article • 03/30/2022

Overview
ITC Matisse? was born out of an editorial layout that Gregory Gray was designing for
Madame Figaro, a supplement to the Figaro newspaper published in Paris. While
working on a special issue featuring the work of Matisse, Gray fashioned his typeface
out of paper with an X-Acto knife, and then scanned these cut-outs into a computer.
While Gray does all the calligraphy for captions in Madame Figaro, this was his first full
typeface design. Like the Matisse cut-outs on which this typeface is based, ITC Matisse
seems to dance along the page. Gray included many alternate characters for letters that
lend themselves to several versions. The spirit of this type design also comes in part
from Gray's passion for African art, with its extreme contrasts from flat areas to
protruding surfaces. Gray envisions ITC Matisse for offbeat display uses, as initial caps,
or for music-related designs projects like CD covers. ITC Matisse was released in 1996.
Description
File name

Matisse_.ttf

Styles &
Weights

Matisse ITC

Designers

Gregory Grey

Copyright

Copyright (c) International Typeface Corporation 1996. Portions Copyright (c)
Microsoft Corporation 1996. All rights reserved.

Font

ITC

vendor
Script

N/A

Tags
Code

1252 Latin 1

pages

Mac Roman Macintosh Character Set (US Roman)

Fixed

False

pitch

Licensing and redistribution info
Font redistribution FAQ for Windows

License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Matisse ITC

Matura MT Script Capitals font family
Article • 03/30/2022

Overview
Designed around 1938, this calligraphic sans serif font contains an occasional serif. This
feature imparts some distinctiveness to this upright, somewhat angular, and heavy font.
Description
File name

Maturasc.ttf

Styles & Weights

Matura MT Script Capitals

Designers

Imre Reiner

Copyright

Copyright © The Monotype Corporation plc. 1992. All Rights Reserved.

Font vendor

Agfa Monotype Corporation

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Matura MT Script Capitals

McZee font family
Article • 03/30/2022

Overview
The McZee is a funny font that shows characters hanging onto every character.
Description
File name

Mczee.ttf

Styles &
Weights

McZee

Designers

N/A

Copyright

Typeface data copyright (C) 1994 Monotype Typography, Ltd. All rights reserved.
McZee copyright (C) 1993 Microsoft Corporation. All rights reserved.

Font
vendor

N/A

Script
Tags

N/A

Code
pages

869 IBM Greek
437 US

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
McZee

Mead Bold font family
Article • 03/30/2022

Overview
Mead, Steve Matteson. Steve Matteson, when not working at Monotype's Palo Alto,
California facility, is always working on his own typeface design projects. Mead is a
casual typeface with a controlled spontaneity that still offers legibility needed for long
documents.
Description
File name

Meadbold.ttf

Styles & Weights

Mead Bold

Designers

Steve Matteson

Copyright

Data Copyright (C) Monotype Corporation 1993.

Font vendor

Agfa Monotype Corporation

Script Tags

N/A

Code pages

869 IBM Greek
437 US

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Mead Bold

Meiryo font family
08/08/2025

Overview
Meiryo is a very versatile modern sans serif type designed to give an exceptionally clean
appearance on screen, as well as in print. It is optimized for on-screen reading. The letterforms
are generously open and well-proportioned; legible and clear at smaller sizes, and dynamic at
larger display sizes. The beauty of this face is that it sets text lines in Japanese with Roman
seamlessly and harmoniously. The balanced inter-letter spacing enhances horizontal alignment,
facilitating smooth reading flow. Meiryo has a very large character set with Japanese and
Roman combined, fully scalable outline technology, making it extremely functional for all
aspects of communication and publishing. It is a robust legible typeface yet compact enough
to enable tight inter-line spacing which is good for space economy.
ﾉ

Item

Description

File name

Meiryo.ttc
Meiryob.ttc

Styles & Weights

Meiryo
Meiryo Bold
Meiryo Bold Italic
Meiryo Italic
Meiryo UI
Meiryo UI Bold
Meiryo UI Italic
Meiryo UI Bold Italic

Designers

C&G Inc.; Eiichi Kono; Matthew Carter

Copyright

© 2019 Microsoft Corporation. All Rights Reserved.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Hani', 'Hira', 'Hrkt', 'Jpan', 'Kana'
slng:'Cyrl', 'Grek', 'Hani', 'Hira', 'Hrkt', 'Jpan', 'Kana', 'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic

Expand table

Item

Description
932 JIS/Japan
Mac Roman Macintosh Character Set (US Roman)
OEM OEM Character Set
869 IBM Greek
866 MS-DOS Russian
865 MS-DOS Nordic
863 MS-DOS Canadian French
861 MS-DOS Icelandic
860 MS-DOS Portuguese
857 IBM Turkish
855 IBM Cyrillic; primarily Russian
852 Latin 2
775 MS-DOS Baltic
737 Greek; former 437 G
850 WE/Latin 1
437 US

Fixed pitch

False

Download

N/A – Exclusively included with Microsoft products and services where applicable.

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
ﾉ

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Expand table

Product name

Font version

Windows Server 2008

5.00

This typeface is also available within Office applications. For more information visit this page.

Style & weight examples
Meiryo & Meiryo UI

Mercurius Script MT Bold font family
Article • 03/30/2022

Overview
Mercurius Bold Script, Imre Reiner 1957. This alphabet was drawn by Imre Reiner with a
pen cut from bamboo cane. It is a dramatic script with an angular and irregular design.
The informal nature of this typeface makes it suitable for display work, especially where
one might wish to suggest the intervention of an artist's hand, mind or eye.
Description
File name

Merscrb.ttf

Styles & Weights

Mercurius Script MT Bold

Designers

Imr? Reiner

Copyright

Copyright (C) 1992 Monotype Corporation plc. All rights reserved.

Font vendor

Agfa Monotype Corporation

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Mercurius Script MT Bold

Microsoft GothicNeo font family
Article • 06/16/2022

Overview
Description
File name

msgothicneo.ttf
msgothicneobold.ttf
MSGothicNeoLight.ttf

Styles &
Weights

Microsoft GothicNeo
Microsoft GothicNeo Bold
Microsoft GothicNeo Light

Copyright

Copyright © 2018 Microsoft Company. All rights reserved. Font designed by
Sandoll Communications Inc.

Designers

N/A

Font vendor

Sandoll Corporation

Script Tags

dlng:'Hang', 'Hani', 'Kore'
slng:'Cyrl', 'Grek', 'Hang', 'Hani', 'Jpan', 'Kana', 'Kore'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1254 Turkish
1257 Windows Baltic

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is also available within Office applications. For more information visit this
page.

Microsoft Himalaya font family
Article • 03/30/2022

Overview
Microsoft Himalaya is a Tibetan font.
Description
File name

Himalaya.ttf

Styles &
Weights

Microsoft Himalaya

Designers

Founder, Beijing China

Copyright

© 2018 Microsoft Corporation. All Rights Reserved. Portions © 2015 Beijing Founder
Electronics Co. Ltd. All Rights Reserved.

Font
vendor
Script
Tags

dlng:'Tibt'
slng:'Tibt', 'Latn'

Code
pages

1252 Latin 1

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Product name

Font version

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows Server 2008

5.00

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Microsoft Himalaya

Microsoft JhengHei & Microsoft
JhengHei UI font family
Article • 09/28/2023

Overview
Microsoft JhengHei & Microsoft JhengHei UI is distributed with Windows Vista as
default interface font. Designed by China Type Design Limited.
Description
File name

Msjhl.ttc
Msjh.ttc
Msjhbd.ttc

Styles & Weights

Microsoft JhengHei Light
Microsoft JhengHei
Microsoft JhengHei Bold
Microsoft JhengHei UI Light
Microsoft JhengHei UI
Microsoft JhengHei UI Bold

Designers

Monotype Imaging Inc.

Copyright

©2016 Microsoft Corporation. All rights reserved.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Bopo', 'Hant'
slng:'Bopo', 'Grek', 'Hani', 'Hant', 'Hira', 'Kana', 'Latn'

Code pages

1252 Latin 1
1253 Greek
950 Chinese: Traditional chars--Taiwan and Hong Kong SAR

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows Server 2008

5.00

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples

Microsoft New Tai Lue font family
Article • 03/30/2022

Overview
The New Tai Lue portions of this font were created by the design teams of Ascender and
DynaComware.
Description
File name

Ntailu.ttf
Ntailub.ttf

Styles &
Weights

Microsoft New Tai Lue
Microsoft New Tai Lue Bold

Designers

N/A

Copyright

© 2018 Microsoft Corporation. All Rights Reserved. Portions © 2009 DynaComware
Corp. All Rights Reserved. Portions © 2008 Ascender Corp. All Rights Reserved.

Font
vendor

Microsoft Corp.

Script
Tags

dlng:'Talu'
slng:'Talu', 'Latn'

Code
pages

1252 Latin 1

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Microsoft New Tai Lue

Microsoft New Tai Lue Bold

Microsoft PhagsPa font family
Article • 03/30/2022

Overview
The PhagsPa portions of this font were created by the design teams of Ascender and
DynaComware.
Description
File name

PhagsPa.ttf
PhagsPaB.ttf

Styles &
Weights

Microsoft PhagsPa
Microsoft PhagsPa Bold

Designers

N/A

Copyright

© 2018 Microsoft Corporation. All Rights Reserved. Portions © 2009 DynaComware
Corp. All Rights Reserved. Portions © 2008 Ascender Corp. All Rights Reserved.

Font
vendor

Microsoft Corp.

Script
Tags

dlng:'Phag'
slng:'Phag', 'Latn'

Code
pages

1252 Latin 1

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Microsoft PhagsPa

Microsoft PhagsPa Bold

Microsoft Sans Serif font family
Article • 03/30/2022

Overview
Microsoft Sans Serif font is a very legible User Interface (UI) font. It was designed to be
metrically compatible with the MS Sans bitmap font that shipped in early versions of
Microsoft Windows.
Description
File name

Micross.ttf

Styles & Weights

Microsoft Sans Serif

Designers

N/A

Copyright

© 2012 Microsoft Corporation. All Rights Reserved.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Armn', 'Cyrl', 'Geor', 'Grek', 'Latn'
slng:'Arab', 'Armn', 'Cyrl', 'Geor', 'Grek', 'Hebr', 'Latn', 'Thai'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1255 Hebrew
1256 Arabic
1257 Windows Baltic
1258 Vietnamese
874 Thai
Mac Roman Macintosh Character Set (US Roman)
862 Hebrew
860 MS-DOS Portuguese
437 US

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows

License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

1.33

Windows 2000

0.93

Windows Server 2008

5.00

Windows Server 2003

1.33

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples

Microsoft Tai Le font family
Article • 03/30/2022

Overview
The Tai Le portions of this font were created by the design teams of Ascender and
DynaComware.
Description
File name

Taile.ttf
Taileb.ttf

Styles &
Weights

Microsoft Tai Le
Microsoft Tai Le Bold

Designers

N/A

Copyright

© 2018 Microsoft Corporation. All Rights Reserved. Portions © 2009 DynaComware
Corp. All Rights Reserved. Portions © 2008 Ascender Corp. All Rights Reserved.

Font
vendor

Microsoft Corp.

Script
Tags

dlng:'Tale'
slng:'Tale', 'Latn'

Code
pages

1252 Latin 1

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Microsoft Tai Le

Microsoft Tai Le Bold

Microsoft Uighur font family
Article • 03/30/2022

Overview
Microsoft Uighur was designed by Mamoun Sakkal exclusively for Microsoft as a text
typeface for the Uighur language. It follows the Persian type examples as done
traditionally with Uighur fonts. It is enhanced for legibility in small sizes.
Description
File name

Msuighur.ttf
MSUighub.ttf

Styles & Weights

Microsoft Uighur
Microsoft Uighur Bold

Designers

Mamoun Sakkal

Copyright

© 2019 Microsoft Corporation. All Rights Reserved.

Font vendor

SKKL

Script Tags

dlng:'Arab', 'ug-Arab'
slng:'Arab', 'Latn', 'ug-Arab'

Code pages

1252 Latin 1
1256 Arabic

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Product name

Font version

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows Server 2008

5.00

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Microsoft Uighur

Microsoft Uighur Bold

Microsoft YaHei & Microsoft YaHei UI
font family
Article • 03/30/2022

Overview
Microsoft YaHei: A Simplified Chinese font developed by taking advantage of ClearType
technology, and it provides excellent reading experience particularly onscreen. The font
is very legible at small sizes.
Microsoft YaHei UI: The font glyphs are certified compliant with China standard
GB18030-2000 with the font name Founder Lan Ting Hei. Microsoft Licensed the font
glyph from Beijing Founder Electronics Co. Ltd. GB18030-2000
Description
File name

Msyhl.ttc
Msyh.ttc
Msyhbd.ttc

Styles &
Weights

Microsoft YaHei Light
Microsoft YaHei
Microsoft YaHei Bold
Microsoft YaHei UI Light
Microsoft YaHei UI
Microsoft YaHei UI Bold

Designers

Founder

Copyright

© 2017 Microsoft Corporation. All Rights Reserved. Portions © 2017 Beijing Founder
Electronics Co. Ltd. All Rights Reserved.

Font
vendor

Microsoft Corp.

Script
Tags

dlng:'Hans'
slng:'Hans'

Code
pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
936 Chinese: Simplified chars--PRC and Singapore

Description
Fixed

False

pitch

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows Server 2008

5.00

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples

Microsoft Yi Baiti font family
Article • 03/30/2022

Overview
The Yi language is a member of the Sino-Tibetan langauge family and is an official
language of the PRC. The Yi people live mostly in southwestern China, but others live in
Myanmar, Laos and Vietnam. Yi follows the writing rules for Han ideographs. Characters
are generally written left to right or occasionally top to bottom.
Description
File name

Msyi.ttf

Designers

Beijing Founder Electronic CO. LTD.

Styles &
Weights

Microsoft Yi Baiti

Copyright

© 2018 Microsoft Corporation. All Rights Reserved. Portions © 2008 Beijing Founder
Electronics Co. Ltd. All Rights Reserved.

Font
vendor

MS

Script
Tags

dlng:'Yiii'
slng:'Yiii', 'Latn'

Code
pages

1252 Latin 1

Fixed

False

pitch

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows Server 2008

5.00

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Microsoft Yi Baiti

MingLiU font family
Article • 03/30/2022

Overview
MingLiu font is a Traditional Chinese font in a mincho (serif) stroke style.
Description
File name

Mingliu.ttc
Mingliub.ttc

Styles & Weights

MingLiU
PMingLiU
MingLiU_HKSCS
MingLiU-ExtB
PMingLiU-ExtB
MingLiU_HKSCS-ExtB

Designers

N/A

Copyright

© DynaComware Corp. 2015

Font vendor

DynaLab

Script Tags

dlng:'Bopo', 'Hant'
slng:'Bopo', 'Cyrl', 'Grek', 'Hani', 'Hant', 'Hira', 'Kana', 'Latn'

Code pages

1252 Latin 1
950 Chinese: Traditional chars--Taiwan and Hong Kong SAR

Fixed pitch

True

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Product name

Font version

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

3.21

Windows 2000

3.00

Windows Server 2008

5.00

Windows Server 2003

3.21

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples

Minion Web font family
Article • 03/30/2022

Overview
Minion is an Adobe Originals typeface family designed by Robert Slimbach. Minion is
inspired by classical, old style typefaces of the late Renaissance, a period of elegant,
beautiful, and highly readable type designs. Minion Web has been optimized for
onscreen use. Adobe Minion Web isn't distributed from the Windows 98 update site or
the Internet Explorer 5 product update site, and was never included on our core fonts
for the Web download page. However if you're not able to download it from the
Internet Explorer 4.0 add-ons page, you can also get it directly from Adobe as part of
their WebType package.

Adobe Minion Web version history
Version 1.00 - Adobe Minion Web is supplied as part of the Internet Explorer 4
supplemental font pack add-on.
Description
File name

Minionw.ttf

Styles & Weights

Minion Web

Designers

Robert Slimbach

Copyright

Copyright 1991-1997, Adobe Systems, Incorporated. All Rights Reserved.

Font vendor

Adobe

Script Tags

N/A

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1254 Turkish
1257 Windows Baltic
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info

Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Minion Web

Miriam font family
Article • 03/30/2022

Overview
Miriam is a Hebrew font.
Description
File name

Mriam.ttf
Mriamc.ttf
Mriamtr.ttf

Styles & Weights

Miriam
Miriam Fixed
Miriam Transparent

Designers

N/A

Copyright

© 1991-1993 Kivun Computers Ltd. Portions © The Monotype Corporation

Font vendor

Glyph Systems

Script Tags

dlng:'Hebr'
slng:'Hebr', 'Latn'

Code pages

1255 Hebrew
437 US

Fixed pitch

True

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Product name

Font version

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

1.10

Windows 2000

1.00

Windows Server 2008

5.00

Windows Server 2003

1.10

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Miriam

Miriam Fixed

Miriam Transparent

Miriam Fixed font family
Article • 03/30/2022

Overview
Description
File name

Mriamc.ttf

Styles & Weights

Miriam Fixed

Designers

N/A

Copyright

© 1991-1993 Kivun Computers Ltd. Portions © The Monotype Corporation

Font vendor

N/A

Script Tags

N/A

Code pages

1255 Hebrew
437 US

Fixed pitch

True

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Miriam Fixed

Mistral font family
Article • 03/30/2022

Overview
Sitting on the edge of the Mediterranean during the 1950s, was the Fonderie Olive.
Supplying it with type designs, from a studio filled with devoted assistants, was Roger
Excoffon. The assistants were right to be devoted; the creative space he filled remains
empty to this day. But among the many faces that came out of Excoffon's studio were
the Antique Olive family and Mistral, which probably will never be successfully imitated.
What better testimonial can a designer have? Mistral was a tour de force in metal type
making, because this apparently casual script joined flawlessly (although the ragged
outline helps to disguise the joins). Now it looks just as good in electronic form.
Description
File name

Mistral.ttf

Styles &
Weights

Mistral

Designers

Roger Excoffon, 1953

Copyright

© Copyright by URW, 1992. Portions © 1992 Microsoft Corp. All rights
reserved.

Font vendor

URW Type Foundry

Script Tags

N/A

Description
Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
Mac Roman Macintosh Character Set (US Roman)
869 IBM Greek
866 MS-DOS Russian
865 MS-DOS Nordic
863 MS-DOS Canadian French
861 MS-DOS Icelandic
860 MS-DOS Portuguese
857 IBM Turkish
855 IBM Cyrillic; primarily Russian
852 Latin 2
775 MS-DOS Baltic
737 Greek; former 437 G
850 WE/Latin 1
437 US

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Mistral

Modern Love font family
Article • 03/30/2022

Overview
Breaking from our catalog of typefaces to create a new handwritten font family, Modern
Love was born out of our desire to see what would happen if we took a step back from
the norm. We weren’t looking for the perfection of the many calligraphy techniques, but
more of a natural way of writing with the same tools. Our escapist experiment into
casual lettering culminated into 4 fonts: Modern Love Regular, Grunge, Rough and Caps.
Modern Love Regular is a hand-painted script, each glyph individually designed with a
pointed brush and walnut ink. The aim was to create an effortless hand-drawn feel while
keeping the contrast high density.
Playful, yet polished, this font works very well when accentuated with the family’s two
distinctive styles: Modern Love Grunge, simulating a washed-out effect, perfect to add a
vintage look to your projects; and Modern Love Rough, with its crunchy borders, makes
letters visibly rough-around-the edges and gives large letters an unmistakable pop. All
three fonts include a hand-painted set of ornaments, swashes and alternates to
limitlessly customize and decorate your texts, accessible through OpenType features.
Modern Love Caps is the fourth font, a handwritten Sans Serif that ties the family
together with its simplicity and readability. Designed with a pointed nib and Indian ink,
this font boasts a different style that perfectly complements Modern Love Regular,
Grunge and Rough.
The result is a fresh font family perfect to create headlines, posters, DIY hand-lettered
artwork, books, holiday cards, wrapping paper, invitations, T-shirts, labels, packaging for
cosmetics, fashion supplies, food products, artisanal goods, and an endless array of
options for your projects. Modern Love…when brush meets passion. – fonts.com
In 2019 we reviewed the set of fonts provided with Office identifying stylistic gaps. The
result of that effort was the addition of over a hundred new fonts, including classics like
Avenir Next LT Pro and Walbaum along with contemporary designs like The Hand,
Sagona and Modern Love. These new fonts are available in most Office applications and
have been used in a range of new templates.
Description

Description
File name

modernlove-regular.ttf
modernlove-caps.ttf
modernlove-grunge.ttf

Styles & Weights

Modern Love
Modern Love Caps
Modern Love Grunge

Copyright

Copyright © 2015 by Paco González & Giuseppe Salerno. All rights reserved.

Designers

Paco González
Giuseppe Salerno

Font vendor

Resistenza

Script Tags

dlng:'Latn'
slng:'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1254 Turkish
1257 Windows Baltic

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is also available within Office applications. For more information visit this
page.

Modern No. 20 font family
Article • 03/30/2022

Overview
Modern No. 20 is the king of titling faces, even though in its original form it could also
be used at less than 10 points. What annual report, what title page doesn't look better
with this used? It has class.
Description
File name

Mod20.ttf

Styles &
Weights

Modern No. 20

Designers

N/A

Copyright

Data by Anna Wheeler and Type Solutions, Inc. © 1993. Microsoft Corporation.
All rights reserved.

Font vendor

N/A

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples

Modern No. 20

Mongolian Baiti font family
Article • 03/30/2022

Overview
Mongolian Baiti is a Mongolian font.
Description
File name

Monbaiti.ttf

Styles &
Weights

Mongolian Baiti

Designers

Founder, Beijing China

Copyright

© 2018 Microsoft Corporation. All Rights Reserved. Portions © 2015 Beijing Founder
Electronics Co. Ltd. All Rights Reserved.

Font
vendor

MS

Script
Tags

dlng:'Mong'
slng:'Mong', 'Latn'

Code
pages

1252 Latin 1

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Product name

Font version

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows Server 2008

5.00

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Mongolian Baiti

Monotype.com font family
Article • 03/30/2022

Overview
Monotype.com is a special version of Monotype's Andale Mono, a highly legible
monospaced font.

Andale (formerly Monotype.com) version history
Version 1.25 - Monotype.com renamed Andale. This WGL4 version of Andale was first
included as part of the Windows 98 update site. The font includes the distinctive zero
and the euro currency symbol first seen in Monotype.com version 1.20.
Monotype.com version 1.20 - This version of Monotype.com was updated to include a
distinctive zero and the euro currency symbol.
Monotype.com version 1.10 - Monotype.com 1.10 was added to our collection of Core
fonts for the Web on 26 January 1998. Version 1.00 was included in the Internet Explorer
4.0 supplemental font pack.
Monotype.com version 1.00 - This WGL4 version was included in the Internet Explorer
4.0 supplemental font pack.
Description
File name

Monotype.ttf

Styles &
Weights

Monotype.com

Designers

Steven R. Matteson

Copyright

Digitized data copyright (C) 1993-1997 The Monotype Corporation. All rights
reserved. Monotype.com is based on Andale. Andale? is a trademark of The
Monotype Corporation which may be registered in cer

Font
vendor

Agfa Monotype Corporation

Script
Tags

N/A

Description
Code

1252 Latin 1

pages

1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
Mac Roman Macintosh Character Set (US Roman)
OEM OEM Character Set
869 IBM Greek
866 MS-DOS Russian
865 MS-DOS Nordic
863 MS-DOS Canadian French
861 MS-DOS Icelandic
860 MS-DOS Portuguese
857 IBM Turkish
855 IBM Cyrillic; primarily Russian
852 Latin 2
775 MS-DOS Baltic
737 Greek; former 437 G
850 WE/Latin 1
437 US

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Monotype.com

Monotype Corsiva font family
Article • 03/30/2022

Overview
An italic typeface made in the style of the early Italian cursives, as exemplified by the
work of the writing master Ludovico degli Arrighi in the sixteenth century. The capitals
are of swash design, with characteristic flourishes, designed primarily for use as initial
letters. Corsiva can be used for short text passages in advertising but is best used to add
sparkle to invitations, greeting cards and menus, and to give a sense of occasion to
certificates and awards.
Description
File name

Mtcorsva.ttf

Styles &
Weights

Monotype Corsiva

Designers

Monotype Type Drawing Office - Patricia Saunders

Copyright

Digitized data copyright The Monotype Corporation 1991-1995. All rights reserved.
Monotype Corsiva? is a trademark of The Monotype Corporation which may be
registered in certain jurisdictions.

Font
vendor

Agfa Monotype Corporation

Script
Tags

N/A

Description
Code

1252 Latin 1

pages

1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
Mac Roman Macintosh Character Set (US Roman)
869 IBM Greek
866 MS-DOS Russian
865 MS-DOS Nordic
863 MS-DOS Canadian French
861 MS-DOS Icelandic
860 MS-DOS Portuguese
857 IBM Turkish
855 IBM Cyrillic; primarily Russian
852 Latin 2
775 MS-DOS Baltic
737 Greek; former 437 G
850 WE/Latin 1
437 US

Fixed

False

pitch

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Monotype Corsiva

Monotype Sorts font family
Article • 03/30/2022

Overview
This extensive selection of characters to enhance all graphic communications was
chosen from Monotype's collection of more than 30,000 symbols, ornaments, and other
special characters. It offers a wide-ranging assortment of symbolic characters which
work well with any standard typeface. It is worth taking the trouble to run through this
font in the Character Map applet and keeping in mind what is available. This way you
are more likely to make use of one of these symbols to brighten up a message.
Description
File name

Mtsorts.ttf
Mtsorts2.ttf

Styles &
Weights

Monotype Sorts
Monotype Sorts 2

Designers

Monotype Type Drawing Office

Copyright

Typeface © The Monotype Corporation plc. Data © The Monotype Corporation
plc/Type Solutions Inc. 1990/91 All Rights Reserved.

Font
vendor

Agfa Monotype Corporation

Script
Tags

N/A

Code

Symbol Symbol Character Set

pages
Fixed

False

pitch

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Monotype Sorts

Monotype Sorts 2

MoolBoran font family
Article • 03/30/2022

Overview
MoolBoran is a Khmer font.
Description
File name

Moolbor.ttf

Styles &
Weights

MoolBoran

Designers

Om Mony

Copyright

Khmer outlines Copyright © 2006 OM Mony. Portions © 2006 Microsoft
Corporation. All Rights Reserved.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Khmr'
slng:'Khmr', 'Latn'

Code pages

1252 Latin 1

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Product name

Font version

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows Server 2008

5.00

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
MoolBoran

MS Gothic font family
08/08/2025

Overview
MS Gothic is a typeface designed for typesetting the Japanese language in the Japanese script.
It has a sans serif, “gothic” style with strokes of uniform thickness and simple, plain,
straightforward character shapes. It was designed to be legible onscreen, in user interfaces on
low-resolution displays. It is appropriate for headings and subheads.
MS Gothic was designed by Ricoh Co. Ltd. and licensed as the default system font for Windows
3.1. It has only one weight, with no accompanying italic style. The font includes Japanese kanji,
hiragana, katakana, symbols, and capitals and lowercase letters for the Latin, Greek, and Cyrillic
alphabets. The Latin letters in MS Gothic are of uniform width (monospaced). MS PGothic has
the same Japanese characters, but with proportional spacing, and the Latin alphabet is a
different design that also has proportional spacing (the widths of the letters varies depending
on their shape). The default glyph shapes of this MS UI Gothic are based on JIS2004. This font
also provides access to a set of JIS90 legacy glyphs via 'jp90' OpenType layout table.
ﾉ

Description
File name

Msgothic.ttc

Styles & Weights

MS Gothic
MS UI Gothic
MS PGothic

Designers

N/A

Copyright

© 2012 data:RICOH Co.,Ltd. typeface:RYOBI IMAGIX CO.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Hani', 'Hira', 'Hrkt', 'Jpan', 'Kana'
slng:'Cyrl', 'Grek', 'Hani', 'Hira', 'Hrkt', 'Jpan', 'Kana', 'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
932 JIS/Japan

Expand table

Description
OEM OEM Character Set
869 IBM Greek
866 MS-DOS Russian
865 MS-DOS Nordic
863 MS-DOS Canadian French
861 MS-DOS Icelandic
860 MS-DOS Portuguese
857 IBM Turkish
855 IBM Cyrillic; primarily Russian
852 Latin 2
775 MS-DOS Baltic
737 Greek; former 437 G
850 WE/Latin 1
437 US
Fixed pitch

True

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
ﾉ

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

2.30

Windows 2000

2.30

Expand table

Product name

Font version

Windows Server 2008

5.00

Windows Server 2003

2.30

This typeface is also available within Office applications. For more information visit this page.

Style & weight examples
MS Gothic

MS LineDraw font family
Article • 03/30/2022

Overview
A special font with line draw characters based on the Courier New font.
Description
File name

Linedraw.ttf

Styles &
Weights

MS LineDraw

Designers

N/A

Copyright

Typeface © The Monotype Corporation plc. Data © The Monotype Corporation
plc/Type Solutions Inc. 1990-1992. All Rights Reserved

Font
vendor

Microsoft Corp.

Script
Tags

N/A

Code
pages

1252 Latin 1
855 IBM Cyrillic; primarily Russian
775 MS-DOS Baltic
737 Greek; former 437 G
437 US

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
MS LineDraw

MS Mincho font family
Article • 03/30/2022

Overview
MS Mincho is a Japanese font that features serifs at the end of its strokes, and can be
used for a variety of uses from screen display to publications.
Description
File name

Msmincho.ttc

Styles & Weights

MS Mincho
MS PMincho

Designers

N/A

Copyright

© 2017 data:RICOH Co.,Ltd. typeface:RYOBI IMAGIX CO.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Hani', 'Hira', 'Hrkt', 'Jpan', 'Kana'
slng:'Cyrl', 'Grek', 'Hani', 'Hira', 'Hrkt', 'Jpan', 'Kana', 'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
932 JIS/Japan
OEM OEM Character Set
869 IBM Greek
866 MS-DOS Russian
865 MS-DOS Nordic
863 MS-DOS Canadian French
861 MS-DOS Icelandic
860 MS-DOS Portuguese
857 IBM Turkish
855 IBM Cyrillic; primarily Russian
852 Latin 2
775 MS-DOS Baltic
737 Greek; former 437 G
850 WE/Latin 1
437 US

Fixed pitch

True

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

2.31

Windows 2000

2.30

Windows Server 2008

5.00

Windows Server 2003

2.31

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
MS Mincho

MS Outlook font family
Article • 03/30/2022

Overview
MS Outlook is a symbol font for Microsoft Outlook.
Description
File name

OUTLOOK.ttf

Styles & Weights

MS Outlook

Designers

Microsoft Office 97

Copyright

Copyright (c) 1996 Microsoft Corporation. All rights reserved.

Font vendor

Microsoft Corp.

Script Tags

N/A

Code pages

Symbol Symbol Character Set

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
MS Outlook

MS PMincho font family
Article • 03/30/2022

Overview
MS PMincho is a Japanese font with proportional latin in the mincho (serif) style
Description
File name

Msmincho_01.ttf

Styles & Weights

MS PMincho

Designers

N/A

Copyright

© 2012 data:RICOH Co.,Ltd. typeface:RYOBI IMAGIX CO.

Font vendor

N/A

Script Tags

N/A

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
932 JIS/Japan
OEM OEM Character Set
869 IBM Greek
866 MS-DOS Russian
865 MS-DOS Nordic
863 MS-DOS Canadian French
861 MS-DOS Icelandic
860 MS-DOS Portuguese
857 IBM Turkish
855 IBM Cyrillic; primarily Russian
852 Latin 2
775 MS-DOS Baltic
737 Greek; former 437 G
850 WE/Latin 1
437 US

Fixed pitch

False

Licensing and redistribution info

Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
MS PMincho

MS Reference font family
Article • 03/30/2022

Overview
A special set of reference fonts used with various Microsoft applications
Description
File name

MSREF1.ttf
MSREF2.ttf
MS Reference Sans Serif.ttf
REFSANB.ttf
REFSANBI.ttf
REFSANI.ttf
MS Reference Specialty.ttf

Styles & Weights

MS Reference 1
MS Reference 2
MS Reference Sans Serif
MS Reference Sans Serif Bold
MS Reference Sans Serif Bold Italic
MS Reference Sans Serif Italic
MS Reference Specialty

Designers

N/A

Copyright

MS Reference 1 © 2004 Microsoft Corporation. All rights reserved

Font vendor

Microsoft Corp.

Script Tags

N/A

Code pages

Symbol Symbol Character Set

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font

This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
MS Reference 1

MS Reference 2

MS Reference Sans Serif

MS Reference Sans Serif Bold

MS Reference Sans Serif Bold Italic

MS Reference Sans Serif Italic

MS Reference Specialty

MT Extra font family
Article • 03/30/2022

Overview
"MT Extra is supplied with Access 2000, Excel 2000, FrontPage 2000, Office 2000
Premium, Office 97 Small Business Edition SR2, Office 97 SR1a, PowerPoint 2000, and
Word 2000. "
Description
File name

Mtextra.ttf

Styles & Weights

MT Extra

Designers

N/A

Copyright

Copyright © Design Science, Inc, 1999-2004.

Font vendor

Agfa Monotype Corporation

Script Tags

N/A

Code pages

869 IBM Greek
437 US

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples

MT Extra

MV Boli font family
Article • 03/30/2022

Overview
MV Boli font was first introduced with Windows XP to support Thaana script, which is
used for the Dhivehi language of the Maldives. Thaana font is similar to the Arabic script
and is written right to left.
Description
File name

Mvboli.ttf

Styles & Weights

MV Boli

Designers

Thomas Rickner, Kamal Mansour

Copyright

© 2019 Microsoft Corporation. All Rights Reserved.

Font vendor

Agfa Monotype Corporation

Script Tags

dlng:'Thaa'
slng:'Thaa', 'Latn'

Code pages

1252 Latin 1

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Product name

Font version

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

1.00

Windows Server 2008

5.00

Windows Server 2003

1.00

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
MV Boli

Myanmar Text font family
Article • 03/30/2022

Overview
Description
File name

Mmrtext.ttf
Mmrtextb.ttf

Styles & Weights

Myanmar Text
Myanmar Text Bold

Designers

John Hudson

Copyright

© 2018 Microsoft Corporation. All Rights Reserved.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Mymr'
slng:'Latn', 'Mymr'

Code pages

1252 Latin 1

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Product name

Font version

Windows 7

See the Windows 7 page.

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Myanmar Text

Narkisim font family
Article • 03/30/2022

Overview
Narkisim is a Hebrew font.
Description
File name

Nrkis.ttf

Styles &
Weights

Narkisim

Designers

N/A

Copyright

© Zvi Narkis. © 1991-1993 Kivun Computers Ltd. Portions © The Monotype
Corporation

Font vendor

Glyph Systems

Script Tags

dlng:'Hebr'
slng:'Hebr', 'Latn'

Code pages

1255 Hebrew
437 US

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Product name

Font version

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

1.00

Windows 2000

1.00

Windows Server 2008

5.00

Windows Server 2003

1.00

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Narkisim

Neue Haas Grotesk Text Pro font family
Article • 03/30/2022

Overview
Description
File name

NHaasGroteskTXPro-55Rg.ttf
NHaasGroteskTXPro-56It.ttf
NHaasGroteskTXPro-65Md.ttf
NHaasGroteskTXPro-66MdIt.ttf
NHaasGroteskTXPro-75Bd.ttf
NHaasGroteskTXPro-76BdIt.ttf

Styles &
Weights

Neue Haas Grotesk Text Pro
Neue Haas Grotesk Text Pro Italic
Neue Haas Grotesk Text Pro Medium
Neue Haas Grotesk Text Pro Medium Italic
Neue Haas Grotesk Text Pro Bold
Neue Haas Grotesk Text Pro Bold Italic

Designers

Christian Schwartz

Copyright

Copyright © 2011 - 2012 Linotype Corp., www.linotype.com . All rights reserved.
This font software may not be reproduced, modified, disclosed or transferred without
the express written approval of Linotype Corp.

Font
vendor

Linotype GmbH

Script
Tags

dlng: 'Latn'
slng: 'Latn'

Code
pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
Mac Roman Macintosh Character Set (US Roman)

Fixed
pitch

False

Licensing and redistribution info

Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Neue Haas Grotesk Text Pro

Neue Haas Grotesk Text Pro Italic

Neue Haas Grotesk Text Pro Medium

Neue Haas Grotesk Text Pro Medium Italic

Neue Haas Grotesk Text Pro Bold

Neue Haas Grotesk Text Pro Bold Italic

Change list:
Windows 10 version 1703 released on April 05, 2017
Following two members are added to the Neue Haas Grotesk Text Pro font family
Neue Haas Grotesk Text Pro Medium
Neue Haas Grotesk Text Pro Medium Italic

Windows 10 version 1507 released on July 29, 2015
Neue Haas Grotesk Text Pro font family was introduced as part of the Windows 10 PanEuropean Supplemental Fonts package.
Neue Haas Grotesk Text Pro
Neue Haas Grotesk Text Pro Bold
Neue Haas Grotesk Text Pro Bold Italic
Neue Haas Grotesk Text Pro Italic

News Gothic MT font family
Article • 03/30/2022

Overview
Sans serif faces can get very boring and can be difficult to read. One of the primary
reasons is that font designers cannot make many variations in the shape of a sans serif
letter, particularly those like 'l', 'i' and 'o'. News Gothic MT, however, has a nice
angularity that allows it to wear better than most, and you will find it a pleasant change
from the other sans serif typefaces of this world. Originally designed in 1908, News
Gothic MT preceded the more fiercely geometric forms of the twentieth century. This
design, with its plainly stated, unselfconscious letterforms, was revived by Monotype in
1962. You'll find it useful as a text face, but it's quite nice for headlines and section
headings as well.
Description
File name

Nwgthc.ttf
Nwgthcb.ttf
Nwgthci.ttf

Styles &
Weights

News Gothic MT
News Gothic MT Bold
News Gothic MT Italic

Designers

Monotype Design Studio

Copyright

Design and data by The Monotype Corporation. © 1993. Microsoft Corporation.
All rights reserved.

Font vendor

Agfa Monotype Corporation

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
News Gothic MT

News Gothic MT Bold

News Gothic MT Italic

New Caledonia font family
Article • 03/30/2022

Overview
The Scotch Roman faces of the 19th century were quite rightly a very popular family of
faces, some being also particularly elegant. In 1938, Dwiggins made this modern design
for the Linotype Company, and Caledonia soon achieved the popularity it deserved.
There was a time after World War II when it was hard to find any magazine in the United
States that was not set in New Caledonia. Just as Times New Roman was the most used
Monotype text face, Caledonia was the staple of Linotype users. Caledonia, you will
remember, is the poetic name of Scotland made famous perhaps by the couplet of Sir
Walter Scott that says, "Oh Caledonia, stern and wild, meet nurse for a poetic child!"
Description
File name

Newcal.ttf
Newcalb.ttf
Newcali.ttf

Styles & Weights

New Caledonia
New Caledonia Bold
New Caledonia Italic

Designers

William Dwiggins, Alex Kaczun

Copyright

© Linotype-Hell AG. Portions © 1992 Microsoft Corp. All rights reserved.

Font vendor

N/A

Script Tags

N/A

Code pages

1252 Latin 1
866 MS-DOS Russian
865 MS-DOS Nordic
862 Hebrew
860 MS-DOS Portuguese
775 MS-DOS Baltic
737 Greek; former 437 G
437 US

Fixed pitch

False

Licensing and redistribution info

Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
New Caledonia

New Caledonia Bold

New Caledonia Italic

Niagara font family
Article • 03/30/2022

Overview
While not a revival in the strictest sense of the word, Niagara recalls the crisp, elegant
geometry found in some of the best American styles from the thirties and forties. The
four condensed weights were designed by Tobias Frere-Jones, who found inspiration in
the straight-sided geometric fonts from that era.
Description
File name

Niageng.ttf
Niagsol.ttf

Styles &
Weights

Niagara Engraved
Niagara Solid

Designers

Tobias Frere-Jones

Copyright

Copyright (c) 1994, Tobias Frere-Jones. Designed by Tobias Frere-Jones. Produced by
The Font Bureau, Inc. All rights reserved.

Font
vendor

The Font Bureau, Inc.

Script
Tags

N/A

Code
pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font

This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Niagara Engraved

Niagara Solid

Nirmala UI font family
Article • 03/30/2022

Overview
Description
File name

Nirmalas.ttf
Nirmala.ttf
Nirmalab.ttf

Styles &
Weights

Nirmala UI Semilight
Nirmala UI
Nirmala UI Bold

Designers

Tiro Typeworks: David Brezina (Gujarati), Valentin Brustaux (Telugu & Kannada), Jo De
Baerdemaeker (Bengali), John Hudson (Devanagari, Odia, Gurmukhi

Copyright

© 2019 Microsoft Corporation. All Rights Reserved.

Font
vendor

Microsoft Corp.

Script
Tags

dlng:'Beng', 'Cakm', 'Deva', 'Gujr', 'Guru', 'Knda', 'Mlym', 'Mtei', 'Olck', 'Orya', 'Sinh',
'Sora', 'Taml', 'Telu'
slng:'Beng', 'Cakm', 'Deva', 'Gujr', 'Guru', 'Knda', 'Latn', 'Mlym', 'Mtei', 'Olck', 'Orya',
'Sinh', 'Sora', 'Taml', 'Telu'

Code
pages

1252 Latin 1

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Nirmala UI

Nirmala UI Bold

Nyala font family
Article • 03/30/2022

Overview
The Nyala typeface is named for the mountain nyala (tragelaphus buxtoni) a species of
great African antelope native to the highlands of Ethiopia.
This typeface was designed for Microsoft by John Hudson of Tiro Typeworks, and is
based on initial drawings by Geraldine Wade. The Ethopic glyphs conform to the stylistic
norms of typical text faces, but are lighter and more open than most Ethiopic types,
making Nyala better suited to screen readability. A Latin typeface was also designed
expressly to harmonise with the style and proportions of Ethiopic syllabics.
Description
File name

Nyala.ttf

Styles & Weights

Nyala

Designers

John Hudson and Geraldine Wade

Copyright

© 2018 Microsoft Corporation. All Rights Reserved.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Ethi'
slng:'Ethi', 'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1254 Turkish
1257 Windows Baltic

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows Server 2008

5.00

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Nyala

OCR-B-Digits font family
Article • 03/30/2022

Overview
A special version of the OCR-B font with just the numerals 0 - 9.
Description
File name

Ocrbnum.ttf

Styles & Weights

OCR-B-Digits

Designers

N/A

Copyright

copyright 1994 Jerry Whiting

Font vendor

N/A

Script Tags

N/A

Code pages

437 US

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
OCR-B-Digits

OCRB font family
Article • 03/30/2022

Overview
With the advent of optical character recognition (OCR) systems, a need arose for
typefaces whose characters could be easily distinguished by machines developed to
read text. Unfortunately, a face that sufficiently distinguished between '1', 'i' and 'l' for
the machine tended to look crude, if not just plain ugly. OCR-A was such a face. OCR-B
was subsequently designed as a standard typeface that would be adequately readable
by both human and machine. OCR-B is still the face that many OCR readers are happiest
with. It makes a good face for advertising that needs a 'typewriter' or obvious
'computer' look. It looks good at low resolutions, too; a fax in this face leaves no room
for doubt even if the image comes out badly at the other end.
Description
File name

Ocrb.ttf

Styles & Weights

OCRB

Designers

N/A

Copyright

Data by URW. © 1993. Microsoft Corporation. All rights reserved.

Font vendor

N/A

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font

This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
OCRB

OCR A Extended font family
Article • 03/30/2022

Overview
Optical Character Recognition face extended to the regular Win Ansi character set.
Description
File name

Ocraext.ttf

Styles &
Weights

OCR A Extended

Designers

N/A

Copyright

Digitized data copyright The Monotype Corporation 1991-1995. All rights
reserved.

Font vendor

Monotype

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
OCR A Extended

Old English Text MT font family
Article • 03/30/2022

Overview
There are two main kinds of what people tend to call Gothic letters: the German Frakturs
and the English Blackletter. The Frakturs have an x that looks like an r with a mysterious
disease, and the Blackletters have fiddly bits in the middle like those you see in this Old
English Text. Little is known about the history of Old English Text, provided here by
Monotype Typography, but it has been beautifully made. It looks remarkably like the
famous Cloister Black designed by Morris Fuller Benton in 1904.
Description
File name

Oldengl.ttf

Styles &
Weights

Old English Text MT

Designers

Monotype Type Drawing Office

Copyright

Typeface © of The Monotype Corporation plc. Data © of The Monotype Corporation
plc/Type Solutions Inc. 1990-91-92 All rights reserved. Portions © 1992 Microsoft
Corp. All rights reserved.

Font
vendor

Agfa Monotype Corporation

Script
Tags

N/A

Code

1252 Latin 1

pages

Mac Roman Macintosh Character Set (US Roman)

Fixed

False

pitch

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples

Onyx font family
Article • 03/30/2022

Overview
Many fonts look like Onyx, inspired by a font named Stephanie that the Bauer foundry
issued in 1870. Onyx began its life in 1937 at the American Type Founders, and this
version comes from Monotype Typography. The condensed form of this font, combined
with its high-waisted letters and mixture of thick/thin strokes, evokes an elegant, formal
charm.
Description
File name

Onyx.ttf

Styles &
Weights

Onyx

Designers

Gerry Powell

Copyright

Typeface © of The Monotype Corporation plc Data © of The Monotype Corporation
plc/Type Solutions, Inc. 1990-1991 All Rights Reserved. Portions © 1992 Microsoft
Corp. All rights reserved.

Font
vendor

Agfa Monotype Corporation

Script
Tags

N/A

Code

1252 Latin 1

pages

Mac Roman Macintosh Character Set (US Roman)

Fixed

False

pitch

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font

This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Onyx

Palace Script MT font family
Article • 03/30/2022

Overview
Palace Script MT is an early twentieth-century version of an English copperplate script.
Its steep incline and dramatic color variation give its letters the appearance of being
engraved. In due course, you may need other script faces in your type library, but Palace
Script MT is a standard that you'll find useful on a regular basis. Because of the small xheight, you'll need to use this face in large sizes, or you won't be able to read the
lowercase letters. Sparing use of the capitals is recommended, lest the frills become
overwhelming.
Description
File name

Palscri.ttf

Styles &
Weights

Palace Script MT

Designers

Monotype Type Drawing Office

Copyright

Design and data by The Monotype Corporation. © 1993. Microsoft Corporation.
All rights reserved.

Font vendor

Agfa Monotype Corporation

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font

This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Palace Script MT

Palatino Linotype font family
Article • 04/05/2024

Overview
Palatino Linotype is the definitive new version of Hermann Zapf's Palatino, which since
its design in 1950 has become one of the world's most widely used typefaces. For this
new digital version, Professor Zapf has drawn numerous additional characters to include
an extensive range of ligatures, numerals, fractions and support for Cyrillic and both
monotonic and polytonic Greek. Special care has been taken to enhance the quality of
the letterforms when displayed on the computer screen, ensuring that Palatino Linotype
is highly legible whether displayed on the screen or in print. This typeface is ideal for use
in extended text settings such as books, periodicals and catalogs.
ﾉ

Expand table

Description
File name

Pala.ttf
Palab.ttf
Palabi.ttf
Palai.ttf

Styles &
Weights

Palatino Linotype
Palatino Linotype Bold
Palatino Linotype Bold Italic
Palatino Linotype Italic

Designers

Hermann Zapf

Copyright

Copyright 1981-1983, 1989,1993, 1998 Heidelberger Druckmaschinen AG. All rights
reserved. The digitally encoded machine readable outline data for producing the
Typefaces licensed are the property of Heidelberger Druckmaschinen AG and/or its
subsidiaries, represented by Linotype Library GmbH, Dupont Strasse 1, 61352 Bad
Homburg Germany. Portions © 1996-1998 Microsoft Corporation. All Rights
Reserved.

Font
vendor
Script Tags

dlng:'Cyrl', 'Grek', 'Latn'
slng:'Cyrl', 'Grek', 'Latn'

Code
pages

1252 Latin 1
1250 Latin 2: Eastern Europe

Description
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
1258 Vietnamese
Mac Roman Macintosh Character Set (US Roman)
Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
ﾉ

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

1.40

Windows 2000

1.05

Windows Server 2008

5.00

Windows Server 2003

1.40

Expand table

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples

Papyrus font family
Article • 03/30/2022

Overview
Papyrus font is a popular and unusual roman typeface that effectively merges the
elegance of a traditional roman letterform with the hand-crafted look of highly skilled
calligraphy.
Description
File name

Papyrus.ttf

Styles &
Weights

Papyrus

Designers

Chris Costello

Copyright

Copyright © Esselte Corporation 1997. Portions Copyright Microsoft Corporation
1997. All rights reserved.

Font vendor

ITC Corporation

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples

Papyrus

Parade font family
Article • 03/30/2022

Overview
A unique font from the Filmotype library, which also provided Contemporary Brush. Few
other typefaces look anything like Parade, made to represent casual lettering by a
competent artist. Use it for invitations, announcements, and other informal
communications.
Description
File name

Parade.ttf

Styles &
Weights

Parade

Designers

N/A

Copyright

Copyright 1989-1992 The Font Company, All rights reserved. Portions © 1992
Microsoft Corp. All rights reserved.

Font
vendor

The Font Company

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Parade

Parchment font family
Article • 03/30/2022

Overview
Parchment is an ornate formal script font in the blackletter style.
Description
File name

Parchm.ttf

Styles &
Weights

Parchment

Designers

N/A

Copyright

© PhotoLettering, Inc. 1993© 1990-1993 Type Solutions, Inc. Portions Copyright
Microsoft Corporation. All rights reserved.

Font
vendor

N/A

Script Tags

N/A

Code
pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Parchment

Parties MT font family
Article • 03/30/2022

Overview
Designed by Carolyn Gibbs, this is one of a versatile set of art fonts from Monotype.
Great for instant illustrations, icons or bullets.
Description
File name

Pa.ttf

Styles &
Weights

Parties MT

Designers

Carolyn Gibbs

Copyright

Digitized data copyright (C) 1991-1995 The Monotype Corporation. All rights
reserved. Parties? is a trademark of The Monotype Corporation which may be
registered in certain jurisdicions.

Font
vendor

Agfa Monotype Corporation

Script
Tags

N/A

Code
pages

Symbol Symbol Character Set

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Parties MT

Peignot Medium font family
Article • 03/30/2022

Overview
One of the really great European type foundries has been Deberny & Peignot in Paris.
Just as Fonderie Olive was so well served by Roger Excoffon, Deberny & Peignot was
served as well in modern times by Cassandre, who designed this and many other faces.
Deberny & Peignot introduced Peignot in 1937.
Description
File name

Peignot.ttf

Styles &
Weights

Peignot Medium

Designers

Adolphe Mouron Cassandre, Charles Peignot, 1993, (1936)

Copyright

© Copyright by URW, 1992. Portions © 1992 Microsoft Corp. All rights
reserved.

Font vendor

URW Type Foundry

Script Tags

N/A

Code pages

869 IBM Greek
437 US

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Peignot Medium

Pepita MT font family
Article • 03/30/2022

Overview
Pepita font is a stylish cursive typeface designed by Imr? Reiner in 1959.
Description
File name

Pepita.ttf

Styles &
Weights

Pepita MT

Designers

Imr? Reiner

Copyright

Digitized data copyright The Monotype Corporation 1991-1995. All rights reserved.
Pepita? is a trademark of The Monotype Corporation which may be registered in
certain jurisdictions.

Font
vendor

Agfa Monotype Corporation

Script
Tags

N/A

Code
pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Pepita MT

Perpetua font family
Article • 03/30/2022

Overview
A sensitive adaptation of a style of letter that had been popularized for monumental
work in stone by Eric Gill. Large scale drawings by Gill were given to Charles Malin, a
Parisian punch-cutter, and his hand cut punches were the basis for the font issued by
Monotype. The incised quality of Perpetua will lend distinction to any work compatible
with its serenity. First used in a private translation called 'The Passion of Perpetua and
Felicity'; the italic was originally called Felicity. Widely used as a text face in quality
books, Perpetua is also very popular in advertising and display work.
Description
File name

Per_____.ttf
Perb____.ttf
Perbi___.ttf
Peri____.ttf

Styles &
Weights

Perpetua
Perpetua Bold
Perpetua Bold Italic
Perpetua Italic

Designers

Eric Gill

Copyright

Digitized data copyright The Monotype Corporation 1991-1995. All rights reserved.
Perpetua? is a trademark of The Monotype Corporation which may be registered in
certain jurisdictions.

Font
vendor

Agfa Monotype Corporation

Script
Tags

N/A

Code
pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed
pitch

False

Licensing and redistribution info

Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Perpetua

Perpetua Bold

Perpetua Bold Italic

Perpetua Italic

Perpetua Titling MT font family
Article • 03/30/2022

Overview
Perpetua Titling was originally designed for Monotype in 1931. From the 1930s to the
1950s (the last days of metal typesetting) Perpetua Titling proved very popular for
contrasting headlines. You can easily find books from that era that were set with Times
or Baskerville body text and Perpetua headings. Because they have been designed to be
used at large point sizes, both Perpetua Titling MT Bold and Perpetua Titling MT Light
look best with extra space between the letters. Consider increasing character spacing so
these fonts do not look too tight.
Description
File name

Pertibd.ttf
Pertili.ttf

Styles &
Weights

Perpetua Titling MT Bold
Perpetua Titling MT Light

Designers

Eric Gill

Copyright

Design and data by The Monotype Corporation. © 1993. Microsoft Corporation.
All rights reserved.

Font vendor

Agfa Monotype Corporation

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font

This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Perpetua Titling MT Bold

Perpetua Titling MT Light

Placard Condensed font family
Article • 03/30/2022

Overview
Placard Condensed, Monotype Type Drawing Office 1937. Based on drawings received
from Germany, these narrow, heavy, sans serif typefaces were made for use in headlines
and advertising display work. They have large x heights, short ascenders and descenders
and are capable of packing very tightly to produce forceful publicity work.
Description
File name

Placcond.ttf

Styles & Weights

Placard Condensed

Designers

N/A

Copyright

Copyright (c) 1992 Monotype Corporation plc. All rights reserved.

Font vendor

Monotype

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Placard Condensed

Plantagenet Cherokee font family
Article • 04/07/2022

Overview
Plantagenet Cherokee is an OpenType font designed by Ross Mills of Tiro Typeworks
Ltd. It was the first font provided by Microsoft to support the Cherokee script, and is in a
classical type style reminiscent of the early metal fonts for the writing system made in
the 19th Century.
Description
File name

Plantc.ttf

Styles & Weights

Plantagenet Cherokee

Designers

Ross Mills

Copyright

© Copyright 2018 Tiro Typeworks. All rights reserved.

Font vendor

Tiro Typeworks

Script Tags

dlng:'Cher'
slng:'Cher', 'Latn'

Code pages

1252 Latin 1

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Product name

Font version

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows Server 2008

5.00

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Plantagenet Cherokee

Playbill font family
Article • 03/30/2022

Overview
The idea of having an Egyptian face whose horizontals were thicker than the verticals
seems to have surfaced only a few years after the Battle of Waterloo. Designs of this
kind were given names like Italienne or, later in England, French Antique. In 1938, the
Stephenson Blake type foundry revived this look, with the appropriately named Playbill,
and others followed. It seems proper to start with the first and best known.
Description
File name

Playbill.ttf

Styles &
Weights

Playbill

Designers

Robert Harling, 1993, (1938)

Copyright

Typeface © 1992 Stphenson Blake (Holdings) Ltd. Data © 1992 URW. Portions ©
1992 Microsoft Corp. All rights reserved.

Font
vendor

URW Type Foundry

Script Tags

N/A

Code
pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Playbill

Poor Richard font family
Article • 03/30/2022

Overview
Poor Richard font is based on the Keystone Type Foundry design, circa 1919.
Description
File name

Poorich.ttf

Styles &
Weights

Poor Richard

Designers

N/A

Copyright

Design copyright © P.L.Digital, Inc., data copyright Projective Solutions, Inc.,
additional data copyright Type Solutions, Inc. Portions Copyright 1994 Microsoft
Corporation. All rights reserved.

Font
vendor

N/A

Script
Tags

N/A

Code
pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Poor Richard

Posterama font family
Article • 03/30/2022

Overview
The Posterama™ typeface family is a true journey through space and time. Posterama
sets an evocative flavor to visualize an entire century of futuristic reference points from
art, architecture, poster design and science fiction into one family.
The first siblings of the family were designed in 2007 as a branding typeface for Jim
Ford’s band. The band was called “Duchamp,” and Ford designed the face to reflect the
spirit of the artist’s work from the opening decades of the 20th century. Bones of the
design can be seen in the Futura® and Gill Sans® typefaces. The fledging family was
used for posters, album covers and other branded material. Gradually additional timesensitive stylistic sets grew into the full Posterama family. As it neared completion,
another Monotype type designer, Karl Leuthold, collaborated with Ford to complete the
suite of designs.
Between the years and the letterforms, themes are drawn from 20th century history, art,
design, architecture, economy, war, pop culture and science fiction. Posterama Text is
the base family. It has the most robust character set including upper and lowercase
glyphs and pan-European language support (including Greek and Cyrillic). Note: all the
other Posterama variants described below do not have lowercase letters or Greek and
Cyrillic support.
Posterama 1901 recalls the decoratively geometric style of Art Nouveau from the turn of
the 20th century. Letterforms such as the slender, snaking 'S', the high-waisted 'E' and
the underlined 'O' revive the spirit of Charles Rennie Mackintosh and the designers of
the Viennese Secession.
Posterama 1913 pays homage to the Armory Show, or 1913 Exhibition of Modern Art,
which brought the revolutionary work of European artists such as Picasso, Duchamp and
Kandinsky to the US for the first time to the shock and astonishment of press and public.
Near-abstract, angular characters such as the 'A', 'E' and 'N' hint at cubism's jagged and
clashing planes.
Posterama 1919 uses a small, but important, variation to set a tone when the Bauhaus
was founded, and the surge in radical European typography that followed. The straightsided, roundheaded 'A' adds a flavor of 1919 - this style of 'A' can still be seen in the
Braun logo, designed in 1934. Posterama 1927 captures the year of Metropolis, The Jazz

Singer and Paul Renner's pioneering, geometric Futura typeface from 1927, which had a
profound influence on design in the US and Europe.
Posterama 1933 - With its low-waisted, sinuous designs, the Posterama 1933 typeface
family echoes lettering of the Art Deco period, which in turn had its roots in Art
Nouveau, the key influence on Posterama 1901. The two fonts make a great team and
can be used interchangeably.
Posterama 1945 features a few Cyrillic characters to conjure up an era when Russian art
and political posters made their mark in cold war propaganda, espionage and also giant
aliens and monsters. Posterama 1984 takes its typographic influences from George
Orwell's classic novel, publicity for the dystopian action and sci-fi movies (Blade Runner,
Videodrome and Terminator) and games like Space Invaders and Pac-Man that made an
impact at that time.
Posterama 2001 was inspired by Stanley Kubrick's science fiction masterpiece, which
made extensive use of the Futura typeface. Posterama 2001 finds its cosmic orbit with its
nosecone-style 'A' from NASA's much-missed 'worm' logotype. There's an echo, too, in
Bauhaus designs from as early as 1920, whose minimalist, geometric lettering also
featured a crossbar-less 'A'.
For the many cases where an all-cap setting is appropriate, Posterama provides a wide
palette that encourages typographic play. It has the familiar charm of iconic design
throughout the 20th century, and can transform seamlessly to accommodate a different
mood or theme. Posters, wordmarks, headlines, and sub heads are all within it’s print
range, while Posterama shines as a branding and display typeface for interactive
projects. – fonts.com
In 2019 we reviewed the set of fonts provided with Office identifying stylistic gaps. The
result of that effort was the addition of over a hundred new fonts, including classics like
Avenir Next LT Pro and Walbaum along with contemporary designs like The Hand,
Sagona and Modern Love. These new fonts are available in most Office applications and
have been used in a range of new templates.
Description
File name

posterama-regular.ttf
posterama-bold.ttf
posterama-bolditalic.ttf
posterama-italic.ttf

Description
Styles & Weights

Posterama
Posterama Bold
Posterama Bold Italic
Posterama Italic

Copyright

Copyright © 2014, 2016, 2018 Monotype Imaging Inc. All rights reserved

Designers

Jim Ford

Font vendor

Monotype Corporation

Script Tags

dlng:'Cyrl','Grek','Latn'
slng:'Cyrl','Grek','Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
1258 Vietnamese

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is also available within Office applications. For more information visit this
page.

Pristina font family
Article • 03/30/2022

Overview
Pristina font has a calligraphic style that expertly reveals all of the natural, unrestrained
qualities of cultured penmanship.
Description
File name

Pristina.ttf

Styles &
Weights

Pristina

Designers

Phill Grimshaw

Copyright

Copyright © Esselte Corporation 1997. Portions Copyright Microsoft Corporation
1997. All rights reserved.

Font vendor

ITC Corporation

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples

Pristina

Quire Sans font family
Article • 03/30/2022

Overview
Quire Sans translates exceptionally well from hardcopy environments to digital screens
and user experience design. It retains its personality and legibility at both large and
small sizes, and its extensive range of weights gives the family extraordinary versatility.
Description
File name

quiresans-regular.ttf
quiresans-bold.ttf
quiresans-bolditalic.ttf
quiresans-italic.ttf
quiresanspro-light.ttf
quiresanspro-lightitalic.ttf

Styles & Weights

Quire Sans
Quire Sans Bold
Quire Sans Bold Italic
Quire Sans Italic
Quire Sans Pro Light
Quire Sans Pro Light Italic

Copyright

Copyright © 2014, 2016, 2018 Monotype Imaging Inc. All rights reserved.

Designers

Jim Ford

Font vendor

Monotype Corporation

Script Tags

dlng:'Latn'
slng:'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1254 Turkish
1257 Windows Baltic

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows

License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Quire Sans

Quire Sans Bold

Quire Sans Bold Italic

Quire Sans Italic

Quire Sans Pro Light

Quire Sans Pro Light Italic

Raavi font family
Article • 03/30/2022

Overview
The Raavi font is a Windows font that is primarily intended to support the Panjabi
language and any other languages written using the Gurmukhi script. It does support
characters used in English and other western European languages, but nonetheless was
created primarily to support Panjabi. The Latin characters in the Raavi font were actually
adapted from the Microsoft Sans Serif font. If you want to use Raavi, please install the
optional feature, "Gurmukhi Supplemental Fonts".
Description
File name

Raavi.ttf
Raavib.ttf

Styles & Weights

Raavi
Raavi Bold

Designers

Raghunath Joshi

Copyright

© 2018 Microsoft Corporation. All Rights Reserved.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Guru'
slng:'Guru', 'Latn'

Code pages

1252 Latin 1

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

1.06

Windows Server 2008

5.00

Windows Server 2003

1.06

This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Raavi

Raavi Bold

Rage Italic font family
Article • 03/30/2022

Overview
Rage Italic font is a popular style is one of the first casual brush script styles with a
rough textured edge.
Description
File name

Rage.ttf

Styles &
Weights

Rage Italic

Designers

Ron Zwingelberg M.W.

Copyright

Copyright Esselte Corporation 1997. Portions Copyright (c) Microsoft Corporation
1999. All rights reserved.

Font vendor

N/A

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples

Rage Italic

Ransom font family
Article • 03/30/2022

Overview
This set of typefaces may not become an important part of the corporate graphic scene.
Nor should you expect to see them much used in presentations. Ransom was
enthusiastically created by the Font Bureau. The best way to use the Ransom set of
typefaces is to write the message in one variant. Next, change letters that appear too
often by replacing them with letters from one of the other variations or by using lower
case instead of caps.
Description
File name

Ransom.ttf
Ransomb.ttf
Ransombi.ttf
Ransomi.ttf

Styles &
Weights

Ransom
Ransom Bold
Ransom Bold Italic
Ransom Italic

Designers

The Font Bureau

Copyright

Typeface ©1992 The Font Bureau, Inc. Portions © 1992 Microsoft Corp. All rights
reserved.

Font vendor

The Font Bureau, Inc.

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Ransom

Ransom Bold

Ransom Bold Italic

Ransom Italic

Ravie font family
Article • 09/30/2022

Overview
This typeface was drawn by Ken O'Brien from 1993 to 1994, while a student at the Art
Center in Pasadena, California. Ravie exudes the funk and energy perfect for your next
dance party, often held in remote, clandestine locations, sometimes lasting for days on
end; FB 1994.
Description
File name

Ravie.ttf

Styles &
Weights

Ravie

Designers

Ken O'Brien

Copyright

Copyright (c) 1994, Ken O'Brien, designer. Produced by The Font Bureau, Inc. Portions
Copyright (c) 1997, 1998 The Font Bureau, Inc. All rights reserved.

Font
vendor

N/A

Script
Tags

N/A

Code
pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed

False

pitch

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font

This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Ravie

RefSpecialty font family
Article • 03/30/2022

Overview
Specialty font containing special characters for MS Reference.
Description
File name

Refspec.ttf

Styles &
Weights

RefSpecialty

Designers

Monotype Typography

Copyright

Digitized data copyright (C) 1998 The Monotype Corporation. All rights
reserved.

Font vendor

Agfa Monotype Corporation

Script Tags

N/A

Code pages

Symbol Symbol Character Set

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
RefSpecialty

Rockwell font family
Article • 03/30/2022

Overview
Rockwell is a distinctive version of a geometric slab serif design, which has retained its
popularity since its appearance in the 1930's. The slab serifs, or Egyptians, originated in
the nineteenth century when they were used principally for display work. Rockwell is
notable for its judiciously clipped slab serifs, and is given a particular sparkle by means
of its angular terminals. In more recent years this style of typeface has been increasingly
used for text setting where their even colour and visual impact can be fully exploited.
Description
File name

Rock.ttf
Rockb.ttf
Rockbi.ttf
Rocc____.ttf
Roccb___.ttf
Rockeb.ttf
Rocki.ttf
rockl.ttf

Styles &
Weights

Rockwell
Rockwell Bold
Rockwell Bold Italic
Rockwell Condensed
Rockwell Condensed Bold
Rockwell Extra Bold
Rockwell Italic
Rockwell Light

Copyright

Digitized data copyright (C) 1992 - 1997 The Monotype Corporation. Rockwell® is a
trademark of The Monotype Corporation which may be registered in certain
jurisdictions. Portions copyright Microsoft Corporation. All rights reserved.

Designers

Monotype Studio

Font

Monotype Corporation

vendor
Script

dlng:'Latn'

Tags

slng:'Latn'

Description
Code

1252 Latin 1

pages

1250 Latin 2: Eastern Europe
1254 Turkish
1257 Windows Baltic

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Rockwell

Rockwell Bold

Rockwell Bold Italic

Rockwell Condensed

Rockwell Condensed Bold

Rockwell Extra Bold

Rockwell Italic

Rockwell Nova font family
Article • 03/30/2022

Overview
Rockwell Nova is a subtle redesign of the classic Rockwell family. It is suitable for
document paragraphs and headings. These fonts are designed for European languages
written with Latin, Greek and Cyrillic scripts.
Description
File name

RockwellNova.ttf
RockwellNova-Bold.ttf
RockwellNova-BoldItalic.ttf
RockwellNovaCond.ttf
RockwellNovaCond-Bold.ttf
RockwellNovaCond-BoldItalic.ttf
RockwellNovaCond-Italic.ttf
RockwellNovaCond-Light.ttf
RockwellNovaCond-LightItalic.ttf
RockwellNova-ExtraBold.ttf
RockwellNova-ExtraBoldItalic.ttf
RockwellNova-Italic.ttf
RockwellNova-Light.ttf
RockwellNova-LightItalic.ttf

Styles &
Weights

Rockwell Nova
Rockwell Nova Bold
Rockwell Nova Bold Italic
Rockwell Nova Cond
Rockwell Nova Cond Bold
Rockwell Nova Cond Bold Italic
Rockwell Nova Cond Italic
Rockwell Nova Cond Light
Rockwell Nova Cond Light Italic
Rockwell Nova Extra Bold
Rockwell Nova Extra Bold Italic
Rockwell Nova Italic
Rockwell Nova Light
Rockwell Nova Light Italic

Designers

Monotype Type Drawing Office

Copyright

Digitized data copyright (C) 1992 - 1997 The Monotype Corporation. Rockwell? is a
trademark of The Monotype Corporation which may be registered in certain
jurisdictions. Portions copyright Microsoft

Description
Font

Agfa Monotype Corporation

vendor
Script

dlng:

Tags

slng:

Code

1252 Latin 1

pages

Mac Roman Macintosh Character Set (US Roman)

Fixed

False

pitch

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Rockwell Nova

Rockwell Nova Bold

Rockwell Nova Bold Italic

Rockwell Nova Italic

Rockwell Nova Extra Bold

Rockwell Nova Condensed

Rockwell Nova Condensed Bold

Change list:
Windows 10 version 1507 released on July 29, 2015
Rockwell font family was introduced as part of the Windows 10 Pan-European
Supplemental Fonts package.

Rod font family
Article • 03/30/2022

Overview
Rod is a Hebrew font.
Description
File name

Rod.ttf
Rodtr.ttf

Styles & Weights

Rod
Rod Transparent

Designers

N/A

Copyright

© 1991-1993 Kivun Computers Ltd. Portions © The Monotype Corporation

Font vendor

Glyph Systems

Script Tags

dlng:'Hebr'
slng:'Hebr', 'Latn'

Code pages

1255 Hebrew
437 US

Fixed pitch

True

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Product name

Font version

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

1.00

Windows 2000

1.00

Windows Server 2008

5.00

Windows Server 2003

1.00

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Rod

Rod Transparent

Runic MT Condensed font family
Article • 03/30/2022

Overview
Developed as a decorative typeface in 1935, Runic Condensed has short serifs and little
contrast between the thick and thin strokes. In this very condensed typeface, the xheight is large, with very short ascenders and descenders. Legible only in large point
sizes, Runic Condensed capably captures a reader's attention. Use this typeface with
care and in small doses for headlines, titles, and other display purposes.
Description
File name

Runiccn.ttf

Styles &
Weights

Runic MT Condensed

Designers

Monotype Type Drawing Office

Copyright

Typeface data Copyright © 1992-94 The Monotype Corporation. Copyright 1994
Microsoft Corporation. All rights reserved.

Font
vendor

Agfa Monotype Corporation

Script Tags

N/A

Code
pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Runic MT Condensed

Sabon Next LT font family
Article • 03/30/2022

Overview
Sabon Next LT typeface family is large and versatile - with Roman and italic styles.
Description
File name

sabonnreglt_57607.ttf
sabonnbollt_57570.ttf
sabonnbolitalt_57572.ttf
sabonnregitalt_57602.ttf

Styles & Weights

Sabon Next LT
Sabon Next LT Bold
Sabon Next LT Bold Italic
Sabon Next LT Italic

Copyright

Copyright © 2002-2015, 2018 Monotype GmbH. All rights reserved.

Designers

Jan Tschichold

Font vendor

Monotype Corporation

Script Tags

dlng:'Cyrl','Grek','Latn'
slng:'Cyrl','Grek','Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe

and Jean François Porchez

1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Sabon Next LT

Sabon Next LT Bold

Sabon Next LT Bold Italic

Sabon Next LT Italic

Sagona font family
Article • 03/30/2022

Overview
Sagona is a contemporary slab serif building on the clarendon/ionic model dating back
to the 19th century. Like its most famous representative, Clarendon, Sagona features
strong serifs and a variable stroke contrast resulting in a versatile typeface working great
in headlines and small text sizes. Where great typefaces like Sentinel, Belizio or FF Hertz
are staying close to the industrial and strict appearance, Sagona is focusing on a warm
and welcoming approach, emphasizing a subtle elegance especially in the mid weights.
– from fonts.com
ﾉ

Description
File name

Sagona-Book.ttf
Sagona-Bold.ttf
Sagona-BoldItalic.ttf
Sagona-BookItalic.ttf
Sagona-ExtraLight.ttf
Sagona-ExtraLightItalic.ttf

Styles & Weights

Sagona Book
Sagona Book Bold
Sagona Book Bold Italic
Sagona Book Italic
Sagona ExtraLight
Sagona ExtraLight Italic

Copyright

Copyright © 2016 by René Bieder. All rights reserved.

Designers

René Bieder

Font vendor

René Bieder

Script Tags

dlng:'Latn'
slng:'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1254 Turkish
1257 Windows Baltic

Expand table

Description
Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Sagona Book

Sagona Book Bold

Sagona Book Bold Italic

Sagona ExtraLight

Sagona ExtraLight Italic

Feedback
Was this page helpful?

 Yes

 No

Sakkal Majalla font family
Article • 03/30/2022

Overview
Sakkal Majalla is an Arabic font based on Naskh calligraphy.
Description
File name

Majalla.ttf
Majallab.ttf

Styles &
Weights

Sakkal Majalla
Sakkal Majalla Bold

Designers

Mamoun Sakkal, Sakkal Design and Steve Matteson, Ascender Corp.

Copyright

© 2018 Microsoft Corporation. All Rights Reserved. Portions © 2018 Mamoun
Sakkal, Sakkal Design.

Font vendor

SKKL

Script Tags

dlng:'Arab'
slng:'Arab', 'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1254 Turkish
1256 Arabic
1257 Windows Baltic
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Sakkal Majalla

Sakkal Majalla Bold

Sanskrit Text font family
Article • 03/30/2022

Overview
Sanskrit Text is Devanagari font specially targeting the typesetting of Sanskrit texts in a
traditional style. The design of Sanskrit Text is based on Monotype Devanagari, a type
initially manufactured for hot metal typesetting technologies back in 1930s, but has
been thoroughly revised and expanded by John Hudson and Fiona Ross (Tiro
Typeworks). Letter shapes have been made more stylistically and proportionally
consistent, and the glyph set supports more than 680 consonant conjunct sequences
attested in Sanskrit texts. The glyph set specification was prepared with advice from
Anshuman Pandey, and is based on both existing catalogues as well as new analysis of
specific Vedic and literary texts.
Sanskrit Text is one of the first fonts to incorporate support for the Unicode encoding of
Vedic symbols and marks. These characters are essential for correct representation of
the various early Hindu religious texts known collectively as the Vedas. This means that
the Sanskrit Text font may be used for literary, scientific, and also religious Sanskrit texts.
The Sanskrit Text Devanagari is accompanied in the font by a companion Latin design.
This is based on Monotype's famous Bembo type, inspired by 15th Century Venetian
models, but has also been thoroughly redrawn to harmonize in weight and proportion
with the Devanagari. The Latin character set supports Microsoft codepage 1252 (Latin 1)
plus a large set of diacritics for transliterating not just Sanskrit but also other Indian
languages.
Description
File name

Sanskr.ttf

Styles &
Weights

Sanskrit Text

Designers

John Hudson & Fiona Ross (based on Monotype Devanagari and Bembo,
thoroughly revised and extended.

Copyright

Copyright © 2015, Microsoft Corporation. Portions copyright © 1999, Monotype
Typography Ltd.

Font vendor

N/A

Description
Script Tags

dlng: 'Deva'
slng: 'Deva', 'Latn'

Code pages

1252 Latin 1

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Regular

Change list:
Windows 10 version 1507 released on July 29, 2015
The Sanskrit Text font was included as part of the Devanagari Supplemental Fonts
package.

Script MT Bold font family
Article • 03/30/2022

Overview
Script MT Bold font has an unusually heavy appearance, inspired by the early twentiethcentury German script writing styles. Despite the heaviness of this font, Monotype Script
Bold has a lively style for packaging and other display purposes.
Description
File name

Scriptbl.ttf

Styles &
Weights

Script MT Bold

Designers

F.H. Steltzer

Copyright

Digitized data copyright Monotype Typography, Ltd 1991-1995. All rights reserved.
Monotype Script? is a trademark of Monotype Typography, Ltd which may be
registered in certain jurisdictions.

Font
vendor

Agfa Monotype Corporation

Script
Tags

N/A

Code
pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font

This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Script MT Bold

Segoe Chess font family
Article • 03/30/2022

Overview
Segoe Chess font is part of the Segoe family of fonts from Microsoft.
Description
File name

SEGOECHESS.ttf

Styles & Weights

Segoe Chess

Designers

Steve Matteson, Jim Ford

Copyright

© 2006 Microsoft Corporation. All Rights Reserved.

Font vendor

Microsoft Corp.

Script Tags

N/A

Code pages

Symbol Symbol Character Set

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Segoe Chess

Segoe MDL2 Assets font family
Article • 03/30/2022

Overview
Segoe MDL2 Assets is a system font that includes new icons.
Description
File name

Segmdl2.ttf

Styles & Weights

Segoe MDL2 Assets

Designers

Microsoft Corporation

Copyright

© 2019 Microsoft Corporation. All Rights Reserved.

Font vendor

Microsoft Corporation

Script Tags

slng: 'Zsym'
dlng: 'Zsym'

Code pages

N/A

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Style & weight examples

Normal

Change list:
Windows 10 version 1507 released on July 29, 2015
The Segoe MDL2 Assets font was included as part of the desktop system fonts.

Segoe Print font family
09/30/2025

Overview
Segoe Print and Segoe Script are the two cursive members of the Segoe typeface family. Both
are handwriting typefaces, with slightly different styles. Both appear to be written with a felt-tip
pen. Segoe Print is more regular, and it works better in all capital letters than Segoe Script
does. Segoe Print is legible at smaller sizes than Segoe Script. Both are effective where an
informal, handmade look is needed. Use Segoe Print for large text or headlines, with Segoe
Script as a fancier accompaniment, for invitations, labels, flyers, brochures, or packaging. Segoe
Script is designed by type designer Carl Crossgrove, based on the handwriting of Brian Allen.
Segoe Print is an adaptation of his handwriting by Crossgrove, James Grieshaber, and Karl
Leuthold. The letters in Segoe Script connect, like cursive handwriting, while the letters in
Segoe Print are independent, though still informal and cursive in form.
ﾉ

Item

Description

File name

Segoepr.ttf
Segoeprb.ttf

Styles & Weights

Segoe Print
Segoe Print Bold

Designers

N/A

Copyright

© 2008 The Monotype Corporation. All Rights Reserved.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Cyrl', 'Grek', 'Latn'
slng:'Cyrl', 'Grek', 'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
Mac Roman Macintosh Character Set (US Roman)
866 MS-DOS Russian
855 IBM Cyrillic; primarily Russian
852 Latin 2

Expand table

Item

Description
775 MS-DOS Baltic
437 US

Fixed pitch

False

Download

N/A – Exclusively included with Microsoft products and services where applicable.

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
ﾉ

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows Server 2008

5.00

Expand table

This typeface is also available within Office applications. For more information visit this page.

Style & weight examples
Segoe Print

Segoe Script font family
09/30/2025

Overview
Font information Segoe Print and Segoe Script are the two cursive members of the Segoe
typeface family. Both are handwriting typefaces, with slightly different styles. Both appear to be
written with a felt-tip pen. Segoe Print is more regular, and it works better in all capital letters
than Segoe Script does. Segoe Print is legible at smaller sizes than Segoe Script. Both are
effective where an informal, handmade look is needed. Use Segoe Print for large text or
headlines, with Segoe Script as a fancier accompaniment, for invitations, labels, flyers,
brochures, or packaging. Segoe Script is designed by type designer Carl Crossgrove, based on
the handwriting of Brian Allen. Segoe Print is an adaptation of his handwriting by Crossgrove,
James Grieshaber, and Karl Leuthold. The letters in Segoe Script connect, like cursive
handwriting, while the letters in Segoe Print are independent, though still informal and cursive
in form.
ﾉ

Item

Description

File name

Segoesc.ttf
Segoescb.ttf

Styles & Weights

Segoe Script
Segoe Script Bold

Designers

N/A

Copyright

© 2016 Microsoft Corporation. All Rights Reserved.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Cyrl', 'Grek', 'Latn'
slng:'Cyrl', 'Grek', 'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic

Fixed pitch

False

Expand table

Item

Description

Download

N/A – Exclusively included with Microsoft products and services where applicable.

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
ﾉ

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows Server 2008

5.00

Expand table

This typeface is also available within Office applications. For more information visit this page.

Style & weight examples
Segoe Script

Segoe UI font family
07/25/2025

Overview
Segoe UI is a version of Microsoft's branding typeface Segoe that is designed specifically for
use on screen. Segoe UI is especially clear and readable for information that will be presented
primarily on the screen of a desktop, laptop, tablet, or phone. It can also be used effectively in
print. Segoe UI is a clear, readable sans serif typeface with an open, neutral look; it works well
both in headlines and in short passages of text. It is especially appropriate for labels, captions,
signs, and subtitles. Segoe was designed by type designer Steve Matteson to be a friendly,
readable sans serif typeface for all corporate applications. It became Microsoft's default user
interface font with the release of Windows Vista in 2007, however it was not added to Office
for use on non-Windows devices until 2022. Segoe UI supports a very wide range of languages
and scripts, including the Latin, Greek, and Cyrillic alphabets, Arabic, Hebrew, Armenian,
Georgian, Vietnamese, Lisu, and Volapuk, as well as digits (number symbols) for most writing
systems.
ﾉ

Item

Description

File name

Segoeuil.ttf
Seguili.ttf
Segoeuisl.ttf
Seguisli.ttf
Segoeui.ttf
Segoeuii.ttf
Seguisb.ttf
Seguisbi.ttf
Segoeuib.ttf
Segoeuiz.ttf
Seguibl.ttf
Seguibli.ttf

Styles &

Segoe UI Light

Weights

Segoe UI Light Italic
Segoe UI Semilight
Segoe UI Semilight Italic
Segoe UI
Segoe UI Italic
Segoe UI Semibold
Segoe UI Semibold Italic
Segoe UI Bold

Expand table

Item

Description
Segoe UI Bold Italic
Segoe UI Black
Segoe UI Black Italic

Designers

N/A

Copyright

© 2018 Microsoft Corporation. All Rights Reserved.
Hebrew OpenType Layout logic copyright © 2003 & 2007, Ralph Hancock & John Hudson.
This layout logic for Biblical Hebrew is open source software under the MIT License; see
embedded license description for details.

Font vendor

Agfa Monotype Corporation

Script Tags

dlng:'Latn', 'Grek', 'Cyrl', 'Armn', 'Geor', 'Geok', 'Arab', 'Hebr', 'Lisu'
slng:'Latn', 'Grek', 'Cyrl', 'Armn', 'Geor', 'Geok', 'Arab', 'Hebr', 'Lisu'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1255 Hebrew
1256 Arabic
1257 Windows Baltic
1258 Vietnamese
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Download

N/A – Exclusively included with Microsoft products and services where applicable.

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
ﾉ

Product name

Font version

Windows 11

See the Windows 11 page.

Expand table

Product name

Font version

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows Server 2008

5.00

This typeface is also available within Office applications. For more information visit this page.

Style & weight examples

Segoe UI Emoji font family
Article • 12/06/2021

Overview
Our PCs continue to play a central role in our lives enabling us to connect with one
another. Emoji in Windows 11 offers a modern and expressive way to add fun and
personality to our hybrid communications.
Property

Description

File name

Seguiemj.ttf

Styles & Weights

Segoe UI Emoji

Designers

N/A

Copyright

© 2020 Microsoft Corporation. All Rights Reserved.

Font vendor

Microsoft Corporation

Script Tags

dlng: 'Zsye', 'Zsym'
slng: 'Latn', 'Zsye', 'Zsym'

Code pages

1252 Latin 1

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Windows 11

Windows 10

Segoe UI Historic font family
Article • 03/30/2022

Overview
Segoe UI Historic is a font that supports a variety of historic languages, scripts and
writing systems. These scripts are not in general everyday use, but are of interest to
students, teachers, academics and other historic script enthusiasts. The style of glyphs
included in the font generally aligns with the Segoe UI design, and on Windows this font
serves as a fallback font for these languages, scripts and writing systems. The font
contains original, licensed and open source components.
Description
File name

Seguihis.ttf

Styles &
Weights

Segoe UI Historic​

Designers

N/A

Copyright

© 2014 Microsoft. All Rights Reserved. Portions Copyright 2012 Google Inc. All Rights
Reserved. Portions Copyright © 2014 Adobe Systems Incorporated. All Rights
Reserved.

Font
vendor

Microsoft Corporation

Script
Tags

dlng: 'Armi', 'Brah', 'Cari', 'Cprt', 'Egyp', 'Glag', 'Goth', 'Ital', 'Khar', 'Lyci', 'Lydi', 'Merc',
'Ogam', 'Orkh', 'Phli', 'Phnx', 'Prti', 'Runr', 'Sarb', 'Shaw', 'Syrc', 'Ugar', 'Xpeo', 'Xsux'
slng: 'Goth', 'Grek', 'Ital', 'Latn', 'Ogam', 'Runr', 'Syrc'

Code
pages

1252 Latin 1

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples

Change list:
Windows 10 version 1507 released on July 29, 2015
The Segoe UI Historic font was included as part of the desktop fonts.

Segoe UI Symbol font family
Article • 03/30/2022

Overview
Designs for the HTML5 logo and its components are attributed to the W3C.
Description
File name

Seguisym.ttf

Styles & Weights

Segoe UI Symbol

Designers

N/A

Copyright

© 2016 Microsoft Corporation. All Rights Reserved.

Trademark

Segoe is a trademark of the Microsoft group of companies.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Brai', 'Zsym'
slng:'Brai', 'Copt', 'Grek', 'Latn', 'Zsym'

Code pages

1252 Latin 1
437 US

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Product name

Font version

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Segoe UI Symbol

Selawik font family
Article • 03/30/2022

Overview
Selawik is an open source replacement for Segoe UI. This Font Software is licensed
under the SIL Open Font License, Version 1.1.
Description
File name

selawk.ttf
selawkb.ttf
selawkl.ttf
selawksb.ttf
selawksl.ttf

Styles &
Weights

Selawik
Selawik Bold
Selawik Light
Selawik Semibold
Selawik Semilight

Copyright

© 2015 Microsoft Corporation (https://www.microsoft.com ), with Reserved Font
Name Selawik. Selawik is a trademark of Microsoft Corporation in the United States
and/or other countries.

Designers

Aaron Bell

Font
vendor

Monotype Corporation

Script

dlng:'Latn'

Tags

slng:'Latn'

Code

1252 Latin 1

pages

1250 Latin 2: Eastern Europe
1254 Turkish
1257 Windows Baltic

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows

License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Selawik

Selawik Bold

Selawik Light

Selawik Semibold

Selawik Semilight

Shonar Bangla font family
Article • 03/30/2022

Overview
Shonar Bangla is a Bengali typeface design based on sources from The Monotype
Corporation library. This font was developed by staff at Monotype Imaging. Earlier
Bengali font development work by Linotype designers and engineers is acknowledged
and is used with permission. The Latin portion of the typeface is based on The
Monotype Corporation?s Times New Roman design.
Description
File name

Shonar.ttf
Shonarb.ttf

Styles & Weights

Shonar Bangla
Shonar Bangla Bold

Designers

N/A

Copyright

© 2015 Microsoft Corporation. All Rights Reserved.

Font vendor

TMC

Script Tags

dlng:'Beng'
slng:'Beng', 'Latn'

Code pages

1252 Latin 1

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Product name

Font version

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Shonar Bangla

Shonar Bangla Bold

Showcard Gothic font family
Article • 03/30/2022

Overview
Showcard Gothic leans from the page to forcefully present any idea you might have exceptingpossibly classical subtlety - with a certain leering emphasis. Derived from the
showcard models prepared for lettering artists in the twenties and thirties, Showcard
Gothic goes a step beyond Poster Black, providing a cheerfully theatrical air to any
presentation. Jim Parkinson designed this type for the Font Bureau.
Description
File name

Showg.ttf

Styles &
Weights

Showcard Gothic

Designers

Jim Parkinson

Copyright

Copyright (c) 1997, 1998 The Font Bureau, Inc. and Jim Parkinson. All rights
reserved.

Font vendor

The Font Bureau, Inc.

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Showcard Gothic

Shruti font family
Article • 03/30/2022

Overview
Shruti is an OpenType font for the Indic script - Gujarati. It is based on Unicode, contains
TrueType outlines and has been designed for use as a UI font.
Description
File name

Shruti.ttf
Shrutib.ttf

Styles & Weights

Shruti
Shruti Bold

Designers

Raghunath Joshi (Type Director), Santosh Kshirsagar

Copyright

© 2015 Microsoft Corporation. All Rights Reserved.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Gujr'
slng:'Gujr', 'Latn'

Code pages

1252 Latin 1

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Product name

Font version

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

1.22

Windows Server 2008

5.00

Windows Server 2003

1.22

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Shruti

Shruti Bold

Signs MT font family
Article • 03/30/2022

Overview
Designed by Carolyn Gibbs, this is one of a versatile set of art fonts from Monotype.
Recycled, No Parking, Fire Extinguisher and lots of other useful symbols that can save
you time and effort. If you need to add a familiar symbol to your document make sure
you have a look in this font first. Great for instant illustrations, icons or bullets.
Description
File name

Signs.ttf

Styles &
Weights

Signs MT

Designers

Carolyn Gibbs

Copyright

Digitized data copyright (C) 1991-1995 The Monotype Corporation. All rights
reserved. Signs? is a trademark of The Monotype Corporation which may be
registered in certain jurisdicions.

Font
vendor

Agfa Monotype Corporation

Script
Tags

N/A

Code
pages

Symbol Symbol Character Set

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples

Signs MT

SimHei font family
Article • 03/30/2022

Overview
SimHei font features plain strokes similar to sans serif designs.
Description
File name

Simhei.ttf

Styles & Weights

SimHei

Designers

N/A

Copyright

© Beijing ZhongYi Electronics Co., 1995-2005, All rights reserved

Font vendor

ZYEC

Script Tags

dlng:'Hans'
slng:'Bopo', 'Cyrl', 'Grek', 'Hani', 'Hans', 'Hira', 'Hrkt', 'Jpan', 'Kana', 'Latn'

Code pages

1252 Latin 1
936 Chinese: Simplified chars--PRC and Singapore

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Product name

Font version

Windows 7

See the Windows 7 page.

Windows Vista

5.01

Windows XP

3.02

Windows Server 2008

5.01

Windows Server 2003

3.02

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
SimHei

Simplified Arabic Fixed font family
Article • 03/30/2022

Overview
Description
File name

Simpo.ttf
Simpbdo.ttf
Simpfxo.ttf

Styles &
Weights

Simplified Arabic
Simplified Arabic Bold
Simplified Arabic Fixed

Designers

N/A

Copyright

Portions (C) 1990 Compugraphic Corporation. Typeface Portions (C) The Monotype
Corporation plc. All Rights Reserved.

Font
vendor

Glyph Systems

Script Tags

dlng:'Arab'
slng:'Arab', 'Latn'

Code
pages

1252 Latin 1
1256 Arabic
862 Hebrew
437 US

Fixed pitch

True

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Product name

Font version

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

1.01

Windows 2000

1.01

Windows Server 2008

5.00

Windows Server 2003

1.01

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Simplified Arabic Fixed

SimSun & NSimSun font family
Article • 03/30/2022

Overview
SimSun & NSimSun is a Simplified Chinese font features mincho (serif) stroke style.
Description
File name

Simsun.ttc
Simsunb.ttf

Styles & Weights

SimSun
SimSun-ExtB
NSimSun

Designers

N/A

Copyright

© Copyright ZHONGYI Electronic Co. 2001

Font vendor

ZYEC

Script Tags

dlng:'Hans'
slng:'Bopo', 'Cyrl', 'Grek', 'Hani', 'Hans', 'Hira', 'Hrkt', 'Jpan', 'Kana', 'Latn'

Code pages

1252 Latin 1
936 Chinese: Simplified chars--PRC and Singapore

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Product name

Font version

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

3.03

Windows 2000

2.11

Windows Server 2008

5.00

Windows Server 2003

3.03

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
SimSun

SimSun-ExtB

NSimSun

Sitka font family
10/11/2025

Overview
Sitka, a collaboration between type design and science, is a general-purpose serif typeface of
Roman, Italic, Bold and Bold Italic. It is primarily designed for on screen use.
We recognize words by ﬁrst recognizing individual letters, then using the letters to build a
word [Larson, 2004; Rayner 'et.al', 2012]. Words become more readable by making each of the
individual letters more recognizable. During the typeface’s development, we tested how well
people could read each of the letters in the typeface, and used the test results to inform design
decisions. While the test results needed to be applied conscientiously, we discovered that
typeface design could be successfully integrated with scientiﬁc legibility testing.
The typeface is optically scaled, in other words different styles are optimized for setting at a
speciﬁed output size or narrow range of sizes. Table below lists recommended sizes for
different styles.
ﾉ

Style

Size range

Sitka Small

0-9.5pt

Sitka Text

9.5-13.5pt

Sitka Subheading

13.5-18.5pt

Sitka Heading

18.5-23.5pt

Sitka Display

23.5-27.5pt

Sitka Banner

27.5-∞

Expand table

To read more about Sitka design process please see
https://www.researchgate.net/publication/309754147_Sitka_A_collaboration_between_type_des
ign_and_science
ﾉ

Expand table

Item

Description

Files

Sitka.ttc
SitkaI.ttc
SitkaB.ttc
SitkaZ.ttc

Styles & Weights

Sitka Small
Sitka Small Italic
Sitka Small Bold
Sitka Small Bold Italic
Sitka Text
Sitka Text Italic
Sitka Text Bold
Sitka Text Bold Italic
Sitka Subheading
Sitka Subheading Italic
Sitka Subheading Bold
Sitka Subheading Bold Italic
Sitka Heading
Sitka Heading Italic
Sitka Heading Bold
Sitka Heading Bold Italic
Sitka Display
Sitka Display Italic
Sitka Display Bold
Sitka Display Bold Italic
Sitka Banner
Sitka Banner Italic
Sitka Banner Bold
Sitka Banner Bold Italic

Designers

Matthew Carter

Copyright

© 2018 Microsoft Corporation. All Rights Reserved.

Font vendor

Tiro Typeworks Ltd. and Carter & Cone, for Microsoft Corporation.

Script Tags

dlng: 'Cyrl', 'Grek', 'Latn'
slng: 'Cyrl', 'Grek', 'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Item

Description

Download

N/A – Exclusively included with Microsoft products and services where applicable.

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts: These Microsoft fonts can be licensed from Tiro Typeworks
Monotype

or

for a range of uses, including individual device use outside of Microsoft

products, webfonts, app embedding, enterprise computing and server installations, and
hardware and software redistribution.

Products that supply this font
ﾉ

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Expand table

This typeface is also available within Office applications. For more information visit this page.

Style & weight examples
Sitka

Skeena Indigenous font family
Article • 03/11/2025

Overview
Skeena Indigenous is a font family designed with an indigenous-first approach to
supporting the languages of the native peoples of North America using alphabets
derived from the Latin script. The default forms of characters and available languagespecific variant forms prioritize the orthographic and typographic norms of indigenous
languages, rather than those of European settler languages. Skeena Indigenous is
intended to provide a focal point for engagement with indigenous communities and
language revitalization organizations. It is a template for a particular way to approach
indigenous language support in fonts, which will hopefully inspire and assist other font
makers to support these languages.
The Skeena Indigenous typeface was designed using documentation from many sources
including individual indigenous experts and language keepers, cultural and language
preservation organizations in the USA and Canada, and typographic and technology
consultants working with North American languages.
Skeena Indigenous is available as a family of 12 static fonts in a range of weights, or as
two weight-axis variable fonts in roman (upright) and italic styles. The fonts are available
as device/desktop TTF files, and as WOFF2 format webfonts.
Read more about the design and production of Skeena Indigenous here
Get the Skeena Indigenous sources and build tools here

.
ﾉ

Menu

Description

Styles & Weights

Skeena Indigenous Black
Skeena Indigenous Black Italic
Skeena Indigenous Bold
Skeena Indigenous Bold Italic
Skeena Indigenous Extra Bold
Skeena Indigenous Extra Bold Italic
Skeena Indigenous Italic
Skeena Indigenous Medium
Skeena Indigenous Medium Italic
Skeena Indigenous Regular

.

Expand table

Menu

Description
Skeena Indigenous Semibold
Skeena Indigenous Semibold Italic

Copyright

© 2025 Microsoft Corporation. All Rights Reserved.

Designers

John Hudson (Tiro Typeworks)
Paul Hanslow and
Kaja Słojewska (Tandem Type)

Font vendor

Tiro Typeworks Ltd. for Microsoft Corporation.

Script Tags

dlng:'Latn'
slng:'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1254 Turkish
1257 Windows Baltic

Fixed pitch

False

Download

Get the latest build of the Skeena Indigenous fonts here.

Licensing and redistribution info
The fonts, sources and build tools are released under the Open Font License v1.1,
meaning they can be freely used, distributed and modified under the terms of that
license. Get the Skeena Indigenous sources and build tools here.

Style & weight examples

:

Feedback
Was this page helpful?

 Yes

 No

Snap ITC font family
Article • 03/30/2022

Overview
ITC Snap? was conceived and drawn by David Sagorski and represents the creative
ability and humor of this inventive designer. Sagorski was born in Kansas, but moved to
southern Florida where he studied at the Art Institute of Fort Lauderdale. This typeface
shows the clear influence of cartoon graphics of the 1960s and 1970s. While visions of
Gerald McBoing-Boing? or the Jetsons? may come to mind, such associations should
not be limited to 'period' or animated graphics. Released in 1995, ITC Snap has the
strength of Superman rippling beneath its angular forms and Latin serifs, and is an ideal
design for headlines that demand attention.
Description
File name

Snap____.ttf

Styles &
Weights

Snap ITC

Designers

David Sagorski

Copyright

Copyright (c) International Typeface Corporation 1996. Portions Copyright (c)
Microsoft Corporation 1996. All rights reserved.

Font
vendor

ITC

Script
Tags

N/A

Code
pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Snap ITC

Sports MT font family
Article • 03/30/2022

Overview
Designed by Carolyn Gibbs & Steve Matteson, this is one of a versatile set of art fonts
from Monotype. Just like the Sports Two MT font this is a selection of sports related
illustrations. However, this covers some more unusual sports or recreational activities
like roller blading and surfing. These symbols are also more illustrative, less formal than
Sports two MT. Great for instant illustrations, icons or bullets.
Description
File name

Spt.ttf
Sporttwo.ttf

Styles &
Weights

Sports Three MT
Sports Two MT

Designers

Carolyn Gibbs and Steve Matteson

Copyright

Digitized data copyright (C) 1991-1995 Monotype Typography, Inc.. All rights
reserved. Monotype? is a trademark of Monotype Typography, Inc. which may be
registered in certain jurisdicions.

Font
vendor

Agfa Monotype Corporation

Script
Tags

N/A

Code
pages

Symbol Symbol Character Set

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Sports Three MT

Sports Two MT

STCaiyun font family
Article • 03/30/2022

Overview
Description
File name

STCAIYUN.ttf

Styles &
Weights

STCaiyun

Copyright

Copyright (c) 1991-1998, Changzhou SinoType Technology Co., Ltd. All rights
reserved.

Designers

N/A

Font vendor

Changzhou SinoType Technology Co., Ltd.

Script Tags

N/A

Code pages

N/A

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is also available within Office applications. For more information visit this
page.

Stencil font family
Article • 03/30/2022

Overview
Stencil faces have been made for as long as people have been shipping wooden boxes.
Most of the letterforms look a bit like a softer, bolder Clarendon before lines are cut
through it to allow counters (those little spaces enclosed in 'a', 'b' and other letters) to
remain as counters without becoming solid blobs. Consider this Stencil face a decorative
font for limited use; a little goes a long way.
Description
File name

Stencil.ttf

Styles & Weights

Stencil

Designers

Robert Hunter Middleton, Gerry Powell, 1993, (1938)

Copyright

Data © 1992 URW. Portions © 1992 Microsoft Corp. All rights reserved.

Font vendor

URW Type Foundry

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Stencil

STFangsong font family
Article • 03/30/2022

Overview
Description
File name

STFANGSO.ttf

Styles &
Weights

STFangsong

Copyright

Copyright (c) 1991-1998, Changzhou SinoType Technology Co., Ltd. All rights
reserved.

Designers

N/A

Font vendor

Changzhou SinoType Technology Co., Ltd.

Script Tags

N/A

Code pages

N/A

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is also available within Office applications. For more information visit this
page.

STHupo font family
Article • 03/30/2022

Overview
Description
File name

STHUPO.ttf

Styles &
Weights

STHupo

Copyright

Copyright (c) 1991-1998, Changzhou SinoType Technology Co., Ltd. All rights
reserved.

Designers

N/A

Font vendor

Changzhou SinoType Technology Co., Ltd.

Script Tags

N/A

Code pages

N/A

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is also available within Office applications. For more information visit this
page.

STKaiti font family
Article • 03/30/2022

Overview
Description
File name

stkaiti.ttf

Styles &
Weights

STKaiti

Copyright

Copyright (c) 1991-1998, Changzhou SinoType Technology Co., Ltd. All rights
reserved.

Designers

N/A

Font vendor

Changzhou SinoType Technology Co., Ltd.

Script Tags

N/A

Code pages

N/A

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is also available within Office applications. For more information visit this
page.

Stop font family
Article • 03/30/2022

Overview
There isn't a lot of humor in type design, but the face called Stop makes up for it. In
1970 Nebiolo, the best known of the Italian foundries, came up with this design, which is
irresistible. It's so irresistible, in fact, that every Tom, Dick, or Harry seems to have copied
it with slight variations. We have gone back to the earliest use of the idea that we can
find.
Description
File name

Stop.ttf

Styles &
Weights

Stop

Designers

Fonderia Caratteri Svizzera Walter Fruttiger A.G.

Copyright

Typeface © 1992 Fonderia Caratteri Svizzera Walter Fruttiger A.G. Data © 1992 URW.
Portions © 1992 Microsoft Corp. All rights reserved.

Font
vendor

N/A

Script

N/A

Tags
Code
pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples

Stop

STXihei font family
Article • 03/30/2022

Overview
Description
File name

STXIHEI.ttf

Styles &
Weights

STXihei

Copyright

Copyright (c) 1991-1998, Changzhou SinoType Technology Co., Ltd. All rights
reserved.

Designers

N/A

Font vendor

Changzhou SinoType Technology Co., Ltd.

Script Tags

N/A

Code pages

N/A

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is also available within Office applications. For more information visit this
page.

STXingkai font family
Article • 03/30/2022

Overview
Description
File name

STXINGKA.ttf

Styles &
Weights

STXingkai

Copyright

Copyright (c) 1991-1998, Changzhou SinoType Technology Co., Ltd. All rights
reserved.

Designers

N/A

Font vendor

Changzhou SinoType Technology Co., Ltd.

Script Tags

N/A

Code pages

N/A

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is also available within Office applications. For more information visit this
page.

STXinwei font family
Article • 03/30/2022

Overview
Description
File name

STXINWEI.ttf

Styles &
Weights

STXinwei

Copyright

Copyright (c) 1991-1998, Changzhou SinoType Technology Co., Ltd. All rights
reserved.

Designers

N/A

Font vendor

Changzhou SinoType Technology Co., Ltd.

Script Tags

N/A

Code pages

N/A

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is also available within Office applications. For more information visit this
page.

STZhongsong font family
Article • 03/30/2022

Overview
Description
File name

STZHONGS.ttf

Styles &
Weights

STZhongsong

Copyright

Copyright (c) 1991-1998, Changzhou SinoType Technology Co., Ltd. All rights
reserved.

Designers

N/A

Font vendor

Changzhou SinoType Technology Co., Ltd.

Script Tags

N/A

Code pages

N/A

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is also available within Office applications. For more information visit this
page.

Sylfaen font family
Article • 03/30/2022

Overview
Sylfaen was designed for Microsoft in 1998 by John Hudson and W. Ross Mills of Tiro
Typeworks, and Geraldine Wade of Monotype Typography. Sylfaen is a Welsh word
meaning "foundation"; an apt name since the font stemmed from research into the
typographic requirements of many different scripts and languages. This version of
Sylfaen supports the WGL4.0 character set, for Pan-European language coverage. In
addition to Latin, Greek and Cyrillic letterforms, the font contains the characters
necessary for support of the Armenian and Georgian languages.
Description
File name

Sylfaen.ttf

Styles & Weights

Sylfaen

Designers

John Hudson/Geraldine Wade

Copyright

© 2018 Microsoft Corporation. All Rights Reserved.

Font vendor

MS

Script Tags

dlng:'Armn', 'Cyrl', 'Geor', 'Grek', 'Latn'
slng:'Armn', 'Cyrl', 'Geor', 'Grek', 'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

1.00

Windows Server 2008

5.00

Windows Server 2003

1.00

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Sylfaen

Symbol font family
Article • 03/30/2022

Overview
The Symbol font contains Times New Roman Greek capitals and lowercase, figures and
basic punctuation together with a collection of mathematical signs and general purpose
Pi characters. Use for setting mathematical and scientific work and as a compliment to
the symbols found in standard fonts.
Description
File name

Symbol.ttf

Styles &
Weights

Symbol

Designers

Monotype Type Drawing Office 1989

Copyright

Typeface © The Monotype Corporation plc. Data © The Monotype Corporation
All Rights Reserved

Font vendor

Agfa Monotype Corporation

Script Tags

dlng:'Zsym'
slng:'Zsym'

Code pages

Symbol Symbol Character Set

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Product name

Font version

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

1.60

Windows 2000

2.00

Windows 98

1.50

Windows 95

1.00

Windows Server 2008

5.00

Windows Server 2003

1.60

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Symbol

Tahoma font family
07/25/2025

Overview
Font information Tahoma is a narrow, sans serif typeface based on its wider cousin Verdana.
Like Verdana, it is especially easy to read onscreen, although it also works well in print. Tahoma
is useful for situations where you need to fit a lot of words into a small space: a newsletter in
narrow columns, for example, or headlines or subheads on a phone screen. Tahoma could be
the headline typeface for a report or a presentation that uses Verdana for the body copy.
Tahoma is also useful for labels, captions, and signs. It has a clear, open feel, and among other
features it makes it easy to distinguish a capital ‘I' (eye) from a lowercase ‘l' (ell).
ﾉ

Expand table

Item

Description

File name

Tahoma.ttf
Tahomabd.ttf

Styles &
Weights

Tahoma
Tahoma Bold

Designers

Matthew Carter

Copyright

© 2018 Microsoft Corporation. All rights reserved.
Hebrew OpenType Layout logic copyright © 2003 & 2007, Ralph Hancock & John Hudson.
This layout logic for Biblical Hebrew is open source software under the MIT License; see
embedded license description for details.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Arab', 'Armn', 'Cyrl', 'Grek', 'Hebr', 'Latn', 'Thai'
slng:'Arab', 'Armn', 'Cyrl', 'Grek', 'Hebr', 'Latn', 'Thai'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1255 Hebrew
1256 Arabic
1257 Windows Baltic
1258 Vietnamese
874 Thai
Mac Roman Macintosh Character Set (US Roman)

Item

Description
862 Hebrew
860 MS-DOS Portuguese
437 US

Fixed pitch

False

Download

N/A – Exclusively included with Microsoft products and services where applicable.

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
ﾉ

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.01

Windows XP

3.00

Windows 2000

2.30

Windows 98

2.25

Windows Server 2008

5.01

Windows Server 2003

3.00

Expand table

This typeface is also available within Office applications. For more information visit
href="https://support.office.com/article/cloud-fonts-in-office-f7b009fe-037f-45ed-a556b5fe6ede6adb?">Cloud fonts in Office.

Style & weight examples

Tempo Grunge font family
Article • 03/30/2022

Overview
This Sans Serif typeface is based on the typeface Tempo Medium from the Ludlow
collection. The original Tempo Medium was introduced in 1930 as part of a family of 26
typefaces designed by R. Hunter Middleton, the director of Ludlow's type design
department. In the 1920s the Sans Serifs became very popular. This family of fonts was
Ludlow's answer to this need. The entire Ludlow collection is under license to
International TypeFounders. © International TypeFounders, Inc. 1998
Tempo Grunge was hinted by Laurence Penney.
Description
File name

Tempog.ttf

Styles & Weights

Tempo Grunge

Designers

N/A

Copyright

Copyright (c) 1998 ITF Inc. All rights reserved.

Font vendor

N/A

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Tempo Grunge

Tempus Sans ITC font family
Article • 03/30/2022

Overview
Phill Grimshaw developed an interest in type design while studying for his master's
degree in design at the Royal College of Art in London between 1972 and 1975.
Grimshaw claims that every calligrapher's aspiration is to render Roman capitals
perfectly with a pen, but admits that it is very difficult to do. For ITC Tempus? he used a
fountain pen on cheap, porous paper, and as you would expect, the ink bled. The
resulting letterforms are classically based, but have rugged edges, so they deviate from
the 'preciousness' of hand lettered romans. Released in 1996, ITC Tempus is a parody of
a classical roman design. It is dictated by proportions, particularly those of capitals. The
lowercase is somewhat loose and uninhibited. "Tempus Sans is just Tempus with the
serifs surgically removed," Grimshaw says. "Yet the proportions of the characters work
nicely." Because of its toughness, the typeface works best at larger point sizes, yet
maintains its characters when set at small sizes. You might consider it a "punk roman"
that works where a roman face is desired, but the fine edge is not.
Description
File name

Tempsitc.ttf

Styles &
Weights

Tempus Sans ITC

Designers

Phill Grimshaw

Copyright

Copyright (c) International Typeface Corporation 1996. Portions Copyright (c)
Microsoft Corporation 1996. All rights reserved.

Font

ITC

vendor
Script
Tags

N/A

Code
pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Tempus Sans ITC

Temp Installer Font font family
Article • 03/30/2022

Overview
A special font used in various Microsoft installation programs. Based on the font
Haettenschweiler.
Description
File name

Offsetup.ttf

Styles &
Weights

Temp Installer Font

Designers

N/A

Copyright

Data by Eraman Ltd., and Monotype Typography Inc. © 1995. Microsoft Corporation.
All rights reserved. This font is to be used only temporarily by the Office installer per
vendor permission.

Font
vendor

N/A

Script
Tags

N/A

Code
pages

1252 Latin 1

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Temp Installer Font

The Hand font family
Article • 03/30/2022

Overview
The Hand is a handwritten font designed by Fanny Coulez and Julien Saurin in Paris. We
wanted to create the most generic, readable and finely balanced handwritten font, to
work well in every kind of design. We hope you will enjoy our work. Merci beaucoup! –
fonts.com
In 2019 we reviewed the set of fonts provided with Office identifying stylistic gaps. The
result of that effort was the addition of over a hundred new fonts, including classics like
Avenir Next LT Pro and Walbaum along with contemporary designs like The Hand,
Sagona and Modern Love. These new fonts are available in most Office applications and
have been used in a range of new templates.
Description
File name

TheHandRegular.ttf
TheHandBlack.ttf
TheHandBold.ttf
TheHandExtrablack.ttf
TheHandLight.ttf

Styles &
Weights

The Hand
The Hand Black
The Hand Bold
The Hand Extrablack
The Hand Light

Copyright

Copyright (c) 2013-2017 by Julien Saurin and Fanny Coulez. All rights reserved.

Designers

Coulez Fanny Saurin Julien
Julien Saurin
Fanny Coulez

Font vendor

S&C Type

Script Tags

dlng:'Latn'
slng:'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1254 Turkish
1257 Windows Baltic

Description
Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples

The Serif Hand font family
Article • 03/30/2022

Overview
Some typefaces are mysterious, like this one—its origins are an enigma wrapped within
a riddle, indeed. While its letterforms may be shrouded in secrecy, this design is sure to
make a fine addition to your typographic arsenal, so we recommend you go try it out. –
fonts.com
In 2019 we reviewed the set of fonts provided with Office identifying stylistic gaps. The
result of that effort was the addition of over a hundred new fonts, including classics like
Avenir Next LT Pro and Walbaum along with contemporary designs like The Hand,
Sagona and Modern Love. These new fonts are available in most Office applications and
have been used in a range of new templates.
Description
File name

the-serif-hand-regular-v2.ttf
the-serif-hand-black-v2.ttf
the-serif-hand-bold-v2.ttf
the-serif-hand-extrablk-v2.ttf
the-serif-hand-light-v2.ttf

Styles & Weights

The Serif Hand
The Serif Hand Black
The Serif Hand Bold
The Serif Hand Extrablack
The Serif Hand Light

Copyright

Copyright (c) 2013 by Julien Saurin and Fanny Coulez. All rights reserved.

Designers

Julien Saurin
Fanny Coulez

Font vendor

S&C Type

Script Tags

dlng:'Latn'
slng:'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1254 Turkish
1257 Windows Baltic

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples

Times New Roman font family
07/25/2025

Overview
This remarkable typeface first appeared in 1932 in The Times of London newspaper, for which
it was designed. It has subsequently become one of the worlds most successful type creations.
The original drawings were made under Stanley Morison's direction by Victor Lardent at The
Times. It then went through an extensive iterative process involving further work in Monotype's
Type Drawing Office. Based on experiments Morison had conducted using Perpetua and
Plantin, it has many old style characteristics but was adapted to give excellent legibility coupled
with good economy. Widely used in books and magazines, for reports, office documents and
also for display and advertising.

Times New Roman version history
Version 2.55 - This WGL4 version of Times New Roman was first supplied with the Final
Windows 95 euro update that shipped on 4 November 1998. This version contains the euro.
Version 2.50 - This version of Times New Roman is supplied with European versions of
Windows 98. North American users can add it by installing multilanguage support. This version
contains the euro.
Version 2.45 - This Win ANSI version of Times New Roman is supplied with the US version of
Windows 98.
Version 2.01 - This special version of Times New Roman was only supplied with the beta
version of the Windows 95 euro update.
Version 2.00 (Win ANSI) - This Win ANSI version of Times New Roman is supplied with
Windows 95.
Version 2.00 (WGL4) - This WGL4 version of Times New Roman is supplied with Windows 95
and Windows NT4. This version does not contain the euro.
Version 1.00 - This version was supplied with Windows 3.1 and Windows for Workgroups 3.11.
ﾉ

Expand table

Item

Description

File name

Times.ttf
Timesbd.ttf
Timesbi.ttf
Timesi.ttf

Styles &
Weights

Times New Roman
Times New Roman Bold
Times New Roman Bold Italic
Times New Roman Italic

Designers

Monotype Type Drawing Office - Stanley Morison, Victor Lardent 1932

Copyright

© 2017 The Monotype Corporation. All Rights Reserved.
Hebrew OpenType Layout logic copyright © 2003 & 2007, Ralph Hancock & John Hudson.
This layout logic for Biblical Hebrew is open source software under the MIT License; see
embedded license description for details.

Font vendor

Agfa Monotype Corporation

Script Tags

dlng:'Armn', 'Cyrl', 'Grek', 'Latn'
slng:'Arab', 'Armn', 'Cyrl', 'Grek', 'Hebr', 'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1255 Hebrew
1256 Arabic
1257 Windows Baltic
1258 Vietnamese
OEM OEM Character Set
869 IBM Greek
866 MS-DOS Russian
865 MS-DOS Nordic
864 Arabic
863 MS-DOS Canadian French
862 Hebrew
861 MS-DOS Icelandic
860 MS-DOS Portuguese
857 IBM Turkish
855 IBM Cyrillic; primarily Russian
852 Latin 2
775 MS-DOS Baltic
737 Greek; former 437 G
708 Arabic; ASMO 708
850 WE/Latin 1
437 US

Item

Description

Fixed pitch

False

Download

N/A – Exclusively included with Microsoft products and services where applicable.

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
ﾉ

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.01

Windows XP SP2

3.00

Windows XP

2.95

Windows 2000

2.76

Windows 98 Second Edition

2.76

Windows 98

2.50

Windows 95

2.00

Windows 3.1

1.00

Windows Server 2008

5.01

Windows Server 2003

2.90

Expand table

Product name

Font version

Windows NT Terminal Server 4.0

2.00

Windows NT Workstation 4.0 SP4

2.50

Windows NT Workstation 4.0

2.00

Windows NT Workstation 3.5

1.77

This typeface is also available within Office applications. For more information visit this page.

Style & weight examples
Times New Roman

Times New Roman Special font family
Article • 03/30/2022

Overview
A special set of Times New Roman fonts used with various Microsoft applications
Description
File name

Msgeotr1.ttf
Msgeotb1.ttf
Msgeotx1.ttf
Msgeoti1.ttf
Msgeotr2.ttf
Msgeotb2.ttf
Msgeotx2.ttf
Msgeoti2.ttf

Styles &
Weights

Times New Roman Special G1
Times New Roman Special G1 Bold
Times New Roman Special G1 Bold Italic
Times New Roman Special G1 Italic
Times New Roman Special G2
Times New Roman Special G2 Bold
Times New Roman Special G2 Bold Italic
Times New Roman Special G2 Italic

Designers

Stanley Morison and Victor Lardent

Copyright

Digitized data copyright The Monotype Corporation 1991-1995. All rights reserved.
Times New Roman? is a trademark of The Monotype Corporation which may be
registered in certain jurisdictions.

Font
vendor

Agfa Monotype Corporation

Script
Tags

N/A

Code
pages

Symbol Symbol Character Set

Fixed
pitch

False

Licensing and redistribution info

Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Times New Roman Special G1

Times New Roman Special G1 Bold

Times New Roman Special G1 Bold Italic

Times New Roman Special G1 Italic

Times New Roman Special G2

Times New Roman Special G2 Bold

Times New Roman Special G2 Bold Italic

Times New Roman Special G2 Italic

Tisa Offc Serif Pro font family
Article • 03/30/2022

Overview
Description
File name

tisaoffcserifpro.ttf
tisaoffcserifpro-bold.ttf
tisaoffcserifpro-bolditalic.ttf
tisaoffcserifpro-italic.ttf
tisaoffcserifpro-thin.ttf
tisaoffcserifpro-thinitalic.ttf

Styles & Weights

Tisa Offc Serif Pro
Tisa Offc Serif Pro Bold
Tisa Offc Serif Pro Bold Italic
Tisa Offc Serif Pro Italic
Tisa Offc Serif Pro Thin
Tisa Offc Serif Pro Thin Italic

Copyright

2009, 2015 Mitja Miklavcic published by FSI FontShop International GmbH

Designers

N/A

Font vendor

Monotype Corporation

Script Tags

dlng:'Latn'
slng:'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1254 Turkish
1257 Windows Baltic

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Tisa Offc Serif Pro

Tisa Offc Serif Pro Bold

Tisa Offc Serif Pro Bold Italic

Tisa Offc Serif Pro Italic

Tisa Offc Serif Pro Thin

Traditional Arabic font family
Article • 03/30/2022

Overview
Traditional Arabic is a TrueType font with Arabic support.
Description
File name

Trado.ttf
Tradbdo.ttf

Styles &
Weights

Traditional Arabic
Traditional Arabic Bold

Designers

N/A

Copyright

© 2015 The Monotype Corporation. Portions © Monotype Imaging. All Rights
Reserved.

Font vendor

Glyph Systems

Script Tags

dlng:'Arab'
slng:'Arab', 'Latn'

Code pages

1252 Latin 1
1256 Arabic
862 Hebrew
437 US

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Product name

Font version

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

1.01

Windows Server 2008

5.00

Windows Server 2003

1.01

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Traditional Arabic

Traditional Arabic Bold

Transport MT font family
Article • 03/30/2022

Overview
Designed by Carolyn Gibbs & Steve Matteson, this is one of a versatile set of art fonts
from Monotype. Trains, planes and automobiles, not to mention a submarine in case you
ever need one as a form of transport. These are clear and simple silhouettes of various
things that might move you, plus a picture of an anchor for some reason. Great for
instant illustrations, icons or bullets.
Description
File name

Trans.ttf

Styles &
Weights

Transport MT

Designers

Carolyn Gibbs and Steve Matteson

Copyright

Digitized data copyright (C) 1991-1995 Monotype Typography, Inc.. All rights
reserved. Monotype? is a trademark of Monotype Typography, Inc. which may be
registered in certain jurisdicions.

Font
vendor

Agfa Monotype Corporation

Script
Tags

N/A

Code

Symbol Symbol Character Set

pages
Fixed

False

pitch

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples

Transport MT

Trebuchet MS font family
07/08/2025

Overview
The Trebuchet typeface family, like Verdana and Georgia, was created for use on the screen.
Designed and engineered in 1996 by Microsoft's Vincent Connare, it has a strong and
unmistakable appearance. Borrowing elements from both the geometric and humanist
classifications of sans serif type - Connare acknowledges the influence of designs as diverse as
Gill Sans, Erbar, Frutiger, Akzidenz Grotesk, and the US Highway signing system - Trebuchet
infuses any page with energy and personality. Its letterforms, loosely based on sans serif
typeface designs of the 1920s and 1930s, carry a large x-height and clean lines designed to
promote legibility, even at small sizes.
Vincent Connare is no stranger to designing and working with type in restrictive environments.
He has spent as many years as anyone solving problems in displaying type on various kinds of
screens, from small handheld devices to wide-screen television sets. Although much of his
working life has been spent making existing typeface designs work in new environments and
technologies, he is already well known for his Comic Sans, which among other faces of his has
received an immediate and warm response from users all over the world. With Trebuchet,
Connare has managed to create a face that has become an instant classic, winning more
admirers day after day.
Perhaps Connare's greatest achievement with the Trebuchet family is to have created a font
that works at heading and display sizes as well as small sizes and low resolutions; no mean task
given the low resolution of the computer screen, which tends to dilute the characteristics of
letterforms, rendering them dull and boring. After all, a lowercase e, which at 8pt on the screen
can be at most four or five pixels high, can only be drawn in a limited number of ways.
One of Connare's intentions when designing Trebuchet was to instill personality into the
letterforms, even at small sizes, while retaining clarity and readability. He wanted to create a
typeface that was 'significantly distinguishable from Verdana and MS Sans'. He has
accomplished this by departing from the classical model in characters such as the lowercase g
and uppercase M, unique yet reminiscent of some of Paul Renner's alternate designs for Futura.
Less noticeable details include the serif-like bars of the lowercase i and j, and the curled,
kicking stem of the lowercase l - efforts intended to make each character as distinct and
recognizable as possible.
Trebuchet is well-suited to use for extended texts, User Interface scenarios, and spreadsheet
design, given the font's narrow letterforms. Trebuchet works brilliantly on the screen and has
quickly become a classic choice for Web page design.

Version history
Version 1.22 - On 1 May 2001 we posted this Trebuchet MS update that includes support for
the full WGL4 character set, including support for Greek and Cyrillic.
Version 1.15 - This version includes some minor table updates, but no new glyphs.
Version 1.10 - In August 1998 the Windows 98 update site's Web font pack was updated to
include Trebuchet MS version 1.10. This version of the font includes the euro currency symbol
but does not feature the full WGL4 character set.
Version 1.00 - Trebuchet MS version 1.00 was added to our collection of 'Core fonts for the
Web' on 11 October 1996. Version 1.00 was also included in the Internet Explorer supplemental
font pack.
ﾉ

Item

Description

File name

Trebuc.ttf
Trebucbd.ttf
Trebucbi.ttf
Trebucit.ttf

Styles & Weights

Trebuchet MS
Trebuchet MS Bold
Trebuchet MS Bold Italic
Trebuchet MS Italic

Designers

Vincent Connare

Copyright

© 2016 Microsoft Corporation. All rights reserved.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Armn', 'Cyrl', 'Grek', 'Latn'
slng:'Armn', 'Cyrl', 'Grek', 'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Expand table

Item

Description

Download

N/A – Exclusively included with Microsoft products and services where applicable.

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
ﾉ

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

1.22

Windows 2000

1.15

Windows 98

0.98

Windows Server 2008

5.00

Windows Server 2003

1.22

Expand table

This typeface is also available within Office applications. For more information visit this page.

Style & weight examples
Trebuchet MS

Tunga font family
Article • 03/30/2022

Overview
Tunga is an OpenType font for the Indic script - Kannada. It is based on Unicode,
contains TrueType outlines and has been designed for use as a UI font.
Description
File name

Tunga.ttf
Tungab.ttf

Styles & Weights

Tunga
Tunga Bold

Designers

Raghunath Joshi (Type Director), Vinay Saynekar

Copyright

© 2015 Microsoft Corporation. All Rights Reserved.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Knda'
slng:'Knda', 'Latn'

Code pages

1252 Latin 1

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Product name

Font version

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

1.06

Windows Server 2008

5.00

Windows Server 2003

1.06

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Tunga

Tunga Bold

Tw Cen MT font family
Article • 06/20/2022

Overview
20th Century was designed and drawn by Sol Hess in the Lanston Monotype drawing
office between 1936 and 1947. The first weights were added to the Monotype typeface
library in 1959. This is a face based on geometric shapes which originated in Germany in
the early 1920's and became an integral part of the Bauhaus movement of that time.
Form and function became the key words, unnecessary decoration was scorned. This
clean cut, sans serif with geometric shapes was most appropriate. The lighter weights
can be used for text setting, the bold and condensed fonts are suitable for display in
headlines and advertising.
ﾉ

Expand table

Description
File name

Tcm_____.ttf
Tcb_____.ttf
Tcbi____.ttf
Tcmi____.ttf
Tccm____.ttf
Tccb____.ttf
Tcceb.ttf

Styles &
Weights

Tw Cen MT
Tw Cen MT Bold
Tw Cen MT Bold Italic
Tw Cen MT Italic
Tw Cen MT Condensed
Tw Cen MT Condensed Bold
Tw Cen MT Condensed Extra Bold

Designers

Sol Hess

Copyright

Digitized data copyright The Monotype Corporation 1991-1997. All rights
reserved. Twentieth Century™ is a trademark of The Monotype Corporation which
may be registered in certain jurisdictions.

Font vendor

Agfa Monotype Corporation

Script Tags

N/A

Description
Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this page.

Style & weight examples
Tw Cen MT

Tw Cen MT Bold

Tw Cen MT Bold Italic

Tw Cen MT Italic

Tw Cen MT Condensed

Tw Cen MT Condensed Bold

Tw Cen MT Condensed Extra Bold

Feedback
Was this page helpful?

 Yes

 No

UD Digi Kyokasho font family
Article • 03/30/2022

Overview
The UD Digi Kyokasho font family is a Windows font that is primarily intended to
support the Japanese language for the education market. It does support characters
used in English and other western European languages but was created primarily to
support the Japanese language. If you want to use the UD Digi Kyokasho font family on
a non-Japanese machine, please install the optional feature, "Japanese Supplemental
Fonts".
“The design of the font adheres to the Japan’s Government requirements to eliminate
discrimination against people with disabilities (effective since 2016). It also conforms to
the educational curriculum guidelines. The font maintains the directionality of
handwriting, and the shapes of tear drops and sweeps, by carefully controlling the
weight of the strokes. Research shows that the font increases readability of textbook
content.” — Morisawa Inc.
Description
File name

UDDigiKyokashoN-B.ttc
UDDigiKyokashoN-R.ttc

Styles & Weights

UD Digi Kyokasho N-R
UD Digi Kyokasho N-B
UD Digi Kyokasho NK-B
UD Digi Kyokasho NK-R
UD Digi Kyokasho NP-B
UD Digi Kyokasho NP-R

Designers

TypeBank Co., Ltd.

Copyright

© Copyright 2016-2017 TypeBank Co., Ltd. All Rights Reserved.

Font vendor

N/A

Script Tags

dlng: 'Hani', 'Hira', 'Hrkt', 'Jpan', 'Kana'
slng: 'Cyrl', 'Grek', 'Hani', 'Hira', 'Hrkt', 'Jpan', 'Kana', 'Latn'

Description
Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
932 JIS/Japan
Mac Roman Macintosh Character Set (US Roman)
OEM OEM Character Set
869 IBM Greek
866 MS-DOS Russian
865 MS-DOS Nordic
863 MS-DOS Canadian French
861 MS-DOS Icelandic
860 MS-DOS Portuguese
857 IBM Turkish
855 IBM Cyrillic; primarily Russian
852 Latin 2
775 MS-DOS Baltic
737 Greek; former 437 G
850 WE/Latin 1
437 US

Fixed pitch

True & False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples

Change list:
Windows 10 version 1709 released on October 17, 2017
UD Digi Kyokasho font family was introduced as part of the Windows 10 Japanese
Supplemental Fonts package.

Univers font family
Article • 03/30/2022

Overview
This font is primarily meant for use in displaying Hindi text in documents. It is an
OpenType font, based on Unicode.
Description
Files

Univers-Regular.ttf
Univers-Condensed.ttf
Univers-Light.ttf
Univers-LightCondensed.ttf
Univers-Bold.ttf
Univers-BoldCondensed.ttf

Styles & Weights

Univers Regular
Univers Condensed Regular
Univers Light
Univers Condensed Light
Univers Bold
Univers Condensed Bold

Designers

Adrian Frutiger

Copyright

Copyright © 2014 Monotype GmbH. All rights reserved.

Font vendor

Monotype Imaging Inc.

Script Tags

dlng: 'Cyrl', 'Grek', 'Latn'
slng: 'Cyrl', 'Grek', 'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
1258 Vietnamese

Fixed pitch

False

Licensing and redistribution info

Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Univers Regular

Univers Condensed Regular

Univers Light

Univers Condensed Light

Univers Bold

Univers Condensed Bold

Urdu Typesetting font family
Article • 03/30/2022

Overview
Description
File name

UrdType.ttf
UrdTypeb.ttf

Styles & Weights

Urdu Typesetting
Urdu Typesetting Bold

Designers

N/A

Copyright

© 2016 Microsoft Corporation. All rights reserved.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Arab', 'Aran'
slng:'Arab', 'Aran', 'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1254 Turkish
1256 Arabic
1257 Windows Baltic
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Product name

Font version

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Urdu Typesetting

Utsaah font family
Article • 03/30/2022

Overview
This font is primarily meant for use in displaying Hindi text in documents. It is an
OpenType font, based on Unicode.
Description
Files

Utsaah.ttf
Utsaahb.ttf
Utsaahi.ttf
Utsaahbi.ttf

Styles & Weights

Utsaah
Utsaah Bold
Utsaah Italic
Utsaah Bold Italic

Designers

N/A

Copyright

Copyright (c) 2011, Modular Infotech, Pune, INDIA. - Licenced to Microsoft

Font vendor

MODI

Script Tags

dlng: 'Deva'
slng: 'Deva', 'Latn'

Code pages

1252 Latin 1

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Utsaah

Utsaah Bold

Utsaah Italic

Utsaah Bold Italic

Vacation MT font family
Article • 03/30/2022

Overview
Designed by Steve Matteson, this is one of a versatile set of art fonts from Monotype.
This font will be extremely useful if you are about to do the artwork for a travel brochure
or the map of a camping site. It consists of stylized simple silhouettes that can make
great instant illustrations, icons or bullets.
Description
File name

Vacation.ttf

Styles &
Weights

Vacation MT

Designers

Steve Matteson

Copyright

Digitized data copyright (C) 1991-1995 Monotype Typography, Inc.. All rights
reserved. Monotype? is a trademark of Monotype Typography, Inc. which may be
registered in certain jurisdicions.

Font
vendor

Agfa Monotype Corporation

Script
Tags

N/A

Code
pages

Symbol Symbol Character Set

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples

Vacation MT

Vani font family
Article • 03/30/2022

Overview
Description
File name

Vani.ttf
Vanib.ttf

Styles & Weights

Vani
Vani Bold

Designers

Muthu Nedumaran

Copyright

© 2015 Microsoft Corporation. All Rights Reserved.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Telu'
slng:'Telu', 'Latn'

Code pages

1252 Latin 1

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Vani

Vani Bold

Verdana font family
07/25/2025

Overview
The Verdana typeface family consists of four TrueType fonts created specifically to address the
challenges of on-screen display. Designed by world renowned type designer Matthew Carter,
and hand-hinted by leading hinting expert, Agfa Monotype's Tom Rickner, these sans serif
fonts are unique examples of type design for the computer screen.
The Verdana family resembles humanist sans serifs such as Frutiger, and Edward Johnston's
typeface for the London Underground, and Carter himself claims to see the influence of his
own Bell Centennial in the face. But to label Verdana a humanist face is to ignore the fact that
this family isn't merely a revival of classical elegance; this is type designed for the medium of
screen.
The Verdana fonts exhibit characteristics derived from the pixel rather than the pen, the brush
or the chisel. The relationship between straight, curved and diagonal strokes has been
painstakingly developed to ensure that the pixel patterns at small sizes are pleasing, clear and
legible. Commonly confused characters, such as the lowercase i j l, the uppercase I J L and the
numeral 1 have been carefully drawn for maximum distinctiveness - an important characteristic
of fonts designed for on-screen use. And the various weights in the typeface family have been
designed to create sufficient contrast from one another ensuring, for example, that the bold
font is heavy enough even at sizes as small as 8 ppem.
The generous width and spacing of Verdana's characters is key to the legibility of these fonts
on the screen. The limited number of pixels available at low resolutions means that tightly set
characters can easily clash; turning an r n into an m, or creating distracting black patches in a
word. In on-screen typography, it's important to keep the characters distinct from one another,
and research has shown that wider letterspacing significantly aids reading from the screen.
The Verdana typeface family was first made available on July 8, 1996. The family is continually
being extended to support multilingual needs.
Despite the quality of the Verdana font family at small sizes it is at higher resolutions that the
fonts are best appreciated. Some of the subtleties of the letterforms, such as the slightly
modulated stroke weight only become truly apparent at larger sizes. In the words of Tom
Rickner, "My hope now is that these faces will be enjoyed beyond just the computer screen.
Although the screen size bitmaps were the most crucial in the production of these fonts [their]
uses should not be limited to on screen typography."

Verdana version history
Version 2.35 - This version of Verdana includes some minor table updates, but no new glyphs.
Version 2.31 - Verdana version 2.31 extends the WGL4 version 2.00 to include the euro currency
symbol and Vietnamese language support.
Version 2.10 - This WGL4 (no euro) version of Verdana was added to our Core fonts for the
Web on 30 September 1997. It was also supplied with Microsoft Internet Explorer 4.0 which
launched on this date. Internet Explorer 3.0 came with Verdana version 1.01.
Version 1.01 - Verdana version 1.01 was added to our Core fonts for the Web on 8 July 1996. It
was also supplied with Microsoft Internet Explorer 3.0 released on 13 August 1996.
ﾉ

Item

Description

File name

Verdana.ttf
Verdanab.ttf
Verdanaz.ttf
Verdanai.ttf

Styles & Weights

Verdana
Verdana Bold
Verdana Bold Italic
Verdana Italic

Designers

Matthew Carter

Copyright

© 2016 Microsoft Corporation. All Rights Reserved.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Armn', 'Cyrl', 'Grek', 'Latn'
slng:'Armn', 'Cyrl', 'Grek', 'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
1258 Vietnamese
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Expand table

Item

Description

Download

N/A – Exclusively included with Microsoft products and services where applicable.

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
ﾉ

Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

2.40

Windows 2000

2.35

Windows 98

2.10

Windows Server 2008

5.00

Windows Server 2003

2.40

Expand table

This typeface is also available within Office applications. For more information visit this page.

Style & weight examples
Verdana

Verdana Pro font family
Article • 03/30/2022

Overview
Description
File name

VerdanaPro-Regular.ttf
VerdanaPro-Italic.ttf
VerdanaPro-Light.ttf
VerdanaPro-LightItalic.ttf
VerdanaPro-SemiBold.ttf
VerdanaPro-SemiBoldItalic.ttf
VerdanaPro-Bold.ttf
VerdanaPro-BoldItalic.ttf
VerdanaPro-Black.ttf
VerdanaPro-BlackItalic.ttf
VerdanaPro-CondLight.ttf
VerdanaPro-CondLightItalic.ttf
VerdanaPro-CondRegular.ttf
VerdanaPro-CondItalic.ttf
VerdanaPro-CondSemiBold.ttf
VerdanaPro-CondSemiBoldItalic.ttf
VerdanaPro-CondBold.ttf
VerdanaPro-CondBoldItalic.ttf
VerdanaPro-CondBlack.ttf
VerdanaPro-CondBlackItalic.ttf

Description
Styles & Weights

Verdana Pro
Verdana Pro Italic
Verdana Pro Light
Verdana Pro Light Italic
Verdana Pro SemiBold
Verdana Pro SemiBold Italic
Verdana Pro Bold
Verdana Pro Bold Italic
Verdana Pro Black
Verdana Pro Black Italic
Verdana Pro Cond Light
Verdana Pro Cond Light Italic
Verdana Pro Cond
Verdana Pro Cond Italic
Verdana Pro Cond SemiBold
Verdana Pro Cond SemiBold Italic
Verdana Pro Cond Bold
Verdana Pro Cond Bold Italic
Verdana Pro Cond Black
Verdana Pro Cond Black Italic

Designers

Matthew Carter, Monotype Imaging, The Font Bureau

Copyright

© 2017 Microsoft Corporation. All Rights Reserved.

Font vendor

Monotype Imaging Inc.

Script Tags

dlng: 'Cyrl', 'Grek', 'Latn'
slng: 'Cyrl', 'Grek', 'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Verdana Pro

Verdana Pro Italic

Verdana Pro Light

Verdana Pro Light Italic

Verdana Pro SemiBold

Verdana Pro SemiBold Italic

Verdana Pro Bold

Verdana Pro Bold Italic

Verdana Pro Black

Verdana Pro Black Italic

Verdana Pro Cond Light

Verdana Pro Cond Light Italic

Verdana Pro Cond

Verdana Pro Cond Italic

Verdana Pro Cond SemiBold

Verdana Pro Cond SemiBold Italic

Verdana Pro Cond Bold

Verdana Pro Cond Bold Italic

Verdana Pro Cond Black

Verdana Pro Cond Black Italic

Change list:
Windows 10 version 1507 released on July 29, 2015

Verdana Pro font family was introduced as part of the Windows 10 Pan-European
Supplemental Fonts package.

Verdana Ref font family
Article • 03/30/2022

Overview
Custom version of Verdana for use with Microsoft Reference.
Description
File name

Verdref.ttf

Styles & Weights

Verdana Ref

Designers

Matthew Carter

Copyright

Typeface and data © 1996 Microsoft Corporation. All Rights Reserved

Font vendor

Microsoft Corp.

Script Tags

N/A

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
1258 Vietnamese
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Verdana Ref

Vijaya font family
Article • 03/30/2022

Overview
This font is primarily meant for use in displaying Tamil text in documents. It is an
OpenType font, based on Unicode.
Description
File name

Vijaya.ttf
Vijayab.ttf

Styles & Weights

Vijaya
Vijaya Bold

Designers

N/A

Copyright

Copyright © 2001, Modular Infotech, Pune, INDIA. - Licensed to Microsoft.

Font vendor

MODI

Script Tags

dlng:'Taml'
slng:'Taml', 'Latn'

Code pages

1252 Latin 1

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Product name

Font version

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Vijaya

Vijaya Bold

Viner Hand ITC font family
Article • 03/30/2022

Overview
ITC Viner Hand? is an informal script face that is based on the handwriting of British
designer John Viner. Viner learned the craft of brush lettering during the late 1940s
while he was working at a firm that produced posters for the Gaumont and Odeon
cinema circuits. After serving in the Royal Air Force, he moved to London and worked as
a lettering and general artist in print studios which produced artwork for major
advertising agencies. Released in 1996, ITC Viner Hand has a relaxed rhythm typical of
handwriting and lends a personal touch to computer generated copy.
Description
File name

Vineritc.ttf

Styles &
Weights

Viner Hand ITC

Designers

John Viner

Copyright

Copyright (c) International Typeface Corporation 1996. Portions Copyright (c)
Microsoft Corporation 1996. All rights reserved.

Font
vendor

ITC

Script
Tags

N/A

Code
pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed
pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Viner Hand ITC

Vivaldi font family
Article • 03/30/2022

Overview
Vivaldi Font was designed by Fritz Peters in 1970. Vivaldi font is a Script Old Style font.
Vivaldi font attributes include 1970s, elegant, script.
Description
File name

Vivaldii.ttf

Styles & Weights

Vivaldi Italic

Designers

Fritz Peters, 1970

Copyright

URW Software, Copyright 1993 by URW

Font vendor

URW Type Foundry

Script Tags

N/A

Code pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Vivaldi Italic

Vixar ASCI font family
Article • 03/30/2022

Overview
A narrow display font designed in 1995 by Vincent Connare. Only contains the ASCII
character set.
Description
File name

Vixarasc.ttf

Styles & Weights

Vixar ASCI

Designers

Vincent Connare

Copyright

Copyright © 1995 Microsoft Corporation. All rights reserved.

Font vendor

Microsoft Corporation

Script Tags

N/A

Code pages

1252 Latin 1

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Vixar ASCI

Vladimir Script font family
Article • 03/30/2022

Overview
Vladimir Script Font was designed by Andrich Vladimir. Vladimir Script font is a Script
Modern Style font.
Description
File name

Vladimir.ttf

Styles &
Weights

Vladimir Script

Designers

Andrich Vladimir, 1995

Copyright

Typeface: URW Software, Copyright (c) 1995 by URW. Data: Copyright (c) 1995
Microsoft Corporation. All rights reserved.

Font
vendor

URW Type Foundry

Script Tags

N/A

Code
pages

1252 Latin 1
Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples
Vladimir Script

Vrinda font family
Article • 03/30/2022

Overview
Vrinda is an OpenType font for the Indic script - Bengali. It is based on Unicode?,
contains TrueType outlines and has been designed for use as a UI font.
Description
File name

Vrinda.ttf
Vrindab.ttf

Styles & Weights

Vrinda
Vrinda Bold

Designers

Raghunath Joshi (Type Director), Vinay Saynekar

Copyright

© 2015 Microsoft Corporation. All Rights Reserved.

Font vendor

MS

Script Tags

dlng:'Beng'
slng:'Beng', 'Latn'

Code pages

1252 Latin 1

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Product name

Font version

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.90

Windows XP SP2

1.03

This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Vrinda

Vrinda Bold

Walbaum font family
Article • 03/30/2022

Overview
A careful restoration of 200-year-old typeface Walbaum, this modern serif blends charm
and warmth together – offering a range of impressively sculpted display forms, and
hard-working text weights. There isn't a place where Walbaum can’t work. From massive
billboards, to micro-type on e-readers, this family has it covered.
Originally designed in Germany in the early 1800s, Justus Erich Walbaum’s modern
typefaces never garnered the audience or acclaim they deserved. The calamity of the
Napoleonic Wars and the tragic death of Walbaum's son and typefounding heir,
Theodor, combined to remove his faces from any widespread use for nearly one
hundred years. Two centuries later, Monotype designers, Carl Crossgrove and Charles
Nix discovered their mutual admiration for Walbaum and set out to give it the
contemporary facelift it deserved. With the mantra “What Would Justus Do?” always in
mind, they set out to expand and update the family for today's varied print and digital
environments. They split the work into three parts: Crossgrove taking on the workhorse
text weights; Nix tackling the dramatic display range; and Monotype designer Juan
Villanueva developing the rich trove of ornaments found in Walbaum’s original
specimens.
Justus Walbaum’s original display sizes were relatively limited. But given the time, the
tools, and the array of type uses of today, what would Justus have made? Nix's display
designs dramatically expand the scope, preserving the fluid transition from small to
large, but adding a striking array of thin to black weights. Some inspiration for the
darker weights came from the work of Walbaum’s son, Theodor, who pushed his father’s
modern style far more into the arena of the corpulent. Nix looked to push it even
further, taking cues from Noguchi’s sculpture, revealing form by carefully subtracting
from a solid mass. The lowercase in the fattest, blackest weights are like slabs of basalt
subtly sculpted to yield letters.
Crossgrove, a master of text type, focused on what originally drew him to Walbaum’s
work—the combination of legibility and warmth lacking in so many other modern
families. Like a deft conservator, he carefully preserved the original spacing, contrast,
and proportions, while introducing details that allow the designs to fully function in the
21st century. A range of weights; a much more robust character set; and the ability to
move seamlessly between the micro and macro of the text range are just a few of the
future-proofing steps Crossgrove introduced.

For Villanueva, the inspiration was to capture the beauty that was so evident in the
ornaments that Nix found while researching original specimens in New York, Leipzig,
and Berlin. He took hundreds of detailed photos giving Juan a nearly microscopic view
of Walbaum’s work. Villanueva found inspiration in the idea that ornaments are a rare
commodity in today’s typographic market. He felt that these are not only an important
part of the Walbaum legacy, but that they’re exciting and relevant to today’s
typographic designer.
Description
File name

walbaumdisp-rg.ttf
walbaumdisp-bd.ttf
walbaumdisp-bdit.ttf
walbaumdisp-hv-rg.ttf
walbaumdisp-hv-it.ttf
walbaumdisp-it.ttf
walbaumdisp-lt-rg.ttf
walbaumdisp-lt-it.ttf
walbaumdisp-sb-rg.ttf
walbaumdisp-sb-it.ttf
walbaumhead-rg.ttf
walbaumhead-bd.ttf
walbaumhead-bdit.ttf
walbaumhead-it.ttf
walbaumtext-rg.ttf
walbaumtext-bd.ttf
walbaumtext-bdit.ttf
walbaumtext-it.ttf

Styles &

Walbaum Display

Weights

Walbaum Display Bold
Walbaum Display Bold Italic
Walbaum Display Heavy
Walbaum Display Heavy Italic
Walbaum Display Italic
Walbaum Display Light
Walbaum Display Light Italic
Walbaum Display SemiBold
Walbaum Display SemiBold Italic
Walbaum Heading
Walbaum Heading Bold
Walbaum Heading Bold Italic
Walbaum Heading Italic
Walbaum Text
Walbaum Text Bold
Walbaum Text Bold Italic
Walbaum Text Italic

Description
Copyright

Copyright © 2018 Monotype Imaging Inc. All rights reserved.

Designers

Juan Villanueva, Charles Nix, Carl Crossgrove, Lynne Yun, Justus Erich
Walbaum

Font vendor

Monotype Corporation

Script Tags

dlng:'Latn'
slng:'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1254 Turkish
1257 Windows Baltic

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Walbaum Display

Walbaum Display Bold

Walbaum Bold Italic

Walbaum Display Heavy

Walbaum Display Heavy Italic

Walbaum Display Italic

Walbaum Display Light

Walbaum Display Light Italic

Walbaum Display SemiBold

Walbaum Display SemiBold Italic

Walbaum Heading

Walbaum Heading Bold

Walbaum Heading Bold Italic

Walbaum Heading Italic

Walbaum Text

Walbaum Text Bold

Walbaum Text Bold Italic

Walbaum Text Italic

Webdings font family
Article • 03/30/2022

Overview
Webdings is a symbol font designed in 1997 as a response to the need of Web
designers for a fast and easy method of incorporating graphics in their pages.
The font contains a wide variety of Web-related images of the kind found in common
use across the Web, as well as some more unusual drawings. User Interface icons
suitable for creating page navigation elements are also included.
Webdings is ideal for enriching the appearance of a Web page. Because it?s a font, it can
be installed on the user?s system, (or embedded in the document itself) is fully scaleable
and quick to render. It?s a perfect way of including graphics on your site without making
users wait for lots of graphic files to download. Each Webding? has been fine-tuned to
ensure high quality and clarity on the screen, regardless of the complexity of the
individual symbol.
Webdings is a result of a collaborative effort between Microsoft?s Vincent Connare - the
designer of Comic Sans MS and Trebuchet MS - and top Monotype designers Sue
Lightfoot, Ian Patterson and Geraldine Wade.

Webdings
Version 1.03 - Webdings version 1.03 is a minor update. A digital signature was added to
the font file.
Version 1.01 - Webdings was added to our core fonts for the Web on 4 June 1997 and
was also added to the core fonts installed with Internet Explorer 4.0 on 14 July 1997.
Description
File name

Webdings.ttf

Styles & Weights

Webdings

Designers

V.Connare,S.Lightfoot,I.Patterson,G.Wade

Copyright

© 2006 Microsoft Corporation. All Rights Reserved.

Font vendor

Microsoft Corp.

Description
Script Tags

dlng:'Zsym'
slng:'Zsym'

Code pages

Symbol Symbol Character Set

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP

1.03

Windows 2000

1.03

Windows 98

1.01

Windows Server 2008

5.00

Windows Server 2003

1.03

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples

Webdings

Westminster font family
Article • 03/30/2022

Overview
In the mid-1960s after banks began printing machine-readable account numbers on
checks, a British font designer made an entire typeface along the same lines. No one
took this typeface seriously, however, until Photoscript produced it, naming the typeface
after the bank that helped Photoscript fund the font's production. Westminster was an
instant hit, and the very font makers who had previously rejected the idea rushed out to
commission alternative designs. This is the first of those designs, and it's the best.
Although you're welcome to use only the numbers (perhaps you run a bank), the rest of
the face can provide a number of interesting uses at both large and small sizes.
Description
File name

Westm.ttf

Styles &
Weights

Westminster

Designers

N/A

Copyright

Data by Eraman, Ltd., and Type Solutions, Inc. © 1993. Microsoft Corporation. All
rights reserved.

Font vendor

N/A

Script Tags

N/A

Code pages

437 US

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Style & weight examples

Westminster

Wide Latin font family
Article • 03/30/2022

Overview
Wide Latin has been much used and not a little abused as well. For example, more
logotypes than you can shake a stick at have used Wide Latin. It has also been used with
the serifs knocked off the right hand side to give a feeling of speed. Sometimes the type
will be oblique as well. Do you remember the PanAm Airlines logo?
Description
File name

Latinwd.ttf

Styles &
Weights

Wide Latin

Designers

N. N., 1940

Copyright

Typeface © 1992 Stphenson Blake (Holdings) Ltd. Data © 1992 URW. Portions ©
1992 Microsoft Corp. All rights reserved.

Font
vendor

URW Type Foundry

Script Tags

N/A

Code

1252 Latin 1

pages

Mac Roman Macintosh Character Set (US Roman)

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
This typeface is available within Office applications. For more information visit this
page.

Style & weight examples
Wide Latin

Wingdings font family
Article • 03/30/2022

Overview
The Wingdings fonts were designed by Kris Holmes and Charles Bigelow in 1990 and
1991. The fonts were originally named Lucida Icons, Arrows, and Stars to complement
the Lucida text font family by the same designers. Renamed, reorganized, and released
in 1992 as Microsoft Wingdings(TM), the three fonts provide a harmoniously designed
set of icons representing the common components of personal computer systems and
the elements of graphical user interfaces. There are icons for PC, monitor, keyboard,
mouse, trackball, hard drive, diskette, tape cassette, printer, fax, etc., as well as icons for
file folders, documents, mail, mailboxes, windows, clipboard, and wastebasket. In
addition, Wingdings includes icons with both traditional and computer significance,
such as writing tools and hands, reading glasses, clipping scissors, bell, bomb, check
boxes, as well as more traditional images such as weather signs, religious symbols,
astrological signs, encircled numerals, a selection of ampersands and interrobangs, plus
elegant flowers and flourishes. Pointing and indicating are frequent functions in
graphical interfaces, so in adition to a wide selection of pointing hands, the Wingdings
fonts also offer arrows in careful gradations of weight and different directions and styles.
For variety and impact as bullets, asterisks, and ornaments, Windings also offers a varied
set of geometric circles, squares, polygons, targets, and stars.
Description
File name

Wingding.ttf
Wingdng2.ttf
Wingdng3.ttf

Styles & Weights

Wingdings
Wingdings 2
Wingdings 3

Designers

N/A

Copyright

© 2006 Microsoft Corporation. All Rights Reserved.

Font vendor

Microsoft Corp.

Script Tags

dlng:'Zsym'
slng:'Zsym'

Code pages

Symbol Symbol Character Set

Description
Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

Windows 8

See the Windows 8 page.

Windows 7

See the Windows 7 page.

Windows Vista

5.00

Windows XP SP2

2.55

Windows XP

2.55

Windows 2000

2.55

Windows 98 Second Edition

2.55

Windows 98

2.50

Windows 95

2.00

Windows 3.1

1.00

Windows Server 2008

5.00

Windows Server 2003

2.55

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Wingdings

Wingdings 2

Wingdings 3

Yu Gothic font family
Article • 03/30/2022

Overview
Description
File name

YuGothL.ttc
YuGothR.ttc
Yugothm.ttc
YuGothB.ttc

Styles & Weights

Yu Gothic Light
Yu Gothic Regular
Yu Gothic Medium
Yu Gothic Bold
Yu Gothic UI Light
Yu Gothic UI Semilight
Yu Gothic UI Regular
Yu Gothic UI Semibold
Yu Gothic UI Bold

Designers

JIYUKOBO Ltd.

Copyright

Copyright © 2018 JIYUKOBO Ltd. All Rights Reserved.

Font vendor

JIYUKOBO Ltd.

Script Tags

dlng: 'Jpan', 'Hrkt', 'Hira', 'Kana'
slng: 'Jpan', 'Hrkt', 'Hira', 'Kana', 'Latn', 'Grek', 'Cyrl'

Description
Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
932 JIS/Japan
Mac Roman Macintosh Character Set (US Roman)
OEM OEM Character Set
869 IBM Greek
866 MS-DOS Russian
865 MS-DOS Nordic
863 MS-DOS Canadian French
861 MS-DOS Icelandic
860 MS-DOS Portuguese
857 IBM Turkish
855 IBM Cyrillic; primarily Russian
852 Latin 2
775 MS-DOS Baltic
737 Greek; former 437 G
850 WE/Latin 1
437 US

Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples

Change list:
Windows 10 version 1507 released on July 29, 2015
The following style was added and
Yu Gothic Medium
Yu Gothic UI component was added to the family.
Yu Gothic UI Light
Yu Gothic UI Semilight
Yu Gothic UI Regular
Yu Gothic UI Semibold
Yu Gothic UI Bold

Windows 8.1

Yu Gothic was introduced as part of the Windows fonts collection. Initially it was
available in three styles
Yu Gothic Light
Yu Gothic
Yu Gothic Bold

Yu Mincho font family
Article • 03/30/2022

Overview
Description
File name

Yuminl.ttf
Yumin.ttf
Yumindb.ttf

Styles & Weights

Yu Mincho Light
Yu Mincho Regular
Yu Mincho Demibold

Designers

JIYUKOBO Ltd.

Copyright

Copyright © 2017 JIYUKOBO Ltd. All Rights Reserved.

Font vendor

JIYUKOBO Ltd.

Script Tags

dlng: 'Hani', 'Hira', 'Hrkt', 'Jpan', 'Kana'
slng: 'Cyrl', 'Grek', 'Hani', 'Hira', 'Hrkt', 'Jpan', 'Kana', 'Latn'

Code pages

1252 Latin 1
1250 Latin 2: Eastern Europe
1251 Cyrillic
1253 Greek
1254 Turkish
1257 Windows Baltic
932 JIS/Japan
Mac Roman Macintosh Character Set (US Roman)
OEM OEM Character Set
869 IBM Greek
866 MS-DOS Russian
865 MS-DOS Nordic
863 MS-DOS Canadian French
861 MS-DOS Icelandic
860 MS-DOS Portuguese
857 IBM Turkish
855 IBM Cyrillic; primarily Russian
852 Latin 2
775 MS-DOS Baltic
737 Greek; former 437 G
850 WE/Latin 1
437 US

Description
Fixed pitch

False

Licensing and redistribution info
Font redistribution FAQ for Windows
License Microsoft fonts

for enterprises, web developers, for hardware & software

redistribution or server installations

Products that supply this font
Product name

Font version

Windows 11

See the Windows 11 page.

Windows 10

See the Windows 10 page.

Windows 8.1

See the Windows 8.1 page.

This typeface is also available within Office applications. For more information visit this
page.

Style & weight examples
Yu Mincho Light

Yu Mincho Regular

Yu Mincho Demibold

Windows 11 font list
Article • 06/16/2022

Introduction
This is a list of fonts that shipped with Windows 11. Your versions numbers may be
different if you did not apply Windows updates.
Family

Font Name

File Name

Version

Arial

Arial

Arial.ttf

7.00

Arial Italic

Ariali.ttf

7.00

Arial Bold

Arialbd.ttf

7.00

Arial Bold Italic

Arialbi.ttf

7.00

Arial Black

Arial Black

Ariblk.ttf

5.23

Bahnschrift

Bahnschrift

Bahnschrift.ttf

2.06

Calibri

Calibri Light

Calibril.ttf

6.23

Calibri Light Italic

Calibrili.ttf

6.23

Calibri

Calibri.ttf

6.23

Calibri Italic

Calibrii.ttf

6.23

Calibri Bold

Calibrib.ttf

6.23

Calibri Bold Italic

Calibriz.ttf

6.23

Cambria

Cambria.ttc

6.99

Cambria Italic

Cambriai.ttf

6.98

Cambria Bold

Cambriab.ttf

6.98

Cambria Bold Italic

Cambriaz.ttf

6.98

Cambria Math

Cambria Math

Cambria.ttc

6.99

Candara

Candara Light

Candaral.ttf

5.63

Candara Light Italic

Candarali.ttf

5.63

Candara

Candara.ttf

5.62

Cambria

Cascadia Code

Cascadia Mono

Comic Sans MS

Candara Italic

Candarai.ttf

5.62

Candara Bold

Candarab.ttf

5.62

Candara Bold Italic

Candaraz.ttf

5.62

Cascadia Code ExtraLight *

CascadiaCode.ttf

2111.001

Cascadia Code ExtraLight Italic *

CascadiaCode Italic.ttf

2111.001

Cascadia Code Light *

CascadiaCode.ttf

2111.001

Cascadia Code Light Italic *

CascadiaCode.ttf

2111.001

Cascadia Code SemiLight *

CascadiaCode Italic.ttf

2111.001

Cascadia Code SemiLight Italic *

CascadiaCode.ttf

2111.001

Cascadia Code Regular *

CascadiaCode Italic.ttf

2111.001

Cascadia Code Italic *

CascadiaCode.ttf

2111.001

Cascadia Code SemiBold *

CascadiaCode Italic.ttf

2111.001

Cascadia Code SemiBold Italic *

CascadiaCode.ttf

2111.001

Cascadia Code Bold *

CascadiaCode Italic.ttf

2111.001

Cascadia Code Bold Italic *

CascadiaCode.ttf

2111.001

Cascadia Mono ExtraLight *

CascadiaMono.ttf

2111.001

Cascadia Mono ExtraLight Italic *

CascadiaMono Italic.ttf

2111.001

Cascadia Mono Light *

CascadiaMono.ttf

2111.001

Cascadia Mono Light Italic *

CascadiaMono.ttf

2111.001

Cascadia Mono SemiLight *

CascadiaMono Italic.ttf

2111.001

Cascadia Mono SemiLight Italic *

CascadiaMono.ttf

2111.001

Cascadia Mono Regular *

CascadiaMono Italic.ttf

2111.001

Cascadia Mono Italic *

CascadiaMono.ttf

2111.001

Cascadia Mono SemiBold *

CascadiaMono Italic.ttf

2111.001

Cascadia Mono SemiBold Italic *

CascadiaMono.ttf

2111.001

Cascadia Mono Bold *

CascadiaMono Italic.ttf

2111.001

Cascadia Mono Bold Italic *

CascadiaMono.ttf

2111.001

Comic Sans MS

Comic.ttf

5.14

Comic Sans MS Italic

Comici.ttf

5.14

Comic Sans MS Bold

Comicbd.ttf

5.14

Comic Sans MS Bold Italic

Comicz.ttf

5.14

Consolas

Consola.ttf

7.00

Consolas Italic

Consolai.ttf

7.00

Consolas Bold

Consolab.ttf

7.00

Consolas Bold Italic

Consolaz.ttf

7.00

Constantia

Constan.ttf

5.93

Constantia Italic

Constani.ttf

5.93

Constantia Bold

Constanb.ttf

5.93

Constantia Bold Italic

Constanz.ttf

5.93

Corbel Light

Corbell.ttf

6.01

Corbel Light Italic

Corbelli.ttf

6.01

Corbel

Corbel.ttf

6.01

Corbel Italic

Corbeli.ttf

6.01

Corbel Bold

Corbelb.ttf

6.01

Corbel Bold Italic

Corbelz.ttf

6.01

Courier New

Cour.ttf

6.92

Courier New Italic

Couri.ttf

6.91

Courier New Bold

Courbd.ttf

6.92

Courier New Bold Italic

Courbi.ttf

6.91

Ebrima

Ebrima.ttf

5.16

Ebrima Bold

Ebrimabd.ttf

5.16

Franklin Gothic Medium

Framd.ttf

5.02

Franklin Gothic Medium Italic

Framdit.ttf

5.01

Gabriola

Gabriola

Gabriola.ttf

5.93

Gadugi

Gadugi

Gadugi.ttf

1.12

Consolas

Constantia

Corbel

Courier New

Ebrima

Franklin Gothic
Medium

Gadugi Bold

Gadugib.ttf

1.12

Georgia

Georgia.ttf

5.59

Georgia Italic

Georgiai.ttf

5.59

Georgia Bold

Georgiab.ttf

5.59

Georgia Bold Italic

Georgiaz.ttf

5.59

HoloLens MDL2
Assets

HoloLens MDL2 Assets

Holomdl2.ttf

2.02

Impact

Impact

Impact.ttf

5.11

Ink Free

Ink Free

Inkfree.ttf

1.02

Javanese Text

Javanese Text

Javatext.ttf

1.10

Leelawadee UI

Leelawadee UI

Leelawui.ttf

5.05

Leelawadee UI Semilight

Leeluisl.ttf

5.05

Leelawadee UI Bold

Leelauib.ttf

5.05

Lucida Console

Lucida Console

Lucon.ttf

5.01

Lucida Sans Unicode

Lucida Sans Unicode

L_10646.ttf

5.01

Malgun Gothic

Malgun Gothic

Malgun.ttf

6.68

Malgun Gothic Bold

Malgunbd.ttf

6.68

Malgun Gothic Semilight

Malgunsl.ttf

6.68

Marlett

Marlett

Marlett.ttf

5.01

Microsoft Himalaya

Microsoft Himalaya

Himalaya.ttf

5.23

Microsoft JhengHei

Microsoft JhengHei Light

Msjhl.ttc

6.14

Microsoft JhengHei

Msjh.ttc

6.14

Microsoft JhengHei Bold

MSJHBD.ttc

6.13

Microsoft JhengHei UI Light

Msjhl.ttc

6.14

Microsoft JhengHei UI

Msjh.ttc

6.14

Microsoft JhengHei UI Bold

MSJHBD.ttc

6.13

Microsoft New Tai Lue

Ntailu.ttf

5.99

Georgia

Microsoft New Tai
Lue

Microsoft New Tai Lue Bold

Ntailub.ttf

5.99

Microsoft PhagsPa

Phagspa.ttf

6.00

Microsoft PhagsPa Bold

PhagsPaB.ttf

6.00

Microsoft Sans Serif

Microsoft Sans Serif

Micross.ttf

7.01

Microsoft Tai Le

Microsoft Tai Le

Taile.ttf

6.00

Microsoft Tai Le Bold

TaiLeb.ttf

6.00

Microsoft YaHei Light

Msyhl.ttc

6.23

Microsoft YaHei

Msyh.ttc

6.25

Microsoft YaHei Bold

Msyhbd.ttc

6.25

Microsoft YaHei UI Light

Msyhl.ttc

6.23

Microsoft YaHei UI

Msyh.ttc

6.25

Microsoft YaHei UI Bold

Msyhbd.ttc

6.25

Microsoft Yi Baiti

Microsoft Yi Baiti

Msyi.ttf

6.00

MingLiU-ExtB

MingLiU-ExtB

Mingliub.ttc

7.02

PMingLiU-ExtB

Mingliub.ttc

7.02

MingLiU_HKSCS-ExtB

Mingliub.ttc

7.02

Mongolian Baiti

Mongolian Baiti

Monbaiti.ttf

5.53

MS Gothic

MS Gothic

Msgothic.ttc

5.32

MS PGothic

Msgothic.ttc

5.32

MS UI Gothic

Msgothic.ttc

5.32

MV Boli

MV Boli

Mvboli.ttf

6.84

Myanmar Text

Myanmar Text

Mmrtext.ttf

1.19

Myanmar Text Bold

Mmrtextb.ttf

1.19

Nirmala UI Semilight

Nirmalas.ttf

1.41

Nirmala UI

Nirmala.ttf

1.41

Nirmala UI Bold

Nirmalab.ttf

1.41

Palatino Linotype

Pala.ttf

5.03

Palatino Linotype Italic

Palai.ttf

5.03

Microsoft PhagsPa

Microsoft YaHei

Nirmala UI

Palatino Linotype

Palatino Linotype Bold

Palab.ttf

5.03

Palatino Linotype Bold Italic

Palabi.ttf

5.03

Segoe Fluent Icons

Segoe Fluent Icons *

SegoeIcons.ttf

1.00

Segoe MDL2 Assets

Segoe MDL2 Assets

Segmdl2.ttf

1.86

Segoe Print

Segoe Print

Segoepr.ttf

5.04

Segoe Print Bold

Segoeprb.ttf

5.04

Segoe Script

Segoesc.ttf

5.02

Segoe Script Bold

Segoescb.ttf

5.02

Segoe UI Light

Segoeuil.ttf

5.62

Segoe UI Light Italic

Seguili.ttf

5.32

Segoe UI Semilight

Segoeuisl.ttf

5.62

Segoe UI Semilight Italic

Seguisli.ttf

5.32

Segoe UI

Segoeui.ttf

5.62

Segoe UI Italic

Segoeuii.ttf

5.32

Segoe UI Semibold

Seguisb.ttf

5.62

Segoe UI Semibold Italic

Seguisbi.ttf

5.32

Segoe UI Bold

Segoeuib.ttf

5.62

Segoe UI Bold Italic

Segoeuiz.ttf

5.32

Segoe UI Black

Seguibl.ttf

2.02

Segoe UI Black Italic

Seguibli.ttf

2.02

Segoe UI Emoji

Segoe UI Emoji

Seguiemj.ttf

1.33

Segoe UI Historic

Segoe UI Historic

Seguihis.ttf

1.06

Segoe UI Symbol

Segoe UI Symbol

Seguisym.ttf

6.23

Segoe UI Variable

Segoe UI Variable Display Light *

SegUIVar.ttf

2.00

Segoe UI Variable Display
Semilight *

SegUIVar.ttf

2.00

Segoe UI Variable Display

SegUIVar.ttf

2.00

Segoe Script

Segoe UI

Regular *

Segoe UI Variable Display
Semibold *

SegUIVar.ttf

2.00

Segoe UI Variable Display Bold *

SegUIVar.ttf

2.00

Segoe UI Variable Small Light *

SegUIVar.ttf

2.00

Segoe UI Variable Small

SegUIVar.ttf

2.00

Segoe UI Variable Small Regular
*

SegUIVar.ttf

2.00

Segoe UI Variable Small
Semibold *

SegUIVar.ttf

2.00

Segoe UI Variable Small Bold *

SegUIVar.ttf

2.00

Segoe UI Variable Text Light *

SegUIVar.ttf

2.00

Segoe UI Variable Text Semilight
*

SegUIVar.ttf

2.00

Segoe UI Variable Text Regular *

SegUIVar.ttf

2.00

Segoe UI Variable Text Semibold
*

SegUIVar.ttf

2.00

Segoe UI Variable Text Bold *

SegUIVar.ttf

2.00

SimSun

Simsun.ttc

5.18

NSimSun

Simsun.ttc

5.18

SimSun-ExtB

Simsunb.ttf

5.04

Sitka Banner

SitkaVF.ttf

2.00

Sitka Banner Italic

SitkaVF-Italic.ttf

2.00

Sitka Banner Semibold *

SitkaVF.ttf

2.00

Sitka Banner Semibold Italic *

SitkaVF-Italic.ttf

2.00

Sitka Banner Bold

SitkaVF.ttf

2.00

Sitka Banner Bold Italic

SitkaVF-Italic.ttf

2.00

Sitka Display

SitkaVF.ttf

2.00

Sitka Display Italic

SitkaVF-Italic.ttf

2.00

Sitka Display Semibold *

SitkaVF.ttf

2.00

Semilight *

SimSun

Sitka

Sitka Display Semibold Italic *

SitkaVF-Italic.ttf

2.00

Sitka Display Bold

SitkaVF.ttf

2.00

Sitka Display Bold Italic

SitkaVF-Italic.ttf

2.00

Sitka Small

SitkaVF.ttf

2.00

Sitka Small Italic

SitkaVF-Italic.ttf

2.00

Sitka Small Semibold *

SitkaVF.ttf

2.00

Sitka Small Semibold Italic *

SitkaVF-Italic.ttf

2.00

Sitka Small Bold

SitkaVF.ttf

2.00

Sitka Small Bold Italic

SitkaVF-Italic.ttf

2.00

Sitka Heading

SitkaVF.ttf

2.00

Sitka Heading Italic

SitkaVF-Italic.ttf

2.00

Sitka Heading Semibold *

SitkaVF.ttf

2.00

Sitka Heading Semibold Italic *

SitkaVF-Italic.ttf

2.00

Sitka Heading Bold

SitkaVF.ttf

2.00

Sitka Heading Bold Italic

SitkaVF-Italic.ttf

2.00

Sitka Subheading

SitkaVF.ttf

2.00

Sitka Subheading Italic

SitkaVF-Italic.ttf

2.00

Sitka Subheading Semibold *

SitkaVF.ttf

2.00

Sitka Subheading Semibold Italic
*

SitkaVF-Italic.ttf

2.00

Sitka Subheading Bold

SitkaVF.ttf

2.00

Sitka Subheading Bold Italic

SitkaVF-Italic.ttf

2.00

Sitka Text

SitkaVF.ttf

2.00

Sitka Text Italic

SitkaVF-Italic.ttf

2.00

Sitka Text Semibold *

SitkaVF.ttf

2.00

Sitka Text Semibold Italic *

SitkaVF-Italic.ttf

2.00

Sitka Text Bold

SitkaVF.ttf

2.00

Sitka Text Bold Italic

SitkaVF-Italic.ttf

2.00

Sylfaen

Sylfaen

Sylfaen.ttf

5.06

Symbol

Symbol

Symbol.ttf

5.01

Tahoma

Tahoma

Tahoma.ttf

7.00

Tahoma Bold

Tahomabd.ttf

7.00

Times New Roman

Times.ttf

7.01

Times New Roman Italic

Timesi.ttf

7.01

Times New Roman Bold

Timesbd.ttf

7.01

Times New Roman Bold Italic

Timesbi.ttf

7.01

Trebuchet MS

Trebuc.ttf

5.15

Trebuchet MS Italic

Trebucit.ttf

5.15

Trebuchet MS Bold

Trebucbd.ttf

5.15

Trebuchet MS Bold Italic

Trebucbi.ttf

5.15

Verdana

Verdana.ttf

5.33

Verdana Italic

Verdanai.ttf

5.33

Verdana Bold

Verdanab.ttf

5.33

Verdana Bold Italic

Verdanaz.ttf

5.33

Webdings

Webdings

Webdings.ttf

5.01

Wingdings

Wingdings

Wingding.ttf

5.01

Yu Gothic

Yu Gothic Light

YuGothL.ttc

1.90

Yu Gothic Regular

YuGothR.ttc

1.93

Yu Gothic Medium

Yugothm.ttc

1.93

Yu Gothic Bold

YuGothB.ttc

1.93

Yu Gothic UI Light

YuGothL.ttc

1.93

Yu Gothic UI Semilight

YuGothR.ttc

1.93

Yu Gothic UI Regular

Yugothm.ttc

1.93

Yu Gothic UI Semibold

YuGothB.ttc

1.93

Yu Gothic UI Bold

YuGothB.ttc

1.93

Times New Roman

Trebuchet MS

Verdana

Fonts included in Feature On Demand (FOD)
packages
Here's a comprehensive listing of which font families are included with each of the
optional font features. Some font families may include multiple fonts for different
weights and styles.

Arabic Script Supplemental Fonts
Languages using Arabic script; e.g., Arabic, Persian, Urdu.
Family

Font Name

File Name

Version

Aldhabi

Aldhabi

Aldhabi.ttf

6.84

Andalus

Andalus

Andlso.ttf

6.84

Arabic Typesetting

Arabic Typesetting

Arabtype.ttf

6.84

Microsoft Uighur

Microsoft Uighur

Msuighur.ttf

7.00

Microsoft Uighur Bold

MSUighub.ttf

7.00

Sakkal Majalla

Majalla.ttf

6.86

Sakkal Majalla Bold

Majallab.ttf

6.86

Simplified Arabic

Simpo.ttf

6.98

Simplified Arabic Bold

Simpbdo.ttf

6.98

Simplified Arabic Fixed

Simpfxo.ttf

6.84

Traditional Arabic

Trado.ttf

6.84

Traditional Arabic Bold

Tradbdo.ttf

6.84

Urdu Typesetting

UrdType.ttf

6.86

Urdu Typesetting Bold

UrdTypeb.ttf

6.86

Sakkal Majalla

Simplified Arabic

Traditional Arabic

Urdu Typesetting

Bangla Script Supplemental Fonts
Languages using Bangla script; e.g., Assamese, Bangla.

Family

Font Name

File Name

Version

Shonar Bangla

Shonar Bangla

Shonar.ttf

6.90

Shonar Bangla Bold

Shonarb.ttf

6.90

Vrinda

Vrinda.ttf

6.90

Vrinda Bold

Vrindab.ttf

6.90

Vrinda

Canadian Aboriginal Syllabics Supplemental
Fonts
Languages using Canadian Syllabics script; e.g., Inuktitut.
Family

Font Name

File Name

Version

Euphemia

Euphemia

Euphemia.ttf

5.08

Cherokee Supplemental Fonts
Cherokee.
Family

Font Name

File Name

Version

Plantagenet Cherokee

Plantagenet Cherokee

Plantc.ttf

5.09

Devanagari Supplemental Fonts
Language using Devanagari script; e.g., Hindi, Konkani,
Marathi.
Family

Font Name

File Name

Version

Aparajita

Aparajita

Aparaj.ttf

6.90

Aparajita Italic

Aparaji.ttf

6.90

Aparajita Bold

Aparajb.ttf

6.90

Aparajita Bold Italic

Aparajbi.ttf

6.90

Kokila

Kokila

Kokila.ttf

6.90

Kokila Italic

Kokilai.ttf

6.90

Kokila Bold

Kokilab.ttf

6.90

Kokila Bold Italic

Kokilabi.ttf

6.90

Mangal

Mangal.ttf

6.90

Mangal Bold

MangalB.ttf

6.90

Sanskrit Text

Sanskrit Text

Sanskr.ttf

1.01

Utsaah

Utsaah

Utsaah.ttf

6.90

Utsaah Italic

Utsaahi.ttf

6.90

Utsaah Bold

Utsaahb.ttf

6.90

Utsaah Bold Italic

Utsaahbi.ttf

6.90

Mangal

Ethiopic Supplemental Fonts
Languages using Ethiopic script; e.g., Amharic, Tigrinya.
Family

Font Name

File Name

Version

Nyala

Nyala

Nyala.ttf

5.04

Gujarati Supplemental Fonts
Gujarati; any other language using Gujurati script.
Family

Font Name

File Name

Version

Shruti

Shruti

Shruti.ttf

6.90

Shruti Bold

Shrutib.ttf

6.90

Gurmukhi Supplemental Fonts
Panjabi; any other language using Gurmukhi script

Family

Font Name

File Name

Version

Raavi

Raavi

Raavi.ttf

6.91

Raavi Bold

Raavib.ttf

6.91

Chinese (Simplified) Supplemental Fonts
Simplified Chinese
Family

Font Name

File Name

Version

DengXian

DengXian Light

Dengl.ttf

1.18

DengXian

Deng.ttf

1.18

DengXian Bold

Dengb.ttf

1.18

FangSong

FangSong

Simfang.ttf

5.01

KaiTi

KaiTi

Simkai.ttf

5.01

SimHei

SimHei

Simhei.ttf

5.03

Chinese (Traditional) Supplemental Fonts
Traditional Chinese
Family

Font Name

File Name

Version

DFKai-SB

DFKai-SB

Kaiu.ttf

5.01

MingLiU

MingLiU

Mingliu.ttc

7.03

MingLiU_HKSCS

Mingliu.ttc

7.03

PMingLiU

Mingliu.ttc

7.03

File Name

Version

Hebrew Supplemental Fonts
Hebrew
Family

Font Name

Aharoni Bold

Aharoni Bold

Ahronbd.ttf

6.01

David

David

David.ttf

6.01

David Bold

Davidbd.ttf

6.01

FrankRuehl

FrankRuehl

Frank.ttf

6.01

Gisha

Gisha

Gisha.ttf

6.01

Gisha Bold

Gishabd.ttf

6.01

Levenim MT

Lvnm.ttf

6.01

Levenim MT Bold

Lvnmbd.ttf

6.01

Miriam

Mriam.ttf

6.01

Miriam Fixed

Mriamc.ttf

6.01

Narkisim

Narkisim

Nrkis.ttf

6.01

Rod

Rod

Rod.ttf

6.01

Levenim MT

Miriam

Japanese Supplemental Fonts
Japanese
Family

Font Name

File Name

Version

BIZ UDGothic

BIZ UDGothic

BIZ-UDGothicR.ttc

2.00

BIZ UDGothic Bold

BIZ-UDGothicB.ttc

2.00

BIZ UDPGothic

BIZ-UDGothicR.ttc

2.00

BIZ UDPGothic Bold

BIZ-UDGothicB.ttc

2.00

BIZ UDMincho Medium

BIZ-UDMinchoM.ttc

2.01

BIZ UDPMincho Medium

BIZ-UDMinchoM.ttc

2.01

Meiryo

Meiryo.ttc

6.50

Meiryo Italic

Meiryo.ttc

6.50

Meiryo Bold

Meiryob.ttc

6.50

Meiryo Bold Italic

Meiryob.ttc

6.50

BIZ UDMincho
Medium

Meiryo

MS Mincho

UD Digi Kyokasho

Yu Mincho

Meiryo UI

Meiryo.ttc

6.50

Meiryo UI Italic

Meiryo.ttc

6.50

Meiryo UI Bold

Meiryob.ttc

6.50

Meiryo UI Bold Italic

Meiryob.ttc

6.50

MS Mincho

Msmincho.ttc

5.31

MS PMincho

Msmincho.ttc

5.31

UD Digi Kyokasho N-B

UDDigiKyokashoN-B.ttc

2.00

UD Digi Kyokasho NK-B

UDDigiKyokashoN-B.ttc

2.00

UD Digi Kyokasho NK-R

UDDigiKyokashoN-R.ttc

2.00

UD Digi Kyokasho NP-B

UDDigiKyokashoN-B.ttc

2.00

UD Digi Kyokasho NP-R

UDDigiKyokashoN-R.ttc

2.00

UD Digi Kyokasho N-R

UDDigiKyokashoN-R.ttc

2.00

Yu Mincho Light

Yuminl.ttf

1.92

Yu Mincho Regular

Yumin.ttf

1.92

Yu Mincho Demibold

Yumindb.ttf

1.92

Kannada Supplemental Fonts
Kannada; any other language using Kannada script.
Family

Font Name

File Name

Version

Tunga

Tunga

Tunga.ttf

6.90

Tunga Bold

Tungab.ttf

6.90

Khmer Supplemental Fonts
Cambodian; any other language using Khmer script.
Family

Font Name

File Name

Version

DaunPenh

DaunPenh

Daunpenh.ttf

5.05

Khmer UI

Khmer UI

KhmerUI.ttf

5.05

Khmer UI Bold

KhmerUIB.ttf

5.05

MoolBoran

Moolbor.ttf

5.05

MoolBoran

Korean Supplemental Fonts
Korean
Family

Font Name

File Name

Version

Batang

Batang

Batang.ttc

5.02

BatangChe

Batang.ttc

5.02

Dotum

Gulim.ttc

5.03

DotumChe

Gulim.ttc

5.03

Gulim

Gulim.ttc

5.03

GulimChe

Gulim.ttc

5.03

Gungsuh

Batang.ttc

5.02

GungsuhChe

Batang.ttc

5.02

Dotum

Gulim

Gungsuh

Lao Supplemental Fonts
Lao; any other language using Lao script.
Family

Font Name

File Name

Version

DokChampa

DokChampa

Dokchamp.ttf

5.06

Lao UI

Lao UI

Laoui.ttf

5.06

Lao UI Bold

Laouib.ttf

5.06

Malayalam Supplemental Fonts

Malayalam; any other language using Malayalam script.
Family

Font Name

File Name

Version

Kartika

Kartika

Kartika.ttf

6.90

Kartika Bold

Kartikab.ttf

6.90

Odia Supplemental Fonts
Odia; any other language using Odia script.
Family

Font Name

File Name

Version

Kalinga

Kalinga

Kalinga.ttf

6.90

Kalinga Bold

Kalingab.ttf

6.90

Pan-European Supplemental Fonts
No automatic language associations.
Family

Font Name

File Name

Version

Arial Nova

Arial Nova Light

ArialNova-Light.ttf

1.05

Arial Nova Light Italic

ArialNova-LightItalic.ttf

1.05

Arial Nova

ArialNova.ttf

1.05

Arial Nova Italic

ArialNova-Italic.ttf

1.05

Arial Nova Bold

ArialNova-Bold.ttf

1.05

Arial Nova Bold Italic

ArialNova-BoldItalic.ttf

1.05

Arial Nova Cond Light

ArialNovaCond-Light.ttf

1.05

Arial Nova Cond Light Italic

ArialNovaCond-LightItalic.ttf

1.05

Arial Nova Cond

ArialNovaCond.ttf

1.05

Arial Nova Cond Italic

ArialNovaCond-Italic.ttf

1.05

Arial Nova Cond Bold

ArialNovaCond-Bold.ttf

1.05

Georgia Pro

Gill Sans Nova

Arial Nova Cond Bold Italic

ArialNovaCond-BoldItalic.ttf

1.05

Georgia Pro Light

GeorgiaPro-Light.ttf

6.14

Georgia Pro Light Italic

GeorgiaPro-LightItalic.ttf

6.14

Georgia Pro

GeorgiaPro-Regular.ttf

6.14

Georgia Pro Italic

GeorgiaPro-Italic.ttf

6.14

Georgia Pro Semibold

GeorgiaPro-SemiBold.ttf

6.14

Georgia Pro Semibold Italic

GeorgiaPro-SemiBoldItalic.ttf

6.14

Georgia Pro Bold

GeorgiaPro-Bold.ttf

6.14

Georgia Pro Bold Italic

GeorgiaPro-BoldItalic.ttf

6.14

Georgia Pro Black

GeorgiaPro-Black.ttf

6.14

Georgia Pro Black Italic

GeorgiaPro-BlackItalic.ttf

6.14

Georgia Pro Cond Light

GeorgiaPro-CondLight.ttf

6.14

Georgia Pro Cond Light Italic

GeorgiaPro-CondLightItalic.ttf

6.14

Georgia Pro Cond

GeorgiaPro-CondRegular.ttf

6.14

Georgia Pro Cond Italic

GeorgiaPro-CondItalic.ttf

6.14

Georgia Pro Cond Semibold

GeorgiaPro-CondSemiBold.ttf

6.14

Georgia Pro Cond Semibold
Italic

GeorgiaProCondSemiBoldItalic.ttf

6.14

Georgia Pro Cond Bold

GeorgiaPro-CondBold.ttf

6.14

Georgia Pro Cond Bold Italic

GeorgiaPro-CondBoldItalic.ttf

6.14

Georgia Pro Cond Black

GeorgiaPro-CondBlack.ttf

6.14

Georgia Pro Cond Black Italic

GeorgiaPro-CondBlackItalic.ttf

6.14

Gill Sans Nova Light

GillSansLightNova.ttf

1.02

Gill Sans Nova Light Italic

GillSansLightItNova.ttf

1.02

Gill Sans Nova

GillSansNova.ttf

1.02

Gill Sans Nova Italic

GillSansItNova.ttf

1.02

Gill Sans Nova Bold

GillSansBoNova.ttf

1.02

Gill Sans Nova Bold Italic

GillSansBoItNova.ttf

1.02

Gill Sans Nova Ultra Bold

GillSansUltraBoNova.ttf

1.02

Gill Sans Nova Cond Lt

GillSansCondLightNova.ttf

1.02

Gill Sans Nova Cond Lt Italic

GillSansCondLightItNova.ttf

1.02

Gill Sans Nova Cond

GillSansCondNova.ttf

1.02

Gill Sans Nova Cond Italic

GillSansCondItNova.ttf

1.02

Gill Sans Nova Cond Bold

GillSansCondBoNova.ttf

1.02

Gill Sans Nova Cond Bold

GillSansCondBoItNova.ttf

1.02

Gill Sans Nova Cond XBd

GillSansCondExtraNova.ttf

1.02

Gill Sans Nova Cond XBd Italic

GillSansCondExtraItNova.ttf

1.02

Gill Sans Nova Cond Ultra

GillSansCondUltraBoNova.ttf

1.02

NHaasGroteskTXPro-Rg.ttf

1.00

Neue Haas Grotesk Text Pro
UltraThin Italic *

NHaasGroteskTXPro-It.ttf

1.00

Neue Haas Grotesk Text Pro
Thin *

NHaasGroteskTXPro-Rg.ttf

1.00

Neue Haas Grotesk Text Pro
Thin Italic *

NHaasGroteskTXPro-It.ttf

1.00

Neue Haas Grotesk Text Pro

NHaasGroteskTXPro-Rg.ttf

1.00

NHaasGroteskTXPro-It.ttf

1.00

NHaasGroteskTXPro-Rg.ttf

1.00

NHaasGroteskTXPro-It.ttf

1.00

NHaasGroteskTXPro-Rg.ttf

1.00

Neue Haas Grotesk Text Pro
Regular Italic *

NHaasGroteskTXPro-It.ttf

1.00

Neue Haas Grotesk Text Pro

NHaasGroteskTXPro-Rg.ttf

1.00

Italic

Bold
Neue Haas Grotesk

Neue Haas Grotesk Text Pro

Text Pro

UltraThin *

ExtraLight *
Neue Haas Grotesk Text Pro
ExtraLight Italic *
Neue Haas Grotesk Text Pro
Light *
Neue Haas Grotesk Text Pro
Light Italic *
Neue Haas Grotesk Text Pro
Regular *

Medium *
Neue Haas Grotesk Text Pro

NHaasGroteskTXPro-It.ttf

1.00

NHaasGroteskTXPro-Rg.ttf

1.00

Neue Haas Grotesk Text Pro
Bold Italic *

NHaasGroteskTXPro-It.ttf

1.00

Neue Haas Grotesk Text Pro
Black *

NHaasGroteskTXPro-Rg.ttf

1.00

Neue Haas Grotesk Text Pro
Black Italic *

NHaasGroteskTXPro-It.ttf

1.00

Rockwell Nova

RockwellNova.ttf

1.02

Rockwell Nova Bold

RockwellNova-Bold.ttf

1.02

Rockwell Nova Bold Italic

RockwellNova-BoldItalic.ttf

1.02

Rockwell Nova Cond

RockwellNovaCond.ttf

1.02

Rockwell Nova Cond Bold

RockwellNovaCond-Bold.ttf

1.02

Rockwell Nova Cond Bold
Italic

RockwellNovaCondBoldItalic.ttf

1.02

Rockwell Nova Cond Italic

RockwellNovaCond-Italic.ttf

1.02

Rockwell Nova Cond Light

RockwellNovaCond-Light.ttf

1.02

Rockwell Nova Cond Light
Italic

RockwellNovaCondLightItalic.ttf

1.02

Rockwell Nova Extra Bold

RockwellNova-ExtraBold.ttf

1.02

Rockwell Nova Extra Bold
Italic

RockwellNova-ExtraBoldItalic.ttf

1.02

Rockwell Nova Italic

RockwellNova-Italic.ttf

1.02

Rockwell Nova Light

RockwellNova-Light.ttf

1.02

Rockwell Nova Light Italic

RockwellNova-LightItalic.ttf

1.02

Verdana Pro Light

VerdanaPro-Light.ttf

6.13

Verdana Pro Light Italic

VerdanaPro-LightItalic.ttf

6.13

Verdana Pro

VerdanaPro-Regular.ttf

6.13

Medium Italic *
Neue Haas Grotesk Text Pro
Bold *

Rockwell Nova

Verdana Pro

Verdana Pro Italic

VerdanaPro-Italic.ttf

6.13

Verdana Pro SemiBold

VerdanaPro-SemiBold.ttf

6.13

Verdana Pro SemiBold Italic

VerdanaPro-SemiBoldItalic.ttf

6.13

Verdana Pro Bold

VerdanaPro-Bold.ttf

6.13

Verdana Pro Bold Italic

VerdanaPro-BoldItalic.ttf

6.13

Verdana Pro Black

VerdanaPro-Black.ttf

6.13

Verdana Pro Black Italic

VerdanaPro-BlackItalic.ttf

6.13

Verdana Pro Cond Light

VerdanaPro-CondLight.ttf

6.13

Verdana Pro Cond Light Italic

VerdanaPro-CondLightItalic.ttf

6.13

Verdana Pro Cond

VerdanaPro-CondRegular.ttf

6.13

Verdana Pro Cond Italic

VerdanaPro-CondItalic.ttf

6.13

Verdana Pro Cond SemiBold

VerdanaPro-CondSemiBold.ttf

6.13

Verdana Pro Cond SemiBold

VerdanaPro-

6.13

Italic

CondSemiBoldItalic.ttf

Verdana Pro Cond Bold

VerdanaPro-CondBold.ttf

6.13

Verdana Pro Cond Bold Italic

VerdanaPro-CondBoldItalic.ttf

6.13

Verdana Pro Cond Black

VerdanaPro-CondBlack.ttf

6.13

Verdana Pro Cond Black Italic

VerdanaPro-CondBlackItalic.ttf

6.13

Sinhala Supplemental Fonts
Sinhala; any other language using Sinhala script.
Family

Font Name

File Name

Version

Iskoola Pota

Iskoola Pota

Iskpota.ttf

6.96

Iskoola Pota Bold

Iskpotab.ttf

6.96

Syriac Supplemental Fonts

Languages using Syriac script.
Family

Font Name

File Name

Version

Estrangelo Edessa

Estrangelo Edessa

Estre.ttf

6.84

Tamil Supplemental Fonts
Tamil; any other language using Tamil script.
Family

Font Name

File Name

Version

Latha

Latha

Latha.ttf

6.90

Latha Bold

Lathab.ttf

6.90

Vijaya

Vijaya.ttf

6.90

Vijaya Bold

Vijayab.ttf

6.90

Vijaya

Telugu Supplemental Fonts
Telugu; any other language using Telugu script.
Family

Font Name

File Name

Version

Gautami

Gautami

Gautami.ttf

6.90

Gautami Bold

Gautamib.ttf

6.90

Vani

Vani.ttf

6.91

Vani Bold

Vanib.ttf

6.91

Vani

Thai Supplemental Fonts
Thai; any other language using Thai script.
Family

Font Name

File Name

Version

Angsana New

Angsana New

Angsana.ttc

5.05

AngsanaUPC

Browallia New

BrowalliaUPC

Cordia New

CordiaUPC

DilleniaUPC

EucrosiaUPC

Angsana New Italic

Angsana.ttc

5.05

Angsana New Bold

Angsana.ttc

5.05

Angsana New Bold Italic

Angsana.ttc

5.05

AngsanaUPC

Angsana.ttc

5.05

AngsanaUPC Italic

Angsana.ttc

5.05

AngsanaUPC Bold

Angsana.ttc

5.05

AngsanaUPC Bold Italic

Angsana.ttc

5.05

Browallia New

Browalia.ttc

5.05

Browallia New Italic

Browalia.ttc

5.05

Browallia New Bold

Browalia.ttc

5.05

Browallia New Bold Italic

Browalia.ttc

5.05

BrowalliaUPC

Browalia.ttc

5.05

BrowalliaUPC Italic

Browalia.ttc

5.05

BrowalliaUPC Bold

Browalia.ttc

5.05

BrowalliaUPC Bold Italic

Browalia.ttc

5.05

Cordia New

Cordia.ttc

5.06

Cordia New Italic

Cordia.ttc

5.06

Cordia New Bold

Cordia.ttc

5.06

Cordia New Bold Italic

Cordia.ttc

5.06

CordiaUPC

Cordia.ttc

5.06

CordiaUPC Italic

Cordia.ttc

5.06

CordiaUPC Bold

Cordia.ttc

5.06

CordiaUPC Bold Italic

Cordia.ttc

5.06

DilleniaUPC

Upcdl.ttf

5.05

DilleniaUPC Italic

Upcdi.ttf

5.05

DilleniaUPC Bold

Upcdb.ttf

5.05

DilleniaUPC Bold Italic

Upcdbi.ttf

5.05

EucrosiaUPC

Upcel.ttf

5.05

FreesiaUPC

IrisUPC

JasmineUPC

KodchiangUPC

Leelawadee

LilyUPC

EucrosiaUPC Italic

Upcei.ttf

5.05

EucrosiaUPC Bold

Upceb.ttf

5.05

EucrosiaUPC Bold Italic

Upcebi.ttf

5.05

FreesiaUPC

Upcfl.ttf

5.05

FreesiaUPC Italic

Upcfi.ttf

5.05

FreesiaUPC Bold

Upcfb.ttf

5.05

FreesiaUPC Bold Italic

Upcfbi.ttf

5.05

IrisUPC

Upcil.ttf

5.05

IrisUPC Italic

Upcii.ttf

5.05

IrisUPC Bold

Upcib.ttf

5.05

IrisUPC Bold Italic

Upcibi.ttf

5.05

JasmineUPC

Upcjl.ttf

5.05

JasmineUPC Italic

Upcji.ttf

5.05

JasmineUPC Bold

Upcjb.ttf

5.05

JasmineUPC Bold Italic

Upcjbi.ttf

5.05

KodchiangUPC

Upckl.ttf

5.05

KodchiangUPC Italic

Upcki.ttf

5.05

KodchiangUPC Bold

Upckb.ttf

5.05

KodchiangUPC Bold Italic

Upckbi.ttf

5.05

Leelawadee

Leelawad.ttf

5.06

Leelawadee Bold

Leelawdb.ttf

5.06

LilyUPC

Upcll.ttf

5.05

LilyUPC Italic

Upcli.ttf

5.05

LilyUPC Bold

Upclb.ttf

5.05

LilyUPC Bold Italic

Upclbi.ttf

5.05

* Added in Windows 11.

See Also
Cloud fonts in Office

Windows 10 font list
Article • 06/16/2022

Introduction
An important development in Windows 10 is the Universal Windows Platform (UWP): a
converged app platform allowing a developer to create a single app that can run on all
Windows devices. Windows fonts are one aspect of this convergence: Windows 10
introduces a recommended UWP font set that is common across all editions that
support UWP, including Desktop, Server, and Xbox.
A number of additional fonts are available for Desktop and Server, including all other
fonts from previous releases. However, not all of these are pre-installed by default in all
images. In order to make disk usage and font choices more relevant to users according
to the languages that they use, a number of fonts have been moved into optional, ondemand packages. These packages are designed around the different scripts that fonts
are primarily intended to support, and most are added automatically by Windows
Update when the associated languages are enabled in language settings (for example,
by enabling a keyboard). Any of these Feature On Demand (FOD) packages can also be
added manually via Settings. To add font packages manually, select the Start button, and
then select Settings > System > Optional features (if on a version older than Windows
10 22H2, navigate to Settings > Apps > Apps & features > Optional features instead).
The following is a list of desktop font sets that are present in the most updated version
(2004, May 2020 release) of Windows 10.
Below you will also find list of fonts in each of the Feature On Demand (FOD) packages.
Please note: Not all of the Desktop fonts will be in non-desktop editions of Windows 10
such as Xbox, HoloLens, Surface Hub, etc.
ﾉ

Expand table

Family

Font Name

File Name

Version

Arial

Arial

Arial.ttf

7.00

Arial Italic

Ariali.ttf

7.00

Arial Bold

Arialbd.ttf

7.00

Arial Bold Italic

Arialbi.ttf

7.00

Arial Black

Arial Black

Ariblk.ttf

5.23

Bahnschrift

Bahnschrift *

Bahnschrift.ttf

2.06

Calibri

Calibri Light

Calibril.ttf

6.23

Calibri Light Italic

Calibrili.ttf

6.23

Calibri

Calibri.ttf

6.23

Calibri Italic

Calibrii.ttf

6.23

Calibri Bold

Calibrib.ttf

6.23

Calibri Bold Italic

Calibriz.ttf

6.23

Cambria

Cambria.ttc

6.99

Cambria Italic

Cambriai.ttf

6.98

Cambria Bold

Cambriab.ttf

6.98

Cambria Bold Italic

Cambriaz.ttf

6.98

Cambria Math

Cambria Math

Cambria.ttc

6.99

Candara

Candara Light *

Candaral.ttf

5.63

Candara Light Italic *

Candarali.ttf

5.63

Candara

Candara.ttf

5.62

Candara Italic

Candarai.ttf

5.62

Candara Bold

Candarab.ttf

5.62

Candara Bold Italic

Candaraz.ttf

5.62

Comic Sans MS

Comic.ttf

5.14

Comic Sans MS Italic

Comici.ttf

5.14

Comic Sans MS Bold

Comicbd.ttf

5.14

Comic Sans MS Bold Italic

Comicz.ttf

5.14

Consolas

Consola.ttf

7.00

Consolas Italic

Consolai.ttf

7.00

Consolas Bold

Consolab.ttf

7.00

Consolas Bold Italic

Consolaz.ttf

7.00

Cambria

Comic Sans MS

Consolas

Constantia

Constantia

Constan.ttf

5.93

Constantia Italic

Constani.ttf

5.93

Constantia Bold

Constanb.ttf

5.93

Constantia Bold Italic

Constanz.ttf

5.93

Corbel Light *

Corbell.ttf

6.01

Corbel Light Italic *

Corbelli.ttf

6.01

Corbel

Corbel.ttf

6.01

Corbel Italic

Corbeli.ttf

6.01

Corbel Bold

Corbelb.ttf

6.01

Corbel Bold Italic

Corbelz.ttf

6.01

Courier New

Cour.ttf

6.92

Courier New Italic

Couri.ttf

6.91

Courier New Bold

Courbd.ttf

6.92

Courier New Bold Italic

Courbi.ttf

6.91

Ebrima

Ebrima.ttf

5.14

Ebrima Bold

Ebrimabd.ttf

5.14

Franklin Gothic Medium

Framd.ttf

5.02

Franklin Gothic Medium Italic

Framdit.ttf

5.01

Gabriola

Gabriola

Gabriola.ttf

5.93

Gadugi

Gadugi

Gadugi.ttf

1.12

Gadugi Bold

Gadugib.ttf

1.12

Georgia

Georgia.ttf

5.59

Georgia Italic

Georgiai.ttf

5.59

Georgia Bold

Georgiab.ttf

5.59

Georgia Bold Italic

Georgiaz.ttf

5.59

HoloLens MDL2 Assets *

Holomdl2.ttf

2.02

Corbel

Courier New

Ebrima

Franklin Gothic
Medium

Georgia

HoloLens MDL2
Assets

Impact

Impact

Impact.ttf

5.11

Ink Free

Ink Free *

Inkfree.ttf

1.00

Javanese Text

Javanese Text

Javatext.ttf

1.10

Leelawadee UI

Leelawadee UI

Leelawui.ttf

5.05

Leelawadee UI Semilight

Leeluisl.ttf

5.05

Leelawadee UI Bold

Leelauib.ttf

5.05

Lucida Console

Lucida Console

Lucon.ttf

5.01

Lucida Sans Unicode

Lucida Sans Unicode

L_10646.ttf

5.01

Malgun Gothic

Malgun Gothic

Malgun.ttf

6.68

Malgun Gothic Bold

Malgunbd.ttf

6.68

Malgun Gothic Semilight *

Malgunsl.ttf

6.68

Marlett

Marlett

Marlett.ttf

5.01

Microsoft Himalaya

Microsoft Himalaya

Himalaya.ttf

5.23

Microsoft JhengHei

Microsoft JhengHei Light

Msjhl.ttc

6.14

Microsoft JhengHei

Msjh.ttc

6.14

Microsoft JhengHei Bold

MSJHBD.ttc

6.13

Microsoft JhengHei UI Light

Msjhl.ttc

6.14

Microsoft JhengHei UI

Msjh.ttc

6.14

Microsoft JhengHei UI Bold

MSJHBD.ttc

6.13

Microsoft New Tai Lue

Ntailu.ttf

5.99

Microsoft New Tai Lue Bold

Ntailub.ttf

5.99

Microsoft PhagsPa

Phagspa.ttf

6.00

Microsoft PhagsPa Bold

PhagsPaB.ttf

6.00

Microsoft Sans Serif

Microsoft Sans Serif

Micross.ttf

7.00

Microsoft Tai Le

Microsoft Tai Le

Taile.ttf

6.00

Microsoft Tai Le Bold

TaiLeb.ttf

6.00

Microsoft YaHei Light

Msyhl.ttc

6.23

Microsoft New Tai
Lue

Microsoft PhagsPa

Microsoft YaHei

Microsoft YaHei

Msyh.ttc

6.25

Microsoft YaHei Bold

Msyhbd.ttc

6.25

Microsoft YaHei UI Light

Msyhl.ttc

6.23

Microsoft YaHei UI

Msyh.ttc

6.25

Microsoft YaHei UI Bold

Msyhbd.ttc

6.25

Microsoft Yi Baiti

Microsoft Yi Baiti

Msyi.ttf

6.00

MingLiU-ExtB

MingLiU-ExtB

Mingliub.ttc

7.02

PMingLiU-ExtB

Mingliub.ttc

7.02

MingLiU_HKSCS-ExtB

Mingliub.ttc

7.02

Mongolian Baiti

Mongolian Baiti

Monbaiti.ttf

5.53

MS Gothic

MS Gothic

Msgothic.ttc

5.32

MS PGothic

Msgothic.ttc

5.32

MS UI Gothic

Msgothic.ttc

5.32

MV Boli

MV Boli

Mvboli.ttf

6.84

Myanmar Text

Myanmar Text

Mmrtext.ttf

1.18

Myanmar Text Bold

Mmrtextb.ttf

1.18

Nirmala UI Semilight

Nirmalas.ttf

1.40

Nirmala UI

Nirmala.ttf

1.40

Nirmala UI Bold

Nirmalab.ttf

1.40

Palatino Linotype

Pala.ttf

5.03

Palatino Linotype Italic

Palai.ttf

5.03

Palatino Linotype Bold

Palab.ttf

5.03

Palatino Linotype Bold Italic

Palabi.ttf

5.03

Segoe MDL2 Assets

Segoe MDL2 Assets *

Segmdl2.ttf

1.82

Segoe Print

Segoe Print

Segoepr.ttf

5.04

Segoe Print Bold

Segoeprb.ttf

5.04

Segoe Script

Segoesc.ttf

5.02

Nirmala UI

Palatino Linotype

Segoe Script

Segoe Script Bold

Segoescb.ttf

5.02

Segoe UI Light

Segoeuil.ttf

5.62

Segoe UI Light Italic

Seguili.ttf

5.32

Segoe UI Semilight

Segoeuisl.ttf

5.62

Segoe UI Semilight Italic

Seguisli.ttf

5.32

Segoe UI

Segoeui.ttf

5.62

Segoe UI Italic

Segoeuii.ttf

5.32

Segoe UI Semibold

Seguisb.ttf

5.62

Segoe UI Semibold Italic

Seguisbi.ttf

5.32

Segoe UI Bold

Segoeuib.ttf

5.62

Segoe UI Bold Italic

Segoeuiz.ttf

5.32

Segoe UI Black

Seguibl.ttf

2.02

Segoe UI Black Italic

Seguibli.ttf

2.02

Segoe UI Historic

Segoe UI Historic *

Seguihis.ttf

1.03

Segoe UI Emoji

Segoe UI Emoji

Seguiemj.ttf

1.29

Segoe UI Symbol

Segoe UI Symbol

Seguisym.ttf

6.23

SimSun

SimSun

Simsun.ttc

5.16

NSimSun

Simsun.ttc

5.16

SimSun-ExtB

Simsunb.ttf

5.03

Sitka Small

Sitka.ttc

1.12

Sitka Small Italic

SitkaI.ttc

1.12

Sitka Small Bold

SitkaB.ttc

1.12

Sitka Small Bold Italic

SitkaZ.ttc

1.12

Sitka Text

Sitka.ttc

1.12

Sitka Text Italic

SitkaI.ttc

1.12

Sitka Text Bold

SitkaB.ttc

1.12

Sitka Text Bold Italic

SitkaZ.ttc

1.12

Segoe UI

Sitka

Sitka Subheading

Sitka.ttc

1.12

Sitka Subheading Italic

SitkaI.ttc

1.12

Sitka Subheading Bold

SitkaB.ttc

1.12

Sitka Subheading Bold Italic

SitkaZ.ttc

1.12

Sitka Heading

Sitka.ttc

1.12

Sitka Heading Italic

SitkaI.ttc

1.12

Sitka Heading Bold

SitkaB.ttc

1.12

Sitka Heading Bold Italic

SitkaZ.ttc

1.12

Sitka Display

Sitka.ttc

1.12

Sitka Display Italic

SitkaI.ttc

1.12

Sitka Display Bold

SitkaB.ttc

1.12

Sitka Display Bold Italic

SitkaZ.ttc

1.12

Sitka Banner

Sitka.ttc

1.12

Sitka Banner Italic

SitkaI.ttc

1.12

Sitka Banner Bold

SitkaB.ttc

1.12

Sitka Banner Bold Italic

SitkaZ.ttc

1.12

Sylfaen

Sylfaen

Sylfaen.ttf

5.06

Symbol

Symbol

Symbol.ttf

5.01

Tahoma

Tahoma

Tahoma.ttf

7.00

Tahoma Bold

Tahomabd.ttf

7.00

Times New Roman

Times.ttf

7.01

Times New Roman Italic

Timesi.ttf

7.01

Times New Roman Bold

Timesbd.ttf

7.01

Times New Roman Bold Italic

Timesbi.ttf

7.01

Trebuchet MS

Trebuc.ttf

5.15

Trebuchet MS Italic

Trebucit.ttf

5.15

Trebuchet MS Bold

Trebucbd.ttf

5.15

Times New Roman

Trebuchet MS

Trebuchet MS Bold Italic

Trebucbi.ttf

5.15

Verdana

Verdana.ttf

5.33

Verdana Italic

Verdanai.ttf

5.33

Verdana Bold

Verdanab.ttf

5.33

Verdana Bold Italic

Verdanaz.ttf

5.33

Webdings

Webdings

Webdings.ttf

5.01

Wingdings

Wingdings

Wingding.ttf

5.01

Yu Gothic

Yu Gothic Light

YuGothL.ttc

1.90

Yu Gothic Regular

YuGothR.ttc

1.90

Yu Gothic Medium *

Yugothm.ttc

1.90

Yu Gothic Bold

YuGothB.ttc

1.90

Yu Gothic UI Light *

YuGothL.ttc

1.90

Yu Gothic UI Semilight *

YuGothR.ttc

1.90

Yu Gothic UI Regular *

Yugothm.ttc

1.90

Yu Gothic UI Semibold *

YuGothB.ttc

1.90

Yu Gothic UI Bold *

YuGothB.ttc

1.90

Verdana

Fonts included in Feature On Demand (FOD)
packages
Here's a comprehensive listing of which font families are included with each of the
optional font features. Some font families may include multiple fonts for different
weights and styles.

Arabic Script Supplemental Fonts
Languages using Arabic script; e.g., Arabic, Persian, Urdu.
ﾉ

Family

Font Name

File Name

Expand table
Version

Aldhabi

Aldhabi

Aldhabi.ttf

6.84

Andalus

Andalus

Andlso.ttf

6.84

Arabic Typesetting

Arabic Typesetting

Arabtype.ttf

6.84

Microsoft Uighur

Microsoft Uighur

Msuighur.ttf

7.00

Microsoft Uighur Bold

MSUighub.ttf

7.00

Sakkal Majalla

Majalla.ttf

6.86

Sakkal Majalla Bold

Majallab.ttf

6.86

Simplified Arabic

Simpo.ttf

6.98

Simplified Arabic Bold

Simpbdo.ttf

6.98

Simplified Arabic Fixed

Simpfxo.ttf

6.84

Traditional Arabic

Trado.ttf

6.84

Traditional Arabic Bold

Tradbdo.ttf

6.84

Urdu Typesetting

UrdType.ttf

6.86

Urdu Typesetting Bold

UrdTypeb.ttf

6.86

Sakkal Majalla

Simplified Arabic

Traditional Arabic

Urdu Typesetting

Bangla Script Supplemental Fonts
Languages using Bangla script; e.g., Assamese, Bangla.
ﾉ

Expand table

Family

Font Name

File Name

Version

Shonar Bangla

Shonar Bangla

Shonar.ttf

6.90

Shonar Bangla Bold

Shonarb.ttf

6.90

Vrinda

Vrinda.ttf

6.90

Vrinda Bold

Vrindab.ttf

6.90

Vrinda

Canadian Aboriginal Syllabics Supplemental
Fonts

Languages using Canadian Syllabics script; e.g., Inuktitut.
ﾉ

Expand table

Family

Font Name

File Name

Version

Euphemia

Euphemia

Euphemia.ttf

5.08

Cherokee Supplemental Fonts
Cherokee.
ﾉ

Expand table

Family

Font Name

File Name

Version

Plantagenet Cherokee

Plantagenet Cherokee

Plantc.ttf

5.09

Devanagari Supplemental Fonts
Language using Devanagari script; e.g., Hindi, Konkani,
Marathi.
ﾉ

Expand table

Family

Font Name

File Name

Version

Aparajita

Aparajita

Aparaj.ttf

6.90

Aparajita Italic

Aparaji.ttf

6.90

Aparajita Bold

Aparajb.ttf

6.90

Aparajita Bold Italic

Aparajbi.ttf

6.90

Kokila

Kokila.ttf

6.90

Kokila Italic

Kokilai.ttf

6.90

Kokila Bold

Kokilab.ttf

6.90

Kokila Bold Italic

Kokilabi.ttf

6.90

Mangal

Mangal.ttf

6.90

Kokila

Mangal

Mangal Bold

MangalB.ttf

6.90

Sanskrit Text

Sanskrit Text *

Sanskr.ttf

1.01

Utsaah

Utsaah

Utsaah.ttf

6.90

Utsaah Italic

Utsaahi.ttf

6.90

Utsaah Bold

Utsaahb.ttf

6.90

Utsaah Bold Italic

Utsaahbi.ttf

6.90

Ethiopic Supplemental Fonts
Languages using Ethiopic script; e.g., Amharic, Tigrinya.
ﾉ

Expand table

Family

Font Name

File Name

Version

Nyala

Nyala

Nyala.ttf

5.04

Gujarati Supplemental Fonts
Gujarati; any other language using Gujurati script.
ﾉ

Expand table

Family

Font Name

File Name

Version

Shruti

Shruti

Shruti.ttf

6.90

Shruti Bold

Shrutib.ttf

6.90

Gurmukhi Supplemental Fonts
Panjabi; any other language using Gurmukhi script
ﾉ

Family

Font Name

File Name

Expand table
Version

Raavi

Raavi

Raavi.ttf

6.91

Raavi Bold

Raavib.ttf

6.91

Chinese (Simplified) Supplemental Fonts
Simplified Chinese
ﾉ

Expand table

Family

Font Name

File Name

Version

DengXian

DengXian Light *

Dengl.ttf

1.17

DengXian *

Deng.ttf

1.17

DengXian Bold *

Dengb.ttf

1.17

FangSong

FangSong

Simfang.ttf

5.01

KaiTi

KaiTi

Simkai.ttf

5.01

SimHei

SimHei

Simhei.ttf

5.03

Chinese (Traditional) Supplemental Fonts
Traditional Chinese
ﾉ

Expand table

Family

Font Name

File Name

Version

DFKai-SB

DFKai-SB

Kaiu.ttf

5.01

MingLiU

MingLiU

Mingliu.ttc

7.03

MingLiU_HKSCS

Mingliu.ttc

7.03

PMingLiU

Mingliu.ttc

7.03

Hebrew Supplemental Fonts

Hebrew
ﾉ

Expand table

Family

Font Name

File Name

Version

Aharoni Bold

Aharoni Bold

Ahronbd.ttf

6.01

David

David

David.ttf

6.01

David Bold

Davidbd.ttf

6.01

FrankRuehl

FrankRuehl

Frank.ttf

6.01

Gisha

Gisha

Gisha.ttf

6.01

Gisha Bold

Gishabd.ttf

6.01

Levenim MT

Lvnm.ttf

6.01

Levenim MT Bold

Lvnmbd.ttf

6.01

Miriam

Mriam.ttf

6.01

Miriam Fixed

Mriamc.ttf

6.01

Narkisim

Narkisim

Nrkis.ttf

6.01

Rod

Rod

Rod.ttf

6.01

Levenim MT

Miriam

Japanese Supplemental Fonts
Japanese
ﾉ

Expand table

Family

Font Name

File Name

Version

BIZ UDGothic

BIZ UDGothic *

BIZ-UDGothicR.ttc

2.00

BIZ UDGothic Bold *

BIZ-UDGothicB.ttc

2.00

BIZ UDPGothic *

BIZ-UDGothicR.ttc

2.00

BIZ UDPGothic Bold *

BIZ-UDGothicB.ttc

2.00

BIZ UDMincho Medium *

BIZ-UDMinchoM.ttc

2.01

BIZ UDMincho
Medium

Meiryo

MS Mincho

UD Digi Kyokasho

Yu Mincho

BIZ UDPMincho Medium *

BIZ-UDMinchoM.ttc

2.01

Meiryo

Meiryo.ttc

6.50

Meiryo Italic

Meiryo.ttc

6.50

Meiryo Bold

Meiryob.ttc

6.50

Meiryo Bold Italic

Meiryob.ttc

6.50

Meiryo UI

Meiryo.ttc

6.50

Meiryo UI Italic

Meiryo.ttc

6.50

Meiryo UI Bold

Meiryob.ttc

6.50

Meiryo UI Bold Italic

Meiryob.ttc

6.50

MS Mincho

Msmincho.ttc

5.31

MS PMincho

Msmincho.ttc

5.31

UD Digi Kyokasho N-B *

UDDigiKyokashoN-B.ttc

2.00

UD Digi Kyokasho NK-B *

UDDigiKyokashoN-B.ttc

2.00

UD Digi Kyokasho NK-R *

UDDigiKyokashoN-R.ttc

2.00

UD Digi Kyokasho NP-B *

UDDigiKyokashoN-B.ttc

2.00

UD Digi Kyokasho NP-R *

UDDigiKyokashoN-R.ttc

2.00

UD Digi Kyokasho N-R *

UDDigiKyokashoN-R.ttc

2.00

Yu Mincho Light

Yuminl.ttf

1.90

Yu Mincho Regular

Yumin.ttf

1.90

Yu Mincho Demibold

Yumindb.ttf

1.90

Kannada Supplemental Fonts
Kannada; any other language using Kannada script.
ﾉ

Expand table

Family

Font Name

File Name

Version

Tunga

Tunga

Tunga.ttf

6.90

Tunga Bold

Tungab.ttf

6.90

Khmer Supplemental Fonts
Cambodian; any other language using Khmer script.
ﾉ

Expand table

Family

Font Name

File Name

Version

DaunPenh

DaunPenh

Daunpenh.ttf

5.05

Khmer UI

Khmer UI

KhmerUI.ttf

5.05

Khmer UI Bold

KhmerUIB.ttf

5.05

MoolBoran

Moolbor.ttf

5.05

MoolBoran

Korean Supplemental Fonts
Korean
ﾉ

Expand table

Family

Font Name

File Name

Version

Batang

Batang

Batang.ttc

5.02

BatangChe

Batang.ttc

5.02

Dotum

Gulim.ttc

5.03

DotumChe

Gulim.ttc

5.03

Gulim

Gulim.ttc

5.03

GulimChe

Gulim.ttc

5.03

Gungsuh

Batang.ttc

5.02

GungsuhChe

Batang.ttc

5.02

Dotum

Gulim

Gungsuh

Lao Supplemental Fonts

Lao; any other language using Lao script.
ﾉ

Expand table

Family

Font Name

File Name

Version

DokChampa

DokChampa

Dokchamp.ttf

5.06

Lao UI

Lao UI

Laoui.ttf

5.06

Lao UI Bold

Laouib.ttf

5.06

Malayalam Supplemental Fonts
Malayalam; any other language using Malayalam script.
ﾉ

Expand table

Family

Font Name

File Name

Version

Kartika

Kartika

Kartika.ttf

6.90

Kartika Bold

Kartikab.ttf

6.90

Odia Supplemental Fonts
Odia; any other language using Odia script.
ﾉ

Expand table

Family

Font Name

File Name

Version

Kalinga

Kalinga

Kalinga.ttf

6.90

Kalinga Bold

Kalingab.ttf

6.90

* Pan-European Supplemental Fonts
No automatic language associations.

ﾉ

Expand table

Family

Font Name

File Name

Version

Arial Nova

Arial Nova Light

ArialNova-Light.ttf

1.05

Arial Nova Light Italic

ArialNova-LightItalic.ttf

1.05

Arial Nova

ArialNova.ttf

1.05

Arial Nova Italic

ArialNova-Italic.ttf

1.05

Arial Nova Bold

ArialNova-Bold.ttf

1.05

Arial Nova Bold Italic

ArialNova-BoldItalic.ttf

1.05

Arial Nova Cond Light

ArialNovaCond-Light.ttf

1.05

Arial Nova Cond Light Italic

ArialNovaCond-LightItalic.ttf

1.05

Arial Nova Cond

ArialNovaCond.ttf

1.05

Arial Nova Cond Italic

ArialNovaCond-Italic.ttf

1.05

Arial Nova Cond Bold

ArialNovaCond-Bold.ttf

1.05

Arial Nova Cond Bold Italic

ArialNovaCond-BoldItalic.ttf

1.05

Georgia Pro Light

GeorgiaPro-Light.ttf

6.14

Georgia Pro Light Italic

GeorgiaPro-LightItalic.ttf

6.14

Georgia Pro

GeorgiaPro-Regular.ttf

6.14

Georgia Pro Italic

GeorgiaPro-Italic.ttf

6.14

Georgia Pro Semibold

GeorgiaPro-SemiBold.ttf

6.14

Georgia Pro Semibold Italic

GeorgiaPro-SemiBoldItalic.ttf

6.14

Georgia Pro Bold

GeorgiaPro-Bold.ttf

6.14

Georgia Pro Bold Italic

GeorgiaPro-BoldItalic.ttf

6.14

Georgia Pro Black

GeorgiaPro-Black.ttf

6.14

Georgia Pro Black Italic

GeorgiaPro-BlackItalic.ttf

6.14

Georgia Pro Cond Light

GeorgiaPro-CondLight.ttf

6.14

Georgia Pro Cond Light Italic

GeorgiaPro-CondLightItalic.ttf

6.14

Georgia Pro Cond

GeorgiaPro-CondRegular.ttf

6.14

Georgia Pro

Gill Sans Nova

Georgia Pro Cond Italic

GeorgiaPro-CondItalic.ttf

6.14

Georgia Pro Cond Semibold

GeorgiaPro-CondSemiBold.ttf

6.14

Georgia Pro Cond Semibold
Italic

GeorgiaProCondSemiBoldItalic.ttf

6.14

Georgia Pro Cond Bold

GeorgiaPro-CondBold.ttf

6.14

Georgia Pro Cond Bold Italic

GeorgiaPro-CondBoldItalic.ttf

6.14

Georgia Pro Cond Black

GeorgiaPro-CondBlack.ttf

6.14

Georgia Pro Cond Black Italic

GeorgiaPro-CondBlackItalic.ttf

6.14

Gill Sans Nova Light

GillSansLightNova.ttf

1.02

Gill Sans Nova Light Italic

GillSansLightItNova.ttf

1.02

Gill Sans Nova

GillSansNova.ttf

1.02

Gill Sans Nova Italic

GillSansItNova.ttf

1.02

Gill Sans Nova Bold

GillSansBoNova.ttf

1.02

Gill Sans Nova Bold Italic

GillSansBoItNova.ttf

1.02

Gill Sans Nova Ultra Bold

GillSansUltraBoNova.ttf

1.02

Gill Sans Nova Cond Lt

GillSansCondLightNova.ttf

1.02

Gill Sans Nova Cond Lt Italic

GillSansCondLightItNova.ttf

1.02

Gill Sans Nova Cond

GillSansCondNova.ttf

1.02

Gill Sans Nova Cond Italic

GillSansCondItNova.ttf

1.02

Gill Sans Nova Cond Bold

GillSansCondBoNova.ttf

1.02

Gill Sans Nova Cond Bold

GillSansCondBoItNova.ttf

1.02

Gill Sans Nova Cond XBd

GillSansCondExtraNova.ttf

1.02

Gill Sans Nova Cond XBd Italic

GillSansCondExtraItNova.ttf

1.02

Gill Sans Nova Cond Ultra
Bold

GillSansCondUltraBoNova.ttf

1.02

Neue Haas Grotesk Text Pro

NHaasGroteskTXPro-55Rg.ttf

1.05

Neue Haas Grotesk Text Pro

NHaasGroteskTXPro-56It.ttf

1.05

Italic

Neue Haas Grotesk
Text Pro

Italic
Neue Haas Grotesk Text Pro

NHaasGroteskTXPro-65Md.ttf

1.05

Neue Haas Grotesk Text Pro
Medium Italic

NHaasGroteskTXPro-66MdIt.ttf

1.05

Neue Haas Grotesk Text Pro
Bold

NHaasGroteskTXPro-75Bd.ttf

1.05

Neue Haas Grotesk Text Pro
Bold Italic

NHaasGroteskTXPro-76BdIt.ttf

1.05

Rockwell Nova

RockwellNova.ttf

1.02

Rockwell Nova Bold

RockwellNova-Bold.ttf

1.02

Rockwell Nova Bold Italic

RockwellNova-BoldItalic.ttf

1.02

Rockwell Nova Cond

RockwellNovaCond.ttf

1.02

Rockwell Nova Cond Bold

RockwellNovaCond-Bold.ttf

1.02

Rockwell Nova Cond Bold
Italic

RockwellNovaCondBoldItalic.ttf

1.02

Rockwell Nova Cond Italic

RockwellNovaCond-Italic.ttf

1.02

Rockwell Nova Cond Light

RockwellNovaCond-Light.ttf

1.02

Rockwell Nova Cond Light
Italic

RockwellNovaCondLightItalic.ttf

1.02

Rockwell Nova Extra Bold

RockwellNova-ExtraBold.ttf

1.02

Rockwell Nova Extra Bold

RockwellNova-

1.02

Italic

ExtraBoldItalic.ttf

Rockwell Nova Italic

RockwellNova-Italic.ttf

1.02

Rockwell Nova Light

RockwellNova-Light.ttf

1.02

Rockwell Nova Light Italic

RockwellNova-LightItalic.ttf

1.02

Verdana Pro Light

VerdanaPro-Light.ttf

6.13

Verdana Pro Light Italic

VerdanaPro-LightItalic.ttf

6.13

Verdana Pro

VerdanaPro-Regular.ttf

6.13

Verdana Pro Italic

VerdanaPro-Italic.ttf

6.13

Verdana Pro SemiBold

VerdanaPro-SemiBold.ttf

6.13

Medium

Rockwell Nova

Verdana Pro

Verdana Pro SemiBold Italic

VerdanaPro-SemiBoldItalic.ttf

6.13

Verdana Pro Bold

VerdanaPro-Bold.ttf

6.13

Verdana Pro Bold Italic

VerdanaPro-BoldItalic.ttf

6.13

Verdana Pro Black

VerdanaPro-Black.ttf

6.13

Verdana Pro Black Italic

VerdanaPro-BlackItalic.ttf

6.13

Verdana Pro Cond Light

VerdanaPro-CondLight.ttf

6.13

Verdana Pro Cond Light Italic

VerdanaPro-CondLightItalic.ttf

6.13

Verdana Pro Cond

VerdanaPro-CondRegular.ttf

6.13

Verdana Pro Cond Italic

VerdanaPro-CondItalic.ttf

6.13

Verdana Pro Cond SemiBold

VerdanaPro-CondSemiBold.ttf

6.13

Verdana Pro Cond SemiBold

VerdanaPro-

6.13

Italic

CondSemiBoldItalic.ttf

Verdana Pro Cond Bold

VerdanaPro-CondBold.ttf

6.13

Verdana Pro Cond Bold Italic

VerdanaPro-CondBoldItalic.ttf

6.13

Verdana Pro Cond Black

VerdanaPro-CondBlack.ttf

6.13

Verdana Pro Cond Black Italic

VerdanaPro-CondBlackItalic.ttf

6.13

Sinhala Supplemental Fonts
Sinhala; any other language using Sinhala script.
ﾉ

Expand table

Family

Font Name

File Name

Version

Iskoola Pota

Iskoola Pota

Iskpota.ttf

6.96

Iskoola Pota Bold

Iskpotab.ttf

6.96

Syriac Supplemental Fonts
Languages using Syriac script.

ﾉ

Expand table

Family

Font Name

File Name

Version

Estrangelo Edessa

Estrangelo Edessa

Estre.ttf

6.84

Tamil Supplemental Fonts
Tamil; any other language using Tamil script.
ﾉ

Expand table

Family

Font Name

File Name

Version

Latha

Latha

Latha.ttf

6.90

Latha Bold

Lathab.ttf

6.90

Vijaya

Vijaya.ttf

6.90

Vijaya Bold

Vijayab.ttf

6.90

Vijaya

Telugu Supplemental Fonts
Telugu; any other language using Telugu script.
ﾉ

Expand table

Family

Font Name

File Name

Version

Gautami

Gautami

Gautami.ttf

6.90

Gautami Bold

Gautamib.ttf

6.90

Vani

Vani.ttf

6.90

Vani Bold

Vanib.ttf

6.90

Vani

Thai Supplemental Fonts
Thai; any other language using Thai script.

ﾉ

Expand table

Family

Font Name

File Name

Version

Angsana New

Angsana New

Angsana.ttc

5.05

Angsana New Italic

Angsana.ttc

5.05

Angsana New Bold

Angsana.ttc

5.05

Angsana New Bold Italic

Angsana.ttc

5.05

AngsanaUPC

Angsana.ttc

5.05

AngsanaUPC Italic

Angsana.ttc

5.05

AngsanaUPC Bold

Angsana.ttc

5.05

AngsanaUPC Bold Italic

Angsana.ttc

5.05

Browallia New

Browalia.ttc

5.05

Browallia New Italic

Browalia.ttc

5.05

Browallia New Bold

Browalia.ttc

5.05

Browallia New Bold Italic

Browalia.ttc

5.05

BrowalliaUPC

Browalia.ttc

5.05

BrowalliaUPC Italic

Browalia.ttc

5.05

BrowalliaUPC Bold

Browalia.ttc

5.05

BrowalliaUPC Bold Italic

Browalia.ttc

5.05

Cordia New

Cordia.ttc

5.06

Cordia New Italic

Cordia.ttc

5.06

Cordia New Bold

Cordia.ttc

5.06

Cordia New Bold Italic

Cordia.ttc

5.06

CordiaUPC

Cordia.ttc

5.06

CordiaUPC Italic

Cordia.ttc

5.06

CordiaUPC Bold

Cordia.ttc

5.06

CordiaUPC Bold Italic

Cordia.ttc

5.06

DilleniaUPC

Upcdl.ttf

5.05

AngsanaUPC

Browallia New

BrowalliaUPC

Cordia New

CordiaUPC

DilleniaUPC

EucrosiaUPC

FreesiaUPC

IrisUPC

JasmineUPC

KodchiangUPC

Leelawadee

LilyUPC

DilleniaUPC Italic

Upcdi.ttf

5.05

DilleniaUPC Bold

Upcdb.ttf

5.05

DilleniaUPC Bold Italic

Upcdbi.ttf

5.05

EucrosiaUPC

Upcel.ttf

5.05

EucrosiaUPC Italic

Upcei.ttf

5.05

EucrosiaUPC Bold

Upceb.ttf

5.05

EucrosiaUPC Bold Italic

Upcebi.ttf

5.05

FreesiaUPC

Upcfl.ttf

5.05

FreesiaUPC Italic

Upcfi.ttf

5.05

FreesiaUPC Bold

Upcfb.ttf

5.05

FreesiaUPC Bold Italic

Upcfbi.ttf

5.05

IrisUPC

Upcil.ttf

5.05

IrisUPC Italic

Upcii.ttf

5.05

IrisUPC Bold

Upcib.ttf

5.05

IrisUPC Bold Italic

Upcibi.ttf

5.05

JasmineUPC

Upcjl.ttf

5.05

JasmineUPC Italic

Upcji.ttf

5.05

JasmineUPC Bold

Upcjb.ttf

5.05

JasmineUPC Bold Italic

Upcjbi.ttf

5.05

KodchiangUPC

Upckl.ttf

5.05

KodchiangUPC Italic

Upcki.ttf

5.05

KodchiangUPC Bold

Upckb.ttf

5.05

KodchiangUPC Bold Italic

Upckbi.ttf

5.05

Leelawadee

Leelawad.ttf

5.06

Leelawadee Bold

Leelawdb.ttf

5.06

LilyUPC

Upcll.ttf

5.05

LilyUPC Italic

Upcli.ttf

5.05

LilyUPC Bold

Upclb.ttf

5.05

LilyUPC Bold Italic

Upclbi.ttf

5.05

* Added in Windows 10.

See Also
Cloud fonts in Office

Windows 8.1 font list
Article • 09/22/2020

This is a list of fonts that shipped with Windows 8.1. Your versions numbers may be
different if you did not apply Windows updates. The list of Windows 10 fonts is here.
Family

Font Name

File Name

Version

Aharoni Bold

Aharoni Bold

Ahronbd.ttf

5.10

Aldhabi

Aldhabi

Aldhabi.ttf

1.00

Andalus

Andalus

Andlso.ttf

6.00

Angsana New

Angsana New

Angsa.ttf

5.01

Angsana New Italic

Angsai.ttf

5.01

Angsana New Bold

Angsab.ttf

5.01

Angsana New Bold Italic

Angsaz.ttf

5.01

AngsanaUPC

Angsau.ttf

5.01

AngsanaUPC Italic

Angsaui.ttf

5.01

AngsanaUPC Bold

Angsaub.ttf

5.01

AngsanaUPC Bold Italic

Angsauz.ttf

5.01

Aparajita

Aparaj.ttf

6.00

Aparajita Italic

Aparaji.ttf

6.00

Aparajita Bold

Aparajb.ttf

6.00

Aparajita Bold Italic

Aparajbi.ttf

6.00

Arabic Typesetting

Arabic Typesetting

Arabtype.ttf

6.00

Arial

Arial

Arial.ttf

6.89

Arial Italic

Ariali.ttf

6.89

Arial Bold

Arialbd.ttf

6.89

Arial Bold Italic

Arialbi.ttf

6.89

Arial Black

Arial Black

Ariblk.ttf

5.21

Batang

Batang

Batang.ttc

5.00

AngsanaUPC

Aparajita

BatangChe

Batang.ttc

5.00

Browallia New

Browa.ttf

5.01

Browallia New Italic

Browai.ttf

5.01

Browallia New Bold

Browab.ttf

5.01

Browallia New Bold Italic

Browaz.ttf

5.01

BrowalliaUPC

Browau.ttf

5.01

BrowalliaUPC Italic

Browaui.ttf

5.01

BrowalliaUPC Bold

Browaub.ttf

5.01

BrowalliaUPC Bold Italic

Browauz.ttf

5.01

Calibri Light

Calibril.ttf

2.15

Calibri Light Italic

Calibrili.ttf

2.15

Calibri

Calibri.ttf

5.90

Calibri Italic

Calibrii.ttf

5.90

Calibri Bold

Calibrib.ttf

5.90

Calibri Bold Italic

Calibriz.ttf

5.90

Cambria

Cambria.ttc

6.84

Cambria Italic

Cambriai.ttf

6.84

Cambria Bold

Cambriab.ttf

6.84

Cambria Bold Italic

Cambriaz.ttf

6.84

Cambria Math

Cambria Math

Cambria.ttc

6.84

Candara

Candara

Candara.ttf

5.61

Candara Italic

Candarai.ttf

5.61

Candara Bold

Candarab.ttf

5.61

Candara Bold Italic

Candaraz.ttf

5.61

Comic Sans MS

Comic.ttf

5.11

Comic Sans MS Italic

Comici.ttf

5.11

Comic Sans MS Bold

Comicbd.ttf

5.11

Browallia New

BrowalliaUPC

Calibri

Cambria

Comic Sans MS

Comic Sans MS Bold Italic

Comicz.ttf

5.11

Consolas

Consola.ttf

5.36

Consolas Italic

Consolai.ttf

5.36

Consolas Bold

Consolab.ttf

5.36

Consolas Bold Italic

Consolaz.ttf

5.36

Constantia

Constan.ttf

5.91

Constantia Italic

Constani.ttf

5.90

Constantia Bold

Constanb.ttf

5.90

Constantia Bold Italic

Constanz.ttf

5.90

Corbel

Corbel.ttf

5.61

Corbel Italic

Corbeli.ttf

5.61

Corbel Bold

Corbelb.ttf

5.61

Corbel Bold Italic

Corbelz.ttf

5.61

Cordia New

Cordia.ttf

5.01

Cordia New Italic

Cordiai.ttf

5.01

Cordia New Bold

Cordiab.ttf

5.01

Cordia New Bold Italic

Cordiaz.ttf

5.01

CordiaUPC

Cordiau.ttf

5.01

CordiaUPC Italic

Cordiaui.ttf

5.01

CordiaUPC Bold

Cordiaub.ttf

5.01

CordiaUPC Bold Italic

Cordiauz.ttf

5.01

Courier New

Cour.ttf

6.87

Courier New Italic

Couri.ttf

6.87

Courier New Bold

Courbd.ttf

6.87

Courier New Bold Italic

Courbi.ttf

6.87

DaunPenh

DaunPenh

Daunpenh.ttf

5.00

David

David

David.ttf

6.00

David Bold

Davidbd.ttf

6.00

Consolas

Constantia

Corbel

Cordia New

CordiaUPC

Courier New

DFKai-SB

DFKai-SB

Kaiu.ttf

5.00

DilleniaUPC

DilleniaUPC

Upcdl.ttf

5.01

DilleniaUPC Italic

Upcdi.ttf

5.01

DilleniaUPC Bold

Upcdb.ttf

5.01

DilleniaUPC Bold Italic

Upcdbi.ttf

5.01

DokChampa

DokChampa

Dokchamp.ttf

5.00

Dotum

Dotum

Gulim.ttc

5.00

DotumChe

Gulim.ttc

5.00

Ebrima

Ebrima.ttf

5.08

Ebrima Bold

Ebrimabd.ttf

5.08

Estrangelo Edessa

Estrangelo Edessa

Estre.ttf

6.00

EucrosiaUPC

EucrosiaUPC

Upcel.ttf

5.01

EucrosiaUPC Italic

Upcei.ttf

5.01

EucrosiaUPC Bold

Upceb.ttf

5.01

EucrosiaUPC Bold Italic

Upcebi.ttf

5.01

Euphemia

Euphemia

Euphemia.ttf

5.05

FangSong

FangSong

Simfang.ttf

5.01

Franklin Gothic Medium

Franklin Gothic Medium

Framd.ttf

5.01

Franklin Gothic Medium Italic

Framdit.ttf

5.00

FrankRuehl

FrankRuehl

Frank.ttf

5.10

FreesiaUPC

FreesiaUPC

Upcfl.ttf

5.02

FreesiaUPC Italic

Upcfi.ttf

5.02

FreesiaUPC Bold

Upcfb.ttf

5.02

FreesiaUPC Bold Italic

Upcfbi.ttf

5.02

Gabriola

Gabriola

Gabriola.ttf

5.92

Gadugi

Gadugi

Gadugi.ttf

1.06

Gadugi Bold

Gadugib.ttf

1.06

Ebrima

Gautami

Gautami

Gautami.ttf

6.00

Gautami Bold

Gautamib.ttf

6.00

Georgia

Georgia.ttf

5.51

Georgia Italic

Georgiai.ttf

5.51

Georgia Bold

Georgiab.ttf

5.51

Georgia Bold Italic

Georgiaz.ttf

5.51

Gisha

Gisha.ttf

5.01

Gisha Bold

Gishabd.ttf

5.01

Gulim

Gulim.ttc

5.00

GulimChe

Gulim.ttc

5.00

Gungsuh

Batang.ttc

5.00

GungsuhChe

Batang.ttc

5.00

Impact

Impact

Impact.ttf

5.10

IrisUPC

IrisUPC

Upcil.ttf

5.02

IrisUPC Italic

Upcii.ttf

5.02

IrisUPC Bold

Upcib.ttf

5.02

IrisUPC Bold Italic

Upcibi.ttf

5.02

Iskoola Pota

Iskpota.ttf

6.00

Iskoola Pota Bold

Iskpotab.ttf

6.00

JasmineUPC

Upcjl.ttf

5.01

JasmineUPC Italic

Upcji.ttf

5.01

JasmineUPC Bold

Upcjb.ttf

5.01

JasmineUPC Bold Italic

Upcjbi.ttf

5.01

Javanese Text

Javanese Text *

Javatext.ttf

1.00

KaiTi

KaiTi

Simkai.ttf

5.01

Kalinga

Kalinga

Kalinga.ttf

6.00

Kalinga Bold

Kalingab.ttf

6.00

Kartika

Kartika.ttf

6.00

Georgia

Gisha

Gulim

Gungsuh

Iskoola Pota

JasmineUPC

Kartika

Khmer UI

KodchiangUPC

Kokila

Lao UI

Latha

Leelawadee

Leelawadee UI

Levenim MT

LilyUPC

Lucida Console

Kartika Bold

Kartikab.ttf

6.00

Khmer UI

KhmerUI.ttf

5.02

Khmer UI Bold

KhmerUIB.ttf

5.02

KodchiangUPC

Upckl.ttf

5.01

KodchiangUPC Italic

Upcki.ttf

5.01

KodchiangUPC Bold

Upckb.ttf

5.01

KodchiangUPC Bold Italic

Upckbi.ttf

5.01

Kokila

Kokila.ttf

6.00

Kokila Italic

Kokilai.ttf

6.00

Kokila Bold

Kokilab.ttf

6.00

Kokila Bold Italic

Kokilabi.ttf

6.00

Lao UI

Laoui.ttf

5.01

Lao UI Bold

Laouib.ttf

5.01

Latha

Latha.ttf

6.00

Latha Bold

Lathab.ttf

6.00

Leelawadee

Leelawad.ttf

5.05

Leelawadee Bold

Leelawdb.ttf

5.05

Leelawadee UI *

LeelawUI.ttf

1.00

Leelawadee UI Semilight *

LeelUIsl.ttf

1.00

Leelawadee UI Bold *

LeelaUIb.ttf

1.00

Levenim MT

Lvnm.ttf

6.00

Levenim MT Bold

Lvnmbd.ttf

6.00

LilyUPC

Upcll.ttf

5.01

LilyUPC Italic

Upcli.ttf

5.01

LilyUPC Bold

Upclb.ttf

5.01

LilyUPC Bold Italic

Upclbi.ttf

5.01

Lucida Console

Lucon.ttf

5.00

Lucida Sans Unicode

Lucida Sans Unicode

L_10646.ttf

5.00

Malgun Gothic

Malgun Gothic

Malgun.ttf

6.50

Malgun Gothic Bold

Malgunbd.ttf

6.50

Mangal

Mangal.ttf

6.00

Mangal Bold

Mangalb.ttf

6.00

Meiryo

Meiryo.ttc

6.30

Meiryo Italic

Meiryo.ttc

6.30

Meiryo Bold

Meiryob.ttc

6.30

Meiryo Bold Italic

Meiryob.ttc

6.30

Meiryo UI

Meiryo.ttc

6.30

Meiryo UI Italic

Meiryo.ttc

6.30

Meiryo UI Bold

Meiryob.ttc

6.30

Meiryo UI Bold Italic

Meiryob.ttc

6.30

Microsoft Himalaya

Microsoft Himalaya

Himalaya.ttf

5.10

Microsoft JhengHei

Microsoft JhengHei Light *

Msjhl.ttc

1.00

Microsoft JhengHei Regular

MSJH.ttc

6.11

Microsoft JhengHei Bold

MSJHBD.ttc

6.11

Microsoft JhengHei UI Light *

Msjhl.ttc

1.00

Microsoft JhengHei UI Regular

MSJH.ttc

6.11

Microsoft JhengHei UI Bold

MSJHBD.ttc

6.11

Microsoft New Tai Lue

Ntailu.ttf

5.96

Microsoft New Tai Lue Bold

Ntailub.ttf

5.96

Microsoft PhagsPa

PhagsPa.ttf

5.97

Microsoft PhagsPa Bold

PhagsPaB.ttf

5.97

Microsoft Sans Serif

Microsoft Sans Serif

Micross.ttf

6.04

Microsoft Tai Le

Microsoft Tai Le

Taile.ttf

5.96

Microsoft Tai Le Bold

TaiLeb.ttf

5.96

Microsoft Uighur

Msuighur.ttf

6.00

Mangal

Meiryo

Meiryo UI

Microsoft New Tai Lue

Microsoft PhagsPa

Microsoft Uighur

Microsoft Uighur Bold

MSUighub.ttf

6.00

Microsoft Yi Baiti

Microsoft Yi Baiti

MSYI.ttf

5.97

Microsoft YaHei

Microsoft YaHei Light *

Msyhl.ttc

1.01

Microsoft YaHei

Msyh.ttc

6.14

Microsoft YaHei Bold

Msyhbd.ttc

6.12

Microsoft YaHei UI Light *

Msyhl.ttc

1.01

Microsoft YaHei UI

Msyh.ttc

6.14

Microsoft YaHei UI Bold

Msyhbd.ttc

6.12

MingLiU

Mingliu.ttc

7.01

PMingLiU

Mingliu.ttc

7.01

MingLiU_HKSCS

Mingliu.ttc

7.01

MingLiU-ExtB

Mingliub.ttc

7.01

PMingLiU-ExtB

Mingliub.ttc

7.01

MingLiU_HKSCS-ExtB

Mingliub.ttc

7.01

Miriam

Mriam.ttf

5.10

Miriam Fixed

Mriamc.ttf

5.10

Mongolian Baiti

Mongolian Baiti

Monbaiti.ttf

5.41

MoolBoran

MoolBoran

Moolbor.ttf

5.00

MS Gothic

MS Gothic

Msgothic.ttc

5.30

MS PGothic

Msgothic.ttc

5.30

MS UI Gothic

Msgothic.ttc

5.30

MS Mincho

Msmincho.ttc

5.30

MS PMincho

Msmincho.ttc

5.30

MV Boli

MV Boli

Mvboli.ttf

6.00

Myanmar Text

Myanmar Text *

Mmrtext.ttf

1.10

Myanmar Text Bold *

Mmrtextb.ttf

1.10

Narkisim

Nrkis.ttf

5.10

MingLiU

Miriam

MS Mincho

Narkisim

Nirmala UI

Nirmala UI Semilight *

Nirmalas.ttf

1.10

Nirmala UI

Nirmala.ttf

1.10

Nirmala UI Bold

Nirmalab.ttf

1.10

Nyala

Nyala

Nyala.ttf

5.01

Palatino Linotype

Palatino Linotype

Pala.ttf

5.02

Palatino Linotype Italic

Palai.ttf

5.02

Palatino Linotype Bold

Palab.ttf

5.02

Palatino Linotype Bold Italic

Palabi.ttf

5.02

Plantagenet Cherokee

Plantagenet Cherokee

Plantc.ttf

5.07

Raavi

Raavi

Raavi.ttf

6.00

Raavi Bold

Raavib.ttf

6.00

Rod

Rod

Rod.ttf

5.10

Sakkal Majalla

Sakkal Majalla

Majalla.ttf

6.81

Sakkal Majalla Bold

Majallab.ttf

6.81

Segoe Print

Segoepr.ttf

5.02

Segoe Print Bold

Segoeprb.ttf

5.02

Segoe Script

Segoesc.ttf

5.00

Segoe Script Bold

Segoescb.ttf

5.00

Segoe UI Light

Segoeuil.ttf

5.37

Segoe UI Light Italic

Seguili.ttf

5.37

Segoe UI Semilight

Segoeuisl.ttf

5.37

Segoe UI Semilight Italic

Seguisli.ttf

5.37

Segoe UI

Segoeui.ttf

5.37

Segoe UI Italic

Segoeuii.ttf

5.37

Segoe UI Semibold

Seguisb.ttf

5.37

Segoe UI Semibold Italic

Seguisbi.ttf

5.37

Segoe UI Bold

Segoeuib.ttf

5.37

Segoe UI Bold Italic

Segoeuiz.ttf

5.37

Segoe Print

Segoe Script

Segoe UI

Segoe UI Black *

Seguibl.ttf

2.00

Segoe UI Black Italic *

Seguibli.ttf

2.00

Segoe UI Emoji

Segoe UI Emoji *

Seguiemj.ttf

1.02

Segoe UI Symbol

Segoe UI Symbol

Seguisym.ttf

6.09

Shonar Bangla

Shonar Bangla

Shonar.ttf

6.81

Shonar Bangla Bold

Shonarb.ttf

6.81

Shruti

Shruti.ttf

6.00

Shruti Bold

Shrutib.ttf

6.00

SimHei

SimHei

Simhei.ttf

5.03

Simplified Arabic

Simplified Arabic

Simpo.ttf

6.00

Simplified Arabic Bold

Simpbdo.ttf

6.00

Simplified Arabic Fixed

Simpfxo.ttf

5.92

SimSun

Simsun.ttc

5.13

NSimSun

Simsun.ttc

5.13

SimSun-ExtB

Simsunb.ttf

5.01

Sitka Small *

Sitka.ttc

1.10

Sitka Small Italic *

SitkaI.ttc

1.10

Sitka Small Bold *

SitkaB.ttc

1.10

Sitka Small Bold Italic *

SitkaZ.ttc

1.10

Sitka Text *

Sitka.ttc

1.10

Sitka Text Italic *

SitkaI.ttc

1.10

Sitka Text Bold *

SitkaB.ttc

1.10

Sitka Text Bold Italic *

SitkaZ.ttc

1.10

Sitka Subheading *

Sitka.ttc

1.10

Sitka Subheading Italic *

SitkaI.ttc

1.10

Sitka Subheading Bold *

SitkaB.ttc

1.10

Sitka Subheading Bold Italic *

SitkaZ.ttc

1.10

Shruti

SimSun

Sitka

Sitka Heading *

Sitka.ttc

1.10

Sitka Heading Italic *

SitkaI.ttc

1.10

Sitka Heading Bold *

SitkaB.ttc

1.10

Sitka Heading Bold Italic *

SitkaZ.ttc

1.10

Sitka Display *

Sitka.ttc

1.10

Sitka Display Italic *

SitkaI.ttc

1.10

Sitka Display Bold *

SitkaB.ttc

1.10

Sitka Display Bold Italic *

SitkaZ.ttc

1.10

Sitka Banner *

Sitka.ttc

1.10

Sitka Banner Italic *

SitkaI.ttc

1.10

Sitka Banner Bold *

SitkaB.ttc

1.10

Sitka Banner Bold Italic *

SitkaZ.ttc

1.10

Sylfaen

Sylfaen

Sylfaen.ttf

5.04

Symbol

Symbol

Symbol.ttf

5.00

Tahoma

Tahoma

Tahoma.ttf

6.05

Tahoma Bold

Tahomabd.ttf

6.05

Times New Roman

Times.ttf

6.89

Times New Roman Italic

Timesi.ttf

6.89

Times New Roman Bold

Timesbd.ttf

6.89

Times New Roman Bold Italic

Timesbi.ttf

6.89

Traditional Arabic

Trado.ttf

6.00

Traditional Arabic Bold

Tradbdo.ttf

6.00

Trebuchet MS

Trebuc.ttf

5.12

Trebuchet MS Italic

Trebucit.ttf

5.12

Trebuchet MS Bold

Trebucbd.ttf

5.12

Trebuchet MS Bold Italic

Trebucbi.ttf

5.12

Tunga

Tunga.ttf

6.00

Tunga Bold

Tungab.ttf

6.00

Times New Roman

Traditional Arabic

Trebuchet MS

Tunga

Urdu Typesetting

Urdu Typesetting

UrdType.ttf

6.00

Urdu Typesetting Bold *

UrdTypeb.ttf

6.00

Utsaah

Utsaah.ttf

6.00

Utsaah Italic

Utsaahi.ttf

6.00

Utsaah Bold

Utsaahb.ttf

6.00

Utsaah Bold Italic

Utsaahbi.ttf

6.00

Vani

Vani.ttf

6.81

Vani Bold

Vanib.ttf

6.81

Verdana

Verdana.ttf

5.31

Verdana Italic

Verdanai.ttf

5.30

Verdana Bold

Verdanab.ttf

5.30

Verdana Bold Italic

Verdanaz.ttf

5.30

Vijaya

Vijaya.ttf

6.81

Vijaya Bold

Vijayab.ttf

6.81

Vrinda

Vrinda.ttf

6.81

Vrinda Bold

Vrindab.ttf

6.81

Webdings

Webdings

Webdings.ttf

5.00

Wingdings

Wingdings

Wingding.ttf

5.00

Yu Gothic

Yu Gothic Light *

Yugothil.ttf

1.60

Yu Gothic Regular *

Yugothic.ttf

1.60

Yu Gothic Bold *

Yugothib.ttf

1.60

Yu Mincho Light *

Yuminl.ttf

1.60

Yu Mincho Regular *

Yumin.ttf

1.60

Yu Mincho Demibold *

Yumindb.ttf

1.60

Utsaah

Vani

Verdana

Vijaya

Vrinda

Yu Mincho

* Fonts added in Windows 8.1

Windows 8 font list
Article • 09/22/2020

This is a list of fonts that shipped with Windows 8. Your versions numbers may be
different if you did not apply Windows updates. The list of Windows 8.1 fonts is here.
Family

Font Name

File Name

Version

Aharoni Bold

Aharoni Bold

Ahronbd.ttf

5.02

Aldhabi

Aldhabi *

Aldhabi.ttf

1.00

Andalus

Andalus

Andlso.ttf

5.99

Angsana New

Angsana New

Angsa.ttf

5.00

Angsana New Italic

Angsai.ttf

5.00

Angsana New Bold

Angsab.ttf

5.00

Angsana New Bold Italic

Angsaz.ttf

5.00

AngsanaUPC

Angsau.ttf

5.00

AngsanaUPC Italic

Angsaui.ttf

5.00

AngsanaUPC Bold

Angsaub.ttf

5.00

AngsanaUPC Bold Italic

Angsauz.ttf

5.00

Aparajita

Aparaj.ttf

5.92

Aparajita Italic

Aparaji.ttf

5.92

Aparajita Bold

Aparajb.ttf

5.92

Aparajita Bold Italic

Aparajbi.ttf

5.92

Arabic Typesetting

Arabic Typesetting

Arabtype.ttf

5.92

Arial

Arial

Arial.ttf

6.89

Arial Italic

Ariali.ttf

6.89

Arial Bold

Arialbd.ttf

6.89

Arial Bold Italic

Arialbi.ttf

6.89

Arial Black

Arial Black

Ariblk.ttf

5.21

Batang

Batang

Batang.ttc

5.00

AngsanaUPC

Aparajita

BatangChe

Batang.ttc

5.00

Browallia New

Browa.ttf

5.00

Browallia New Italic

Browai.ttf

5.00

Browallia New Bold

Browab.ttf

5.00

Browallia New Bold Italic

Browaz.ttf

5.00

BrowalliaUPC

Browau.ttf

5.00

BrowalliaUPC Italic

Browaui.ttf

5.00

BrowalliaUPC Bold

Browaub.ttf

5.00

BrowalliaUPC Bold Italic

Browauz.ttf

5.00

Calibri Light *

Calibril.ttf

2.15

Calibri Light Italic *

Calibrili.ttf

2.15

Calibri

Calibri.ttf

5.90

Calibri Italic

Calibrii.ttf

5.90

Calibri Bold

Calibrib.ttf

5.90

Calibri Bold Italic

Calibriz.ttf

5.90

Cambria

Cambria.ttc

6.84

Cambria Italic

Cambriai.ttf

6.84

Cambria Bold

Cambriab.ttf

6.84

Cambria Bold Italic

Cambriaz.ttf

6.84

Cambria Math

Cambria Math

Cambria.ttc

6.84

Candara

Candara

Candara.ttf

5.61

Candara Italic

Candarai.ttf

5.61

Candara Bold

Candarab.ttf

5.61

Candara Bold Italic

Candaraz.ttf

5.61

Comic Sans MS

Comic.ttf

5.11

Comic Sans MS Italic *

Comici.ttf

5.11

Comic Sans MS Bold

Comicbd.ttf

5.11

Browallia New

BrowalliaUPC

Calibri

Cambria

Comic Sans MS

Comic Sans MS Bold Italic *

Comicz.ttf

5.11

Consolas

Consola.ttf

5.36

Consolas Italic

Consolai.ttf

5.36

Consolas Bold

Consolab.ttf

5.36

Consolas Bold Italic

Consolaz.ttf

5.36

Constantia

Constan.ttf

5.90

Constantia Italic

Constani.ttf

5.90

Constantia Bold

Constanb.ttf

5.90

Constantia Bold Italic

Constanz.ttf

5.90

Corbel

Corbel.ttf

5.61

Corbel Italic

Corbeli.ttf

5.61

Corbel Bold

Corbelb.ttf

5.61

Corbel Bold Italic

Corbelz.ttf

5.61

Cordia New

Cordia.ttf

5.00

Cordia New Italic

Cordiai.ttf

5.00

Cordia New Bold

Cordiab.ttf

5.00

Cordia New Bold Italic

Cordiaz.ttf

5.00

CordiaUPC

Cordiau.ttf

5.00

CordiaUPC Italic

Cordiaui.ttf

5.00

CordiaUPC Bold

Cordiaub.ttf

5.00

CordiaUPC Bold Italic

Cordiauz.ttf

5.00

Courier New

Cour.ttf

6.87

Courier New Italic

Couri.ttf

6.87

Courier New Bold

Courbd.ttf

6.87

Courier New Bold Italic

Courbi.ttf

6.87

DaunPenh

DaunPenh

Daunpenh.ttf

5.00

David

David

David.ttf

5.02

David Bold

Davidbd.ttf

5.02

Consolas

Constantia

Corbel

Cordia New

CordiaUPC

Courier New

DFKai-SB

DFKai-SB

Kaiu.ttf

5.00

DilleniaUPC

DilleniaUPC

Upcdl.ttf

5.01

DilleniaUPC Italic

Upcdi.ttf

5.01

DilleniaUPC Bold

Upcdb.ttf

5.01

DilleniaUPC Bold Italic

Upcdbi.ttf

5.01

DokChampa

DokChampa

Dokchamp.ttf

5.00

Dotum

Dotum

Gulim.ttc

5.00

DotumChe

Gulim.ttc

5.00

Ebrima

Ebrima.ttf

5.06

Ebrima Bold

Ebrimabd.ttf

5.06

Estrangelo Edessa

Estrangelo Edessa

Estre.ttf

5.00

EucrosiaUPC

EucrosiaUPC

Upcel.ttf

5.01

EucrosiaUPC Italic

Upcei.ttf

5.01

EucrosiaUPC Bold

Upceb.ttf

5.01

EucrosiaUPC Bold Italic

Upcebi.ttf

5.01

Euphemia

Euphemia

Euphemia.ttf

5.05

FangSong

FangSong

Simfang.ttf

5.01

Franklin Gothic Medium

Franklin Gothic Medium

Framd.ttf

5.01

Franklin Gothic Medium Italic

Framdit.ttf

5.00

FrankRuehl

FrankRuehl

Frank.ttf

5.02

FreesiaUPC

FreesiaUPC

Upcfl.ttf

5.01

FreesiaUPC Italic

Upcfi.ttf

5.01

FreesiaUPC Bold

Upcfb.ttf

5.01

FreesiaUPC Bold Italic

Upcfbi.ttf

5.01

Gabriola

Gabriola

Gabriola.ttf

5.92

Gadugi

Gadugi *

Gadugi.ttf

1.03

Gadugi Bold *

Gadugib.ttf

1.03

Ebrima

Gautami

Gautami

Gautami.ttf

5.94

Gautami Bold

Gautamib.ttf

5.94

Georgia

Georgia.ttf

5.51

Georgia Italic

Georgiai.ttf

5.51

Georgia Bold

Georgiab.ttf

5.51

Georgia Bold Italic

Georgiaz.ttf

5.51

Gisha

Gisha.ttf

5.01

Gisha Bold

Gishabd.ttf

5.01

Gulim

Gulim.ttc

5.01

GulimChe

Gulim.ttc

5.00

Gungsuh

Batang.ttc

5.00

GungsuhChe

Batang.ttc

5.00

Impact

Impact

Impact.ttf

5.10

IrisUPC

IrisUPC

Upcil.ttf

5.01

IrisUPC Italic

Upcii.ttf

5.01

IrisUPC Bold

Upcib.ttf

5.01

IrisUPC Bold Italic

Upcibi.ttf

5.01

Iskoola Pota

Iskpota.ttf

5.94

Iskoola Pota Bold

Iskpotab.ttf

5.94

JasmineUPC

Upcjl.ttf

5.01

JasmineUPC Italic

Upcji.ttf

5.01

JasmineUPC Bold

Upcjb.ttf

5.01

JasmineUPC Bold Italic

Upcjbi.ttf

5.01

KaiTi

KaiTi

Simkai.ttf

5.01

Kalinga

Kalinga

Kalinga.ttf

5.95

Kalinga Bold

Kalingab.ttf

5.95

Kartika

Kartika.ttf

5.95

Kartika Bold

Kartikab.ttf

5.95

Georgia

Gisha

Gulim

Gungsuh

Iskoola Pota

JasmineUPC

Kartika

Khmer UI

Khmer UI

KhmerUI.ttf

5.02

Khmer UI Bold

KhmerUIB.ttf

5.02

KodchiangUPC

Upckl.ttf

5.01

KodchiangUPC Italic

Upcki.ttf

5.01

KodchiangUPC Bold

Upckb.ttf

5.01

KodchiangUPC Bold Italic

Upckbi.ttf

5.01

Kokila

Kokila.ttf

5.92

Kokila Italic

Kokilai.ttf

5.92

Kokila Bold

Kokilab.ttf

5.92

Kokila Bold Italic

Kokilabi.ttf

5.92

Lao UI

Laoui.ttf

5.01

Lao UI Bold

Laouib.ttf

5.01

Latha

Latha.ttf

5.94

Latha Bold

Lathab.ttf

5.94

Leelawadee

Leelawad.ttf

5.05

Leelawadee Bold

Leelawdb.ttf

5.05

Levenim MT

Lvnm.ttf

5.03

Levenim MT Bold

Lvnmbd.ttf

5.03

LilyUPC

Upcll.ttf

5.01

LilyUPC Italic

Upcli.ttf

5.01

LilyUPC Bold

Upclb.ttf

5.01

LilyUPC Bold Italic

Upclbi.ttf

5.01

Lucida Console

Lucida Console

Lucon.ttf

5.00

Lucida Sans Unicode

Lucida Sans Unicode

L_10646.ttf

5.00

Malgun Gothic

Malgun Gothic

Malgun.ttf

6.22

Malgun Gothic Bold

Malgunbd.ttf

6.22

Mangal

Mangal.ttf

5.94

KodchiangUPC

Kokila

Lao UI

Latha

Leelawadee

Levenim MT

LilyUPC

Mangal

Mangal Bold

Mangalb.ttf

5.94

Marlett

Marlett

Marlett.ttf

5.00

Meiryo

Meiryo

Meiryo.ttc

6.30

Meiryo Italic

Meiryo.ttc

6.30

Meiryo Bold

Meiryob.ttc

6.30

Meiryo Bold Italic

Meiryob.ttc

6.30

Meiryo UI

Meiryo.ttc

6.30

Meiryo UI Italic

Meiryo.ttc

6.30

Meiryo UI Bold

Meiryob.ttc

6.30

Meiryo UI Bold Italic

Meiryob.ttc

6.30

Microsoft Himalaya

Microsoft Himalaya

Himalaya.ttf

5.06

Microsoft JhengHei

Microsoft JhengHei Regular

MSJH.ttc

6.10

Microsoft JhengHei Bold

MSJHBD.ttc

6.10

Microsoft JhengHei UI Regular

MSJH.ttc

6.10

Microsoft JhengHei UI Bold

MSJHBD.ttc

6.10

Microsoft New Tai Lue

Ntailu.ttf

5.96

Microsoft New Tai Lue Bold

Ntailub.ttf

5.96

Microsoft PhagsPa

PhagsPa.ttf

5.96

Microsoft PhagsPa Bold

PhagsPaB.ttf

5.96

Microsoft Sans Serif

Microsoft Sans Serif

Micross.ttf

6.04

Microsoft Tai Le

Microsoft Tai Le

Taile.ttf

5.96

Microsoft Tai Le Bold

TaiLeb.ttf

5.96

Microsoft Uighur

Msuighur.ttf

5.93

Microsoft Uighur Bold *

MSUighub.ttf

5.93

Microsoft Yi Baiti

Microsoft Yi Baiti

MSYI.ttf

5.97

Microsoft YaHei

Microsoft YaHei

Msyh.ttf

6.10

Microsoft YaHei Bold

Msyhbd.ttf

6.11

Microsoft YaHei UI

Msyh.ttf

6.10

Meiryo UI

Microsoft New Tai Lue

Microsoft PhagsPa

Microsoft Uighur

Microsoft YaHei UI Bold

Msyhbd.ttf

6.11

MingLiU

Mingliu.ttc

7.01

MingLiU-ExtB

Mingliub.ttc

7.01

PMingLiU

Mingliu.ttc

7.01

PMingLiU-ExtB

Mingliub.ttc

7.01

MingLiU_HKSCS

Mingliu.ttc

7.01

MingLiU_HKSCS-ExtB

Mingliub.ttc

7.01

Miriam

Mriam.ttf

5.02

Miriam Fixed

Mriamc.ttf

5.02

Mongolian Baiti

Mongolian Baiti

Monbaiti.ttf

5.10

MoolBoran

MoolBoran

Moolbor.ttf

5.00

MS Gothic

MS Gothic

Msgothic.ttc

5.31

MS PGothic

Msgothic.ttc

5.31

MS UI Gothic

Msgothic.ttc

5.31

MS Mincho

Msmincho.ttc

5.30

MS PMincho

Msmincho.ttc

5.30

MV Boli

MV Boli

Mvboli.ttf

5.01

Myanmar Text

Myanmar Text *

Mmrtext.ttf

1.00

Narkisim

Narkisim

Nrkis.ttf

5.02

Nirmala UI

Nirmala UI *

Nirmala.ttf

1.10

Nirmala UI Bold *

Nirmalab.ttf

1.10

Nyala

Nyala

Nyala.ttf

5.01

Palatino Linotype

Palatino Linotype

Pala.ttf

5.01

Palatino Linotype Italic

Palai.ttf

5.01

Palatino Linotype Bold

Palab.ttf

5.01

Palatino Linotype Bold Italic

Palabi.ttf

5.01

Plantagenet Cherokee

Plantc.ttf

5.07

MingLiU

Miriam

MS Mincho

Plantagenet Cherokee

Raavi

Raavi

Raavi.ttf

5.94

Raavi Bold

Raavib.ttf

5.94

Rod

Rod

Rod.ttf

5.02

Sakkal Majalla

Sakkal Majalla

Majalla.ttf

6.80

Sakkal Majalla Bold

Majallab.ttf

6.80

Segoe Print

Segoepr.ttf

5.02

Segoe Print Bold

Segoeprb.ttf

5.02

Segoe Script

Segoesc.ttf

5.00

Segoe Script Bold

Segoescb.ttf

5.00

Segoe UI Light

Segoeuil.ttf

5.37

Segoe UI Light Italic *

Seguili.ttf

5.37

Segoe UI Semilight *

Segoeuisl.ttf

5.37

Segoe UI Semilight Italic *

Seguisli.ttf

5.37

Segoe UI

Segoeui.ttf

5.37

Segoe UI Italic

Segoeuii.ttf

5.37

Segoe UI Semibold

Seguisb.ttf

5.37

Segoe UI Semibold Italic *

Seguisbi.ttf

5.37

Segoe UI Bold

Segoeuib.ttf

5.37

Segoe UI Bold Italic

Segoeuiz.ttf

5.37

Segoe UI Symbol

Segoe UI Symbol

Seguisym.ttf

5.90

Shonar Bangla

Shonar Bangla

Shonar.ttf

6.80

Shonar Bangla Bold

Shonarb.ttf

6.80

Shruti

Shruti.ttf

5.94

Shruti Bold

Shrutib.ttf

5.94

SimHei

SimHei

Simhei.ttf

5.03

Simplified Arabic

Simplified Arabic

Simpo.ttf

5.98

Simplified Arabic Bold

Simpbdo.ttf

5.98

Simplified Arabic Fixed

Simpfxo.ttf

5.92

Segoe Print

Segoe Script

Segoe UI

Shruti

SimSun

SimSun

Simsun.ttc

5.13

NSimSun

Simsun.ttc

5.13

SimSun-ExtB

Simsunb.ttf

5.01

Sylfaen

Sylfaen

Sylfaen.ttf

5.04

Symbol

Symbol

Symbol.ttf

5.00

Tahoma

Tahoma

Tahoma.ttf

6.05

Tahoma Bold

Tahomabd.ttf

6.05

Times New Roman

Times.ttf

6.89

Times New Roman Italic

Timesi.ttf

6.89

Times New Roman Bold

Timesbd.ttf

6.89

Times New Roman Bold Italic

Timesbi.ttf

6.89

Traditional Arabic

Trado.ttf

5.98

Traditional Arabic Bold

Tradbdo.ttf

5.98

Trebuchet MS

Trebuc.ttf

5.10

Trebuchet MS Italic

Trebucit.ttf

5.10

Trebuchet MS Bold

Trebucbd.ttf

5.10

Trebuchet MS Bold Italic

Trebucbi.ttf

5.10

Tunga

Tunga.ttf

5.94

Tunga Bold

Tungab.ttf

5.94

Utsaah

Utsaah.ttf

5.92

Utsaah Italic

Utsaahi.ttf

5.92

Utsaah Bold

Utsaahb.ttf

5.92

Utsaah Bold Italic

Utsaahbi.ttf

5.92

Urdu Typesetting

Urdu Typesetting *

UrdType.ttf

5.93

Vani

Vani

Vani.ttf

6.80

Vani Bold

Vanib.ttf

6.80

Verdana

Verdana.ttf

5.31

Times New Roman

Traditional Arabic

Trebuchet MS

Tunga

Utsaah

Verdana

Verdana Italic

Verdanai.ttf

5.30

Verdana Bold

Verdanab.ttf

5.30

Verdana Bold Italic

Verdanaz.ttf

5.30

Vijaya

Vijaya.ttf

6.80

Vijaya Bold

Vijayab.ttf

6.80

Vrinda

Vrinda.ttf

6.80

Vrinda Bold

Vrindab.ttf

6.80

Webdings

Webdings

Webdings.ttf

5.00

Wingdings

Wingdings

Wingding.ttf

5.00

Vijaya

Vrinda

* Fonts added in Windows 8

Windows 7 font list
Article • 02/10/2021

This is a list of fonts that shipped with Windows 7. Your versions numbers may be
different if you did not apply Windows updates. The list of Windows 8 fonts is here.
Family

Font Name

File Name

Version

Aharoni Bold

Aharoni Bold

Ahronbd.ttf

5.02

Andalus

Andalus

Andlso.ttf

5.92

Angsana New

Angsana New

Angsa.ttf

5.00

Angsana New Italic

Angsai.ttf

5.00

Angsana New Bold

Angsab.ttf

5.00

Angsana New Bold Italic

Angsaz.ttf

5.00

AngsanaUPC

Angsau.ttf

5.00

AngsanaUPC Italic

Angsaui.ttf

5.00

AngsanaUPC Bold

Angsaub.ttf

5.00

AngsanaUPC Bold Italic

Angsauz.ttf

5.00

Aparajita

Aparaj.ttf

5.91

Aparajita Italic

Aparaji.ttf

5.91

Aparajita Bold

Aparajb.ttf

5.91

Aparajita Bold Italic

Aparajbi.ttf

5.91

Arabic Typesetting

Arabic Typesetting

Arabtype.ttf

5.91

Arial

Arial

Arial.ttf

5.22

Arial Italic

Ariali.ttf

5.22

Arial Bold

Arialbd.ttf

5.22

Arial Bold Italic

Arialbi.ttf

5.22

Arial Black

Arial Black

Ariblk.ttf

5.06

Batang

Batang

Batang.ttc

5.00

BatangChe

Batang.ttc

5.00

AngsanaUPC

Aparajita

Browallia New

Browallia New

Browa.ttf

5.00

Browallia New Italic

Browai.ttf

5.00

Browallia New Bold

Browab.ttf

5.00

Browallia New Bold Italic

Browaz.ttf

5.00

BrowalliaUPC

Browau.ttf

5.00

BrowalliaUPC Italic

Browaui.ttf

5.00

BrowalliaUPC Bold

Browaub.ttf

5.00

BrowalliaUPC Bold Italic

Browauz.ttf

5.00

Calibri

Calibri.ttf

5.75

Calibri Italic

Calibrii.ttf

5.75

Calibri Bold

Calibrib.ttf

5.75

Calibri Bold Italic

Calibriz.ttf

5.75

Calibri Light

Calibril.ttf

2.10

Calibri Light Italic

Calibrili.ttf

2.10

Cambria

Cambria.ttc

5.97

Cambria Italic

Cambriai.ttf

5.97

Cambria Bold

Cambriab.ttf

5.97

Cambria Bold Italic

Cambriaz.ttf

5.97

Cambria Math

Cambria Math

Cambria.ttc

5.97

Candara

Candara

Candara.ttf

5.61

Candara Italic

Candarai.ttf

5.61

Candara Bold

Candarab.ttf

5.61

Candara Bold Italic

Candaraz.ttf

5.61

Comic Sans MS

Comic.ttf

5.11

Comic Sans MS Bold

Comicbd.ttf

5.11

Comic Sans MS Italic

Comici.ttf

5.11

Comic Sans MS Bold Italic

Comicz.ttf

5.11

BrowalliaUPC

Calibri

Cambria

Comic Sans MS

Consolas

Consolas

Consola.ttf

5.24

Consolas Italic

Consolai.ttf

5.24

Consolas Bold

Consolab.ttf

5.24

Consolas Bold Italic

Consolaz.ttf

5.24

Constantia

Constan.ttf

5.90

Constantia Italic

Constani.ttf

5.90

Constantia Bold

Constanb.ttf

5.90

Constantia Bold Italic

Constanz.ttf

5.90

Corbel

Corbel.ttf

5.61

Corbel Italic

Corbeli.ttf

5.61

Corbel Bold

Corbelb.ttf

5.61

Corbel Bold Italic

Corbelz.ttf

5.61

Cordia New

Cordia.ttf

5.00

Cordia New Italic

Cordiai.ttf

5.00

Cordia New Bold

Cordiab.ttf

5.00

Cordia New Bold Italic

Cordiaz.ttf

5.00

CordiaUPC

Cordiau.ttf

5.00

CordiaUPC Italic

Cordiaui.ttf

5.00

CordiaUPC Bold

Cordiaub.ttf

5.00

CordiaUPC Bold Italic

Cordiauz.ttf

5.00

Courier New

Cour.ttf

5.13

Courier New Italic

Couri.ttf

5.13

Courier New Bold

Courbd.ttf

5.13

Courier New Bold Italic

Courbi.ttf

5.13

DaunPenh

DaunPenh

Daunpenh.ttf

5.00

David

David

David.ttf

5.02

David Bold

Davidbd.ttf

5.02

DFKai-SB

Kaiu.ttf

5.00

Constantia

Corbel

Cordia New

CordiaUPC

Courier New

DFKai-SB

DilleniaUPC

DilleniaUPC

Upcdl.ttf

5.01

DilleniaUPC Italic

Upcdi.ttf

5.01

DilleniaUPC Bold

Upcdb.ttf

5.01

DilleniaUPC Bold Italic

Upcdbi.ttf

5.01

DokChampa

DokChampa

Dokchamp.ttf

5.00

Dotum

Dotum

Gulim.ttc

5.00

DotumChe

Gulim.ttc

5.00

Ebrima

Ebrima.ttf

5.00

Ebrima Bold

Ebrimabd.ttf

5.00

Estrangelo Edessa

Estrangelo Edessa

Estre.ttf

5.00

EucrosiaUPC

EucrosiaUPC

Upcel.ttf

5.01

EucrosiaUPC Italic

Upcei.ttf

5.01

EucrosiaUPC Bold

Upceb.ttf

5.01

EucrosiaUPC Bold Italic

Upcebi.ttf

5.01

Euphemia

Euphemia

Euphemia.ttf

5.00

FangSong

FangSong

Simfang.ttf

5.01

Franklin Gothic Medium

Franklin Gothic Medium

Framd.ttf

5.01

Franklin Gothic Medium Italic

Framdit.ttf

5.00

FrankRuehl

FrankRuehl

Frank.ttf

5.02

FreesiaUPC

FreesiaUPC

Upcfl.ttf

5.01

FreesiaUPC Italic

Upcfi.ttf

5.01

FreesiaUPC Bold

Upcfb.ttf

5.01

FreesiaUPC Bold Italic

Upcfbi.ttf

5.01

Gabriola

Gabriola

Gabriola.ttf

5.92

Gautami

Gautami

Gautami.ttf

5.90

Gautami Bold

Gautamib.ttf

5.90

Georgia

Georgia.ttf

5.51

Ebrima

Georgia

Georgia Italic

Georgiai.ttf

5.51

Georgia Bold

Georgiab.ttf

5.51

Georgia Bold Italic

Georgiaz.ttf

5.51

Gisha

Gisha.ttf

5.00

Gisha Bold

Gishabd.ttf

5.00

Gulim

Gulim.ttc

5.01

GulimChe

Gulim.ttc

5.00

Gungsuh

Batang.ttc

5.00

GungsuhChe

Batang.ttc

5.00

Impact

Impact

Impact.ttf

5.00

IrisUPC

IrisUPC

Upcil.ttf

5.01

IrisUPC Italic

Upcii.ttf

5.01

IrisUPC Bold

Upcib.ttf

5.01

IrisUPC Bold Italic

Upcibi.ttf

5.01

Iskoola Pota

Iskpota.ttf

5.90

Iskoola Pota Bold

Iskpotab.ttf

5.90

JasmineUPC

Upcjl.ttf

5.01

JasmineUPC Italic

Upcji.ttf

5.01

JasmineUPC Bold

Upcjb.ttf

5.01

JasmineUPC Bold Italic

Upcjbi.ttf

5.01

KaiTi

KaiTi

Simkai.ttf

5.01

Kalinga

Kalinga

Kalinga.ttf

5.90

Kalinga Bold

Kalingab.ttf

5.90

Kartika

Kartika.ttf

5.90

Kartika Bold

Kartikab.ttf

5.90

Khmer UI

KhmerUI.ttf

5.00

Khmer UI Bold

KhmerUIB.ttf

5.00

KodchiangUPC

Upckl.ttf

5.01

Gisha

Gulim

Gungsuh

Iskoola Pota

JasmineUPC

Kartika

Khmer UI

KodchiangUPC

KodchiangUPC Italic

Upcki.ttf

5.01

KodchiangUPC Bold

Upckb.ttf

5.01

KodchiangUPC Bold Italic

Upckbi.ttf

5.01

Kokila

Kokila.ttf

5.91

Kokila Italic

Kokilai.ttf

5.91

Kokila Bold

Kokilab.ttf

5.91

Kokila Bold Italic

Kokilabi.ttf

5.91

Lao UI

Laoui.ttf

5.00

Lao UI Bold

Laouib.ttf

5.00

Latha

Latha.ttf

5.90

Latha Bold

Lathab.ttf

5.90

Leelawadee

Leelawad.ttf

5.00

Leelawadee Bold

Leelawdb.ttf

5.00

Levenim MT

Lvnm.ttf

5.02

Levenim MT Bold

Lvnmbd.ttf

5.02

LilyUPC

Upcll.ttf

5.01

LilyUPC Italic

Upcli.ttf

5.01

LilyUPC Bold

Upclb.ttf

5.01

LilyUPC Bold Italic

Upclbi.ttf

5.01

Lucida Console

Lucida Console

Lucon.ttf

5.00

Lucida Sans Unicode

Lucida Sans Unicode

L_10646.ttf

5.00

Malgun Gothic

Malgun Gothic

Malgun.ttf

6.11

Malgun Gothic Bold

Malgunbd.ttf

6.00

Mangal

Mangal.ttf

5.91

Mangal Bold

Mangalb.ttf

5.91

Marlett

Marlett

Marlett.ttf

5.00

Meiryo

Meiryo

Meiryo.ttc

6.05

Kokila

Lao UI

Latha

Leelawadee

Levenim MT

LilyUPC

Mangal

Meiryo Italic

Meiryo.ttc

6.05

Meiryo Bold

Meiryob.ttc

6.05

Meiryo Bold Italic

Meiryob.ttc

6.05

Meiryo UI

Meiryo.ttc

6.05

Meiryo UI Italic

Meiryo.ttc

6.05

Meiryo UI Bold

Meiryob.ttc

6.05

Meiryo UI Bold Italic

Meiryob.ttc

6.05

Microsoft Himalaya

Microsoft Himalaya

Himalaya.ttf

5.00

Microsoft JhengHei

Microsoft JhengHei

MSJH.ttf

6.02

Microsoft JhengHei Bold

MSJHBD.ttf

6.00

Microsoft New Tai Lue

Ntailu.ttf

5.90

Microsoft New Tai Lue Bold

Ntailub.ttf

5.90

Microsoft PhagsPa

PhagsPa.ttf

5.90

Microsoft PhagsPa Bold

PhagsPaB.ttf

5.90

Microsoft Sans Serif

Microsoft Sans Serif

Micross.ttf

5.22

Microsoft Tai Le

Microsoft Tai Le

Taile.ttf

5.90

Microsoft Tai Le Bold

TaiLeb.ttf

5.90

Microsoft Uighur

Microsoft Uighur

Msuighur.ttf

5.91

Microsoft YaHei

Microsoft YaHei

Msyh.ttf

6.02

Microsoft YaHei Bold

Msyhbd.ttf

6.02

Microsoft Yi Baiti

Microsoft Yi Baiti

MSYI.ttf

5.00

MingLiU

MingLiU

Mingliu.ttc

7.00

MingLiU-ExtB

Mingliub.ttc

7.00

PMingLiU

Mingliu.ttc

7.00

PMingLiU-ExtB

Mingliub.ttc

7.00

MingLiU_HKSCS

Mingliu.ttc

7.00

MingLiU_HKSCS-ExtB

Mingliub.ttc

7.00

Miriam

Mriam.ttf

5.02

Meiryo UI

Microsoft New Tai Lue

Microsoft PhagsPa

Miriam

Miriam Fixed

Mriamc.ttf

5.02

Mongolian Baiti

Mongolian Baiti

Monbaiti.ttf

5.01

MoolBoran

MoolBoran

Moolbor.ttf

5.00

MS Gothic

MS Gothic

Msgothic.ttc

5.05

MS PGothic

Msgothic.ttc

5.05

MS UI Gothic

Msgothic.ttc

5.05

MS Mincho

Msmincho.ttc

5.05

MS PMincho

Msmincho.ttc

5.05

MV Boli

MV Boli

Mvboli.ttf

5.01

Narkisim

Narkisim

Nrkis.ttf

5.02

Nyala

Nyala

Nyala.ttf

5.00

Palatino Linotype

Palatino Linotype

Pala.ttf

5.00

Palatino Linotype Italic

Palai.ttf

5.00

Palatino Linotype Bold

Palab.ttf

5.00

Palatino Linotype Bold Italic

Palabi.ttf

5.00

Plantagenet Cherokee

Plantagenet Cherokee

Plantc.ttf

5.00

Raavi

Raavi

Raavi.ttf

5.90

Raavi Bold

Raavib.ttf

5.90

Rod

Rod

Rod.ttf

5.02

Sakkal Majalla

Sakkal Majalla

Majalla.ttf

5.01

Sakkal Majalla Bold

Majallab.ttf

5.01

Segoe Print

Segoepr.ttf

5.02

Segoe Print Bold

Segoeprb.ttf

5.02

Segoe Script

Segoesc.ttf

5.00

Segoe Script Bold

Segoescb.ttf

5.00

Segoe UI Light

Segoeuil.ttf

5.00

Segoe UI

Segoeui.ttf

5.13

MS Mincho

Segoe Print

Segoe Script

Segoe UI

Segoe UI Italic

Segoeuii.ttf

5.13

Segoe UI Semibold

Seguisb.ttf

5.00

Segoe UI Bold

Segoeuib.ttf

5.13

Segoe UI Bold Italic

Segoeuiz.ttf

5.13

Segoe UI Symbol

Segoe UI Symbol

Seguisym.ttf

5.01

Shonar Bangla

Shonar Bangla

Shonar.ttf

5.91

Shonar Bangla Bold

Shonarb.ttf

5.91

Shruti

Shruti.ttf

5.90

Shruti Bold

Shrutib.ttf

5.90

SimHei

SimHei

Simhei.ttf

5.01

Simplified Arabic

Simplified Arabic

Simpo.ttf

5.92

Simplified Arabic Bold

Simpbdo.ttf

5.92

Simplified Arabic Fixed

Simpfxo.ttf

5.92

SimSun

Simsun.ttc

5.03

NSimSun

Simsun.ttc

5.03

SimSun-ExtB

Simsunb.ttf

5.00

Sylfaen

Sylfaen

Sylfaen.ttf

5.02

Symbol

Symbol

Symbol.ttf

5.00

Tahoma

Tahoma

Tahoma.ttf

5.22

Tahoma Bold

Tahomabd.ttf

5.22

Times New Roman

Times.ttf

5.22

Times New Roman Italic

Timesi.ttf

5.22

Times New Roman Bold

Timesbd.ttf

5.22

Times New Roman Bold Italic

Timesbi.ttf

5.22

Traditional Arabic

Trado.ttf

5.92

Traditional Arabic Bold

Tradbdo.ttf

5.92

Trebuchet MS

Trebuc.ttf

5.11

Trebuchet MS Italic

Trebucit.ttf

5.11

Shruti

SimSun

Times New Roman

Traditional Arabic

Trebuchet MS

Trebuchet MS Bold

Trebucbd.ttf

5.11

Trebuchet MS Bold Italic

Trebucbi.ttf

5.11

Tunga

Tunga.ttf

5.90

Tunga Bold

Tungab.ttf

5.90

Utsaah

Utsaah.ttf

5.91

Utsaah Italic

Utsaahi.ttf

5.91

Utsaah Bold

Utsaahb.ttf

5.91

Utsaah Bold Italic

Utsaahbi.ttf

5.91

Vani

Vani.ttf

5.91

Vani Bold

Vanib.ttf

5.91

Verdana

Verdana.ttf

5.31

Verdana Italic

Verdanai.ttf

5.30

Verdana Bold

Verdanab.ttf

5.30

Verdana Bold Italic

Verdanaz.ttf

5.30

Vijaya

Vijaya.ttf

5.91

Vijaya Bold

Vijayab.ttf

5.91

Vrinda

Vrinda.ttf

5.90

Vrinda Bold

Vrindab.ttf

5.90

Webdings

Webdings

Webdings.ttf

5.00

Wingdings

Wingdings

Wingding.ttf

5.00

Tunga

Utsaah

Vani

Verdana

Vijaya

Vrinda

* Fonts added in Windows 7

Font redistribution FAQ (Frequently
Asked Questions) for Windows
Article • 11/19/2024

Windows comes with a collection of fonts that are installed as system-wide resources.
Any application installed on your Windows computer has access to these fonts.
A Windows application can use the fonts to render content to a screen, allow that
content to be edited, and allow that content to be output to a device, like a printer. Here
are answers to common questions about using these fonts.

Frequent questions
Where did the Windows fonts come from?
Some of the fonts supplied with Windows were created specifically for Microsoft by
leading type designers and type design companies (known as font foundries). Other
fonts were licensed to Microsoft from font foundries for inclusion with Windows.
What can I do with the things that I print from Windows using these fonts?
Unless you are using an application that is specifically licensed for home, student, or
non-commercial use, we do not place any restrictions on what you do with print output
that uses these fonts.
Can I sell things I print from Windows or make using these printouts, say a book,
logo, advertisement, report, t-shirt, or crafts that use fonts that come with Windows?
Unless you are using an application that is specifically licensed for home, student, or
non-commercial use, we do not restrict you from selling the things you print and make
using the Windows-supplied fonts.
Can I make graphic files using the fonts, say a screengrab, advertisement, meme or
poster and share, sell or redistribute those graphic files?
We view creating graphic files as being essentially the same as printing from an output
device.
Can I use the fonts to produce captions and text included in videos?
We view this as the same as graphic files, providing the captions or text is rendered as a
bitmap image, and the font files themselves are not embedded within the video file.

Can I make a company logo using the fonts?
Unless you are using an application that is specifically licensed for home, student, or
non-commercial use, we do not restrict you from making logos using the Windowssupplied fonts.
I have a printer connected to my computer that supports fonts being download to it
to speed up printing. Is that allowed?
Yes, we allow the temporary downloading of Windows-supplied fonts to a printer or
output device to improve printing performance.
Do these general use guidelines apply to the symbol and emoji fonts supplied with
Windows?
Yes, they apply to all the fonts installed with Windows as system-wide resources. Hidden
fonts—those that don’t show up in font menus, which may be embedded in code—are
not covered by this guide and should not be extracted and used.

Web
CSS lets a web page creator specify a prioritized list of fonts (commonly known as a
“font stack”) that a web content rendering engine, such as those used by a web browser,
should use to render the text of a web page if they are available on the device on which
the rendering engine is running. Web content publishers are free to specify Windows
supplied fonts in their font stacks. In fact, as a web page creator you don’t even need to
be a Windows licensee to include a Windows font name in a CSS font stack, as the “use”
of the font occurs on the Windows device, not on your web server.
Web fonts are fonts that are hosted on a web server. You do not have rights to:
copy fonts from a Windows installation to a web server, a process known as web
font “self-hosting”.
convert the font to the formats typically associated with web fonts, such as the
WOFF or WOFF2 format.
Many Windows fonts are available for web use through Monotype’s Fonts.com web font
service, some are also available via Type Network’s WebType.com. Other Windows fonts
may be available from their original creator.

Document embedding

Although the redistribution of fonts supplied with Windows is generally not allowed,
“document font embedding” is a special case which is allowed in some circumstances.
What is document embedding?
Document font embedding is defined in the OpenType and TrueType font
specifications – with a specific set of rules and restrictions.
When can I use document embedding?
The brief answer: If an application follows the rules and restrictions defined in the
OpenType or TrueType specification, you can use it to embed Windows supplied fonts in
any document file it creates. For example, Microsoft Word and PowerPoint follow the
rules and restrictions, so you can use these applications to create documents (such as
Word documents, PowerPoint decks and PDFs) that include embedded fonts.
A more detailed explanation:
Font files contain flags that indicate if and how they can be embedded within a
document file. Applications that support document font embedding look at these flags
and determine if and how it may be embedded in a document file, and when they open
a document containing embedded fonts, they will also look at these flags to determine
if and how a document can be viewed or edited.
There are several different flags, and you can see them all defined in the OpenType and
TrueType font specifications but there are only four in common use.
The most common setting for Microsoft supplied fonts is “editable embedding.” When
this flag is set an authoring application may embed the font into a saved document file.
When the document is opened on a machine that does not have the font installed the
application may allow the document to be edited.
The most common setting for Microsoft third party fonts is “print and preview
embedding.” When this flag is set an authoring application may embed the font into a
saved document file. When the document is opened on a machine that does not have
the font installed the application can use the font to display and print the content, but
the document must be locked for editing.
Another, less common setting to be aware of is “installable embedding.” When this flag
is set an authoring application may embed the font into a saved document file. When
the document is opened on a machine that does not have the font installed the
application may allow the document to be viewed printed and edited and may install
the font for use on the computer outside of that document. In practice all of the
applications we are aware of treat these fonts the same as those set to “editable

embedding.” The other setting to be aware of is the “restricted license”, also known as
the “no embedding” setting. These fonts may not be embedded.
What if I embed “print and preview” fonts and “editable” fonts in the same document,
can I only edit the parts that use the editable embedding fonts?
No, the specification requires that the whole document be locked for editing.
What if a font has more than one flag set?
The specification states that the least restrictive setting takes precedence.
You mention PowerPoint decks, Word documents and PDFs output from Word but
how about other applications and document formats like ePub?
If the applications follow the rules and restrictions documented in the OpenType and
TrueType font specifications around document font embedding, you are allowed to use
them to embed the Windows-supplied font. Please check the documentation associated
with the application and document file format to confirm it is compliant with the
OpenType or TrueType specs.
If I use software that follows the rules and I output document files that include
embedded Windows fonts, are there any restrictions around redistributing the
documents?
The applications you use to create the documents may limit commercial use, but in
general, there are no special restrictions around the distribution of documents that
contain embedded Windows’ fonts (unless you are using an application that is
specifically licensed for home, student, or non-commercial use).
Can I embed the fonts into a game, application or device I’m developing based on the
document font embedding permissions?
No, document font embedding permissions relate to embedding fonts in documents
only, not embedding fonts in games, apps and devices.
If I convert the font into a bitmap font can I include that in my game or app?
No, converting Windows fonts to other formats does not change the rules around
embedding or redistribution, and format conversion itself is not allowed. Many
Microsoft supplied fonts are available for app and game licensing through the original
font foundry or Monotype.
Can I include graphic files (eg. GIFs, PNGs or JPEGs) I create using the fonts in my
game or apps, say for a logo or banner?

Yes, you can (provided you're using a product that is not specifically licensed for home,
student or non-commercial use). The graphic file must be an image of a word, phrase or
passage of text. Converting the font to a bitmap font (where each letter is treated
individually) is not allowed.

Redistribution and extended rights
Apart from the document embedding rights described previously, you may not
redistribute the Windows fonts. You may not copy them to other computers or servers,
and you may not convert them to other formats, including bitmap formats, or modify
them.
I like to tinker with fonts, what if I do this in the privacy of my own home and promise
not to redistribute or embed the modified or converted fonts?
We do not provide the rights to authorize end-user modifications or conversions of the
fonts included in Microsoft Windows.
Where can I obtain extended rights that allow me to do the things that are not
allowed under the Windows license, such as ship the fonts with my app, game or
device?
Check the font properties to find the owner or developer of the font in question. Many
of the fonts owned by Microsoft can be licensed with extended rights from Monotype

.

For other fonts contact the foundry owner identified under font properties. Select Start
> Settings > Personalization > Fonts. Or, in the search box on the taskbar, type fonts,
and then select Font settings. Click on any of the fonts installed to learn more about the
designer and manufacturer of the font file.
Regarding Segoe UI and Segoe UI Variable: I am interested in using these fonts in my
non-Windows application or game. Are they available for licensing through
Monotype?
Please note that while Segoe UI can be licensed from Monotype, Segoe UI Variable is
not available for licensing or use outside of Microsoft products or on non-Windows
platforms.

Downgrading to older fonts
We work hard to address bugs, add language support, and generally improve the fonts
we ship with every release of Windows – ensuring backward compatibility and limiting
content reflow is a top priority for us too. Occasionally, a bug fix may cause issues with

an existing app or document. Unfortunately, there is no official process to downgrade to
an older version of a Windows font. If you are experiencing issues, contact Microsoft
support

.

Upgrading to new fonts
In most cases you will need to upgrade Windows to get the latest font updates.
Occasionally, font updates will be available via the download center, most commonly to
add currency symbols to common document and UI fonts.

Other fonts
This FAQ covers only the fonts Microsoft supplies with Windows as system wide
resources: Microsoft Fonts list. For fonts obtained elsewhere or supplied with other apps,
you will need to review the license agreements that accompany those applications.
Why must I dig up and read those agreements?
We're sorry, but Microsoft can’t provide guidance to fonts that we didn’t supply.
The rights we provide to you for Windows supplied fonts are considered quite broad,
and it’s possible that other font licenses, even some free ones, may be more restrictive.
Some font foundries may give away “free” versions of fonts with limited licenses and
make their money selling extended rights.
Some font licenses may restrict commercial use, require attribution, and restrict
redistribution or commercial redistribution of documents that include embedded
versions of the font.

Feedback
Was this page helpful?

 Yes

 No

Registered font vendors
The following is the list of registered vendor IDs, with links to vendor sites. All vendor IDs are
unique to a single vendor.
To learn more about how to register a vendor ID or to update vendor details for a registered
ID, please see Register as a typography vendor.

[0-9, !$…]
ﾉ

ID

Foundry Name

!666

Agyei Archer

!ETF

!xclamachine Type Foundry

!YNE

Yne

$pro

CheapProFonts

(FT)

Fuerte Type

(K)

KOMETA

@

ArrowType

@MT

MarkType

0.IZ

0.itemzero

00F3

Óliver Lalan

0VDO

Vicido GmbH

100

AUTHENTIC

123

Numbers Font Foundry

0264

Patricia Lillie

0909

Oladino

1206

yayoyuyue

1995

San Sagittarius

3011

LuxSVG

Expand table

1ASC

Ascender Corporation

1BOU

Boutros International

1dot

I.Font Project

1FAN

One Fan Foundry

1KTF

Kief Type Foundry

1UKR

AndrijType

205

205TF

2000

2000px Media Inc.

2DLT

2D Typo

2REB

2Rebels

3011

LuxSVG

3103

Foxlify

3270

Ricardo Bánffy

3333

SVGVIBE

39BC

Finley's Barcode Fonts

3ip

Three Islands Press

3tp

3type

4A

4A LLC

42

42dot

4FEB

4th february

50FX

50Fox Studio

53VN

Seun Badejo

5PTS

Five Points Technology

6666

Designova

6789

Greentrik6789

72PT

72 Puntos

8686

SVG Idea

918

RavenType

9999

Cricut Market

A
ﾉ

ID

Foundry Name

A&S

Art&Sign Studio

A&TP

Art & Type

A70

AutumnSeventy

A2

A2-Type

AAA

AlefAlefAlef

aaff

AstroAcademia Font Foundry

AA

Alireza Alipour

AARN

Aaron212

AAT

AhmetAltunType

AATF

Abstract Animal Type Foundry

ABBO

Arabic Dictionary Lab

ABBT

Alkin Bugra Baskurt Type

ABC

Altek Instruments

ABCD

Dinamo Typefoundry

ABCO

About Contact

ABCX

ABC ETC INC

ABEL

Abeltive

ABOU

Aboutype, Inc.

ABTS

alphabeet, Type Studio

ABYM

Abyme

AC

AllCaps

Expand table

ACNT

Accentype

ACT2

Ansel Zhong (白云岫)

ACUT

Acute Type

ACW

Andrew Christopher West (BabelStone)

Ad56

Devotees of Sri Sri Ravi Shankar Ashram

Adam

Adam Jagosz

ADBE

Adobe

ADBO

Adobe

ADG

Apply Design Group

AEF

Altered Ego Fonts

AES

AE Type

AFOS

A Foundry of Sorts

AFOU

a.Foundry

AGC

André G. Costa

AGFA

Monotype Imaging (replaced by MONO)

AGFO

Agung Rohmat

AGIA

LaMagia

AID

Artistic Imposter Design

aide

Aiolfi.design

AIFF

Idiofonts

AIYR

Aiyari

AJL

Alex John Lucas

AJPT

Alan Jay Prescott Typography

AKDL

AK Design Lab

AKOF

AKOFAType

AKRU

Akuru Foundry

AL

Alessio Laiso Type

ALEF

Alef Type

ALFA

Alphabets

ALFT

Alifinart Studio

ALIF

Alif Type

ALPH

Alphameric Broadcast Solutions Limited

ALPN

Alpona Portal

ALS

Art. Lebedev Studio

alte

Altemus

ALTR

alterType

ALTS

Altsys / Made with Fontographer

AMB

AmbType

amcs

Amit soni

amin

fontamin

AMPR

Ampersand

AMUT

Kwesi Amuti

ANBS

Anbassa

ANDO

Osam Ando

ANDR

André Simard Typedesigner

ANGL

Type Angel

ANGT

Anagata

anir

Dr Anirban Mitra

ANRT

Atelier National de Recherche Typographique

ANSL

Ansel Zhong (白云岫)

anty

Anatoletype

AOP

an Art Of Pengwyn

APCX

Another Planet Font Foundry

APF

All Purpose Fonts

APLY

Apply Interactive

APOS

Apostrophic Laboratories

APPL

Apple

APTF

Apoorva Fontech

ARAB

ArabicType Ltd

ARAV

Aravis Fonts

ARBX

Arabetics

ARCH

Architext

ARCN

Arcane Type Foundry

ARFS

And Repeat

ARGN

Alpha Argon

ARIN

Aring Typeface AB

ARit

Arabia-it

ARM

ArimaType

ARMA

Arman Khorramak

ARPH

Arphic Technology Co.

ARQX

Archelogix Inc.

ARS

EN ARS Ltd.

ART

Alex Rosario Type

ARTA

Tarumian

ARTE

Artegra

ArTy

Archive Type

AS

Alex Slobzheninov

ASL

Abneil Software Ltd fonts

ASMB

Assembly

ASSA

astype

ASYM

Applied Symbols

At

Arilla Type Studio

ATEC

Page Technology Marketing, Inc.

ATF

American Type Founders Collection

ATF1

Australian Type Foundry

ATFF

ArabType Font Foundry

ATFM

Asira Type Foundry

ATFS

Andrew Tyler's fonts

athk

atelier type hong kong

ATKN

aratakana

ATKS

ATK Studio

ATLR

Atelier Triay

ATLS

Atlas Fonts

ATPK

Atelier Pickard

ATS

Average Type Service

ATSM

Akshara Type Studio

ATYP

Attype Studio

AUH

Atelier Ursula Heilig SGD

AURE

Aure Font Design

AUTO

Autodidakt

AVFF

Agustín Varela Font Factory

AvGd

Avante Vangard Publishing Tools

AVP

Aviation Partners

AVT

AvanType Foundry

AWSM

Font Awesome

AX86

ax86.net

AY

Alen Yang

AYRE

AYRES FONTS

AZLS

Azalea Software, Inc.

B
ﾉ

ID

Foundry Name

B&H

Bigelow & Holmes

b52

Borno52 Font Foundry

BABA

alibaba

BAPS

Baps Patil

BARS

CIA (BAR CODES) UK

BASE

Baseline Fonts

BAT

BUREAU DES AFFAIRES TYPOGRAPHIQUES

BB

Ben Busby

BBB

Bye Bye Binary

BBBB

Bea Korsh Type Design

BBFF

Bangla Borno Font Foundry.

BBOX

bBox Type GmbH

BBSL

BrainBox Solutions GmbH

BBTF

buero bauer

BBTL

Banglagraphy Bangla Type Library

BBTY

Bruno Bernard Typographie

BCAI

Boharat Cairo

BCDS

Blue Curve Designstudio

BCHF

Blake Hodgetts Fonts

BCHN

Studio Buchanan

BCP

Expert Labels Ltd.

BD71

Bangladesh1971

Expand table

BDFZ

Beijing Founder Electronics Co., Ltd.

BDTD

Typedifferent

BDZ

Bonez Designz

BE

typografie

BEAR

Topography Typography

BEN

Ben Hodosi

BERT

Berthold

BEST

Bespoke Type

Bela

Belagraph

BenP

Ben Pang

BF

BrassFonts

BFF

Bangla Font Foundry

BFGS

BrassFonts

bftr

Bleed Design Studio

BGDN

Ryan Bugden

bgtl

bigital

BHRT

Boharat Cairo

BHS

Bahasatype Foundry

BIJU

Bijou Type

BIRD

Magpie Paper Works

BITM

Bitmap Software

BITS

Bitstream

bizf

Bizfonts.com

BJHa

Ben Harris

BL

Binnenland

BLAB

BaseLab

BLAH

Mister Bla's Fontworx

BLCK

Black Foundry

BLF

Bangla Lipikar Font Foundry

BLFF

Bongolipi Font Foundry

BLGY

BOLD GUYS

BLI

Blissym Language Institute

BLIF

Bangla Lipi Font Foundry

BLK

Blackletra Type Foundry

BLKT

Biliktu Foundry

BLOM

Bloom Type

BLST

Blast Foundry

BLTS

Blancoletters

BLUE

Blue Shell

BLV

Bladvulling

BLZT

Blaze Type

BM86

Madzonga

BMD

Brittney Murphy Design

BNDR

Ori Ben-Dor

BNFF

BengalFonts

BNT

Brand New Type

BOGG

Giulia B.

BOGS

Bogstav

BOLD

Bold Monday

BOLE

Bongolekhon Font Foundry

BOLT

Bolt Cutter Type

BOMF

Beach-o-matic

BONE

Bonneville Electronics

BOOM

Boom-Promphans

BORW

em2 Solutions

BOUF

Bou Fonts

BOYB

BoyBeaver Fonts

BRBT

Bureau Brut

BRDV

BoardVantage, Inc.

brdy

Brody Fonts

BREM

Mark Bremmer

BRET

Bretagne

BRIJ

Brijesh Jivani

BROS

Michael Brosnan

BRTC

ITSCO - Bar Code Fonts

BRTE

Brenners Template

BRWN

Brown Type

BS

Barcodesoft

BSBS

Bolid System

BST

Bolorsoft LLC

BSTD

Bastard Type Inc

BSTF

British Standard Type

BSYV

Ben Syverson

BTF

Bangla Type Foundry

BTFF

Bangla Type Font Foundry

BTYP

BeeType

BUBU

BUBULogix

Buer

Buernia

BUN

Buntype

BVH

BVH Type Foundry

BWFW

B/W Fontworks

BWJC

不务鸡字体

BwT

Branding with Type

BZER

Bézier

C
ﾉ

ID

Foundry Name

C&B

Coppers & Brasses

C&C

Carter & Cone

C&G

C&G Inc.

C21

Club 21

CAB

CabargaType

CAD3

Clipartdesign

CAF

CHOA FONT

CAFE

Cafe24 Corp.

CAK

pluginfonts.com

CAL

California Type Foundry

CAM

Camelot Typefaces

camp

Campotype

CANA

Canada Type

CANO

Canon

CAPE

Cape Arcona Type Foundry

CAPS

Capitalics Warsaw Type Foundry

CASL

H.W. Caslon & Company Ltd.

CATG

CAT-Fonts Germany

CAVE

Fonderia Cavedoni

CB

Christian Büning

Expand table

CBDO

Borges Lettering & Design

CBWJ

不务正业的小鸡 (cod'dte)

CCCT

Cho Choi Creative

CDAC

Centre for Development of Advanced Computing

cdd

Crazy Diamond Design

CDFP

VT2000 Technical Services

CELB

Celebrity Fontz

CENT

Central Type

CERC

Cercurius

CF

Colophon Foundry

CFA

Computer Fonts Australia

CFAB

Creative Fabrica

CFF

Characters Font Foundry

CHAI

Tall Chai

CHIC

CHIC Type

CHLL

Chill Type

CHRY

Cherry Fonts

CHTY

Character Type

CINE

Cinetype

CJCJ

Creative Juncture

CJT

CJ Type

CKTP

CakeType

CLM

Culmus Project

CLNT

Cloanto

CLP

Gutenberg Labo

CLT

Collletttivo

CLVR

Font Clover

CMDX

Cory Maylett Design

CMJK

Slanted Hall

CMMA

Comma Type

CNFA

Connary Fagen

CNK

Cinketype

CNTY

CNTYPE

CNTP

Contextype

COFM

Contraforma Fundidora

COFO

Contrast Foundry

COLM

ColumnType

COMI

Comicraft

COMM

Commercial Type

CONR

Connare.com

CONT

Contemporary Type

COOK

Graphicook

COOL

Cool Fonts

CORD

corduroy

CORE

Blockchain Hub

corm

Cormullion Foundry

COTF

CoType Foundry

COTY

CocijoType

CP

Constructive Projects Ltd

CPTL

Graphicapital

CR8

CR8 Software Solutions

CROS

Crossgrove Studio

CRRT

Carrot Type

CSCF

Casasin Custom Fonts

CSCO

Craft Supply Co

CSDA

Creative Sauce FZ LLC

csmp

cosmope type

CSTM

CSTM Fonts

CT

CastleType

CTCO

Colt Type Co.

CTDL

China Type Designs Ltd.

CTL

Chaitanya Type Library

CTYP

Countertype

CUBI

CubicType

cwwf

Computers World Wide/AC Capital Funding

CYLA

Cyla Costa Studio

CYPE

Club Type

CYRE

Cyreal

CYTY

Cybertype

CZOO

Creative ZOO

CZYK

Czyk Labor

D
ﾉ

ID

Foundry Name

D&ST

Dots&Stripes Type

D502

DisneySVG

DADA

Dada Studio

DAIN

DainType

DAMA

Dalton Maag Limited

DARK

Out Of The Dark

Expand table

DARN

Darren Embry

DB

Daniel Bruce

DBCO

Design Business Company

DBDS

DotBox Design Studio

DBFF

DesignBase

DC

Domicile Foundry

DD

Devon DeLapp

DDT

DosDiez Type

Deco

DecoType (replaced by DT)

DELV

Delve Fonts

DETF

Detective Fonts / Font Detective LLC

dezc

Dezcom

DF

Dyslexic Font

DFHA

deFharo

DFS

Datascan Font Service Ltd

DFX

Differentialtype

DG

Daniel Grumer

DGL

Digital Graphic Labs foundry

DGRY

Dogray

DHA

Dhakatype

DHRM

Dharma Type

DICO

Dicotype

DIFO

Digital Foundry

DIMK

Dimka Fonts

DJDJ

Dominik Jáger

djr

DJR

DKMS

Dan Kreider Music

DKSP

Duck Soup Design

DMGR

Dmitry Grenev

dmol

David Moles

DNF

Deranged Neko Foundry

DnGr

DevnGraphics

DO

dito-typo

DOCS

Documents Inc.

DOM

Dukom Design

DonR

union Type, Design

DONS

Don SVG Files

DOT

DDOTT Typefoundry

DOUG

Douglas Hayes Studio

DP

Displaay

DR

Dmitry Rastvortsev

DRFN

DR Fonts

DRT

Dave Rowland Type

DRZF

Drizy Font

DS

Dainippon Screen Mfg. Co., Inc.

dsbn

Design Bundles

DSBV

Datascan bv

DSCI

Design Science Inc.

DSGN

DizajnDesign

DSKY

Jacek Dziubinski

DSLF

Dsl Fonts Type Foundry

DSSR

Dresser Johnson

DSST

Dubina Nikolay

DST

DSType

DSTE

Dieste

DT

DecoType

DTC

Digital Typeface Corp.

DTF

Dunwich Type Founders

DTIL

Detail Type Foundry

DTL

Dutch Type Library

DTPS

DTP-Software

dtpT

dtpTypes Limited

DTSM

Shimada Mizuki (Ender7 Tina / 岛田水木)

DTZM

Dotzeem

DU

Daniel Uzquiano

DUAL

DualType

DUXB

Duxbury Systems, Inc.

DX

Dirtyline Studio

DXTF

DXTypefoundry

DY

Dmitry Ivanov

DYNA

DynaComware

DZRF

Dzus Rhythm Font Foundry

E
ﾉ

ID

Foundry Name

EAFN

EA FONTS

EAST

East of Rome

EB

Électro-bibliothèque

ECAL

ECAL Typefaces

EDBI

edilbiStudio

Expand table

EDGE

Rivers Edge Corp.

EDIT

Edito

EDU

EDUfonts

EF

Elsner+Flake

EFC

Efrat Chen

EFF

Electronic Font Foundry

EFFD

Erik Faulhaber Font-Design

EFI

Elfring Fonts Inc.

EFNT

E Fonts L.L.C.

EFST

Ef Studio

EFWS

eFilm World

Egg9

EGG9 font

EINW

David Einwaller

EKIO

Ekioh

EKTF

EK TYPE

ELE

Elefonts

ELEO

Enliteleo

ELIO

Tipo Elio

ELLR

Eller Type

ELSE

Elseware

EMGR

Emigre

EMPH

Emphase

EMT

Emtype Foundry

EPS

Eliyahu Peretz Simon

EPSN

Epson

ERKO

Erkin Karamemet

ESAD

X Cicéro

ESD

Sogari Design

ESIG

E-Signature

ESTF

Extraset Typefoundry

ET

Esintype

ETAL

Lettersetal

ETCO

Etcetera Type Company

ETDF

E-Type Design

ETIO

Ethiopian Font Foundry

ETYM

Etymos

ETYP

EuropaType

EVER

Evertype

F
ﾉ

ID

Foundry Name

F5

Foundry5

FA

FontArte Type Foundry

FA37

F37 Foundry

FAFO

FamiraFonts

FAIR

Faire Type

FAKT

FAKT CREATIVE OFFICE

FAM

Family Type

FANC

字言字型 Fancytype foundry/字言字語

FAPY

Faptype

FARH

Peter Verheul (cc)

FAT

Fatype

FAUX

FauxFoundry

Expand table

FAY

FayType

fbf

Free Bangla Font Project

FBI

The Font Bureau, Inc.

FBRC

Fabric Font

FBRO

FaizType.

FBS

Febspace Studio

FC

Font.Cafe

FCAB

The Font Cabinet

FCAN

fontage canada

FCB

Font Club Belgica

FCTP

Facetype

FDI

FDI Type Foundry

FeCo

FerCozzi.

FEED

Studio Feed Inc.

FeoN

Feòrag NìcBhrìde

FEOR

Fer Online Community

FeTy

Feliciano Type

FETZ

Markus Fetz

FFBR

Fontfabric

FFC

Fincker Font Cuisine

FFF

Final Final Foundry

FFFF

Fabiola Mejía

FG

Font.Gold

FGOD

FontGod

FHF

Fanny Hamelin

FHTP

Fabio Haag Type

FILI

Louise Fili Ltd

FIRA

Firasoft Fonts

FIRE

youbringfire

FIRM

TYPE FIRM

FJ

FRNCOJONAS®

FJR

F.J.R. German Typeface

FJTY

Frank Jonen - Illustration & Typography

FK

Florian Karsten Typefaces

FKAI

Font-Kai

FKT

Formerly Known

FL

Flight Mode Foundry

FM

FontMo

FMFO

Fontmill Foundry

FMLJ

Familjen

FNBD

FontBD Type Foundry

FNKI

Font Kitchen

FNSA

Fonseca Fonts

fntb

Font Bundles

FNTF

Fontfoundry

FNTP

FansyType

FoFa

FontFabrik

fofm

Font FM

FOGC

Fog City Type

FoHa

The Fonthausen Font Foundry

FONT

Font Source

FONZ

Font Zone 108

foon

FoonType

FOR

Formagari

FORM

Formation Type Foundry

FORT

Fort Foundry

FOS

FonStorage

FOSH

Forgotten Shapes

FOSP

Font Spectrum

FOST

Foster Type

FOUN

The Foundry

FP

The Fontpad

FPCY

Fontprime

FPKY

Fitzgerald P. K. (Fitzgerald Yu / 蔽芪茢·茇䓮·蓲䒤菥)

FPPL

FontPeople

FPTF

Fontplat Type Foundry

frag

fragTYPE

FRGT

Freight Collection

FRJN

Frere-Jones Type

FRML

formlos

FRNK

Frank Fonts

FRNZ

Franziska Weitgruber

FRTH

Forthcome

FS

Formula Solutions

FSD

Fabrizio Schiavi Design

FSE

Font Source Europe

FSFS

Fontastica

FSI

FontShop International

FSL

FontSurfer Ltd

FSLF

Fontself

fsmi

Fontsmith

FSTR

Fontstore Pte Ltd

FT

Formula Type

FTC

Fridaytype

FTDS

FONTDASU

FTF

Fontef

FTFT

FontFont

FTGD

Font Garden

FTH

For the Hearts

FTN

Fountain

FTPT

Fontpartners

FUNA

Mt. Funa Design Office

FVL

Font Viet Linh

FW

Workshop

FWD

Fontwright Design

FWKS

Fontworks

FWRE

Fontware Limited

FXTL

Foxtail Collectif

FXTP

FoxType Co

FY

Fontyou

G
ﾉ

ID

Foundry Name

GAF

Glifo Art Fonts Inc.

GAKU

Gakumon

GAL

Gal Shamir

GALA

Galápagos Design Group, Inc.

Expand table

GALO

Gerald Gallo

GALW

Galway Cultural Development and Activity Company Limited by Guarantee

GARI

Gary Ritchie

GATF

Greater Albion Typefounders

Gco

Glyph Co

GD

GD Fonts

GDFY

Gärde Design Foundry

GEEZ

Geezfonts

GenT

General Titles

GF

GarageFonts

GFNT

Graffont

GFT

Geez Font Types

GGWA

Grenzgänger

GIA

Georgian Internet Avenue

GIFT

Souvenir Typefaces

GIGA

St. GIGAFONT Typefaces (stgiga)

GIL

gilat graphic designer

GKOU

GEEKOU.IO

GLAD

Glad Type

GLCF

GLC foundry

GLDN

Studio Gulden

GLGX

Golgex Design

GLIN

Glintelen

GLRY

Gallery Type

GLYF

Glyph Systems

GNRL

General Type Studio

GNU

Free Software Foundation, Inc.

GOAT

Dingbat Dungeon

gobl

Type Goblin

GOGO

Fonts-A-Go-Go

GOHE

GoHebrew, division of GoME2.com Inc.

GOOG

Google

Goss

Goss Typography

GPI

Gamma Productions, Inc.

GRAF

Grafikarna d.o.o.

GRCR

Graphicore

GREY

Greyletter

GRIL

Grilled cheese

GRIM

Legacy publishing

GRPS

Gurup Stüdyo

grro

grafikk RØren

GS

Grayscale Limited

GT

Graphity!

GTF

Grilli Type

GTff

Greg Thompson Type

GTL

GTL Type Label

GTYP

G-Type

GWPL

Gatewater Publishing, LLC

GXH

H.G. Font

GYST

Groteskly Yours Studio

H
ﾉ

ID

Foundry Name

Expand table

H

Hurme Design

H&FJ

Hoefler & Frere-Jones

HA

HoboArt

HACO

HACOLLECTIVE

HAD

Hoffmann Angelic Design

Hafo

Hafonton

HAIL

Hail Design

HAL

HAL Typefaces

HALB

HALBFETT

HAMZ

Hamzeh Naghdi

hano

Hanoded Fonts

HanS

HanStyle

HAUS

TypeHaus

HB

HB Type

HBM

HADAR BOSMAT

HBT

Harbor Type

HCMP

Happycompany Italy

HD

Hard Type

HDCO

Hanken Design Co.

HDZP

Hoodzpah, Inc

HEB

Sivan Toledo

HenT

Henestrosa Type

HERZ

Herzberg Design Co

HEUM

Heumm Design

HEX

HEX Projects

HEYP

HEY PORTER!

HFEW

Happyfew

HFJ

Hoefler & Frere-Jones (replaced by H&FJ)

HH

Halwote Hareg

HIH

HiH Retrofonts

HILL

Hill Systems

HJZ

Hans J. Zinken

HK

Hadar Katan

HKSY

HAKUSYUFONTS

HL

High-Logic

HLDN

Holdon Typefoundry

HM

Haiku Monkey

HN

Hora Nocte Type Foundry

HOH

HOHOHtype

Hone

H-one Design

HOOL

Hooloovoo Studio

HoP

House of Pretty

HOUS

House Industries

HoX

House of X

HP

Hewlett-Packard

HS

HermesSOFT Company

HSH

Hassan Shebli

HT

Huerta Tipográfica

HTA

活字攷古

HTCO

Harmonious Type Co.

HTF

The Hoefler Type Foundry, Inc.

HTT

Hype Type Type

HU

Hungarumlaut

HUY!

Huy! Fonts

HVD

HVD Fonts GmbH

HWT

Hamilton Wood Typethety

HXTP

Hexatype

HY

HanYang Information & Communication

HYPE

HyperType

HYPN

Heypentype

HZ

Hubert Zasępa

I
ﾉ

ID

Foundry Name

IAMT

IamTiago

IB

Instinctual Beings

IBCR

Ironbird Creative Studio

IBM

IBM

IC

Ian J. Cox

IDAU

IDAutomation.com, Inc.

IDEA

Glenn Campbell t/a Idea Studio

IDEE

IDEE TYPOGRAFICA

IDF

International Digital Fonts

IDKB

Kostas Bartsokas

IDL

Identity Lab

IDLT

Identity Letters

IDMS

Incstone Design by Megami Studios

Idt.

Identitype

IFF

Indian Font Factory

IFHC

辰皓喵 / ChenhaoUwU

Expand table

IH

In-House

IINF

iInformatica Srls

IKMJ

Ikimoji

IKN

Ikosa Nona

IKOF

IKOffice GmbH

ILP

Indigenous Languages Project

IMPR

Impress

INCD

INCDesign

INDG

Indigo+Indigo

INFS

iNfernalSoft

INGA

Inga Type

INGT

Ingrimayne Type

INNO

INNO.LLC

INRA

INRAY Inc.

INTF

Interfont

INTP

Inhouse Type

INTR

Interstitial Entertainment

INVC

Invoice Central

INVD

TYPE INVADERS

INVI

Inviline Typeface

INVT

Invisible Type

IRRT

Irregular Regular

ISAC

Isaco Type

ISE

ISE (devanagarifonts.com)

it*

indestructible type*

ITC

ITC

ITF

Red Rooster Collection (ITF, Inc.)

ITFO

Indian Type Foundry

ITSK

Saki Itomi

ITSM

Simon Stratford

IvyF

The Ivy Foundry

IWA

Iwata Corporation

J
ﾉ

ID

Foundry Name

J23

June 23

JABM

JAB'M Foundry

JAF

Just Another Foundry

JAKE

Jake Tilson Studio

JAM

JAM Type

JAMO

JAMO

JANS

Jan Šindler

JASO

studioJASO

JB

JetBrains

JBLT

JEAN-BAPTISTE LEVÉE TYPOGRAPHY

JCF

Juan Casco Fonts

JCT

Jamie Clarke Type

JDB

Jeff Bensch

jeff

jeff-levine

JENS

Jens Kutilek

JF

Jan Fromm

jftw

justfont

JHA

Jan Henrik Arnold

Expand table

JHC

Jehoo Creative

JHF

JH Fonts

JKOB

Foundry Jakob

JLCY

Jolicia Type

JLIF

jli Foundry – Julie Soudanne

JMN

Jeff Napadow

JO M

Jo Malinis

JOON

JoonFont

JOT

Josh Ownby

JP

Jamra Patel

JPTT

Jeremy Tankard Typography Ltd

JQKA

Queen of Spades Design

JRW

Richard Wordingham

JSTN

Justin Penner

JT

Julytype

JTD

JTD Type

JUST

Just in Type

JuTy

JudouEco

JUXT

Juxtaproof Studio

JVRT

Just van Rossum Type

JWTM

Type Matters

JY

JIYUKOBO Ltd.

JYT

Just Your Type

K
ﾉ

ID

Foundry Name

Expand table

K

Kvant Type Foundry

K&C

Kerns & Cairns

ka

kloeg architecture

KAME

Kame Design

KAPT

Kaptype

KATF

Kingsley/ATF

KBFF

Krakenbox Font Foundry

KBNT

Kombinat-Typefounders

KD

Kassymkulov Design

KDW

Kinuta Font Factory

KERN

Machine Kerning

KEYA

Keya Vadgama

KF

Karakta Fonthome

KFoF

Kevin Foley Fonts

KGLR

Kugler Industries

KH

Kristy Hatswell

KHTB

Monkey Arts Ltd.

KHTF

KH Type

KILO

Kilotype

KIND

Emily Klaebe

KIRK

Typekirk

KK

Kiwari Kolektiv Studio

KK95

Kuirnovi Kether

klew

Kent Lew

KLIM

Klim Typographic Design

KLNT

Kowloon Type

KLTF

Karsten Luecke

KMR

kimera

KMRS

Mony Sath & Chhit Wornnarith - KhemaraSoft

KNON

KF Digital Typefaces AB

KNST

Konst.ru

KNTR

Kontour

KNWT

Karl Nawrot

KO

Kotype

KOKN

KOKIN

KOP

Leo Koppelkamm

KORK

Khork OÜ

KOST

Kostic Type Foundry

KOVL

Koval Type Foundry

KP

Kontrapunkt

KrKo

Kreative Software

KRND

Karandash Type & Graphics Foundry

KSES

KSE Software

KT

Kalaus Type

KTF

Kustomtype

KTKM

KTKM

KTRF

Kazan Traditional Font

KTTF

Kitchen Table Type Foundry

KUBA

Kuba Tatarkiewicz

KUSH

KushJain

KWKK

キウイ皮ごと齧る

L
ﾉ

Expand table

ID

Foundry Name

L2M3

L2M3 Kommunikationsdesign GmbH

L52

Lipika52 Type Foundry

LA

Large

LADD

Adam Ladd Design

LaG

Matt LaGrandeur

LAGA

Lagarto

laic

Laïc: Type Foundry

LAIT

la laiterie

LAND

Typeland

LANS

Lanston Type Company

LARA

Larabiefonts

LARR

Larry

LArt

Limelight Artistry

LAUD

Carolina Laudon

LAYT

LAYOUT SARL

LBV

La Bolde Vita

LCMT

Locomotype

LCRM

Local Remote

LDNT

London Type Foundry

LDTP

Leedotype

LEAF

Interleaf, Inc.

Leah

Leah Lackey

LECH

Antonio Lechuga

Lee

Lee Mounsey

LEKS

Leksen Design LLC

LETR

Letraset

LETS

Let’s Type

Lev

Lev Rastvortsev

lewd

Lettering World LLC

LFS

Letters from Sweden

LGFF

LIPIGHOR FONT FOUNDRY

LGX

Logix Research Institute, Inc.

LHF

Letterhead Fonts

LIAM

Liam Spradlin

LIEB

LiebeFonts

LIGA

Ligatipo Foundry

LIND

Lindenberg Software LLC

LING

Linguist's Software

Linh

ÁccentiaType

LINK

Linkpen Handwriting Fonts

LINO

Linotype GmbH

LINZ

Linda Hintz

LIVE

Livedesign

LJ

Letterjuice

LJDS

LJ Design Studios

LKAS

Shawn Lukas

LKTF

LEE KEDAH

LL75

Lior Livne

LLD

Lipton Letter Design

LLDL

La Lettre de Luxe

LLGW

Laura Worthington Design

LLP

Léna Le Pommelet

LMNT

Element Type

LNGU

LangusteFonts

LNTO

Lineto

LOFF

Logan Font Foundry

Log9

Log9 Foundry

LOMT

The League of Moveable Type

LONT

Lontar GmbH

lool

lo-ol Type

LORO

LoRo Productions

LOSK

Losketch

LOU

Lou Type Foundry

LOUD

Loudifier

LOVE

LoveFrom

LP

LetterPerfect Fonts

LPKL

Lipikola Type Foundry

LS

lettersoup

LST

Laucke Siebein Type

LT

Le Typophage

LTF

Liberty Type Foundry

LTFD

Linnea Type

LTRK

Letterka Type Foundry / Olga Kovalenko

Ltrm

Lettermin type and design

LTRS

The Letters

LTRX

Lighttracks

LTS

LLettertype Studio

LTT

Latinotype Ltda.

LTTR

LettError

LuAn

Patrice Provost

LUD

Ludlow

LUDE

LudwigType

LUFF

Ellen Luff Type Foundry

LuFo

LucasFonts

LuRa

Lucid Rabbit Productions

LUSH

Lush Type

LUV

iLUVfonts

LVRC

Lovercase

LVSC

Leviathan Science

LXGW

LXGW (落霞孤鹜 / 霞鹜)

LZS

LiuZhao Studio

M
ﾉ

ID

Foundry Name

M

MARSNEV

M+F

Measure + Fit

MACR

Macromedia / Made with Fontographer

MADE

Marmite Defontes

MADT

MADType

MagD

Magus Digital

MAMA

alimama

MANC

Manchester Type

MANS

Mans Greback AB

MAPS

Tom Mouat's Map Symbol Fonts

MARA

Amarachi Nwauwa

MARK

Mark Frömberg

Expand table

MATE

TypeMates

MATF

Manos Andreakis

MATS

Match Fonts

MAW

Matthew Willsone

MAXI

MaxiType

MAXN

MaxnorType

MBDS

Mbonster Design Studio

MBF

Moonbandit font foundry

MBJH

Mutsuba Jouhou

MC

Cerajewski Computer Consulting

MCHL

Michal Sahar

MCKL

MCKL

MCL

My Creative Land

MCOW

Mountaincow

MCTF

Monoco Type Foundry

MD

Mass-Driver

MDIV

Dhivehi Type Foundry

MDSN

Moraitis Design

MEAP

MetaAppz

MEEM

MEEM TYPE

MEGA

Megatype

MEH

Steve Mehallo

MEIR

Meir Sadan

MESA

FontMesa,

META

Metatype

METC

More Etc. Studios

METZ

Nathan Metzler

MF

Magic Fonts

MFCF

Make Fun Creating Fonts

MFNT

Masterfont

MG

Milieu Grotesque

MGD

Matt Grey Design

MH

Misti’s Fonts

MHED

McGraw-Hill Education

MHMD

Mohammad Elikaei

MHTY

Minjoo Ham

MILL

Millan

MINT

Mint Type

MISS

Missy Meyer

MITF

Mehras Types

MJ

Liberty Type Foundry

MJ&D

moji.design

MJR

Majur Inc.

MJWK

もじワク研究

MK

Murat Karibay

MKSD

Maniackers Design

MKTP

Mokatype Studio

MLAG

Michael LaGattuta

MLBU

Malibu Dream Designs, LLC

MLF

PGML Communications Pty Ltd

MLFM

MultiFormis

MLFN

Monoline Fonts

MLGC

Micrologic Software

MLKT

Mallikātype

mlss

Mark Simonson Studio LLC

MLTH

Monolith

MMCG

Miko McGinty

MMFT

Michel M.

MMIK

Monomonnik

MMMM

Martin Majoor

MMNG

MonogramBros

MNCK

Mine Creek

MNIC

manic type

mnik

Mooniak

MNJU

Manjunatha Bengaluru

MNKR

Monokrom Skriftforlag AS

MNKY

Monkey Type

MNLF

Manual Foundry

MODI

Modular Infotech Private Limited.

MOGT

MOGTAHID

MOHT

Al Mohtaraf Assaudi Ltd

MOJI

Mojijuku

MOLG

MoolongType

MOMI

Momentum 18

MONB

Monib

MONE

Meta One Limited

MONI

monitor

MONO

Monotype Imaging

MOON

Moonlight Type and Technolog

MORF

morefont

MORN

Morning Type

MORO

Moro Type Foundry

MOSH

Moshik Nadav Typography

MOT

Multiocular Type

MOTA

Mota Italic

MOTF

Mostardesign Type Foundry SAS

MPTG

Typogama

MPXS

Minor Praxis Studio

MR

Michael Rafailyk

MRF

Mac Rhino Fonts

MRMN

M#RM#N FONTS

MRSL

Mark Russell

MRSW

Morisawa & Company, Ltd.

MRV

Morovia Corporation

MS

Microsoft Corp.

MSCH

Guitar-Injection

MSCR

Majus Corporation

MSE

MSE-iT

MSPG

Masterpage

MSTK

Alex Serada

MSTR

Mestara Type foundry

MT

Monotype Imaging (replaced by MONO)

MTCO

Martype Company

MTDS

Multitudes

MTF

Miss Tiina Fonts

MTFO

Music Type Foundry

MTIF

The Motif Media Company

MTM!

Manufacturas Tipográficas Madrileñas

MTMF

Modern Type

MTNT

Mutant Standard

MTY

Motoya Co. ,LTD.

MUCC

muccatypo

MUK!

Mukmonsalve

MULT

mulat

MUNC

munchfonts

MUSA

Musashi System

MUTF

Murasu Systems Sdn. Bhd

MVB

MVB Fonts

MVTP

Mauve Type

MVST

Man Versus Type

MVty

MV Typo

MW

Michael Want

MY

My Type

MYFO

MyFonts.com

MYIL

綿雲飴里

MYNT

Arif Rahman

N
ﾉ

ID

Foundry Name

N&G

Nikish

n8

Nathan Willis

NaN

NaN

NANO

NANOFONT Inc.

NASK

Naske Studio

Expand table

NASR

Nasir Udin

NAUM

Naumtype

NB

No Bodoni Typography

NBM

Nerya Bem Moshe

NBR

Noir Blanc Rouge

NBTF

Norberg Type Foundry

ncnd

&cond

ND

Neufville Digital

NDEF

Notdef Type

NEAT

Neatnik

NEC

NEC Corporation

NEEC

Netvarec

NERK

Nermin Kahrimanovic

NEUE

Neue Foundry

NEW

Newlyn

NFMS

Nice Fonts

NFSL

NFSL2001

NG

Nguyen Gobber

NGMK

Kousuke Nagai

NICE

nice to type

NICK

Nick's Fonts

NICO

NW digital type foundry

NIKO

Niko uno

NIS

NIS Corporation

NITS

Niteesh Yadav

NIVA

Nivatype

nkan

Nontynet

NKTL

Nokturnal13

NM

NM type

NMAD

Nomad Foundry

NMKK

波間のかけひき (Namima no Kakehiki)

NMRK

Nymark Type

NN

NN Type Foundry

NNSS

NANOFONT-StaticStudios

NONO

Nouvelle Noire Type Foundry

NOOT

Nootype

NOPN

Noponies

NorB

NorFonts.ma

NORF

Norfok Incredible Font Design

NORT

Nort

NOSE

Nose AG

NOVA

NOVATYPE

NP

Nipponia

NPD

Nick Pitscheider

NRON

Nurrontype

NtT

node-to-type

NU

Nutype

NUFO

Nuform Type

NVTF

Nova Type Foundry

NWGH

newglyph

NX

Noxakar

NYCM

NYC Music Services

NYPE

Naipe Foundry

O
ﾉ

ID

Foundry Name

OBR

Obrysy

OCC

Occupant Fonts

OCTY

Objectype

ODSR

Oddsorts

ofdn

O Foundation

OFTY

Office for Typography

OGJ

OGJ Type

OHG

Our House Graphics Inc.

OHNO

OH no Type Company

OKAY

Okay Type

OLAP

Overlap Type

OLEX

Olex

OM

Oscar Marcelo

OMAR

omar-type foundry

OMG

Omega Type Foundry

OMNI

Omnitype

OMNY

OMNY TYPE

Once

Michael T Neff

ONES

Ones Technology

OO

Outline Online

OPR

Office of Personal Responsibility

OPEN

OPENBOEK / 오픈북

OPTM

Optimo

Expand table

OPTO

Opto

OR

Or Type

ORBI

Orbit Enterprises, Inc.

ORK1

Ork1

ORNG

Orange Italic

ORTY

Original Type

OSFC

Out Of Step Font Company

OSPF

OneSevenPointFive

OST

Orange Slice Type

OSTF

O’Plérou Studio

otaf

of types and faces

OTF

Order Type Foundry

OTLR

OTLab Rus

OTT

OTT (Ornamental & Title Type)

OTTO

Otto Type Co.

OTTS

OneTen The Studio

OTYP

O-Type

OURT

Ourtype

OVER

Overtype

OZTY

Oz Type

P
ﾉ

ID

Foundry Name

P22

P22 Inc.

PANA

Pana Type Studio

PAPF

Pappware Fonts

Expand table

PARA

ParaType Inc.

PARK

Boomi Park

pbd0

Peter Bain

PBL

Publié

PBLC

Public Type

PBNG

Playbeing

PBRC

Pubric

PCJ

Minhocossauro Tipografia

PDWX

Parsons Design Workx

PEAC

PeachCreme.com

PEAR

Pear-Socam Softworks

PEBL

Pebblestone Design

PECI

Pecita

PETR

Daria Petrova

PF

Phil's Fonts, Inc.

PFRM

Punchform

PFV

Phelan’s Fontastic Ventures

PHO

phospho type foundry

PHTM

Phantom Foundry

PILZ

Tamara Pilz

PINT

PintassilgoPrints

PIXL

Pixilate

PIZZ

pizzadude.dk

PKDD

Philip Kelly Digital Design

PLAT

PLATINUM technology

Plau

Plau

PLAY

Playtype

PLN

Plain Form

plnt

Plantype

PMAR

PLASMAR PUBLICIDAD S.A.S

PMNT

pprmint.

PMPT

PampaType font foundry

POEM

Poem

POI

Place of Interest Type Foundry

PoW

Proof of Words

PPPR

Pepper Type

PRCH

Parachute Typefoundry

PRFS

Production First Software

PRGR

Paragraph

PRLK

Emre Parlak

PRNM

Pronama

PROD

Production Type

PROT

PROTOTYPO

Prox

Proxima Software

PRTF

Process Type Foundry

PRTP

Protype Foundry

PSD

p0s3id0n

PSG

Page Studio Graphics

PSIS

PhotoShopIsland.com

PSTL

ps.type.lab

PSTP

Positype

pstu

Pseudonym Type Studio

PSY

PSY/OPS

PSYM

Psymon

PT

Playtype

PTF

Porchez Typofonderie

PTHF

Pathfinders Type Foundry

PTMI

Page Technology Marketing, Inc.

PTS

Paavola Type Studio

PTYP

PreussType

PUBL

Public Letters

PWR

Power Type Foundry

PYRS

PYRS Fontlab Ltd. / Made with FontLab

PYTE

The Pyte Foundry

Q

ID

Foundry Name

QMSI

QMS/Imagen

QRAT

Quadrat Communications

QTYP

Qtypography

QUAN

Quantum Enterprises

QUE

Alerque

ﾉ

Expand table

ﾉ

Expand table

R

ID

Foundry Name

R667

Remedy667

R777

SanSLit

Ra

Ramoreira Foundry

RAGA

Rahul Gajjar

RAIN

Rainbird

RARE

Rare Bird Font Foundry

RARI

RAR Illustrations

RAVU

Ravi Uppalapati

RAWR

Melvian Foundry

RDGR

Rüdiger

RDMK

RandomMaerks

READ

ReadyType

REAL

Underware

RENE

Studio Rene Bieder

RES

Resultat

RETY

Retype

REZ

Reztype

RICK

Rickner Type

RIXF

FONTRIX Inc.

RJPS

Reall Graphics

RJST

Rob Jelinski Studios, llc.

RJTY

rojotype

RKFN

R K Fonts

RKRD

REKORD

RL

Ruben Holthuijsen

RLTF

Rebeletter Studios

RMGC

Ramega

RMU

RMU TypeDesign

RNDY

randytype

RNGD

RenegadeFonts

ROAD

Road Research Society

ROB

Robert Janes

robo

Buro Petr van Blokland

ROBU

Andrei Robu

ROHH

ROHH studio

ROMA

Romanée Type Foundry

ROST

Robert Strauch

RPTR

Rampage Raptor

RR

Rüdiger

RR41

Reber R41

RRT

Red Rooster Collection (ITF, Inc.)

RSET

Reset Type Studio

RSJ

RSJ Software

RSMS

Rsms

RST

Rosetta

RSZ

Resistenza Type Foundry

RT

Ritmo

RTG

Roach Typografics

rthy

Arthy

RTYP

REALTYPE, Inc.

RUDY

RudynFluffy

RUNE

Rune Revival

RVLR

Revolver Type Foundry

RXBN

Roxaboxen

RYHG

Yanghee Ryu

RYOB

Ryobi Limited

RYT

Ra'ey Type

Robert Janes

S
ﾉ

ID

Foundry Name

S4TF

Sed4-Type Foundry

sacc

Saccade SchriftBildWort Fonts

SAJA

Saja Typeworks

SALT

Solonka Type Foundry

SAMT

Samtype

SAND

Sandoll

SAPL

Fonderie sans plomb

SATO

Satori Type

SATY

Samuelstype Design AB

SAX

s.a.x. Software gmbh

SB

Sascha Bente

SbB

Sketchbook B

SBFY

Somebay Foundry

SBT

SelfBuild Type Foundry

SBYA

Shibuya Font

SCHF

Schrift Foundry

ScHo

Hila Schory

SCIN

Slavonic Computing Initiative

SCTO

Schick Toikka

SDFF

StaleyDigital Font Foundry

Sdtp

Sudetype

SE

Stéphane Elbaz

Sean

The FontSite

Expand table

SEMI

SEMIREGULAR Type

SERF

Seraphemer Foundry

SERP

Serpentype

SEVY

Yves Chartrand

SF

Sans Fontières

SfC

Shapes for Cash

SFF

Shilalipi Font Foundry.

SFS

Sarumadhu Services Pvt. Ltd.

SFUN

Software Union

SG

Scooter Graphics

SGNL

Signal Type Foundry Limited

SHAM

ShamFonts / Shamrock Int.

SHAN

Fontsim by Shana Koppel

SHFP

Sheaf Publishing

SHFT

Shift

SHMI

Sharanda

SHNC

Shiningtown Creative Studio

SHOT

Shotype

SHOW

Show Me Fonts

SHRB

Shorba Type Foundry

SHRP

Sharp Type

SHS

Shahab Siavash Studio

SHUB

The Software Hub

SHYF

ShyFoundry Fonts

sic

Skill Information"S" Co., Ltd.

SIDE

Sunny Side Type

SIG

vLetter, Inc

SIKI

Sikifonts

SIL

SIL International (SIL)

SIT

Summit Information Technologies Pvt.Ltd,

SK

Anton Skugarov

SKKL

Sakkal Design

SKP

Essqué Productions

skz

Celtic Lady's Fonts

SL

Silesian Letters

Slab

Schriftlabor

SLCH

Sale Character

SLDE

Sergej Lebedev

SLFN

Single Line Fonts

SLTP

Solutype

SLVK

PTRSLVK Font Foundry

SMC

Swathanthra Malayalam Computing

SMPJ

Senamirmir Project

SN

SourceNet

SNTR

Sintra Beatz LLC

SOBF

Soren Bakhol Fonts

SOHO

Soft Horizons

SOOP

Studio Sooper

SOS

Standing Ovations Software

SOTY

So Type

SPFM

SP Font Maker

SPFO

SproetS

SPIL

Spilling Type

SPIR

Spiratype

SPKE

Spoke

SPT

Type Forward

spty

supertype

SPVT

Sproviero Type

SRC

Source Foundry

SRCE

Source Type

SRFT

Schrifteria Foundry

SSFD

Stefan Stoychev

ssm0

Siryali Studios

SSTK

Smuss Type Kiosk

ST

SocioType

STAI

Sophia Tai

STAN

Stanley fonts

STC

Sorkin Type Co

STCO

Space Type Continuum

STF

Brian Sooy & Co + Sooy Type Foundry

STFD

snuffletrumper

STIX

The STI Pub Companies

STJO

studio Type

STLF

Studio Lowrie Fonts

STMT

Statement

Stor

Storm Type Foundry

STPE

Setup Type

STyC

Fobytype Foundry

STYK

Satsuyako

STYP

Stone Type Foundry

SUNN

Sunn

SUNW

sunwalk fontworks

SVTD

Synthview

SWEL

Swell Type

SWFT

Swfte International

SWSH

SHOWASHOTAI Co., Ltd.

SWTY

Swiss Typefaces

SXRA

Page42 Type Foundry

SYDA

Shree Muktananda Ashram

SyDi

SyyDai

SYN

SynFonts

SYRC

Syriac Computing Institute

SYRF

Syrian Revolution font

SySt

Syfon Studio

szgs

Szabó Gergely Sándor

T
ﾉ

ID

Foundry Name

T&S

Type & Style

T&T

TYPE&type

TAB

Tabular Type Foundry

TAF

Taf Studio

TAFS

Taf Studio

TAFT

Tural Alisoy Font

tanu

Tanuki Font

TB

TypeBank Co.,Ltd

TBFF

TrueBlue Font Foundry

Expand table

TBLD

Typobold

TBTF

TypoBaaz Type Foundry

TC

Typeco

TCH

Darryl Cook

TCO

Type Colony

TD

Typedepot

TDBK

Typeface Design Borys Kosmynka

TDFF

Tour de Force Font Foundry

TDFO

The Designers Foundry

TDKI

Type Design

TDR

Tansin A. Darcos & Co.

TERM

Terminal Design, Inc.

TES

Takshila Educational Society

TF

Treacyfaces / Headliners

TF3D

TattooFont3D

TFAC

Typefactory

TFc

Type Flock

TFND

Typefounding

TFTS

The Foundry Types

TFWD

Sports Fonts

TG

Tom Grace

TGD

Typo Graphic Design ■ Manuel Viergutz

TGHT

TIGHTYPE

TGIF

Tegamitype® Foundry

TGS

The Good Store

THIN

Thinstroke Design LLC

THNA

Thaana Type Foundry

THYH

Thy Hà

TILD

Tilde, SIA

TIME

TimeType / Timepiece Typefaces

TIMO

Tim Romano

TIMR

Tim Rolands

TINY

Tiny Type Co.

TIPO

Tipo

TIRO

Tiro Typeworks

TJ

TJ Trewin

TJS

Typejockeys

TKSW

Takushun Wu

TLIN

Teeline Fonts

Tlab

PYJ&Typolab (박윤정&타이포랩)

TM

Type Mafia

TMBR

TimbreType

TMF

The MicroFoundry

TMKL

Timo Klaavo

TMNL

Terminal Design Branding Agency

TMT

TypeMyType Comm. V.

TN

Type Network

TNB

The Northern Block

TNDM

TandemType

TNOF

Takayuki Nishida

TNOZ

ToneOZ

TNSC

The Native Saint Club

TNTY

tntypography

TO

Tondonero

TOFU

Tofu Type Foundry

TOGF

Types of Graffiti

TOKO

Tokotype

TOM6

tomliou design studio

TOPP

Toppan Inc.

ToSp

ToSupply

tots

Type-Ø-Tones

TPDP

Type Department

TPMA

typoma

TPOC

Typeóca

TPOP

Tipos Pereira Type Foundry

TPSP

Type Supply

TPTA

TPTQ Arabic

TPTC

Test Pilot Collective

TpTp

TypeType

TPTQ

Typotheque

TPTR

TYPETR

TR

Type Revivals

TRAF

Traffictype

TrAn

Trifon Andreev

TREE

Treeflow

TRIO

TrionesType

TROL

The Republic of Letters

TROY

Leinster Type

TRSH

TrashType

TS

TamilSoft Corporation

TSEN

Typesenses

TSGT

Tapiwanashe Sebastian Garikayi

TSPC

Typespec Ltd

TSTY

Torleiv Georg Sverdrup

TT

TypeTogether

TTC

Tribby Type Co.

TTF

Telugu Type Foundry

TTG

Twardoch Typography

TTNC

Typetanic Fonts

TTOK

TikTok

TTTT

TypeUnit

TTY

Tipotype

TUDO

tudotype

TWK

TYPE.WELTKERN®

TWTY

TwinType

TY

Typocalypse

TYBY

TYPE TAILORS

TYCU

TypeCulture

TYFA

typofactur

TYFR

typographies.fr

TYHA

TypeHabesha

TYMD

TYPEMADE

TYME

type me! Font Foundry

TYPA

Typadelic

TYPB

Type Brut

TYPE

Type Associates Pty Ltd

TYPO

Typodermic

TYPR

Type Project

TYPS

TypoSynthesis

TYPT

Typearture

TYRE

typerepublic

TYSL

Type Salon

TYSO

TYSO Type

TYSP

Typespace

TYSY

Type Syndicate

TYTA

TYPE TAILORS

U
ﾉ

ID

Foundry Name

UA

UnAuthorized Type

UCT

Undercase Type

UFAS

Unicode Fonts for Ancient Scripts

UFCB

Unforma Club

UFDN

UNDERFOREST DESIGN

UKUK

Ultra Kühl

ULA

Montserrat Typeface

UNDS

Underscore Type

UNDT

ÜNDT

UNIC

Unicode Consortium

UNIT

Universal Thirst

UNTP

Untype

UNTY

Unitype / Universal Typefaces

UPUP

Up Up Creative

URW

URW Type Foundry GmbH

Expand table

USGC

U.S. Graphics Company

USSS

USSSUAL

UT

Unitype Inc

UTF

Undercase Type Foundry

UTFI

Universitype Foundry

V
ﾉ

ID

Foundry Name

VCMS

Sichuan modern Vocational College

VCTR

Vectro Type Foundry

VEZ

Victoria Eloise Zunhiga

VILE

Font Monger & Chris Vile Fonts

VINT

Vinterstille

VJ

eDESIGNzone

VKP

Vijay K. Patel

VLKF

Visualogik Technology & Design

VLNL

VetteLetters.nl

VLQN

VLQNC Font Foundry

VLRY

Valeriy Egorov

VMT

VMType

VN

Viktor Nübel Type Design

VO

Violet Office

VOG

Martin Vogel

VOL

Bernd Volmer

VOLK

Radmir Volk

VOLT

volto.one

Expand table

VR

Victoria Rushton

VRED

Vred Letters

VROM

Vladimir Romanov

VS

VorSicht GmbH

VT

VISUALTYPE SRL

VTC

Vocal Type Co.

VTF

Velvetyne Type Foundry

VTP

Quang Manh Nguyen

VTYP

(v) design

VVD

Vintage Voyage Design

VZWO

VZWO | Viktor Zumegen

W
ﾉ

ID

Foundry Name

WAFO

Walden Font Co.

WALA

Fontwala

WASP

Wasp Barcode Technologies

WBHE

Webhance

WCYS

WCYS & Co.

WE

WeType

WEBF

WebFonts JAPAN Inc.

WEBR

WebRain

WEI

Wei Huang

WERK

Fontwerk

WF

Walking Fearless

WILL

Willerstorfer Font Foundry

Expand table

WISE

WiseType

WISH

Willie Shaw

WKND

Weekend Type

WL

Writ Large Fonts

WM

Webmakers India

WNK

Wanaka

WORK

Working Library

WS

WS · Schriftmanufaktur

WSCo

Wahyu & Sani Co.

WT

Weekend Type

WZGF

WenzhouHanziMakeGroup (温州字工坊)

X
ﾉ

ID

Foundry Name

XCON

IntoTheDesign

XFC

Xerox Font Services

xljb

exljbris Font Foundry

XOT

XO Type Co.

XOTH

Xoth Morello

XSCR

Xeroscript

XTMS

Extumus

XXL

Xiang-Xiang Lee

XYZ

XYZ Type LLC

Y

Expand table

ID

Foundry Name

Y&Y

Y&Y, Inc.

YADS

YA Type

YAM

Yamit fridman

YDI

YOONDESIGN Inc.

YDS

Yellow Design Studio

YERK

Jeff Yerkey Typography

YFFI

Yfficient Graphic Design and Marketing

YMGT

YMG Type Foundry

YN

Yanone

YOFF

Your Own Font Foundry

YOKO

Yokokaku

YOUR

YourFonts.com

YT

YT Foundry

YU

YU Type

YUKI

Yuki Type Foundry

YVES

Yves Michel

YWFT

YouWorkForThem

YYYY

Yellow Type Foundry

ﾉ

Expand table

ﾉ

Expand table

Z

ID

Foundry Name

z01

Jiangxi ZoomlaCMS Soft Co. LTD

ZAKZ

Zakznak

ZAMJ

Zamjump | Ahmad Zamzami

ZANE

Unrender

ZeGr

Zebra Font Factory

ZEN!

A-1 Corp.

ZERO

Federico Parra

zeta

Tangram Studio

ZFRT

Zafara Studios / Zafara Type

ZIHI

字嗨

ZKZN

Zakznak

ZORN

Benn Zorn

ZP

Zilap Estudio

ZPL

Zapal

ZSFT

Zsoft

ZTFN

Zetafonts

External links disclaimer
External Web sites listed here are not under the control of Microsoft. Accordingly, Microsoft
can make no representation concerning the content of these sites to you, nor can the fact that
Microsoft has given you this listing serve as an endorsement by Microsoft of any of these sites.
Microsoft is providing external links only as a convenience to you. This is to inform you that
Microsoft has not tested any software found on these sites and therefore cannot make any
representations regarding the quality, safety or suitability of any software found there. There
are inherent dangers in the use of any software found on the Internet, and Microsoft cautions
you to make sure that you completely understand the risks before retrieving any software on
the Internet.

Last updated on 11/03/2025

Register a font vendor ID
Article • 08/11/2021

The Vendor ID identifies the company responsible for the marketing and distribution of
typefaces. It is reasonable to assume that there will be 6 vendors of ITC Zapf Dingbats
for use on desktop platforms in the near future (if not already). It is also likely that the
vendors will have other inherent benefits in their fonts (more kern pairs, unregularized
data, hand hinted, etc.). This identifier will allow for the correct vendor's type to be used
over another, possibly inferior, font file.
If you are making TrueType or OpenType fonts you should consider registering a fourletter 'Vendor ID' with us and include the ID in your fonts OS/2 table.

Registering or updating a Vendor ID
Font producers are under no obligation to register a Vendor ID with Microsoft. However,
if they register with us and include their Vendor ID within their fonts, they will be
assured that users will always be able to contact them, even if they change their Web or
physical address.
To register or update your Vendor ID, e-mail the following information to
mstwsite@microsoft.com.
Vendor ID (Required)
The Vendor ID you'd like to register (The four-character identifier for the vendor
of the given type face - certain combinations can't be accepted)
Foundry Name (Required)
The name of the foundry you are attempting to register.
E-mail Address
The e-mail address will not be shared publicly or to anyone outside of
Microsoft.
It will be used only as needed to maintain the vendor registry. For example, if
changes are requested to an existing ID, this e-mail address will be used to
verify the request with the foundry.
Website
Link to the foundry website. This will be hyperlinked to the foundry name.
This is not required but does help others with contacting the font foundry
associated with a vendor ID.

Contact
Please contact us at mstwsite@microsoft.com for any questions or concerns you may
have.

OpenType® overview
Article • 06/09/2022

OpenType is a font format developed jointly by Microsoft and Adobe as an extension of
Apple’s TrueType font format. The OpenType 1.0 font specification was released in 1997.
Since that time Adobe and Microsoft have continued to work together updating and
refining the specification. Several other companies, including Apple and Monotype, have
also contributed to the specification over the years. Currently, every major font foundry
and most minor ones are developing fonts in OpenType format.
OpenType provides several advantages over older font technologies:
Larger glyph limit (64k)
Cross-platform support (Win and Mac)
Support for both PostScript Type 1 or TrueType outlines
Support for advanced typographic features
OpenType, like TrueType, is based on Unicode, the system for encoding all of the world’s
writing systems. OpenType fonts can potentially contain many thousands of characters.
This means that an OpenType font may contain multiple alphabets (such as Latin, Greek,
and Cyrillic; or kanji, kana, and romaji for Japanese use). OpenType fonts can also
include typographic refinements such as true small caps, different styles of figures, and
extensive sets of ligatures and alternates, as well as complete sets of accented
characters and diacritical marks. Different applications have differing levels of support
for all the OpenType features.
OpenType version 1.4 was contributed to ISO and became the foundation for the
development of ISO/IEC 14496-22 “Open Font Format” standard. The standard was
published in 2007, and is now freely available for download from ITTF website .
OpenType version 1.6 is identical to the “Final Draft International Standard” version of
ISO/IEC 14496-22 FDIS “Open Font Format” (second edition).
To learn more about OpenType fonts, refer to the most recent version of the OpenType
specification and the FAQ that follows.

Frequently asked questions about OpenType
What is OpenType and how does it relate to Type 1 and
TrueType?

OpenType, also known as TrueType Open version 2, is an extension of Microsoft’s
TrueType Open format, adding support for Type 1 data. An OpenType font can have
Type 1 data only, TrueType data only, or both. The Type 1 data can be rasterized by a
Type 1 rasterizer (such as Adobe Type Manager) if installed, or converted to TrueType
data for rasterization by the TrueType rasterizer. The exact rasterization behavior will be
a function of the rasterizers present in the system, and user preference.
This font format is a superset of the existing TrueType and Type 1 formats, which is
designed to provide great support for type in print and on-screen. In addition, the
subsetting and compression technology of OpenType makes the OpenType initiative
especially relevant to the Internet and the World Wide Web, since it allows for fast
download of type.

What is the benefit of the OpenType initiative to the enduser?
So far as customers are concerned, fonts just work. OpenType handles all fonts with a
unified registry, which means that both Type 1 and TrueType fonts will be reliably
supported across all platforms. In addition, by working together Adobe and Microsoft
will drive innovations in quality and on-screen support, resulting in better more viewable
fonts for customers.

What will happen to existing Type 1 and TrueType fonts?
From a customer perspective, all existing Type 1 and TrueType fonts will be supported by
the OpenType initiative. As part of the agreement between Microsoft and Adobe,
however, Adobe will convert popular existing Type 1 fonts to the new OpenType format,
and Microsoft and Adobe will jointly promote and develop new OpenType fonts.

If I’m an existing user of one font type or the other, what
will I do?
You should continue working as you always have. OpenType will seamlessly support
both TrueType and Type 1 fonts.

What does this mean for all the type vendors who have
large libraries of fonts? Are they obsolete?
Font vendors don’t need to worry. Their existing fonts just work.

Will all data types continue to be supported by the
OpenType initiative?
Yes. Because the OpenType font format is a superset of Type 1 and TrueType font
technologies, it will continue to support both standards. In the future, both Microsoft
and Adobe will invest in promoting and developing OpenType fonts, and as part of the
agreement between Microsoft and Adobe, Adobe has agreed to convert some of the
existing popular Type 1 fonts to the new format.

Can an OpenType font contain TrueType outlines?
Yes, OpenType fonts can contain either PostScript Type 1 or TrueType outlines. All
Microsoft Windows fonts contain TrueType outlines.

What is an OpenType CFF font?
An OpenType CFF font is an OpenType font which contains PostScript Type 1 outlines.

Why is my OpenType font listed as a TrueType font by my
application?
Different applications have different ways of determining if a font is OpenType. Most
look for specific tables within the font. In some cases, a font may be OpenType, but a
particular table is missing and the application may consider it a TrueType font.

What applications support OpenType features?
Desktop publishing applications such as Adobe InDesign and QuarkXpress support the
largest number of OpenType features. Adobe Photoshop and Adobe Illustrator support
many features. Support for common OpenType features is also being added to
Microsoft Publisher and Microsoft Word in Office 14.

Can I convert old fonts to OpenType format?
The best thing to do is to contact the font vendor who created the original fonts.

How many glyphs are allowed in an OpenType font?
64,000 glyphs

Can the same font file be used on both Mac and
Windows?
Yes.

Why did Adobe and Microsoft decide to end the font
wars?
Both companies realized that merging Type 1 and TrueType is the best solution for
customers because now both font standards will be seamlessly supported on the
Windows and Macintosh platforms. Additionally, OpenType will allow the industry to
drive font innovation, display quality, and print output into new publishing arenas, such
as the Web.

What does the OpenType initiative mean to Adobe’s font
business?
The OpenType initiative represents a new opportunity for Adobe to expand its font
business into the Windows market because Type 1 fonts will now work out of the box on
all Windows systems. In addition, because Adobe will license TrueType technology, it will
now be able to develop and market TrueType fonts.

What will Adobe and Microsoft be cross-licensing?
Both companies will license their respective font rasterizers, production tools, and
conversion software.

Character design standards
Article • 06/09/2022

The purpose of our character Design Standards is to state the general rules for character
shapes in Latin based languages in digital fonts. Primarily defining the guidelines
designers use for character alignments, both vertical and horizontal and how these
relate to other similar characters or character groups.
These guidelines should be thought of as a roadway to the goal of a well made
typeface. This roadway is not a heavily patrolled, narrow one lane street but a well
marked multi-lane path that takes you where you want to go.

Making digital type is not the same as drawing
a typeface
The art and process of designing letterforms is a very creative task but it is not void of
the rules and guidelines that govern good design. Any form of design is a solution to a
problem or need. A good design is one that is appropriate for its use without any
inappropriate features.
As an example, a well designed house is one large enough for its inhabitants, stylistically
equivalent to its culture and strong enough for its environment. A well designed
typeface is appropriate for its use and its final usable form appropriate for that use or
device.
This document is about the final usable font. It is not a definition of how to use or
design a typeface. This document also is less concerned with the artistic decisions in
creating letterforms than it is with creating a usable, functional solution for written
communication.

Type is a tool for communication
Type is the single most used method of communication. Most people are not aware of
this fact because type is usually doing its job by delivering and not distracting from the
message. To continue to do that job digitally we must consider that the solution for a
printed document is very different than the solution for a low resolution screen. These
images may be derived from the same source but the final images seen are NOT the
same thing. The rules and design decisions made for the printed high resolution images
need to be keep separate from those of low resolution devices. A new set of rules needs
to be adopted for these new devices.

Visual equality is not mathematical equality
The most important concept in type design is visual equality. It is the most used
technique in designing letterforms. Type designers make very subtle changes to
different letterforms to make them appear equal. They lighten vertical strokes when
there are multiple strokes and make serifs different lengths to make them visually the
same. Sidebearings, advance widths and stem weights are all examples of this balancing
technique. The technique is to be used at the right time and should not be confused
with poorly marked or aligned stems, badly spaced glyphs or inconsistent vertical and
horizontal distances.
In the following chapters we will discuss the guidelines and rules that apply to making
the highest quality TrueType and OpenType fonts for low resolution and high resolution
devices.
This document contains only technical information that is helpful in explaining the
design standards. For additional technical information that pertains to the specific font
formats TrueType, OpenType, AAT fonts , PostScript

font files or Unicode

see the

specific technical specification.
In finalizing this specification it would be incomplete without acknowledging the input
and support I've received from friends and colleagues around the world. All though I
have spent my entire professional career in type production and training at and for type
and software corporations, I could not have correctly explained all the standards and
design requirements of these letterforms without their input and help. Susan
Lightfoot

of Monotype Typography provided valuable input into the correctness of

the text and production processes. Geraldine Wade

of Monotype was very helpful

with her expertise and extensive research into character origins and language specific
requirements. I collaborated constantly with Simon Daniels on the layout, design and
planning, and he is responsible for finalizing these documents for the web. JeanFrançois Porchez

and Jacques André

provided valuable proofing support and input

into French typographic practices. Mário Feliciano provided insight into the use of
ordinals in Portuguese. Adam Twardoch

and his web site are a good resource for

designing diacritics in the Polish language. Bill Kienzel explained the proper design for
the uppercase Eng and the lowercase kra and Matthew Carter finally cleared up why
occasionally some letters are different heights than others. Many thanks to Thomas
Phinney

and David Lemon

of Adobe Systems who provided naming information

and character design input. George Ryan

of Galapagos Design Group for sharing his

experiences at Mergenthaler Linotype and John Hudson

of Tiro Typeworks for his

ideas and his linguistic expertise. Arno Schmitt, Prof. Erik Spiekermann
Berlow

helped sort out some information on ligatures.

and David

Bibliography
The Chicago manual of style, 14th ed. The University of Chicago. (Chicago, IL USA: The
University of Chicago Press, 1969, 1982, 1993) ISBN: 0-226-10389-7 (cloth)
An invaluable resource for writers and typographers.
Words into Type, 3rd ed. Marjorie E. Skillin, Robert Malcolm Gay. (Englewood Cliffs, NJ
USA: Prentice Hall, 1974) ISBN: 0-13-964262-5.
A nice companion to The Chicago manual of style. This book explains both setting text
as well as mathematics.
Lexique des règles typographiques. Imprimerie nationale (France: Imprimerie nationale.
1990) ISBN: 2-11-081075-0 (pbk.)
A French language book. This is the book of typographic rules that the national printing
office of France publishes and uses in its publications and books.
Calligraphy: The art of written forms: Donald M. Anderson. (New York, NY USA: Holt,
Rinehart, and Winston, 1969) ISBN: 0-486-27212-5 (pbk.)
This is more a book about the history of written communication than a book on
calligraphy. Includes Latin and non-Latin scripts.
The elements of typographic style, Robert Bringhurst (Vancouver BC Canada: Hartley &
Marks, Publishers, 1992, 1996, 1997) ISBN: 0-88179-133-4 (bound) ISBN: 0-88179-132-6
(pbk.)
Popularly voted 'the typographer's bible' with in-depth character definitions and
descriptions.
American metal typefaces of the twentieth century. Mac McGrew (Delaware, USA: Oak
Knoll Books, 1986, 1993) ISBN: 0-938768-34-4 (bound) ISBN: 0-938768-39-5 (pbk.)
Nicely printed hard cover book with almost every American metal typeface released in
the twentieth century. Includes a few display types and a few imports in the back. Also
has nice tidbits on the bottom of some pages.
Memoire des metiers du livre, à l'usage de la publication, assitée par ordiateur. Roger
Dédame avec le concours d'André Delord (France: Éditions Cercle d'Art & Association
pour la formation permanente des personnels d'imprimerie. 1998) ISBN: 2-7022-0495-3
(pbk.)
French language book on typography and mechanical and computer writing systems in
France.
Ligatures & caractères contextuels. Jacques André, Jean-Louis Estève. (Rennes, France:
Association GUTenberg. 1995) ISSN: 1140-9304.

French language book. An excellent compilation of research papers on ligatures in Latin
languages with some non-Latin ligature examples.
Branding with Type, How type sells. Stefan Rögener, Albert-Jan Pool, Ursula Packhäuser,
E.M. Ginger. (Mountain View, CA USA: Adobe Press, Adobe Systems Inc. 1995) ISBN: 156830-248-7 (pbk.)
One of the books in the series of Adobe Press books on typography, originally
published in German. This book concentrates on typography and its use in European
Advertising.
The Unicode Standard, Version 2.0. The Unicode Consortium. (Reading, MA USA:
Addison-Wesley Developers Press, 1991-1996) ISBN: 0-201-48345-9 (pbk.)
Technical specification for Unicode character encoding. The place to find Unicode
numbers for characters in Latin and non-Latin scripts.
The Microsoft OpenType Specification. Microsoft Corporation. (Redmond, Washington.
Microsoft Corporation. 1990-1998)
The technical specification for Microsoft OpenType fonts.
The Hewlett-Packard Book of Characters. Hewlett-Packard Company. (Boise, ID: HewlettPackard Company, 1990)
Internet: http://www.fonts.com/
The description of characters for Hewlett-Packard printers and code pages.
The Art & Technology of Typography. Compugraphic Corporation. (Wilmington MA USA:
Compugraphic Corporation. 1988)
A pamphlet released by Compugraphic for its typesetting customers. It has common
descriptions and examples of typographic terms, characters and uses.
Guide to Macintosh Software Localization. Apple Computer, Inc. (Reading, MA USA:
Addison-Wesley Publishing Company, 1992) ISBN: 0-201-60856-1 (pbk.)
Part of the Inside Macintosh series technical specifications. Specifically relates to user
interfaces and text on worldwide Macintosh Systems. Shows examples of user interface
guidelines, keyboard layouts, localised character sets, language descriptions, country
and writing systems.
HTML 4.0. World Wide Web Consortium. (Massachusetts Institute of Technology, Institut
National de Recherche en Informatique et en Automatique, Keio University, 1997).
Internet: http://www.w3.org/

What's next
Uppercase characters

Technical specification for HTML.

Feedback
Was this page helpful?

 Yes

 No

Character design standards - Uppercase
for Latin 1
Article • 06/09/2022

Advance width rule
All glyphs in proportionally spaced typefaces have advance widths that are dependent
on their proportional design.

Vertical alignment rule
This is the value of uppercase flat heights such as the top of the B,D,E,F,H,
I,J,K,L,M,N,P,R,T,U,V,W,X,Y and Z in most typefaces.
All other uppercase flat characters that have the same top feature should be at the same
value exactly in most text fonts.
Note : On the diagonal strokes of the characters A, V or W, the alignment of the top
or bottom varies depending on the horizontal thickness of where the diagonal
strokes join. A very pointed A, V or W should have the top or bottom exceeding the
value of the flat height so it does not appear short. A wide top or bottom junction
design may reside on the baseline or align to the uppercase flat height as the 'A' in
the illustration below.

Round overshoot values rule
This is the value of uppercase round heights such as the C,G,O,Q,S,J and U.
All other uppercase round characters that have the same top and bottom feature should
be at the same value exactly in most text fonts. They should overshoot the baseline of
the flat characters the same amount as the top overshoots the uppercase flat characters.
Note : It is far more important the tops and bottoms of round characters are visually
more than mathematically equal. It is common for designers to make some round
characters, such as the uppercase S and C slightly smaller than the uppercase O.
'I'm very unsystematic about things like the relative sizes of round characters, I judge
them purely by eye. It's my impression that S and C often need to be a bit smaller

than the fully-enclosed O because the openings in their forms make them look bigger.
This applies equally to the lowercase.'
Comments on visual character heights by Matthew Carter, Carter and Cone Type, Inc.

Spacing rule
The two most important characters with regard to spacing in the uppercase are the H
and the O. These two are the model characters most type designers use to space the
rest of the group. They are used in chains to test how the current character spaces
between other straight or round stems. When spacing outlines, glyphs should be
visually centered as opposed to mathematically. It is helpful in upright modern
geometric designs to use mathematical logic in spacing. In such a case the sidebearing
values of round featured characters are mathematically the same and usually less than
the flat characters values.
All characters should position in their cell in a similar way so when placed in text they
space evenly. This does not mean the center of its advance width. It is common for some
typefaces (italics) to position the black (black width) of the glyph to the right of the
mathematical center of the advance width. The H and O are used to test how the current
character centers in the font, not in its advance width.

Specific character standards
Uppercase OE diphthong
Unicode: U+0152
Uppercase AE diphthong
Unicode: U+00C6

Design : There are two common design styles for the uppercase OE and AE
diphthongs. The most common style is one where the uppercase E is the main or
dominant character as in Matthew Carter's Georgia. A less common design is one
where the first component the O or A is the dominant character as in Monotype
Plantin. The bar of the uppercase A does not necessarily have to be at the same
vertical height as the bar of the uppercase E.
Advance width rule : The advance width is proportional to the design. The left
sidebearing is commonly the same as in the uppercase O or A and the right
sidebearing is commonly the same as in the uppercase E.

Uppercase L slash
Unicode: U+0141
Design : This letter is used in Polish and many languages including some native
American languages. The bar length should be longer on the right than the left
and large enough to be clearly visible at all sizes. The bar angle should be
approximately 30 degrees. The bar angle in Palatino Linotype regular is 29.8
degrees from horizontal and the Palatino Linotype italic is 28.03 degrees from
horizontal.
For help on the design, bar length and angle for the Polish language see the
suggestions for Polish diacritics byAdam Twardoch .
Advance width rule : The advance width is commonly the same as the uppercase L.

Uppercase O slash
Unicode: U+00D8
Design : This letter is used in Danish and Norwegian languages. The bar length is
commonly equal too or greater than the leftmost and rightmost portions of the
uppercase O and equal to or greater than the top and bottom. Its angle should

evenly divide the counter. Some very bold and display designs the bar does not
extend through the center counter of the uppercase O instead it only extends from
the outer portions of the letter.
Advance width rule : The advance width is commonly the same as the uppercase O.

Uppercase Eth
Unicode: U+00D0
Design : This character's design is based on the uppercase D with a bar. The bar should
be the same thickness as other uppercase characters with bars in the font. Bar should be
positioned vertically to visually center. This is usually slightly north of the mathematical
center. Horizontally the bar should extend more to the right of the stem of the D and be
approximately half the length of the D counter. The left side should extend sufficiently
to be visible at smaller point sizes. This is the same glyph shape as Unicode character D
with stroke U+0110.
For more help on designing the Eth and Thorn see the tutorial by Icelandic type
designer Gunnlaugur SE Briem .
Advance width rule : It is often necessary for the advance width of this character to be
greater than that of the uppercase D to visually compensate for the bar.
Uppercase D with stroke - Dyet
Unicode: U+0110
Design : This is the same glyph shape and design as Unicode character Eth
U+00D0. This character is used in the Croatian, Vietnamese, Macedonian and
Serbian languages.
Uppercase T with stroke
Unicode: U+0166
Design : This character's design is based on the uppercase T with a bar. The bar
should be the same thickness as other uppercase characters with bars in the font.
Bar is positioned commonly slightly north of the mathematical center. Horizontally
the bar should extend equally to the left and right of the stem in roman designs
and visually equal in italic designs.

Advance width rule : The advance width should be equal to the uppercase T
character's advance width.
Uppercase H with stroke
Unicode: U+0126
Design : This character's design is based on the uppercase H with a bar. The bar
should be the same thickness as other uppercase characters with bars in the font.
The bar should be positioned vertically in the upper portion above the center
crossbar of the H, visually centered. Horizontally the bar commonly extends
equally to the left and right of the stem in roman designs and visually equal in
italic designs. In some designs the bar does not extend through the stems of the H.
Advance width rule : When the bar extends through the H it is often necessary for
the advance width to be greater than that of the uppercase H to visually
compensate for the bar.

Uppercase Thorn
Unicode: U+00DE
Design : This character's design is based on the uppercase P. The common practice
is to move the round bowl of the uppercase P down so the bowl is vertically
positioned slightly north of the mathematical center. In serif designs the top of the
main straight stroke's serif is usually equal to the lower inner serif on this main
stroke.

Advance width rule : The advance width should be equal to the uppercase P
character's advance width.
For more help on designing the eth and thorn see the tutorial by Icelandic type
designer Gunnlaugur SE Briem .
Uppercase Eng
Unicode: U+014a

Design : The preferred design of the uppercase Eng for the Sami language is one
based on the uppercase N. The design form that resembles a lowercase n is an
equivalent form of the uppercase Eng.

The uppercase and lowercase Eng are also used in the western African language of
Hausa. In this African language the preferred design for the uppercase Eng is one
that has a rounded top similar to a lowercase n.

Advance width rule: The advance width should be equal to the uppercase N
character's advance width or proportional to the design.

Small caps
Design : These characters are smaller versions of the uppercase characters. Their weight
relates to the lowercase and the stroke distances are often slightly heavier than the
round and straight strokes of the lowercase. Mathematical scaling should only be used
as a basis for the final designs. The vertical height is created commonly by using a larger
scale than the horizontal direction. Common scales are 65..80% of the uppercase height.
It is always necessary to adjust the weight of the scaled letterforms. These smaller
characters need to have proportionally heavier stems than the scaling provides.
Example: The small caps characters for Tahoma are vertically 78.5% and horizontally 82%
of the uppercase height. The small cap characters in Palatino Linotype are 65% vertically
and 66% horizontally less than the uppercase height.
There are no Unicode numbers for these characters. The Unicode Consortium sees these
characters as glyph variants and not unique characters. These glyphs can be accessed in
OpenType fonts by glyph substitution.
Vertical alignment : The small cap flat height is commonly greater than or equal to the
lowercase x-height. Its actual height is dependent on the design.

What's next
Lowercase

Character design standards - Lowercase
for Latin 1
Article • 06/09/2022

Advance width rule
All glyphs in proportionally spaced typefaces have advance widths that are dependent
on their proportional design.

Vertical alignment rules
Flat characters align with the lowercase x-height and baseline
Lowercase flat height values are the tops of all flat characters that have the same top
feature. These characters should be at the same value exactly in most text fonts.
Note: The diagonal strokes on the character v or w, alignment of the bottom varies
depending on the thickness of the bottom where the two strokes join. A very
pointed v needs to descend below the baseline so it does not appear short. A wide
bottom junction design may reside on the baseline.

Lowercase ascender and descender height rules
Characters that have ascenders or descenders very often are at the same vertical height
value regardless if they are round or flat. Unlike other round characters these round
ascenders (such as the f) or descenders (such as the g or j) many times do not overshoot
other flat or slanted characters (such as the b, d, h, l, p, or q).

Round overshoot rules
All other lowercase round characters that have the same top and bottom feature should
be at the same value exactly in most text fonts. They should overshoot the baseline of
the flat characters the same amount as the top overshoots the lowercase flat characters.
Note: It is far more important the tops and bottoms of round characters are visually
more than mathematically equal. It is common for designers to make some round
characters, such as the lowercase s and c slightly smaller than the lowercase o. See

the quotation on visual character heights in the uppercase section by Matthew
Carter, Carter and Cone Type, Inc.

Spacing rules
The two most important characters with regard to spacing in the lowercase are the n
and the o. These two are the model characters most type designers use to space the rest
of the group. They are used in chains to test how the current character spaces between
other straight or round stems. When spacing outlines, glyphs should be visually
centered as opposed to mathematically. It is helpful in upright modern geometric
designs to use a mathematical logic in spacing. In such a case the sidebearing values of
round featured characters are mathematically the same and usually less than the flat
characters values.
All characters should position in their cell in a similar way so when placed in text they
space evenly. This does not mean the center of its advance width. It is common for some
typefaces (italics) to position the black (black width) of the glyph to the right of the
mathematical center of the advance width. The n and o are used to test how the current
character centers in the font, not in its advance width.

Specific character standards
German double s - eszett
Unicode: U+00DF

Design: This character is a ligature of two lowercase 's' characters and is a
traditionally based ligature made with an archaic long 's' and lowercase 's'. On
personal computers, it has been used as a substitute for the greek lowercase beta
U+03B2 commonly in the version numbers of files and applications.
The top bowl and bottom bowl should meet at approximately the x-height of the
lowercase.
In Cap Only typefaces, two uppercase 'S' characters are used as the design for this
character. The ligature form is a lowercase design. The advance width of the Cap
Only German double 'S' usually is not made twice the width of the single 'S'. It is
made to space slightly tighter than two uppercase S characters.

Alignment rules: The top should align with the lowercase ascender.
Long lowercase s
Unicode: U+017F
Design: This character is an archaic form of the lowercase s. Its origins are from the
earliest forms of the lowercase, from cursive scribe's literature. In early Roman
scribe's literature, it appeared with lowercase ascenders in the minuscule, or halfuncial, alphabet. Uncial came to England with Roman missionaries in the Christian
literature of the sixth and seventh century.
Its form is similar to the lowercase f. This character's shape is also related to the
design of the German double s U+00DF.
Alignment rules: This character aligns with the lowercase ascender and is of the
same style as the lowercase f.
Advance width rule: The advance width should be the same as the lowercase f.
Ampersand
Unicode: U+0026
Design: This character is an abbreviation for the word 'and'. It is historically based
on the Latin word 'et' and its name is said to be derived from the words 'and per
se'. It is a unique design with a stroke weight that often relates to the lowercase

and it is commonly grouped with lowercase ligatures. Traditionally it was grouped
with the uppercase due to common use in business names.
Alignment rules: Its alignment is unique and it commonly is slightly shorter than
the uppercase top overshoot height.
Advance width rule: The advance width is proportional to the design.
Lowercase oe diphthong
Unicode: U+0153
Lowercase ae diphthong
Unicode: U+00e6
Design: The central connection of both elements of the ligature should be the
same weight visually as similar strokes of the lowercase. Commonly the lowercase e
is the more dominant character in the ligature.
Advance width rule: The advance width is proportional to the design. The left
sidebearing is commonly the same as in the lowercase o or a and the right
sidebearing is commonly the same as in the lowercase e.

Lowercase l slash
Unicode: U+0142
Design: This letter is used in Polish and many languages including some native
American languages. The bar length is commonly slightly longer on the right than
the left and large enough to be clearly visible at all sizes. The bar angle should be
approximately 30 degrees. The bar angle in Palatino Linotype regular is 30.2
degrees from horizontal and Palatino Linotype italic is 31.85 degrees from
horizontal.
For help on the design, bar length and angle for the Polish language see the
suggestions for Polish diacritics by Adam Twardoch

.

Advance width rule: The advance width is commonly the same as the lowercase l. In
sans serif fonts the advance width may need to be larger than the lowercase l.

Lowercase o slash
Unicode: U+00F8
Design: This letter is used in Danish and Norwegian languages. The bar length is
commonly equal too or greater than the leftmost and rightmost portions of the
lowercase o and equal to or greater than the top and bottom. Its angle should
evenly divide the counter. Some very bold and display designs the bar does not
extend through the center counter of the lowercase o instead it only extends from
the outer portions of the letter.
Advance width rule: The advance width is commonly the same as the lowercase o.

Lowercase eth
Unicode: U+00F0
Design: This character's design is based on the lowercase o with an added
ascender. The ascender generally extends to the lowercase ascender height
vertically.

Advance width rule: The advance width should be the same as the lowercase o.
For more help on designing the eth and thorn see the tutorial by Icelandic type
designer Gunnlaugur SE Briem

.

Lowercase d with stroke - dyet
Unicode: U+0111
Design: This character's is used in the Croatian, Vietnamese, Macedonian and
Serbian languages. Its design is based on the lowercase d with an added bar. The

bar should be the same thickness as other lowercase characters with bars.
Vertically the bar should be visually centered between the x-height and the
ascender. It should horizontally extend to the right of the stem similarly to the serif
in serif designs and enough to be visible at small size but not long enough to
cause spacing problems for sans serif designs. To the left the bar should extend
approximately one half the width of the lower bowl of the d and in italic designs
visually one half the bowl.

Advance width rule: The advance width should be the same as the lowercase d. In
sans serif designs it may be necessary for the advance width of this character to be
greater than that of the lowercase d to visually compensate for the bar.
Lowercase t with stroke
Unicode: U+0167
Design: This character's design is based on the lowercase t with a bar. The bar
should extend left of the main stem about the same distance as the crossbar of the
t. The thickness should be the same as other lowercase characters with bars. The
right side of the bar should extend farther from the main stem than the left side.

Advance width rule: The advance width should be the same as the lowercase t.
Lowercase h with stroke
Unicode: U+0127
Design: This character's design is based on the lowercase h with a bar. The bar
should be the same thickness as other lowercase characters with bars in the font.
Vertically the bar should visually center between the x-height and the ascender. It
should horizontally extend to the left of the stem similarly to the serif in serif
designs and enough to be visible at small size but not long enough to cause
spacing problems for sans serif designs. To the right the bar should extend
approximately one half the width of the lower bowl of the lowercase h and in italic
designs visually one half the bowl.

Advance width rule: The advance width should be equal to the lowercase h
character's advance width. In sans serif designs it may be necessary for the
advance width of this character to be greater than that of the lowercase h to
visually compensate for the bar.
Lowercase thorn
Unicode: U+00FE
Design: This character's design is based on the lowercase p and the lowercase l.

Advance width rule: The advance width should be equal to the lowercase p
character's advance width.
For more help on designing the eth and thorn see the tutorial by Icelandic type
designer Gunnlaugur SE Briem

.

Lowercase eng
Unicode: U+014B
Design: This character's design is based on the lowercase n.

Advance width rule: The advance width should be based on the lowercase n
character's advance width. It is commonly necessary to decrease the right
sidebearing in serif fonts to compensate for the loss of the serif.
Feminine ordinal
Unicode: U+00AA
Masculine ordinal
Unicode: U+00BA

Design: These ordinal characters are used in the Spanish and other romance
languages for proper gender ordinal numbers. Similar to the English abbreviations
1st, 2nd, 3rd and 4th.
There are two basic styles of design for the ordinals. Some designs have a bar
beneath the ordinal. Others do not. The ordinal version with the bar is the
preferred version.
Spanish abbreviations for primera, primer, segunda, and segundo.

Note: Traditionally in Portuguese the ordinal characters should contain the
underline. The underline helps avoid confusion between the masculine ordinal
and the degree character. This is important at low resolution, such as the
screen, when both characters are very similar in size and shape.
Language information contributed by Mário Feliciano, Secretonix-Typography
& Design. Lisbon, Portugal
Alignment: Aligns with the figure height. Commonly at the top of the figure height.
Advance width: The advance width is commonly proportional to the design.
Spacing: This character should space between figure zeros.
Greenlandic lowercase kra
Unicode: U+0138
Design: The design should be of the weight of the lowercase. This is not a small
cap version of the uppercase K. In serif designs the left top serif should be of the
same design as the lowercase n, i, m, j etc.

Alignment rules: This character aligns with the lowercase flat x-height.
Advance width rule: The advance width is proportional to the design.

Lowercase ligatures

Lowercase ff ligature
Unicode: U+fb00
Used as a doubled f ligature and also as an abbreviation in music for fortissimo.
Lowercase fi ligature
Unicode: U+fb01 and U+f001
Lowercase fl ligature
Unicode: U+fb02 and U+f002
Lowercase ffi ligature
Unicode: U+fb03
Lowercase ffl ligature
Unicode: U+fb04
Long s and t ligature
Unicode: U+fb05
Lowercase st ligature
Unicode: U+fb06
These characters are traditional typographic lowercase ligatures that are present in
Unicode 2.0. The fi and fl ligature placed in all fonts released previous to the
Unicode 2.0 specification, were set at the beginning of the private use area at
positions U+f001 and U+f002. Unicode version 1.0 did not support ligature forms
that are not a main character of the script until the release of version 2.0 of the
Unicode specification.
Design: Traditionally these characters were individually designed and found
commonly only in serif fonts. They are not just a merging of two or three lowercase
letters. These character's ligature connection (if present) should be a smooth
transition and not a simple overlap of contours. Sans serif fonts are not calligraphic
in nature and it is common for these ligatures to be a tighter spaced version of the
two or three base lowercase glyphs.
Advance width rule: The left sidebearing should be equal to the base model
character's left sidebearing (example: the f in a fi ligature). The right sidebearing
should be equal to the sidebearing of the right most character's original right
sidebearing (example: the i in a ffi ligature).
Lowercase ch ligature
Unicode: A substitute glyph for U+0063 and U+0068

This glyph is a traditional ligature for the lowercase c and h characters found in
Fraktur style German lettering. It has been included with other lowercase ligatures
in some Roman typefaces such as the typefaces of Hermann Zapf, Rudolph Koch's
Kabel and David Berlow's

Berlin Sans. The lowercase c and lowercase h are

treated as one character when reading German and many typographers kern them
quite closely together when setting text. In the German language the c and h
characters are rarely broken by hyphenation. The c and h are hyphenated in the
rare case of the first word component ending with a c (commonly of foreign origin)
and the next word component beginning with an h.
Example: The foreign words: 'Ad hoc' and the abbreviation for the Macintosh
computer: 'Mac' when combined with the German word for help, 'hilfe' are
commonly written in German text as Mac-Hilfe and Ad-hoc-Hilfe.
Advance width: The advance width is proportional to the design. The left
sidebearing should be the same as the lowercase c character’s sidebearing. The
right sidebearing should be the same as the lowercase h character’s sidebearing.
The white space between the characters of the ligature are spaced commonly
much less than the white space between the lowercase c and h characters.
Lowercase ck ligature
Unicode: A substitute glyph for U+0063 and U+006B
This glyph is a traditional ligature for the lowercase c and k characters found in
Fraktur style German lettering. It has been included with other lowercase ligatures
in some Roman typefaces such as the typefaces of Hermann Zapf, Rudolph Koch's
Kabel and David Berlow's Berlin Sans.
Advance width: The advance width is proportional to the design. The left
sidebearing should be the same as the lowercase c character's sidebearing. The
right sidebearing should be the same as the lowercase k character's sidebearing.
The white space between the characters of the ligature are spaced commonly
much less than the white space between the lowercase c and k characters.
In German text setting and hyphenation the lowercase c and k are written in one of
two ways.
Traditionally in all German speaking countries/regions the lowercase c and k
should be separated as: k-k
Example : The German word Zucker would be separated at the end of a line
as : Zuk- ker.
In modern German spelling the lowercase c and k are not broken.

Example : The German word Zucker would be broken at the end of the line as
: Zu- cker.
Lowercase tz ligature
Unicode: A substitute glyph for U+0074 and U+007A
This glyph is a traditional ligature for the lowercase t and z characters used in the
German language. It is mostly designed as a finial character.This ligature has been
included with other lowercase ligatures in some Roman typefaces such as the
typefaces of Hermann Zapf, Rudolph Koch's Kabel and David Berlow's Berlin Sans.
Advance width: The advance width is proportional to the design. The left
sidebearing should be the same as the lowercase t character's sidebearing. The
right sidebearing should be the same as the lowercase z character's sidebearing or
specific to the design in a more decorative finial style. The white space between
the characters of the ligature are spaced commonly much less than the white
space between the lowercase t and z characters.
'The reason for many ligatures is not so much an esthetic one, but one of
simple labour-saving. When I worked as a comp, we used a lot of those regular
German workhorse faces, like (Berthold) Block, and they often had ligatures for
frequently used combinations. There was sch, ch, tz, st, and ss. All these occur
in every other German word, and if you're setting type by hand and are judged
by your hourly output, saving one character per word makes a lot of
difference. The letter c never appears on its own in German words, only ever
preceding an h or a k, so it usually looks too far apart from these letters.
Another reason to have a ligature. They didn't often look like a ligature,
however, as they were not touching, but still cast onto one body.'
Comments on the use of ligatures in German text by Prof. Erik Spiekermann,
MetaDesign

: Berlin, Germany

Superior lowercase
There are several forms of superior lowercase letters each with a specific use.
Ordinals are superior lowercase letters that are used in abbreviations in Spanish and
other romance languages. See the male and female ordinals in this section.
In mathematics, letters are used as variables and are vertically and horizontally
positioned, different depending on the formula. To make the formulas more clear these
letterforms are usually larger than the ones used in text settings. An example of a

common math related superior letter is the superior n U+207F found in the Microsoft
WGL4 character set to support the PC-8 code page for Hewlett-Packard printers.
The form that more closely relates to the lowercase are letters that are intended to be
used with text. This form aligns with the uppercase letters.
These lowercase letters commonly are placed so the x-height is at the top of the
uppercase. More typographically correct and commonly placed so the superior ascender
height is at about the uppercase height. This places the superior baseline at
approximately half the uppercase height and the superior lowercase x-height lower than
the uppercase height. Commonly included in this set of characters is the accented
lowercase e grave. While typographically considered incorrect in French, the e grave is
commonly used in the abbreviations of the words première and in deuxième, troisième,
and higher ordinal numerals. The common and typographically correct abbreviations are
shown in the illustration below.
The abbreviations for premier, première, and deuxième.

Abbreviations are very common in the French language. Below are some additional
lowercase superiors used in a few common abbreviations. Note the alignment of the
lowercase l in the abbreviation of the word mademoiselle.

Language information contributed by Jean-François Porchez, Porchez Typofonderie

,

France
There are no Unicode numbers for these characters. The Unicode Consortium sees these
characters as glyph variants and not unique characters. These glyphs can be accessed in
OpenType fonts by glyph substitution.

What's next
Figures

Character design standards - Figures for
Latin 1
Article • 06/09/2022

Advance width rule
There are two main categories of numerals.
Proportional - the advanced widths of characters zero through nine are on widths in
proportion to their individual character's black width. In most proportionally spaced
numerals the number one is on a thinner proportional advance width than the other
figures which are on the same width as the zero. Old style numerals are also considered
proportional numerals.
Tabular - all character's advance widths are the same value. This aids in setting numerals
for data in columns.
Note : Traditional non-digital typefaces offered proportional, tabular, old style
and/or lining numerals. In tabular numerals the advance width and in proportional
numerals any good model figure, such as the figure zero, is commonly referred to as
the 'figure width' and it is used for the widths of some monetary symbols. The
Dollar, Pound Sterling, Lira, Vietnamese Dong and Euro should all be on the figure
width. The monetary signs Cent, Colon, Cruzeiro, French Franc, Naira, Peseta, Rupee,
Won, and New Shekel may require a unique advance width.

Vertical alignments
This is the value of uppercase flat heights such as the top of the 1, 4, 5, and 7 in most
typefaces with proportional and lining numerals.

Alignment rule
All figure flat characters that have the same top feature should be at the same value
exactly in most text fonts.
Old style numerals like the numerals in Georgia, have different alignment rules. These
numerals are sometimes called hanging or x-height numerals and were offered in most
traditional text fonts. They are best suited for text settings with numerals as opposed to
solely numeric data. The 0, 1, and 2 align from the baseline to the x-height (rounds to
overshoot heights). The numerals 3, 4, 5, 7 and 9 descend to the nearly the lowercase
descender. The numerals 6 and 8 ascend to commonly the figure overshoot height.
Note : The figure 1 or 4 tops may not align with the flat numerals 5 and 7 in many
serif typefaces dependent on the diagonal strokes at the top of the characters.

Round overshoot values
This is the value of figure round heights such as the 0, 2, 3, 5, 6, 8 and 9.

Overshoot rule
All other figure round characters that have the same top and bottom feature should be
at the same value exactly in most text fonts. They should overshoot the baseline of the
flat characters the same amount as the top overshoots the top of the figure flat
characters.

Spacing rule

The most important character with regard to spacing any figure, mathematical or
monetary symbol is the zero. This is the model character most type designers use to
space the rest of these groups. They are used in chains to test how the current character
spaces between other straight or round stems.
When spacing outlines, glyphs should be visually centered as opposed to
mathematically. It is helpful in modern geometric designs to use a mathematical logic in
spacing. In such a case the sidebearing values of round featured characters are
mathematically the same and usually less than the flat characters values.
All characters should position in their cell in a similar way so when placed in text they
space evenly. This does not mean center. It is common for some typefaces (italics) to
position the black of the glyph (black width) to the right of the mathematical center of
the advance width. The zero is used to test how the current character centers in the font,
not in its advance width.

Superior numerals
Superior one
Unicode: U+00B9
Superior two
Unicode: U+00B2
Superior three
Unicode: U+00B3
These characters are based on the full size numerals. A suggested scale factor of
63% in the horizontal direction and 60% in the vertical yields a good proportional
superior or inferior numeral. It is always necessary to adjust the weight of the
scaled numeral in making a superior or inferior character. These smaller characters
need to have proportionally heavier stems than the scaling provides.
Related Unicode characters: Superior numerals and forms U+2070..208E. These
characters share the same standards.
Advance width : The advance width is proportional and usually the about same as
the math sign's advance width.

Alignment : The alignment of the superior numerals is unique. The round
character's tops align with the round numeral tops. The flat height and baseline are
centered on the round top and bottom of the zero and the difference or resulting
overshoot value should be evenly distributed. The value of each overshoot should
be about 60% of the figure overshoot value.
Inferior numerals are commonly placed descending below the baseline in numerals
used for scientific notation and on the baseline for numerals intended to be used
as shilling fraction denominators.

Inferior numerals
Inferior numerals zero to nine
Unicode: U+2080..2089
Advance width : The advance width should be the same as the superior numeral's
advance width.
Alignment : There are traditionally two alignments for inferior numerals.
The most useful for text and scientific notation is an alignment that descends
below the baseline approximately half the inferior numeral's height.

The alignment commonly used for setting shilling fractions is on the baseline.
Many typefaces also have shilling fractions with denominators that descend.

Vulgar fractions
Fraction bar
Unicode: U+2044
This character is used when making fractions that are not pre-composed.
Advance width : The advance width is proportional to the design and commonly
the advance width is only wide enough so it separates two numerals or superior
and inferior numerals to form an inline fraction. The fraction bar will have a
negative right and left sidebearing in most cases.

Alignment : The top and bottom of the bar are design dependant and commonly
at the visual top and bottom of the figure height.
One quarter
Unicode: U+00BC
One half
Unicode: U+00BD
Three quarters
Unicode: U+00BE
These characters are built from the inferior and superior numerals and the fraction
bar.
Advance width : The advance width is proportional to the design and all fractions
should share the same advance width.

Additional Unicode fraction characters:
Fraction numerator one
Unicode: U+215F
The left sidebearing should be the same as other fractions with a numerator one.
The right sidebearing should be adjusted to space well when an inferior baseline
numeral follows.
Alignment : The numerator aligns with the figure height and at the same position
as the one in other fractions.
Case fractions - 'nut' fractions
These characters are fractions useful for setting data in tighter spaces than allowed
by shilling or vulgar fractions. They are called 'nut' fractions commonly since they
are placed on the en space or 'nut' of the typeface.
Design : The numerator and denominator for these fractions usually need to be
smaller than the inferior and superior numerals to fit within the figure height of the
typeface. Their weight should be adjusted so they do not appear too light in
comparison to the rest of the typeface.
Alignment : The numerator aligns with the figure height and the denominator
traditionaly sits below the baseline. It is also common for the denominator to sit on
the baseline.

What's next
Space characters

Character design standards - Space
characters for Latin 1
Article • 06/10/2020

In traditional typesetting there were several characters used for word spacing. In digital
font files the word space is a specific width character used for word spacing. Applications
are responsible for adjusting the word spacing and character spacing to suit the current
page layout. Many page layout applications allow for custom control of the word
spacing through application specific functions. Unicode and OpenType fonts can
provide similar custom word space glyphs or other glyph substitutions that will be
portable to other applications.
In digital fonts there are only two kinds of space characters supported by most
computers, the space and the no-break space.
Standard space characters
Space
Unicode: U+0020
Advance width rule : The space's advance width is set by visually selecting a value
that is appropriate for the current font. The general guidelines for the advance
widths are:
The minimum value should be no less than 1/5 the em, which is equivalent to
the value of a thin space in traditional typesetting.
For an average width font a good value is ~1/4 the em.
Example: In Monotype's font Times New Roman-regular the space is 512 units,
the em is 2048.
For a wide width font a good value is ~1/3 the em.
Example: in Microsoft's Verdana the space is 720 units, Tahoma is 640 units. In
Stephenson Blake's Wide Latin the space is 612 units. In all fonts the em is 2048
units.
The maximum width should be no greater than 1/2 the em, which is equivalent
to the en space of a typeface.
No-break space
Unicode: U+00A0

The no-break space is the same as the word space character with the added
functionality of providing a way to prevent two words from being separated by a
line break.
Example: If the words 'Monotype's Arial' were at the end of a sentence and the
author wishes for them to remain as a pair, a no-break space character could be
used to keep the two words together.
Advance width rule : The advance width of the no-break space should be equal to
the width of the space.
The no-break space is not the same character as the figure space. The figure space
is not a character defined in most computer system's current code pages. In some
fonts this character's width has been defined as equal to the figure width. This is an
incorrect usage of the character no-break space.

Other space characters
The following characters are word space characters defined in Unicode. The majority of
these characters are traditional typographic space values or characters that are related
to other character's width criteria. Typographers used these characters to manually set
type. Today computer applications and page layout systems alter space and set text.
These page layout systems make use of only the space and no-break space. A
typographer could use any of these characters to manually set text (when text is left or
right justified) by substituting the word space U+0020 with one of these specific space
characters.
Word space characters are also language and script dependent.
En quad U+2000 - equal to the en space and one half the em. In a noisy printing
shop the en quad was called a 'nut' so it would not be confuse with the em quad.
Em quad U+2001 - equal to the em space.
En space U+2002 - 1/2 of the em space. 1024 units in a 2048 unit per em font.
Em space U+2003 - Traditionally defined as a space character with an advance
width value equal to the current point size. In a 12 point font the em is equal to 12
point. In PostScript and TrueType fonts there are 72.0 points to the inch. This is not
necessarily equivalent to the advance width of the uppercase M. In digital fonts
font units are used to calculate point size. There are 2048 units in the em of a Latin
1 TrueType font.

Three per em space U+2004 - equal to 1/3 of the em space. 683 units in a 2048 unit
per em font.
Four per em space U+2005 - equal to 1/4 of the em space. 512 units in a 2048 unit
per em font.
Six per em space U+2006 - equal to 1/6 of the em space. 341 units in a 2048 unit
per em font.
Figure space U+2007 - Standard setting is equal to the advance width of the
figures, or figure zero.
Punctuation space U+2008 - Standard setting is equal to the advance width of the
period U+002e and comma U+002c.
Thin space U+2009 - Standard setting is 1/5 of the em space. 410 units in a 2048
unit per em font. This should be language dependent. The standard language
dependent setting for French is 1/8 of the em space. 256 units in a 2048 unit per
em font.
Note : When traditionally typesetting the French language a word space is inserted
before or after several punctuation characters. These characters are colon, semi colon,
question, exclamation, right guillemets, and left guillemets. Commonly the preferred
word space used is a thin space of 1/8 the em. Some French typographers prefer to use
a larger space character of 1/4 the em with the colon and some other punctuation
characters. OpenType supports character substitution and language dependant variants.
Hair space U+200A - The thinnest space in a typeface. Recommended standard
setting is 1/10..1/16 of the em.

What's next
Diacritics

Character design standards - Diacritics
for Latin 1
Article • 06/09/2022

Historically typefaces contained accented characters with diacritics that were separately
designed for lowercase and uppercase characters. Generally the uppercase designs were
shorter (to keep them in the em height) and more robust than the lowercase diacritics.
In some type manufacturer's proprietary font formats there were algorithms to create
composite accented characters. These typesetting systems used uppercase and
lowercase diacritics that were on zero units with programmed logic for combining
diacritics and base glyphs to make accent characters. In PostScript or TrueType formats,
most fonts only contain lowercase spacing accents and these characters are used to
create composite accented characters.

Advance width rules
Sometimes called en spacing accents, these diacritic widths are commonly on the en
space. This is not a requirement. These characters can be placed on proportional widths
but all glyphs should share that same value. These spacing accents are rarely used alone
and are mostly used for creating composite accented characters. Their advance width is
not used in the final composite character.

Vertical alignment rules
If there is only a single design for these characters, the design should be lowercase and
positioned at the vertical height for use with lowercase characters.
There are two methods of aligning all diacritics. Both use the acute and grave as the
models for all characters vertical positioning. The most common method of alignment is
center alignment on the height of the acute and grave. The less frequent method is
bottom aligning. All diacritics are aligned with the bottom of the acute or grave.

Spacing rules

Visually spaced between uppercase H and O.

Composite character placement rules
Vertical placement: Most commonly vertically placed so the space between the bottom
of the acute and grave are offset approximately 5 to 10% of the em above the top of the
lowercase overshoot height. In a 2048 em the space is usually between 100 and 200
units. Uppercase accents are usually closer to the tops of the base glyph than lowercase
accents.
Example: Palatino Linotype regular has 98 units between the acute and uppercase O.
There are 130 units between the acute and lowercase o. Georgia regular has 54 units
between the acute and the uppercase O. There are 96 units between the acute and the
lowercase o. Georgia accents are considered very tightly spaced. In both fonts the em is
2048.
Horizontal placement: Horizontally diacritics are to be placed in the visual center of the
glyph. The two most difficult glyphs to center are the acute and grave. There are two
common theories when centering these glyphs. A common way is to place the acute or
grave so the front goes through an imaginary line of the visual center of the base glyph.

The second method was taught at the type foundries of Monotype and Mergenthaler
Linotype. The acute is placed so 1/3 of its black width is on the left of the imaginary
centerline of the base character and 2/3 are on the right of that line. The grave has
2/3rds on the left and 1/3 is on the right. This is considered a starting point and visual
adjustment is made dependent on the design.

All other diacritics are placed so they visually center on an imaginary center line of each
base glyph.

Note: In the Polish language the preferred angle of the acute is steeper than the
acute diacritic's angle in most typefaces. For help on the design and position of the
acute diacritic for the Polish language see Adam Twardoch's

recommendations for

the acute diacritic. A language dependent substitute would a good solution for the
Polish language.

Specific character placement
Ogonek
The ogonek should be placed on the right stem of an uppercase A and to the left
of center. In round featured glyphs such as the uppercase U and lowercase e care
should be taken so the ogonek is placed just slightly to the right of center and the
ogonek extends from the stroke as it would as a calligraphic stroke. For more help
on designing the ogonek diacritic and its placement see Adam Twardoch's
design recommendations for Polish accented characters.

L or l Catalan (L with mid dot)
This character is actually a compound character made from a base character and
an additional punctuation character. The mid dot is used in the Catalan language
to separte two lowercase l or two uppercase L characters that are not part of the
same syllable in a word.
The mid dot is commonly made from the overdot diacritic U+02D9 or a character
made specifically for this purpose. Often the period U+002E, period centered
U+2219 or mid dot U+00B7 are not an appropriate size for this character. The dot
in the L or l Catalan character should be positioned to center vertically on the
uppercase height and center horizontally when followed by another L or l.

Under comma and cedilla
The under comma is the preferred form in the Romanian language for the
uppercase characters S and T with under comma accent and *lowercase s and t with

under comma accent. Four new Unicode values have been defined to
accommodate this preference.
Scommaaccent U+0218 ; scommaaccent U+0219 ; Tcommaaccent U+021A ;
tcommaaccent U+021B
The connecting cedilla is the preferred form in the Turkish language for the
uppercase S with cedilla and lowercase s with cedilla:
Scedilla U+015E ; scedilla U+015F
An under comma is an acceptable alternative to a connecting cedilla for the
following characters:
Ccedilla U+00c7 ; ccedilla U+00e7 ; Kcedilla U+0136 ; kcedilla U+0137
Lcedilla U+013b ; lcedilla U+013c ; Ncedilla U+0145 ; ncedilla U+0146
Rcedilla U+0156 ; rcedilla U+0157 ; Tcedilla U+0162 ; tcedilla U+0163
Note: In the Portuguese and Catalan languages the traditional connecting style of a
cedilla is more commonly preferred for the Ccedilla U+00c7 and ccedilla U+00e7.
It is common in modern designs and French typography to see a cedilla design
with a stroke that is not connecting or as in common handwriting, a line that
passes through the bottom or beneath the uppercase or lowercase c.
A good solution for these differences would be a language dependant substitute
glyph for the Ccedilla U+00c7 and ccedilla U+00e7.

Additional note: Recently some type designers have been designing a hybrid form
of an under comma or cedilla. This takes the shape of the lower portion of the
connecting cedilla and is used beneath any base character which has an open base
as on the uppercase R, K, k, N and n.
Caron
Tcaron U+0164 and tcaron U+0165
In the lowercase the apostrophe is the preferred diacritic. This diacritic is often a
unique glyph designed for this purpose. For the uppercase the caron U+030c is the
preferred diacritic.
Dcaron U+010e and dcaron U+010f

In the lowercase the apostrophe is the preferred diacritic. This diacritic is often a
unique glyph designed for this purpose. For the uppercase the caron U+030c is the
preferred diacritic.
The following characters use the caron U+030c for both uppercase and lowercase:
Scaron U+0160 ; scaron U+0161 ; Zcaron U+017d ; zcaron U+017e
U+010c ; ccaron U+010d ; Ecaron U+011a ; ecaron U+011b
Ncaron U+0147 ; ncaron U+0148 ; Rcaron U+0158 ; rcaron U+0159

What's next
Punctuation characters

Character design standards Punctuation for Latin 1
Article • 10/03/2020

This section describes characters with individual design standards for punctuation. Some
punctuation characters follow standard guidelines but the majority are designed specific
to the typeface.

Parentheses, brackets and braces
Left parentheses
Unicode: U+0028
Right parentheses
Unicode: U+0029
Left bracket
Unicode: U+005B
Right bracket
Unicode: U+005D
Left brace
Unicode: U+007B
Right brace
Unicode: U+007D
While these characters are related they do not all share exact standards for
advance widths and exact height alignments.
Advance width rule : All may share the same advance width but this is not a
requirement. The parentheses and braces are commonly on the same advance
width while the braces may require a slightly larger advance width.
Height alignment : The top height of these characters should relate to the
uppercase heights. The bottom does not generally descend as low as the
lowercase descender value. A typical bottom height for these characters is 1/2 to
3/4 the lowercase descender value.
Spacing : Visually center between uppercase H and O.

Periods, comma, and colons
Period
Unicode: U+002E
Comma
Unicode: U+002C
Colon
Unicode: U+003A
Semi colon
Unicode: U+003B
Advance width rule : All these characters should be on the same advance width.
This width is similar to the thin space width but not necessarily 1/5 the em.
Spacing: Visually center between lowercase n and o.
Language note : In French typographic usage the colon (deux-points) is preceded
by a non-breaking word space (espace mots insécable) and followed by a normal
word space. The semi-colon (point-virgule) is preceded by a non-breaking thin
space (espace fine insécable) and followed by a normal word space. In Microsoft
Word 97 the non-breaking space U+00A0 is automatically inserted when the
French language is selected and a colon or semi-colon are typed.
Period centered - bullet operator
Unicode: U+2219
Design : Same design and size as the period.
Note : In the Latin 1 code page 1252 for Windows this is the character used for
position decimal 183. This is both a centering period Math operator and a
punctuation character used in the Catalan language. With Spanish and Catalan
keyboards this character is commonly used as a mid dot to separate lowercase and
uppercase L characters that are not part of the same syllable in a word. In many
typefaces the period character maybe considered too large to be used as a mid dot
in the Catalan language and a substitute glyph for the lowercase l and uppercase L
would be more appropriate. OpenType fonts support glyph substitution.
Alignment : Vertically centers on the figure height.
Advance width : Advance width should be the same as the period width.
Spacing : This character should space between figure zeros.

Uppercase mid dot for Catalan
Unicode: none
Alignment : Vertically centers on the uppercase L height.
Design : This glyph could be used as a substitute glyph in OpenType for the
periodcentered U+2219 and or the mid dot U+00B7. Commonly the character used
for the mid dot for the Catalan language is one based on the overdot diacritic
U+02D9. It should be the same vertical and horizontal size as the mid dot in the
lowercase l and the Ldot U+013F and ldot U+0140.
Advance width : The advance width commonly is zero units and the mid dot is
centered between two uppercase L characters, and has a negative left sidebearing.
The horizontal placement should be the same as the placement of the mid dot in
the character Ldot U+013F.
Lowercase mid dot for Catalan
Unicode: none
Alignment : Vertically centers on the lowercase l height.
Design : This glyph could be used as a substitute glyph in OpenType for the
periodcentered U+2219 and or the mid dot U+00B7. Commonly the character used
for the mid dot for the Catalan language is one based on the overdot diacritic
U+02D9. It should be the same vertical and horizontal size as the mid dot in the
lowercase l and the Ldot U+013F and ldot U+0140.
Advance width : The advance width is visually set based on the horizontal size of
the mid dot and the appropriate space needed for mid dot to comfortably center
between two lowercase l characters. The advance width maybe the same as
periodcenterd U+2219. The mid dot should have the same left sidebearing as the l
catalan U+0140 character's left sidebearing and space the same when placed
between two lowercase l characters.

Ellipsis, em leader and en leader
Ellipsis, em leader
Unicode: U+2026

In the majority of modern uses these names are synonymous for a three dot
leader.
Advance width rule : The advance width should be set on the em space.
Spacing : The dots should be evenly space so when this character is repeated the
space between the dots and the space between each repetition is equal. Visually
center between lowercase n and o.
Two dot leader - en leader
Unicode: U+2025
This character is not in many code pages but is a traditional typographic leader.
Advance width rule : The advance width should be set on the en space.
Spacing : The dots should be evenly space so when this character is repeated the
space between the dots and the space between each repetition is equal. Visually
center between lowercase n and o.

Quotes
Single neutral quote
Unicode: U+0027
Double neutral quote
Unicode: U+0022
These quotes are the remnants of the dual purpose quotation marks that were
used on typewriters as opening and closing quotation marks. The angles of the
quotes are visually equivalent to the angle of the font. Which in roman faces is
upright and italics at a visually equivalent angle to the italic slope of the font.
These quotation marks are also commonly used as replacement characters for
prime U+2032 and double prime U+2033 marks. Prime and double prime marks,
also called minute and second, are used in the abbreviations for inches, feet,
minutes and seconds.
Advance width rule : The advance width of the single quote is proportional to the
design and the double quote is commonly not greater than two times the advance
width of the single quote.

Typographic quotation marks

Cute nicknames like 'smart quotes', 'fancy quotes', 'curly quotes', '66 and 99' or 'duck's
feet' are some of the terms used today to refer to these typographically specific
characters. Fonts in early letterpress typography had no quotation marks. A typographer
would use a comma, shifted or rotated as a quotation mark. It could be said these marks
are traditionally based on the comma design. These methods were inadequate and
design specific quotation marks were developed.
Right single quotation mark
Unicode: U+2019
Advance width rule : The advance width of the right single quote is the same as the
left single quote.
Height alignment : This character aligns with the uppercase height.
Single baseline quotation mark
Unicode: U+201a
Advance width rule : The advance width of the single baseline quote is the same as
the left single quote.
Height alignment : This character aligns on the baseline at similar height as the
comma.
Single high reversed quotation mark
Unicode: U+201b
This is the same character as Right single quote
Unicode: U+2019 mirrored in the horizontal direction.
Advance width rule : The advance width of the single high reversed quote is the
same as the left single quote.
Height alignment : This character aligns with the uppercase height.
Double left quotation mark
Unicode: U+201c
This character is made from the left single quote U+2018 and is equivalent to a 180
degree rotation of the double right quotation mark U+201d.
Advance width rule : The advance width of the double left quote is proportional to
the design and commonly not greater than twice the advance width of the single
quote.
Height alignment : This character aligns with the uppercase height.

Double right quotation mark
Unicode: U+201d
This character is made from the right single quote U+2018 and is equivalent to a
180 degree rotation of the double left quotation mark U+201c.
Advance width rule : The advance width of the double right quote is proportional to
the design and commonly not greater than twice the advance width of the single
quote.
Height alignment : This character aligns with the uppercase height.
Double baseline quotation mark
Unicode: U+201e
This character is commonly made by shifting the right double quote to the position
of the single baseline quote U+201d.
Advance width rule : The advance width of the double low quotation mark is the
same as the double right quote.
Height alignment : This character aligns on the baseline at similar height as the
comma and single baseline quote.

Guillemets
These quotation marks commonly called 'French quotes' or 'duck's feet' are said to have
been named after a French typecutter Guillaume (William) Le Bé. Guillemets is the
French word for quotation marks. The similarly named Guillemot is a narrow billed, sea
auk with duck like feet found in cold northern regions of the world.
These pointing quotation marks are used in many languages and point differently
dependent on the language. The German language uses these quotation marks with the
right pointing guillemets as the open quotation marks and the left pointing guillemts as
the close quotation marks. In French typography the left pointing quillemets are used as
the open quotation marks and the right pointing quillemets are the closing quotation
marks.
Traditionally in French typography the left pointing guillemets are followed by a nonbreaking word space or thin space of 1/8 the em and the right proceeded by a non-

breaking word space or thin space of 1/8 the em.
Single left pointing quillemet
Unicode: U+2039
Advance width rule : This character's advance width is proportional and the same as
the single right pointing guillemet.
Height alignment : This character aligns on the lowercase x-height at the same
vertical height as the single right guillemet.
Single right pointing quillemet
Unicode: U+203a
Advance width rule : This character's advance width is proportional and the same as
the single left pointing guillemet.
Height alignment : This character aligns on the lowercase x-height at the same
vertical height as the single left pointing guillemet.
Left pointing quillemets - guillemet ouvrant
Unicode: U+00ab
Advance width rule : This character's advance width is proportional and the same as
the right pointing guillemets.
Height alignment : This character aligns on the lowercase x-height with the same
vertical alignment as the right pointing guillemets.
Right pointing quillemets - guillemet fermant
Unicode: U+00bb
Advance width rule : This character's advance width is proportional and the same as
the left pointing guillemets.
Height alignment : This character aligns on the lowercase x-height with the same
vertical alignment as the left pointing guillemets.
Language note : In French typographic usage the left pointing guillemet - guillemet
ourvant is followed by a non-breaking word space (espace mots insécable) and the
right pointing guillemet - guillemet fermant is preceded by a non-breaking word
space. In Microsoft Word 97 the non-breaking space U+00A0 is automatically
inserted when the French language is selected and a guillemet is typed. Some
French typographers prefer to use a non-breaking thin space (espace fine
insécable) with the guillemets.

Question and exclamation marks
Question
Unicode: U+003F
Exclamation
Unicode: U+0021
Advance width rule : There is no requirement for the advance width of these
characters with the exception of the inverted question and inverted exclamation.
_These two characters should be on the same unit value as the upright _question and
exclamation, respectively and be a 180 degree rotation of the question and
exclamation marks.
Height alignment : There is no absolute requirement for top alignment of the
question and exclamation. They are typically the same in height as the uppercase
round characters. The bottom dot aligns with the lowercase overshoot in round
designs and the baseline in square designs.
Language note : In French typographic usage the question and exclamation marks
(point d'exclamation et point d'interrogation) are preceded by a non-breaking thin
space (espace fine insécable) and followed by a normal word space. In Microsoft
Word 97 the non-breaking space U+00A0 is automatically inserted when the
French language is selected and a exclamation or question mark are typed.
Inverted question
Unicode: U+00BF
Inverted exclamation
Unicode: U+00A1
The inverted question and inverted exclamation have two possible alignments.
X-height alignment : In most text fonts the inverted question and inverted
exclamation tops align with the lowercase x-height. In a round design the
lowercase x-height's overshoot. The bottom should not exceed the lowercase
descender value. In this case many type designers use an uppercase alignment
method or shorten and redesign the glyphs.

Uppercase alignment : This is a simple 180 degree rotation with no vertical offset
from the position of the question and exclamation. Used very commonly in display
fonts and modern designs.

Spacing : Visually center between uppercase H and O.

Trademark symbols and copyright sign
Registered trademark
Unicode: U+00AE
Copyright
Unicode: U+00A9
Trademark
Unicode: U+2122
Trademark symbols in traditional typography were available as a separate font of
many basic font styles and sizes. Common usage for logotypes and typesetting is
the larger the logotype or text the smaller the trademark symbol.
In modern digital typography there are three common practices used by font
suppliers. In all cases there are no italic designs only upright versions.
One standard serif design in all font files. Spaced and aligned for the current
font.
Two standard designs, one serif for serif style fonts and one sans serif for sans
serif designs. Spaced and aligned for the current font.
Designed to match the style of the typeface.
The bottom line: What should I do? It is always best for any character to match the
style of the typeface.

There are also two different styles of copyright and registered trademark symbols
provided in fonts today.
Copyright and registered trademark symbol - full size
Because of the scaling ability of digital fonts and the lower resolution of most
output devices, these are the style of symbols found in current digital fonts.
Advance width rule : They are commonly placed on the em space width.
Height alignment : Bottom aligns with the uppercase overshoot, top aligns with the
uppercase top overshoot or visually centers on the uppercase height dependent
on the typeface design.
Copyright and registered trademark symbol - superior
Typeface foundries sometimes offered a smaller raised or superior style character
as an alternate to the full size copyright and trademark symbols.
Height alignment : Top aligns with the uppercase round height.
Trademark symbol
There is no rule for the advance width of this character.
Advance width rule : In practice it is commonly placed on an appropriate width for
the design.
Height alignment : Aligns with the uppercase flat height in most designs.
Spacing : Visually center between uppercase H and O. These characters are almost
always used at the end of a word followed by a word space. It is important that the
left portion of these characters do not touch the right portion of the preceding
character. Some designers and companies test these characters with the uppercase
T.
Commercial at sign
Unicode: U+0040
There are three common practices in supplying the commercial at character by font
designers.
One standard serif design in all font files.
Two standard designs, one serif for serif style fonts and one sans serif for sans
serif designs.
Designed to match the style of the typeface.

The bottom line: What should I do? It is always best for any character to match the
style of the typeface.
Height alignment : Visually centers on the uppercase height, dependent on the
typeface design.
Spacing : Visually center between uppercase H and O.

Bullets
En bullet
This is the more commonly included bullet in most typefaces.
Advance width rule : Its advance width is generally set to the en space and is a
smaller sized bullet than the em bullet.
Height alignment : Visually centers on the lowercase uppercase height.
Em bullet
This is the large bullet sometimes chosen to be included in place of the en bullet in
some typefaces.
Advance width rule : Its advance width is generally set to the em space value.
Height alignment : Visually centers on the lowercase uppercase height.
Spacing : Visually center between uppercase H and O.

Hyphens, horizontal bars and dashes
Hyphen - minus
Unicode: U+002D
This character is the manually typed, always visible, hard hyphen inserted by an
author of text. It is not to be confused with the soft hyphen.
Soft hyphen
Unicode: U+00AD
This character is an additional hyphen character code. An application or client
determines its use and implementation. It is not the same character as a nonbreaking hyphen.

The most common use of the soft hyphen is for hyphenation in an application's
page layout. These applications use the soft hyphen for hyphenation when a line
break occurs. It is removed by the application when the text is reformatted and the
hyphenation is no longer necessary.
Currently, Web publishing is a less automated use of text layout. HTML authors are
the 'typographer' and they are responsible for formatting the text. Web browsers
do not automatically provide hyphenation as do page layout applications.
The W3C has defined the soft hyphen entity and its use by authors and clients of
HTML as:
soft hyphen = discretionary hyphen: ENTITY shy "­"
"The soft hyphen tells the user agent where a line break can occur."
In this implementation, the soft hyphen is a hidden hyphen and only displayed
when a line break occurs at a soft hyphen position.
For the full W3C definition of the soft hyphen see the hyphenation

section of the

HTML 4.0 specification.
Because of the inconsistent use and implementation of the soft hyphen, most
recommendations for manual HTML authoring are currently discouraging the use
of the soft hyphen.
Non-breaking hyphen
Unicode: U+2011
This character is similar to the character No-Break Space U+00A0.
The non-breaking hyphen _is the same as the _hyphen character with the added
functionality of providing a way to preventing a hyphenated word from being
separated by a line break.
Advance width rule : All these characters should be of the same design and on the
same advance width.
Spacing : Visually center between lowercase n and o; H and O.

The en and em dash
Design: These characters are commonly straight rules that extend the full length of the
advance width. Some type designers have designed these characters to not fill the

advance width and have a small left and right sidebearing. The full length version is the
preferred design.
The en dash is used in text solely as a replacement for a hyphen and as a replacement
for the word through (Jan-Jun) The 2-em dash is used in text setting to indicate missing
letters in a word. The 3-em dash is used to indicate an entire word missing. Being
doubled and tripled the preferred design is one that fills the advance width and
connects.
The em dash is also used in bibliographies to replace the author's name when a
repeated series of works is described. The em dash is tripled as a 3-em dash.
Example of the use of the em dash in Bibliographies.
The Pointed Palominos. 1998. I can't stand up for my saddle done let me down again.
Albuquerque, New Mexico: South Dusty Lung Records.
———, 1997. Songs of warm women, cold beer and rusty trucks. Albuquerque, New
Mexico: South Dusty Lung Records.
———, 1997. If you ever leave the light on I'll find my way home again. Dusty,
Washington: Dusty Lung Records.
———, 1962. You're rockin' my baby, so buy me a beer. Dusty, Washington: Dusty
Lung Records.
En dash
Unicode: U+2013
Height alignment : Visually centers on the lowercase x-height.
Advance width Rule : Placed on the en space of the typeface.
Em dash
Unicode: U+2014
Height alignment : Visually centers on the lowercase x-height.
Advance width rule : Placed on the em space of the typeface.
Underscore
Unicode: U+005F
Height alignment : Placed vertically to underline the uppercase characters. A good
distance is 5-10% of the em square below the baseline or ~100-200 units in a 2048
unit em.

Advance width rule : Placed on the en space of the typeface.
Spacing : This character extends the length of its advance width and should be
connecting in a continuous string of the character in both roman and italic designs.
Overscore
Unicode: U+00AF
Height alignment : Placed vertically to overstrike the uppercase characters. This is
approximately the same position as the placement of the uppercase diacritics. This
character is a copy of the underscore, commonly offset the em square value vertically.
That value is 2048 in a 2048 unit em font. This is not the same character as the lowercase
spacing macron - U+02C9.
Advance width rule : Placed on the en space of the typeface.
Spacing : This character extends the length of its advance width and should be
connecting in a continuous string of the character.

Slashes
Slash
Unicode: U+002F
Height alignment : This character's vertical alignment is design dependent.
Commonly it aligns either visually to the uppercase flat height and baseline or
extends slightly above the uppercase flat height and descends to a value not
greater than the lowercase descender.
Advance width rule : The advance width is proportional to the design of the slash.
Spacing : Horizontally centered between uppercase H and O.
Backslash
Unicode: U+005C
In italic fonts the backslash's angle is commonly more upright than in the roman
font of the typeface.

Height alignment : This character's alignment should be the same as Slash U+007C
Advance width rule : The advance width is proportional to the design.
Spacing : Horizontally centered between uppercase H and O.

Vertical rules and bars
These characters were used on computer systems defined as, used to create vertical
continuous or dashed lines. Current use is to separate text or as a computer
programming operator for 'or'.

if (myFont > yourFont || (yourFont == "Courier New")
{ getNewFont() }

Vertical bar
Unicode: U+007C
Broken vertical bar
Unicode: U+00A6
Height alignment : There is no general rule in current usage of these characters.
Common height alignments are:
Vertically aligns with ascender and descender.
Vertically aligns with uppercase and the baseline.
Vertically aligns so the bar connects vertically when the document is set solid
with no leading. For this character to connect when set with no leading the top
would have to be equal to the highest character (often the 'Aring') and the
bottom equal to the lowest character (often the 'Ccedilla'). These highest and
lowest characters are used in TrueType for the WinAscent and WinDescent in
the 'OS/2' table. They are also used to calculate the values in the 'VDMX' table.
Both these tables in Microsoft Windows define the vertical cell height. See the
TrueType Specification for more information about these tables.
The bottom line: What should I do? Modern usage of vertical rules on personal
computers suggests there is no need for this character to be a connecting vertical
rule character. Unicode characters U+2500..U+256C are line drawing characters
and better suited for this task. Also most page layout programs provide horizontal
and vertical rule capability.

The alignment for this character would be best if it is in the body height of the
typeface and be approximately the height of the lowercase ascender and the
depth of the lowercase descender.
Advance width rule : Placed on the en space of the typeface.
Spacing : Horizontally centered between figure zeros.

What's next
Monetary characters

Character design standards - Monetary
characters for Latin 1
Article • 06/09/2022

This section covers monetary symbols for countries/regions supported by the Latin 1
code page. All these characters are primarily used with numerals and should align, space
and work well with the numerals.
It may not be always possible for all monetary symbols to vertically align and have
advance widths equal to the figures. In fonts with proportionally spaced figures the
monetary symbols should be proportional. Meaning symbols that do not comfortably fit
on a figure width should be made larger or smaller to compensate for the width of the
image. Fonts with tabular figures should have monetary symbols that are tabular so
when they are used for monetary amounts in columns or spreadsheets the data will
align.
Dollar
Unicode: U+0024
Design : Its actual design origins are unknown but most scholars believe it to be
derived for the Spanish peso of the 1700s. The myth that the double barred
version 'escudo' is derived from the overlapping of 'U' and 'S' has been proven to
be a clever repeated mistruth with no historical basis.
Alignment : Visually aligns with figure height, actual distance of the top of the 'S'
portion of the dollar is usually lower than the figure top overshoot and/or figure
bottom overshoot.
Advance width : Advance width should be the same as the figure space width.
Spacing : This character should space between figure zeros.

Cent
Unicode: U+00A2
Alignment : Most designs are made from the lowercase 'c' and align with the
lowercase overshoots top and bottom or visually center on the figure height. These
two alignments are equally common.

Advance width : Advance width should be the same as the figure space width.
Spacing : Spaces between figure zeros.
Pound sterling
Unicode: U+00A3
Alignment : Aligns with the figure heights.

Advance width : Advance width should be the same as the figure space width.
Spacing : This character should space between figure zeros.

Currency symbol
Unicode: U+00A4
Design : The weight of the symbol should match the weight of the font. As an
example, the regular weight font should have a lighter version of the symbol than
the bold weight.

Alignment : Visually centers on the figure height.

Advance width : Advance width should be the same as the figure space width.
Spacing : This character should space between figure zeros.

Yen
Unicode: U+00A5
Design : Current design tastes do not accept the style used prior to the 1980's.
These earlier designs with two bars crossing at the middle stem, well below the
junction of the top diagonal strokes are now considered incorrect.
Today the most common Yen designs are with two or one bar crossing through the
'Y' of the yen. The one bar design is more rare. With two bars the top bar crosses
through at the junction of the top diagonal strokes while the lower bar crosses
through the main stem. With one bar the placement is slightly lower just under the
junction of the diagonals.

Alignment : Aligns with the figure flat height and baseline.
Advance width : Advance width should be the same as the figure space width.
Spacing : This character should space between figure zeros.
Florin currency symbol (Dutch)
Unicode: U+0192
Design : This character's design is commonly based on the italic lowercase f design
of the typeface.
Alignment : Aligns with the lowercase ascender height and lowercase descender
and it is dependent on the design of the typeface.
Advance width : Advance width should be the same as the figure space width.
Spacing : Spaces between figure zeros.
Franc
Unicode: U+20A3
Design : There are three common types of designs from the Franc. Type companies
have been supplying an 'F' with small 'r' design or an 'F' with a horizontal bar.
Common usage in France is to use an uppercase or superior F to represent the
French Franc.

Alignment : Aligns with the uppercase flat height.
Advance width : Advance width should be the same as the figure space width.
Spacing : Spaces between figure zeros.
Lira
Unicode: U+20A4
Design : The Lira is of the same basic design as the Pound Sterling but with two
horizontal bars instead of one.

Alignment : Aligns with the figure heights.
Advance width : Advance width should be the same as the figure space width.
Spacing : This character should space between figure zeros.
Peseta
Unicode: U+20A7
Design : Similarly to the French Franc the Spanish Peseta has two possible forms.
One is an uppercase 'P' with a horizontal bar traveling through the upper bowl of
the 'P'. The second and most common design supplied in fonts is the 'Pts' form of
a ligature made from the uppercase 'P' lowercase 't' and lowercase 's'.

Alignment : Aligns with the uppercase flat height.
Advance width : Advance width should be the same as the figure space width when
the design allows. Otherwise the 'P' and 'Pts' form widths are proportional to the

design.
Spacing : This character should space between figure zeros.

Euro
Unicode: U+20AC
Design : All well designed images in a font should match the style, weight and look
of the host font. The European Union has shown exact specifications for their
standard design of this character. Type designers have unanimously agreed that
this is a character and not a logo. And for it to be included in their font, its design
should be consistent with the typeface and have the same requirements as other
monetary symbols.
Alignment : Aligns with the figure overshoot heights or uppercase height.
Advance width : Advance width should be proportional to the design or equal to
the figure space when used with tabular figures.
Spacing : This character should space between figure zeros.

What's next
Math symbols

Character design standards - Math
symbols for Latin 1
Article • 06/09/2022

This section covers math symbols supported by the Latin 1 code page. The characters
that are less commonly used in text mathematical symbols and line drawing symbols are
covered in the Symbol design section of this specification.
All math symbols are primarily used with numerals and should align, space and work
well with the numerals. Many of them share the same advance width, particularly math
operators. Traditionally math signs were not part of the standard font set. Math signs
also traditionally are only upright. Some designers are creating and arguing about the
need for italic math operators.

Math symbols advance width
Advance width is proportional to the typeface and the numeral design. Traditionally
larger than the figure space width in most regular width fonts. It is common for type
designers to make the math widths equal to the figure width. In some typefaces with
larger numerals the math signs advance widths are smaller. Example Adobe Minion is
overall a medium width typeface and its figure width is 944 units and its math widths are
1272 units. The em is 2000 units. Bookman Old Style's has very wide numerals and the
figure width is 1270 and the math width is 1229. The em is 2048 units.
Plus sign
Unicode: U+002B
Alignment : Traditionally placed slightly lower than center on the figure height.
Often on the baseline.
Advance width : Advance width should be the same as the figure space width.
Spacing : This character should space between figure zeros.
Minus
Unicode: U+2212

Alignment : Vertically centers on the plus sign.
Advance width : Advance width should be the same as the figure space width.
Spacing : This character should space between figure zeros.
Equals
Unicode: U+003D
Alignment : Vertically centers on the plus sign.
Advance width : Advance width should be the same as the figure space width.
Spacing : This character should space between figure zeros.
Not equal
Unicode: U+2260
Design : The design is based on the equals and should be the same horizontal
length, vertical height and stem thickness as the equals.
Alignment : Vertically centers on the plus sign with the same alignment as the
equals.
Advance width : Advance width should be the same as the figure space width.
Spacing : This character should space between figure zeros.
Less than
Unicode: U+003C
Greater than
Unicode: U+003E
Alignment : Traditionally placed slightly lower than center on the figure height and
centering on the plus sign. Often the lowest point is on the baseline.
Advance width : Advance width should be the same as the figure space width.
Spacing : This character should space between figure zeros.
Less than or equal
Unicode: U+2264
Alignment : Traditionally placed slightly lower than center on the figure height and
centering on the plus sign. The bar should align with Greater Than or Equal
character and PlusMinus character bars. Often the bar is also on the baseline.

Advance width : Advance width should be the same as the figure space width.
Spacing : This character should space between figure zeros.
Greater than or equal
Unicode: U+2265
Alignment : Traditionally placed slightly lower than center on the figure height and
centering on the plus sign. The bar should align with Less Than or Equal character
and PlusMinus character bars. Often the bar is also on the baseline.
Advance width : Advance width should be the same as the figure space width.
Spacing : This character should space between figure zeros.
Plus minus
Unicode: U+00B1
Design : Lower minus bar aligns with Greater Than or Equals and Less Than or
Equals bar. Not necessarily on the baseline and the plus sign does not necessarily
connect with the minus in all fonts.
Alignment : Bottom minus bar aligns with the Greater Than or Equals and Less Than
or Equals bar and vertically visually centered on the plus sign.
Advance width : Advance width should be the same as the figure space width.
Spacing : This character should space between figure zeros.

Multiply
Unicode: U+00D7
Alignment : Vertically centers on the plus sign.
Advance width : Advance width should be the same as the figure space width.
Spacing : This character should space between figure zeros.
Period centered - bullet operator
Unicode: U+2219
Note : In the Latin 1 code page 1252 for Windows this is the character used for
position decimal 183. This is both a Math operator and centering period

punctuation character used in the Catalan language. With the Catalan and Spanish
keyboards this character is commonly used as a mid dot to separate lowercase and
uppercase L characters that are not part of the same syllable in a word. In many
typefaces the period character maybe considered too large to be used as a mid dot
in the Catalan language and a substitute glyph for the lowercase l and uppercase L
would be more appropriate. OpenType fonts support glyph substitution.
Design : Same design and size as the period.
Alignment : Vertically centers on the figure height.
Advance width : Advance width should be the same as the period width.
Spacing : This character should space between figure zeros.

ASCII tilde
Unicode: U+007E
Design : This character is used in mathematics as an operator for 'is proportional or
similar to'. This character is also commonly used in text as a sign of approximation.
The double tilde U+2248 is the correct mathematical operator for ' is approximately
equal to'.
Example of common usage : One inch is ~72 point in traditonal typography.
This is not the same design and character as the lowercase spacing tilde diacritic.
Alignment : Vertically centers on the plus sign.
Advance width : Advance width should be the same as the figure space width.
Spacing : This character should space between figure zeros.
ASCII circumflex
Unicode: U+005E
This character, often called a 'caret' is used in mathematical expressions for
exponents.
The expression 2^5 is read 'two to the power of five'.

It is also used by some computer programming languages as a symbol. In Pascal
and Modula-2 it is used to signify a pointer to a variable.
This is not the same design and character as the lowercase spacing circumflex
diacritic.
Alignment : Aligns to the figure height
Advance width : Advance width should be the same as the figure space width.
Spacing : This character should space between figure zeros.

Degree
Unicode: U+00B0
Alignment : Aligns to the figure height overshoot
Advance width : Advance width should be the same as the figure space width.
Spacing : This character should space between figure zeros.
Logical not
Unicode: U+00AC
This character is used in mathematical expressions as a sign of negation.
Design : Horizontal length is the same as the horizontal length of the plus sign.
Vertical stem is the same length and thickness as the plus vertical strokes. Design
of the strokes is the same as the plus sign.
Alignment : Vertically centers in some designs on the plus sign or others on the
figure height.
Advance width : Advance width should be the same as the figure space width.
Spacing : This character should space between figure zeros.

Approximately equal
Unicode: U+2248
Alignment : Vertically centers on the plus sign.
Advance width : Advance width should be the same as the figure space width.
Spacing : This character should space between figure zeros.

Micro sign
Unicode: U+00b5
Design : This character's design is commonly the same as the lowercase Greek mu
U+03BC based on the lowercase u.
Alignment : Aligns with the lowercase x-height and the lowercase u.
Advance width : Advance width is commonly the same as the lowercase u and is
sometimes adjusted on the left side dependent on the design.
Spacing : This character should space between figure zeros.

What's next
Symbol

Character design standards - Symbol
characters for Latin 1
Article • 06/09/2022

This section is in two parts. The first section is for symbol characters found in the
Macintosh character set. The second section is for symbols found in many mathematics
and symbol based PC code pages.

Spacing
All symbol characters are used with numerals or mathematical formulas and should
space well between figure zeros.

Symbols for the Macintosh standard character
set
Previous to TrueType fonts these symbols were only present in a PostScript symbol font
in ROM on Macintosh printers and as screen bitmaps in the Macintosh font 'suitcase'.
The characters from the regular weight Times Roman font were used for all fonts. As
TrueType fonts were developed many font companies continued this practice and
included only one design based on a Times family in all their fonts. PC font formats used
a similar method of using a universal font for math symbols but expanded the selection
of glyphs to include some sans serif and bold characters to better match the current
font.
The following characters are part of the Macintosh Standard Character Set.
Product
Unicode: U+220F
Design : This character is similar in design to the uppercase Greek Pi U+03A0 with
the exception of the overall vertical alignment.
Alignment : The bottom of the Product aligns with the Summation U+2211 that
descends below the baseline commonly 1/2 to 3/4 of the lowercase descender.
The top aligns with the uppercase flat height.
Advance width : The Advance width is proportional to the design.

Lowercase Greek pi
Unicode: U+03C0
Design : The Macintosh Standard Character Set includes this character in the
Macintosh 'cmap' table (platform ID 1 encoding ID 0 at position xB9). Some
TrueType fonts that do not contain support for the Greek language have used the
Unicode value in the private use area instead of the lowercase Greek pi Unicode
value.
Advance width : The Advance width is the same as the Greek lowercase pi U+03C0
or proportional to the design.
Integral
Unicode: U+222B
Advance width : The Advance width is proportional to the design.
Alignment : Commonly the integral aligns to approximately the height of the
lowercase ascender and descender.
Ohm
Unicode: U+2126
Design : This character is commonly the same as the uppercase Greek Omega
U+03A9.
Advance width : The Advance width is commonly the same as the uppercase Greek
Omega U+03A9 or proportional to the design.
Increment
Unicode: U+2206
Design : This character is the same design as the uppercase Greek Delta U+0394.
Advance width : The Advance width is commonly the same as the uppercase Greek
Delta or proportional to the design.
Summation
Unicode: U+2211
Design : This character is the similar in design to the uppercase Greek Sigma
U+03A3 with the exception of the overall vertical alignment.
Alignment : The bottom of the summation aligns with the Product U+220F that
descends below the baseline commonly 1/2 to 3/4 of the lowercase descender.
The top aligns with the uppercase flat height.

Advance width : The Advance width is proportional to the design.
Lozenge
Unicode: U+25CA
Design : This is an open diamond shaped character that is commonly threequarters of the uppercase height with the strokes being monoline.
Advance width : The Advance width is proportional to the design.
Alignment : This symbol commonly sits on the baseline.

Additional symbols in PC code pages
Unicode characters U+2190 through U+266B
Characters in this range are commonly referred to as 'universal math and symbol
characters'. Many of these characters in this range are resident in the original set of
Microsoft Windows core fonts Times New Roman, Arial and Courier New and most
printer resident font formats. In these Microsoft core fonts all symbols are designed
specifically to match the style of the host font or typeface family.
Estimated
Unicode: U+212E
Design : This character could be considered a logotype. It is used in Europe for
product packaging to show the estimated volume of the product. Its design is a
standardised shape of a sans serif _lowercase e _with straight inner contours.

Alignment : This symbol varies in size but sits on the baseline in all designs.
Advance width : The Advance width is proportional to the design.
Single prime mark
Unicode: U+2032
Double prime mark
Unicode: U+2033
Prime and double prime marks, also called minute and second, are used in the
abbreviations for inches, feet, minutes and seconds. The angle of these characters
is commonly a slight italic angle of approximately 75..80 degrees on both roman

and italic fonts. Perfectly vertical is considered 90 degrees. The single neutral quote
U+0027 and double neutral quote U+0022 are often used as substitutes or
equivalents for these two characters.
Advance width rule : The advance width of the single prime mark is proportional to
the design and the double prime mark is commonly not greater than two times the
advance width of the single prime mark.
Numero mark
Unicode: U+2116
The numero mark resides in Unicode in the section 'Letterlike Symbols'. It is used in
several languages as an abbreviation for the word number. It is a very commonly
used abbreviation in the French language and it is almost always typed manually
with either an uppercase N or lowercase n and a degree symbol.
Example: _the common French abbreviation for the word _Number would be N° and
number would be n°.
The numero is also used in the Cyrillic code page 1251 for Microsoft Windows at
position alt-0185 (xB9).
Advance width rule : The advance width of the numero is proportional to the
design.

OpenType font variations
Article • 11/13/2021

Ask any graphic designer: The key to communicating your ideas concisely and effectively
is good typography. Designers make use of a variety of font weights and styles to make
your message stand out clearly. The problem has been that all those weights and styles
—bold, semibold, regular, display, caption—are separate font files, which increases
application size and slows down web page load times, especially on mobile phones.
OpenType Font Variations provide all the weights and styles of a full font family in a
single, compact file to improve applications size and web site responsiveness.
A variable font file supports more than typical font instances like bold and condensed: it
also can generate a smooth continuum of styles between them (e.g. semi-semi-bold, or
very-slightly-condensed). This great variety makes possible a number of responsive
typography features that can produce really polished layouts. Web sites can make fine
adjustments font width to fit headlines to column widths without wrapping or ugly
whitespace; applications can adjust fonts to match the pixel density of devices, creating
an excellent looking design from low resolution monitors to smartphones. In his article
on responsive typography

, Nick Sherman has described many other scenarios in

which variable fonts could help.
OpenType Font Variations marries the font variations technology created by Apple for
QuickDraw GX with the richness OpenType, including its advanced layout capabilities of
OpenType Layout and the choice of outline formats. A variable font contains three main
components: Each font file contains a single set of outlines that forms the basis for the
typeface family. It also includes a set of design axes, such as weight, width, optical size,
or more, to describe the ways that the font family varies. Finally, it includes a set of
deltas that describe how the outline shapes, kerning, mark positioning, and metrics
change across those axes. When applications or web sites use a variable font, they
choose a particular style within the ranges of the design axes, and the operating system
will apply the appropriate deltas and OpenType substitutions to create an ephemeral,
virtual font for rendering text in that style. A variable font can also provide a set of predefined styles, called named instances, which will surface just like traditional static fonts
in operating systems that support variable fonts.
John Hudson has written an excellent article with more details of the mechanics of
variable fonts . The specification of OpenType Variations is available in version 1.8 (or
later) of the OpenType specification.
Variable fonts are supported by current versions of Windows, MacOS, and Android, as
well as all major web browsers. Windows currently includes the variable font Bahnschrift,

and more will be coming in future releases.
Microsoft and its collaborators hope that OpenType Font Variations will create a new
font platform on which developers and designers can create a new level of typographic
richness while also providing better solutions for their customers.

Related articles
Video: OpenType variations launch at AtypI 2016

Windows glyph processing for
OpenType fonts, part 1
Article • 11/17/2020

This article was written for Microsoft by John Hudson, and originally published in 2000.
Since it is now more than twenty years old, some of the information may be either out-ofdate or incomplete in terms of describing current Windows glyph processing. The article
describes the infrastructure in place prior to the DirectWrite platform that is now
responsible for much of the text layout and display in Windows and does not take into
account other platforms such as that used by recent versions of the Edge browser. The
basic principles of OpenType Layout and shaping engine interaction described in the
article remain relevant.
In a relatively simple digital font architecture, as typified by the original TrueType format
developed at Apple Computers, there is a one-to-one relationship between an encoded
character and the glyph that represents it. Systems and applications that make use of
such fonts do not need to make a distinction between character processing and glyph
processing. In working with such fonts, it is most often convenient to think only in terms
of character processing, or simply text processing: that is, the sequential rendering of
glyphs representing character codes as input in logical order. When applications have
needed to provide more complicated text processing for complex scripts [1] or
sophisticated typography, they have generally made use of proprietary engines to shape
text based on custom character sets, or have obliged users to resort to font switching to
access variant glyph forms. The idiosyncratic nature of these solutions frequently results
in text that cannot be exchanged outside of particular systems and applications.
(The term “complex script” refers to any writing system that requires some degree of
character reordering and/or glyph processing to display, print or edit. In other words,
scripts for which Unicode logical order and nominal glyph rendering of codepoints do
not result in acceptable text. Such scripts, examples of which are Arabic and the
numerous Indic scripts descended from the Brahmi writing system, are generally
identifiable by their morphographic characteristics: the changing of the shape or
position of glyphs as determined by their relationship to each other. It should be noted
that such processing is not optional, but is essential to correctly rendering text in these
scripts. Additional glyph processing to render appropriately sophisticated typography
may be desirable beyond the minimum required to make the text readable.)
The wide adoption of the Unicode Standard for character encoding provides a means to
make text interchangeable across different systems and between applications that
implement the standard. The Unicode Standard is strictly concerned with character

processing, and presumes that Unicode text strings will be input and stored in a simple
sequence defined as “logical order”. The Unicode Standard also presumes the existence
of rendering systems above the Unicode text string that will, as necessary, reorder
codepoints and affect sophisticated glyph processing to shape the rendering of the text
through glyph substitution and positioning features. This article introduces the different
elements of the Microsoft Windows implementation of Unicode character and glyph
processing, and explains how they can be used by font and application developers to
provide users with sophisticated typographic controls and the ability to process text in
complex scripts.
(For more information about the Unicode Standard and the work of the Unicode
Consortium and its technical committees, see www.unicode.org

.)

This article explains three principal elements of Windows technology and their
interaction: the OpenType font format, the Windows Unicode Script Processor
(Uniscribe), and the OpenType Layout Services library (OTLS). The first part of the article
provides an overview of Windows glyph processing, explaining the role of each of these
elements and demonstrating how they render a sample string of complex script text.
The second part of the article covers each of these elements in greater detail, explaining
some of the internal workings of font tables, Uniscribe script shaping engines, and the
interaction of OTLS with client applications. The audience for this article includes type
designers and font vendors, software engineers and application developers. These
groups do not always speak the same language, so I have tried to provide concise
definitions, in the notes, of terminology that may be confusing for some readers; these
and other notes are indicated in the text by bracketed numbers. One person’s daily
vocabulary is another’s impenetrable jargon, and not all type designers are comfortable
with terms such as API and DLL that are common currency among software engineers.
Likewise, most engineers are likely to scratch their heads when typographers start
speaking of nuts and mutton.

Overview
As mentioned in the introduction, some writing systems in the world require processing
of both characters and glyphs beyond logical order input. Looking at the problems and
solutions of system, application and font support for these complex scripts is a good
place to start in discussing Windows glyph processing. The demands of these scripts
require all the features of character string processing and glyph substitution and
positioning that are available through OpenType, Uniscribe and OTLS. In addition,
because glyph processing is an absolute requirement of their rendering, complex scripts
demand the attention of developers hoping to produce fonts and software for the
significant markets that use them. I will discuss later, in the conclusion of this article, why

sophisticated typographic controls for non-complex scripts should not be treated as
secondary to complex script support or necessarily of a lower priority. It is likely,
however, that many application developers will first encounter system components like
Uniscribe and libraries like OTLS during internationalization development involving
complex scripts.
It is important to point out, at the beginning of this overview, that the Windows glyph
processing model does not force particular solutions on application developers,
although it does expect certain things. For example, applications are responsible for
storing backing strings of text codepoints, for buffering them when necessary for line
justification and breaking (this is particularly crucial for complex scripts), and for all
aspects of memory management. Applications are entirely free to choose how to
present layout features to users, and free to select which features to support. It should
be noted that all the line layout, character reordering and glyph substitution and
positioning features discussed in this article can be implemented entirely at the
application level, or across application suites, using private code and DLLs. [3] However,
this requires major investments in code writing and maintenance, and in understanding
implementation of individual scripts with very complex requirements. This article focuses
on how developers can insulate themselves from script support issues and from much of
the nuts and bolts of glyph processing by using the Uniscribe APIs and helper functions
in the OTLS library. It always remains possible for client applications to override or
supplement Windows glyph processing.

OpenType fonts
We will begin our overview by looking at the font format, OpenType. All the information
controlling the substitution and relative positioning of glyphs during glyph processing is
contained within the font itself. This information is defined in OpenType Layout (OTL)
features that are, in turn, associated with specific scripts and language systems. Placing
control of glyph substitution and positioning directly in the font puts a great deal of
responsibility for the success of complicated glyph processing on the shoulders of type
designers and font developers, but since the work involves making decisions about the
appearance of text, this is the correct place for the responsibility to land. OpenType font
developers enjoy a great deal of freedom in defining what features are suitable to a
particular typeface design, but they remain dependent on application support to make
those features accessible to users. As we shall see, in the case of complex scripts
requiring the presence of specific OTL features for correct shaping, it is very important
that font developers ensure that the feature lookups they define meet the expectations
of other elements of Windows glyph processing technology, particularly Uniscribe.

The OpenType font format is discussed in more depth later, but two internal tables need
to be introduced now. These are the GSUB and GPOS tables that contain instructions
for, respectively, glyph substitution and glyph positioning. Glyph substitution involves
replacing one or more glyphs with one or more different glyphs representing the same
text string. The backing string of Unicode characters is not changed; only the visual
presentation is changed. These substitutions may be required (as part of script
rendering), recommended as default behavior, or activated at the discretion of the user;
they may also be contextual, active only when preceded or followed by a certain glyph
or sequence of glyphs, or contextually chained so that one substitution affects another.
In the first of the following simple examples, substitutions are made by activating the
“Standard Ligatures” OTL feature in a line of Latin script text. This replaces colliding
letter combinations with ligatured forms: a better solution than adding space between
the colliding glyphs that would result in gaping wounds in the middle of words. This
font also contains a ligature for the frequent Th combination that reduces the amount of
white space between the T and the h.

In this second example, a user has chosen to activate the “Discretionary Ligatures”
feature to replace the ct letter combination with a decorative, historical ligature. This
flamboyant typographer has also used the “Swash” feature to replace the initial Th
ligature with a more calligraphic form, replace the y with a subtly swung form, and
substitute corsiva versions of h and l.
(Swash letters are stylised, flourished variants of their staid typographic cousins,
generally found accompanying italic fonts but occasionally in romans. They are at home
in the major European scripts—Latin, Cyrillic and Greek—but have relatives around the
world. The term corsiva literally means cursive, a word that is often applied to any type

style that displays some aspects of a handwritten model. In this instance it is used, as it
was by renaissance scribes, to distinguish the informal flowing style of ascender from
the more carefully formed formata seen in the first example.)

None of these changes requires any font switching, because all the variant glyphs are
included in a single italic font. Because all substitutions take place at the glyph level,
rather than at the character level, the text string remains unchanged and can be
selected, copied and pasted between Unicode savvy programs without semantic
damage.
Features associated with the GPOS table shift glyphs from their normative positions and
reposition them relative to each other. This is particularly useful for complex scripts in
which graphic elements change position contextually, or in which quality typographic or
manuscript tradition demands that two or more glyphs maintain a particular relationship
when one or more of them are adjusted. For instance, GPOS lookups can be used to
control the precise positioning of matras (vowel markers) in Indic scripts relative to base
consonants or conjuncts, and can then adjust the position of other markers above and
below the syllable to avoid collisions. The conjuncts themselves will have been rendered
using GSUB lookups, and this is a good example of how GSUB and GPOS features work
together to provide sophisticated solutions for complex script rendering.
In the following Latin script example, two quite simple GPOS features—“Case-Sensitive
Forms” and “Capital Spacing”—are applied to the Spanish and English text when it is
converted to an all uppercase setting.

In the mixed upper and lowercase setting above, the dot of the initial inverted question
mark is vertically aligned with the x-height of the lowercase letters and descends below
the baseline. Likewise, the parentheses around the English text are optically aligned with
the mix of letter cases. In the image below, the same text has been set in all uppercase
letters, and the two GPOS features have been applied. The “Case-Sensitive Forms”

feature has raised the inverted question mark to align with the capital letters, and has
slightly raised the parentheses so that they vertically align with the new setting.

The third line allows direct comparison of the adjusted glyph positions to the normative
vertical positioning. The light grey glyphs are in normative positions; the red glyphs
show the new positions after the “Case-Sensitive Forms” feature has been applied. It
should also be noted that the same effect could have been achieved using GSUB
lookups to replace the normative glyphs with glyphs in new positions; in fact, the
registered definition of the “Case-Sensitive Forms” feature explicitly notes that either
solution is legitimate.
The second GPOS feature applied in the above example—“Capital Spacing”—is a metrics
adjustment feature that increases the normal spacing between letters to make
uppercase settings easier to read. These two features together are a good example of
something that an application might choose to present to users as a single UI choice,
associating both with an “All Caps” option that uses Unicode case mapping to switch
between lower and uppercase. An application might leave it to the user to select and
apply these kind of case sensitive features to text, or it might use heuristics to identify
words and phrases that the user has set in uppercase and apply the features
automatically.
Both the features demonstrated above are examples of GPOS lookups that adjust the
position of glyphs relative to their normative positions. It is also possible to adjust glyph
positions relative to specific elements of other glyphs, and this is discussed in more
detail later.

OpenType Layout Services
The OpenType font format is the central element of the Windows glyph processing
model. The OpenType Layout Services library (OTLS), on the other hand, is not essential,
but it has great benefits to application developers who need to support glyph
processing but want to be insulated from details of the font file format. OTLS allows
client applications to concentrate on those aspects of text processing with which they
are familiar—character handling and presentation of formatting features to users—by
using OTLS to handle the unfamiliar details of lookup tables and glyph IDs.

The OTLS library is a set of helper functions that serve a text processing client by
retrieving information from fonts and guiding the operating system in rendering text.
The client and OTLS work together to layout text, using some, all or none of the
OpenType Layout features defined within a font, as decided by the application
developer. The client can use OTLS functions to query a font about what layout feature it
supports and with what script and language systems they are associated. Using this
information, the client can implement required features for specific scripts and present
other features to users. An application may tightly integrate specific features into its UI,
associating one or more OpenType features with formatting options—as suggested in
the GPOS example earlier—, or may present the features dynamically as they are
returned from individual fonts.
Many of the OTLS functions need to be applied to “runs” of text, and one of the basic
responsibilities of a client using OTLS is the ability to parse and tag runs. A run is
normally a maximum of one line in length and consists of a text string formatted in a
single font at a particular size, in a single direction, in a particular script and a particular
language system. Obviously, in many documents, the majority of consecutive runs of
text will simply equate to individual lines. In multilingual documents, however, a client
may need to be able to identify and tag a number of runs within a single line of text. In
the example below, two lines of bilingual text need to be separated into eight runs. At
the top of the illustration, the two lines appear with formatting; below this, the same
lines appear as Unicode plain text, with the formatting runs indicated in red. Lastly, the
Unicode codepoints stored by the application are shown, also with runs marked in red,
which makes clear exactly where one run ends and another begins (punctuation
characters are dark grey, and space characters are light grey).

(This example is adapted from the chapter on Arabic typesetting in Théotiste Lefevre’s
Guide Pratique du Compositeur et de L’Imprimeur Typographes. The business of
complex script and multilingual typography is not new, nor was it in the 1870s when this
book was first published. If anything, digital typography is only just beginning to catch
up with its analogue history.)
In this example, there are three types of run boundary, indicated by the small red letters:
a. Change of font (bold to roman, roman to italic, italic to roman).
b. Change of script, language system and direction. Any one of these changes is
sufficient to require the start of a new run. In many multilingual texts, a change of
script might also occasion a change in font, but for this example we will presume
that this is a multiscript font with both Latin and Arabic support.
c. End of line (the end of the first line is also a change in script, language system
and direction, because the second line starts with an Arabic character).
When runs have been identified and tagged, OTLS text layout functions can be used to
implement glyph substitution and glyph positioning in individual runs. OpenType
features are never applied across run boundaries; the run is the basic element to which

glyph processing is applied, although, for complex scripts, it is necessary to further
divide the run into smaller segments (see “Uniscribe” below).
OTLS is designed to expose the full functionality of OpenType fonts to an application, so
it is a powerful assistant in implementing support for even the most complicated
aspects of Windows glyph processing: for instance, GSUB layout features that are
designed to present the user with a choice of variant glyphs. OTLS supports these
features by enabling clients to specify features with parameters to enumerate possible
substitutions. In response to, for example, a user’s application of the “Stylistic Alternates”
feature (using GSUB lookup type 3, replacing one glyph with one of many), the
application would call OTLS repeatedly until the possible parameters for that feature—
i.e. the number of possible glyphs to be substituted—were exhausted. The application
would record the resulting glyph alternates and present them to the user. In the image
below, a user wants to replace a particular occurrence of the letter e with a stylistic
variant. The application has called OTLS to query the font, and has found that there are
eight variant glyphs available (including the normative glyph); these variants are
presented to the user in a simple pop-up menu.

In addition to parsing and tagging runs, an OTLS client remains responsible for line
breaking, layout direction and justification, and for memory allocation. The internal
structure of the OTLS library and details of the various helper functions are explained
later.

Uniscribe
Uniscribe—the Windows Unicode Script Processor, to give it its full name—is a
collection of APIs and shaping engines that enable text layout clients to format complex
scripts.
(API is an abbreviation for Application Programming Interface. An API is a function, or
set of functions, that applications use to take advantage of system components. For
example, amost all Windows applications that process plain text use the common
TextOut or ExtTextOut system APIs to draw text.)

The Uniscribe DLL (USP10.DLL) currently ships with Windows 2000 and with Internet
Explorer 5.0+. After the release of Windows Xp, later in 2001, Uniscribe will be made
available via the Microsoft Developer Network (MSDN), which will allow for more
frequent updates supporting new scripts and languages. Although Uniscribe is of
greatest benefit under Windows 2000, where it can take advantage of input method
support for Arabic and Indic languages, it can also be used in Windows NT4, 98 and 95
to view and print Unicode text for complex scripts. The Uniscribe APIs include a core set
of ScriptString functions similar to the familiar TextOut for plain text clients, with
advanced caret placement, and functions that prepare complex scripts for shaping in the
Uniscribe engines.
Each of the shaping engines in Uniscribe contains the shaping knowledge for a
particular script or closely related group of scripts. This shaping knowledge focuses on
the basic element of each script, which will vary depending on the nature of the writing
system. In the Indic scripts, for example, the basic element that needs to be processed is
the syllable; in the Arabic script the basic element is always a pair of letters, with the
second letter of a pair becoming the first letter of the next. Uniscribe analyses and
prepares strings of Unicode text by breaking runs—i.e. strings of text in a single script
with uniform formatting—into clusters corresponding to the basic element for that
script. The kind of character preprocessing that some complex scripts require—
reordering of certain characters in the string, for example—are detailed in the Unicode
Standard. Character preprocessing takes logical order text as supplied by the client, and
outputs it in a form that can take efficient advantage of glyph processing. Once this preprocessing is complete, Uniscribe takes advantage of OpenType Layout Services to
render complex scripts, activating specific layout features based on cluster analysis.
Uniscribe is an OTLS client, using the library functions to apply specific OpenType Layout
features that are required to correctly render complex scripts. This does not preclude an
application that uses Uniscribe from also being an OTLS client itself. Applications may
use Uniscribe for basic rendering of complex script text, but interact with OTLS directly
to offer users additional discretionary typographic features, such as stylistic variant
forms. These discretionary features would be enabled by applying OpenType Layout
lookups to the GIDs received from Uniscribe.
In the following example, we will follow the progress of a short piece of complex script
text as it makes its way from input to rendering. The focus will be on what happens to
the text within Uniscribe. The sample text is a single word in the Sanskrit language, as
written in the Devanagari script. It is a long, compound word that exhibits many of the
character pre-processing and OTL feature requirements of Indic scripts. The word is
extracted from a short sentence in the Aitreyopanishad; the sample word is indicated in
red and transliterated below. [7]

(The Aitreyopanishad or Aitareya Upanishad is one of the classical Hindu spiritual texts
collectively known as the Upanishads.)
Note: in this example, the Sanskrit text is displayed in the Microsoft Devanagari UI font,
Mangal. This is not an ideal font for classical Sanskrit, being somewhat simplified and
with a limited set of ligatured conjunct forms, but it has the benefit of being well hinted
for low resolution which will make the illustrations easier to follow.
Here are the characters in the backing string for our sample word, as input by the user
using the Windows 2000 Sanskrit keyboard. Beneath it are the codepoints stored by the
application in logical order.

Because we are dealing with a single word, using a single font at a single size, our
sample constitutes a run of text, as understood by both Uniscribe and OTLS. The first
task of the Indic script shaping engine is to break the run into clusters. As mentioned
above, the basic element of script processing for Indic scripts is the syllable, so the result
of this operation will be separation of our word into syllables. The script shaping engine
makes use of Unicode character properties to identify the different types of characters in
the run, and its own knowledge of the possible relationships of these characters to
identify syllable boundaries. Here are the characters, still in logical order, separated into
clusters as indicated by the blue bars.

Once the run is separated into clusters, the shaping engine analyses each cluster to
determine if any character reordering is necessary. The rules for character processing in
Devanagari are explained in the Unicode Standard.
(In The Unicode Standard Version 3.0, the Devanagari shaping rules are explained in
§9.1, pp. 211-223. Devanagari provides the model for the shaping of other Indic scripts
in Unicode, and this section should be read in conjunction with the descriptions of script
shaping requirements for Bengali, Gurmukhi, Gujarati, etc.. Note that Thai, although
closely related to the Indic scripts, has unique requirements that justify a separate Thai
shaping engine in Uniscribe--see Part Two.)
In the next illustration, the characters affected by reordering are indicated in red.

Only four clusters in our sample run require character reordering; three of these involve
below-base and above-base forms of the ra consonant, and the other involves moving
the i matra to the left of the consonant conjunct. Once this character processing has
been done, Uniscribe calls text layout functions in OTLS to apply OpenType substitution
and positioning features. All the features required to render the Indic scripts supported
by Uniscribe are published in the OpenType specification, and are explained in detail in
the Microsoft Typography document Creating and supporting OpenType fonts for Indic
Scripts.

Bengali
Devanagari
Gujarati
Gurmukhi
Kannada
Malayalam
Odia
Tamil
Telugu
In all, eighteen applications of GSUB and GPOS features are required to render this one
Sanskrit word.

Uniscribe completely insulates client applications from the shaping knowledge required
for complex scripts. Once Uniscribe has finished calling OTLS to apply the required
features for a complex script like Devanagari, it can pass the glyph string back to the
application and to device drivers and system font rasterizers. The application,
meanwhile, only needs to manage the original backing string of logical order Unicode
text. Uniscribe never changes the backing string, and any character reordering required
by Unicode script shaping rules occurs in a buffer. Uniscribe maintains one index from
the buffered characters to the original backing string, and another from the buffered
characters to the font glyph string. Client applications can utilize additional Uniscribe
APIs to control cursor positioning and caret movement in the rendered text.
Uniscribe likewise insulates font developers from complex script shaping requirements
by taking on the task of analyzing clusters and preparing them for OpenType layout.
This means that type designers and developers can work with efficient and predictable
sets of lookups and features, rather than trying to define the incredibly large number of
complicated contextual lookups that would be necessary to render directly from the
Unicode backing string. Because the OpenType lookup types were not designed to
perform all the reordering required by Unicode shaping rules, some complex script
rendering would be impossible without the kind of character preprocessing available in
Uniscribe.
This overview should have given you a basic insight into what glyph processing is, why it
is necessary, and how it is implemented in Windows. Part Two covers each of the three
elements of Windows glyph processing—OpenType, OTLS and Uniscribe—in more
technical detail and provides information on licensing, distribution and online resources.

Syllable-by-syllable OpenType Layout features
applied to our sample Sanskrit word
For readers especially interested in Indic script glyph processing, here is a syllable-bysyllable—i.e. cluster-by-cluster—description of the Indic OpenType Layout features
applied to our sample Sanskrit word. These are the features used to render this text
string in the Mangal Devanagari UI font; other OpenType fonts may well employ more
full conjunct form substitutions in place of the half forms used heavily in Mangal. The
codepoint sequence of each cluster is presented in bold type, followed by a Latin
transliteration of the syllable, followed by a detailed description of the applied OTL
features and their effects.
092A 0930 094D : pra : The “Below-Base Forms” feature is applied to substitute the
0930 (ra) and 094D (halant, vowel killer) with a default below-base form of 0930 (vattu).
The “Below-Base Substitutions” feature is then applied to 092A (pa) and the default
below-base form (**vattu) to render the required ligature.
091C 094D 091E 0947 : jñe : The “Akhand” feature is applied to replace 091C (ja) 094D
(halant) 091E (nya) with the necessary ligature. The “Above-Base Mark Positioning”
feature is applied to position 0947 (e matra, vowel sign) above the ligature.
0928 093E : na : No OpenType Layout features required.
0924 094D 092E : tma : The “Half Forms” feature is applied to the combination 0924 (ta)
094D (halant) to substitute the half form of 0924 (t).
0928 093E : na : No OTL features required.
0938 094D 092E 093E : sma : The “Half Forms” feature is applied to the combination
0938 (sa) 094D (halant) to substitute the half form of 0938 (s).
0932 094D 0932 094B : llo : The “Half Forms” feature is applied to the combination
0932 (la) 094D (halant) to substitute the half form of 0932 (l).
0915 093E : ka : No OTL features required.
0926 0941 : du : The “Below-Base Mark Positioning” feature is applied to position 0941
(u matra) below 0926 (da).
0924 094D 0915 0930 094D : tkra : The “Half Forms” feature is applied to the
combination 0924 (ta) 094D (halant) to get the half form of 0924 (t). The “Below-Base
Form” feature is applied to 0930 (ra) and 094D (halant) to substitute it with a default
below base form of 0930 (vattu). The “Below-base Substitutions” is then applied to 0915
(ka) and the default below base form (vattu) to render the required ligature.

092E 094D 092F 093E : mya : The “Half Forms” feature is applied to the combination
092E (ma) 094D (halant) to substitute the half form of 092E (m).
092E 0941 : mu : No OTL features required.
093F 0937 094D 092E : smi : The “Pre-Base Substitutions” feature is applied to get the
desired glyph variant of 093F (i matra); this feature substitutes one of five different i
matras in the Mangal font that are designed to fit over different widths of consonants
and conjuncts.
0928 094D 0938 094D 0935 : nsva : The “Half Forms” feature is applied to the
combinations 0928 (na) 094D (halant) and 0938 (sa) 094D (halant) to substitute the
respective half forms of 0928 (n) and 0938 (s).
0917 0947 0930 094D : rge : The “Reph” feature is applied to substitute 0930 (ra) and
094D (halant) with a default glyph for the reph (the above-base form of ra). The “AboveBase Substitutions” feature is then applied to 0947 (e matra) and the reph to substitute
them with a composite. The “Above-Base Mark Positioning” feature is applied to
position the composite above 0917 (ga).

Next: Part 2
Learn about glyph processing in more detail in Windows glyph processing, part 2.

Windows glyph processing for
OpenType fonts, part 2
Article • 09/23/2020

As the central element of Windows glyph processing, the OpenType font format is a vast
subject. Fortunately, the specification provides not only minute detail of the font table
structures, header formats and internal tag lists, but a large number of examples that
demonstrate the function of specific aspects of the technology. The following
information provides a detailed introduction to the key glyph processing aspects of the
OpenType format, somewhere between the level of the overview in Part One and the
technical coverage of the specification itself, and some “real world” examples of OTL
feature implementation.
OpenType is an extension of the original TrueType format, developed in partnership by
Microsoft and Adobe Systems. OpenType makes use of the basic architecture of
TrueType to add support for a wide variety of glyph substitution, positioning,
justification and alignment features. The TrueType font format is based on a series of
tables containing code and data for different aspects of the font architecture: character
mapping, glyph outline descriptions, spacing metrics information, glyph naming,
copyright and licensing, etc.. OpenType adds to the number of possible tables in the
existing TrueType specification, to allow a greater degree of intelligence to be built into
a font. Most of these new tables are optional, and it is important to note that it is
possible to produce an OpenType font without any of the glyph substitution and
positioning features encountered in Part One. The tables that will be discussed in this
article are the five optional Advanced Typographic Tables:
GDEF — Glyph definition data
GSUB — Glyph substitution data
GPOS — Glyph positioning data
BASE — Baseline data
JSTF — Justification data
and two required tables
CMAP — Character to glyph mapping
DSIG — Digital Signature
There is also a discussion of the role of script and language system tags.

CMAP Table

Every glyph in a TrueType font is identified by a unique Glyph ID (GID), a simple
sequential numbering of all the glyphs in the font. These GIDs are mapped to character
codepoints in the font’s CMAP table. In OpenType fonts, the principal mapping is to
Unicode codepoints; that is, the GIDs of nominal glyph representations of specific
characters are mapped to appropriate Unicode values.
The key to OpenType glyph processing is that not every glyph in a font is directly
mapped to a codepoint. Variant glyph forms, ligatures, dynamically composed diacritics
and other rendering forms do not require entries in the CMAP table. Rather, their GIDs
are mapped in layout features to the GIDs of nominal character forms, i.e. to those
glyphs that do have CMAP entries. This is the heart of glyph processing: the mapping of
GIDs to each other, rather than directly to character codepoints.
In order for fonts to be able to correctly render text, font developers must ensure that
the correct nominal glyph form GIDs are mapped to the correct Unicode codepoints.
Application developers, of course, must ensure that their applications correctly manage
input and storage of Unicode text codepoints, or map correctly to these codepoints
from other codepages and character sets.

GDEF Table
As discussed in Part One, the most important tables for glyph processing are GSUB and
GPOS, but both these tables make use of data in the Glyph Definition table. The GDEF
table contains three kinds of information in subtables: glyph class definitions that
classify different types of glyphs in a font; attachment point lists that identify glyph
positioning attachments for each glyph; and ligature caret lists that provide information
for caret positioning and text selection involving ligatures.
The Glyph Class Definition subtable identifies four glyph classes: simple glyphs, ligature
glyphs (glyphs representing two or more glyph components), combining mark glyphs
(glyphs that combine with other classes), and glyph components (glyphs that represent
individual parts of ligature glyphs). These classes are used by both GSUB and GPOS to
differentiate glyphs in a string; for example, to distinguish between a base vowel (simple
glyph) and the accent (combining mark glyph) that a GPOS feature will position above it.
The Attachment Point List identifies all the glyph attachment points defined in the GPOS
table. Clients that access this information in the GDEF table can cache attachment
coordinates with the rasterized glyph bitmaps, and avoid having to recalculate the
attachment points each time they display a glyph. Without this table, GPOS features
could still be enabled, but processing speed would be slower because the client would
need to decode the GPOS lookups that define the attachment points and compile its
own list.

The Ligature Caret List defines the positions for the caret to occupy in ligatures. This
information, which can be fine tuned for particular bitmap sizes, makes it possible for
the caret to step across the component characters of a ligature, and for the user to
select text including parts of ligatures. In the example on the left, below, the caret is
positioned between two components of a ligature; on the right, text is selected from
within a ligature.

The Ligature Caret List can contain positioning data in both X and Y directions.

GSUB Table
The GSUB table contains substitution lookups that map GIDs to GIDs and associate
these mappings with particular OpenType Layout features. The OpenType specification
currently supports six different GSUB lookup types:
1. Single
Replaces one glyph with one glyph.
2. Multiple
Replaces one glyph with more than one glyph.
3. Alternate
Replaces one glyph with one of many glyphs.
4. Ligature
Replaces multiple glyphs with one glyph.
5. Context
Replaces one or more glyphs in context.
6. Chaining Context
Replaces one or more glyphs in chained context.
Although these lookups are defined by the font developer, it is important for application
developers to understand that some features require relatively complex UI support. In
particular, OTL features using type 3 lookups may require the application to present
options to the user (an example of this is provided in the discussion of OTLS in Part
One). In addition, some registered features allow more than one lookup type to be
employed, so application developers cannot rely on supporting only some lookup types.
Similarly, features may have both GSUB and GPOS solutions—e.g. the “Case-Sensitive
Forms” feature—so applications that want to support these features should avoid

limiting their support to only one of these tables. In setting priorities for feature support,
it is important to consider the possible interaction of features and to provide users with
powerful sets of typographic tools that work together.

Scripts and Language Systems
A discussion of GSUB lookups and features affords a good opportunity to introduce the
importance of script and language systems. These are a central aspect of the OpenType
format: all glyph processing is defined within a context of script and language system.
Even features that are not script or language specific by nature are located in this
hierarchy:
Script > Language System > Feature > Lookup
An OpenType language system tag is always associated with a script tag, and indicates a
specific orthographic convention for writing that language in that script. Because many
written languages sharing a common script also share common typographic
requirements, font developers can specify a Default <dflt> language system for each
script that will be sufficient to support all but a few languages. By specifying additional
language systems, the font developer can modify the function of OTL features when a
script is used to represent these languages. This, of course, requires application level
support for different language systems, possibly including mapping of OTL language
systems to user locales, as well as language tagging of text runs.
In this example of a truncated tree structure, a Turkish language system has been added
to Latin script support in a font in order to enable an exception to the default results of
the “Standard Ligatures” feature. This feature includes the common f-ligatures in the
Default language system, including the ffi and fi ligatures, but the latter are excluded in
the Turkish language system to avoid confusion between the dotless i in the ligature
glyphs and the Turkish letter with the same form. Mnemonic glyph names are used here,
rather than GID numbers.

Latin <latn>
Default <dflt>
Standard Ligatures <liga> (GSUB feature)
All f-ligs (GSUB type 4 lookups)
f f i -> ffi
f f l -> ffl
f f -> ff
f i -> fi
f l -> fl
Turkish <TRK>

Standard Ligatures <liga> (GSUB feature)
ff and fl f-ligs (GSUB type 4 lookups)
f f l -> ffl
f f -> ff
f l -> fl

It should be noted that there are several different ways to achieve the same rendering,
using different sets of lookups within the OTL feature. The best method will depend on
the nature of the different languages supported by the font, and the number of
exceptions to the default glyph processing.
The differing results of the same feature applied under two different language systems
are shown below.

(Both the English and Turkish samples are from the work of the Turkish poet Nazim
Hikmet.)
Note: although they enable exceptions to the Default language system feature behavior,
additional language systems do not act exceptionally; that is, all desired features need
to be associated with each language system, not just those that differ from the Default
language system feature set.
While any OTL feature can be associated with different language systems, and may
provide distinct glyph processing results for each, some registered features are designed
specifically to take advantage of OpenType’s language system tags. One of these is the
“Localized Forms” feature that associates stylistic glyph variants with particular language
systems. This enables developers to provide support for different localized typographic
cultures within the same script, and to “disunify” Unicode codepoint assignments at the
font level. One important implementation of this would be in East Asian fonts that
provide preferred forms of Han ideographs for Traditional and Simplified Chinese,
Japanese and Korean users. In the simpler example below, the “Localized Forms” feature
is used in an italic font to substitute the traditional Serbian forms of some Cyrillic letters
where they differ from the international norms based on the Russian tradition. Again,
mnemonic glyph names are used rather than GIDs.

Cyrillic <cyrl>
Default <dflt>
...
Serbian <SRB>
Localized Forms <locl> (GSUB feature)
Serbian forms (GSUB type 1 lookups)
cyrbe -> cyrbe.serb
cyrghe -> cyrghe.serb
cyrde -> cyrde.serb
cyrpe -> cyrpe.serb
cyrte -> cyrte.serb

The illustration below shows the dramatic results of this feature applied to just a few
lines of Serbian poetry. The text on the left uses the font’s default glyph forms, the
Russian norms, and the text on the right uses the substituted Serbian forms; the affected
letters are indicated in red. Once again, the text string remains entirely unchanged, and
only the rendering differs.

(These are the opening lines of “Belgrade, April 1944”, by the poet Miodrag Pavlović.)
As in the previous example, there are many ways to achieve the same results, and the
OpenType specification does not favor any particular solution. It would be perfectly
legitimate to designate the Serbian forms as the default glyphs for these Cyrillic
characters, i.e. to make Serbian the Default language system. However, this would
require many more instances of the “Localized Forms” feature to be applied to
substitute the Russian forms that are also used for so many other languages like
Belarusian, Ukrainian and dozens of minority languages within the Russian Federation.
OpenType font developers need to plan their projects carefully to make efficient use of
features and lookups.

GPOS table

The GPOS table contains a very powerful set of lookup types to reposition glyphs
relative to their normative positions and to each other. Glyph positioning lookups work
in two ways: by adjusting glyph positions relative to their metrical space or by linking
predefined attachment points on different glyphs. These two methods are further
divided into specific adjustment and attachment lookup types that can be used to
control positioning of diacritics relative to single or ligatured characters, and even to
enable chains of contextual positioning operations. The OpenType specification
currently supports eight different GPOS lookup types:
1. Single adjustment
Adjusts the position of a single glyph.
2. Pair adjustment
Adjusts the position of a pair of glyphs.
3. Cursive attachment
Attaches cursive glyphs to each other.
4. MarkToBase attachment
Attaches a combining mark to a base glyph.
5. MarkToLigature attachment
Attaches a combining mark to a ligature.
6. MarkToMark attachment
Attaches a combining mark to another mark.
7. Context positioning
Positions one or more glyphs in context.
8. Chained Context positioning
Position one or more glyphs in chained context.
Adjustment lookups are defined using the font’s internal metrical units (font units),
which are specified as units of the total body or em height of the font, hence em units.
The TrueType specification allows font developers to set the number of units per em in a
font, but recommends the use of a power of two. This is actually a procurement
requirement for fonts that ship with Microsoft products, and the majority of TrueType
fonts have an em of 2048 units. It was much easier to visualize an em in earlier days,
when the body of a piece of type was a chunk of metal. Digital glyph outlines are drawn
on a Cartesian grid originating at the intersection of the left sidebearing and the
nominal baseline. Digital ems are invisible most of the time, and the same glyph in
different fonts may occupy more or less of the body height, and may even overflow the
total height. The illustration below shows the lowercase b from the Windows 2000 font
Sylfaen on its Cartesian grid with an em of 2048 units. Sylfaen is a font that comes close
to filling the em height with its Latin ascender height and descender depth, but there
are many fonts that are “cast small on the body”, whose glyphs occupy much less
vertical space.

GPOS adjustment lookups can shift the position of a glyph in both X and Y directions,
and can move a glyph well beyond its normative sidebearings and em height. Lookups
are defined as offsets from the normative glyph position.
Among the OTL features that call GPOS table entries, the “Kerning” feature deserves
special mention because it provides a new solution for an existing function in most text
layout software. This feature generally implements type 2 GPOS lookups (chained
contextual kerning is also possible using type 8 lookups), and has several advantages
over traditional kerning pairs as stored in the TrueType KERN table. The GPOS “Kerning”
feature can make use of class-based kerning, that is, adjustment of inter-glyph spacing
in horizontal text according to predefined classes of glyphs with similar shapes and
spacing. This both speeds up font production, especially in OpenType fonts with large
glyph sets involving many diacritic variants of base glyphs, and decreases the file size of
a well-kerned font. The “Kerning” feature can also provide device dependent kerning
data for specific bitmap sizes to optimize screen typography. GPOS kerning and KERN
table kerning information can be stored in the same font, and applications can decide
which to make use of, although the production advantages of class-based kerning may
render the KERN table effectively obsolete as more applications support the “Kerning”
feature.
GPOS attachment lookups are made by predefining one or more absolute points on a
glyph’s em grid, and then aligning attachment points on different glyphs. Attachment
points are defined in the Glyph Definition Table (GDEF), which is referenced by the GPOS
table. GPOS lookup types allow for attachment of marks, e.g. combining accents or
vowel matras in Indic scripts, to base glyphs or to other marks. The latter MarkToMark
attachments can be used to avoid collisions when more than one mark is applied to a

base glyph. When contextual positioning or chained contextual positioning is used, it is
possible to reposition glyphs more than once as the sequence of input characters is
rendered.
The following example, using the Windows Devanagari UI font, Mangal, demonstrates
how two different GPOS lookups are applied in conjunction with an initial GSUB lookup
in shaping an Indic syllable. In the first line, the ja consonant, its inherent vowel
suppressed by the halant, combines with the nya consonant to form an akhand, a
required ligature form; this is achieved by implementing a type 4 (Ligature) GSUB
lookup called by the “Akhand” feature. In the second line, the inherent vowel in jnya is
replaced by the u vowel matra; this is a type 5 (MarkToLigature) GPOS attachment
lookup called by the “Below-base Mark Positioning” feature. The attachment point on
the two glyphs is indicated in the illustration by a small green dot; the lookup aligns
these attachment points to correctly position the u matra below the conjunct ligature. In
the third line, an anudatta stress accent is added to the syllable; this is lowered from its
normative position and repositioned below the u matra by a type 2 (Pair adjustment)
GPOS lookup, also called by the “Below-base Mark Positioning” feature. The preadjustment position of the anudatta is indicated in the final syllable by the pale gray
rectangle.

BASE table

BASE table entries, defined relative to the em height, are used to adjust the vertical
position of lines of text composed with glyphs of different scripts and point sizes. Every
glyph in a font has a nominal default baseline and, presuming the font has been well
made, this baseline will provide consistent alignment appropriate for the supported
script or scripts. When scripts are mixed in text, correct alignment and interlinear
spacing may require an adjustment of the vertical position of one or more scripts
relative to the baseline of the “dominant” script. In the example below, the dominant
script is Latin, and the single kanji character needs to be moved down in order to align it
correctly with the Latin text. CJKV ideographs have a default baseline near the bottom of
the character, and in order to properly align with Latin text they need to have a BASE
table entry identifying a second baseline that will set them lower on the line of text.
(CJKV is a common software development abbreviation for Chinese, Japanese, Korean
and Vietnamese. It is also frequently encountered simply as CJK, since the Chinese
ideographs are no longer part of the day-to-day writing system of most Vietnamese.
The best source of information on East Asian text and digital typography is Ken Lunde’s
book CJKV Information Processing.)
In the first sample, the kanji character’s default baseline is used; this positions the glyph
too high and it almost collides with the descender of the p. In the second sample, this
problem has been corrected by using the BASE table entry for dominant Latin text.

In addition to allowing multiple baselines to be identified for different scripts, the BASE
table also gives clients the option of using minimum and maximum text extent entries to
override the default text extent of particular scripts. The BASE table can define script,
language system and feature specific min/max extent values. This is particularly useful
for word processing applications that employ automatic interlinear adjustment to
prevent collisions, as layout can be optimized for specific glyph processing features.

JSTF table
The JSTF table provides font developers with increased control over glyph substitution
and positioning in justified text, i.e. text that is flush to both the left and right margins.
JSTF table entries are designed to supplement an application’s justification algorithms
by enabling or disabling specific OTL features. The table entries present a sequence of
suggested priorities to improve the spacing and general appearance or “color” of
justified text, the options for which will depend on particular script and language
systems. For example, the spacing of justified Latin text might be improved in some
circumstances by decomposing ligatures, while Arabic text may benefit from the use of
swash forms or kashidas.
(A kashida is a lengthening stroke that extends, often very dramatically, certain Arabic
letters in traditional calligraphic styles and fine typography.)

DSIG table
At the beginning of this section, I referred to the DSIG table as a “required” table. In fact,
a digital signature is not required in the same sense that the CMAP and many other
tables are required simply for the font to work. A font without a DSIG table will work,
but it will not be recognized as an OpenType font by the Windows operating system.
Because the OpenType format is an extension of the TrueType format, and most of the
new tables are optional, Windows makes a distinction between the two formats based
solely on the presence or absence of a DSIG table. A font with a DSIG table will be
recorded in the Windows font folder as an OpenType font and presented with the
OpenType icon.
A digital signature assures users that the signed software or document (in this case, the
font) has not be altered or tampered with since it was signed by the maker, and that it
does not contain malicious code or dangerous flaws. Digital signatures are based on a
public/private key model, and keys are granted by Certification Authorities. Font
developers can download a free font signing tool from the Microsoft Typography
website. This is a command line utility that, in addition to adding a DSIG table to a font,
runs a number of glyph integrity checks to confirm that the font is minimally
conformant with the font format specification. If the font contains errors that may affect
its performance, the digital signature tool will fail.

OTLS in Detail

The OpenType Layout Services library is currently available under a free license to
application developers who are interested in using its helper functions to implement
OpenType glyph processing. As explained in Part One, OTLS is composed of helper
functions that insulate client applications from the details of the OpenType font tables
and assist in applying GSUB and GPOS features. Client applications are free to make full
or partial use of OTLS functions, making it a highly adaptive solution for developers who
want to implement OpenType glyph processing support within existing text layout
architecture.
In order to process runs of text, as defined in Part One, a client needs to be able to store
characters, glyph coordinates, and flag and formatting properties. To make this easy,
OTLS provides a general purpose object called an otlList. In addition to identifying and
tagging runs of text, an OTLS client needs to be able to create and fill otlLists using
inline helper functions. These otlLists will be used as input and output parameters for
OTLS functions.
The principal OTLS functions are grouped in three categories. Font Information
Functions are used to query an OpenType font about what scripts, language systems
and features it supports:
GetOtlVersion
Returns current library version.
GetOtlScriptList
Enumerates scripts in a font.
GetOtlLangSysList
Enumerates language systems in each script.
GetOtlFeatureDefs
Enumerates OTL features in each language system.
Text Information Functions return information about text layout and locate run elements
such as character position and feature parameters:
GetOtlLineSpacing
Returns interlinear spacing for a run of text.
GetOtlBaselineOffsets
Returns baseline adjustment between two scripts in adjacent runs (using font BASE
table).
GetOtlCharAtPosition
Identifies what character is at given x,y coordinate.
GetOtlExtentOfChars
Returns location of character range.

GetOtlFeatureParams
Finds feature parameters within a run.
Text Layout Functions implement GSUB and GPOS features:
SubstituteOtlChars
Performs primary glyph substitutions, i.e. substitutions of default glyphs.
SubstituteOtlGlyphs
Performs secondary glyph substitutions, i.e. substitutions of subsequent glyphs.
PositionOtlGlyphs
Performs initial glyph positioning.
RePositionOtlGlyphs
Adjusts glyph positioning.
In addition to these functions, OTLS provides a resource management function,
FreeOtlResources, to clear client memory.
It should also be noted that, although it pays particular attention to Windows glyph
processing, the OTLS library is designed to be adaptable to other platforms. Developers
who are interested in obtaining a version of OTLS for a non-Windows platform should
contact Microsoft Typography.

Uniscribe in Detail
The Uniscribe processor, USP10.DLL, ships with Windows 2000 and with Internet
Explorer 5.0+, which is the current update mechanism. Uniscribe is not available under
license to other vendors, but any application and font needing complex script shaping in
Windows 2000 can make use of it. Applications can also use Uniscribe to display and
print complex script text on older versions of the operating system, if the DLL is present.
Windows applications have a number of system API options for performing text layout.
These include basic Win32 text APIs such as TextOut; more advanced Win32 edit
controls that have been extended in Windows 2000 to support multilingual text and
some aspects of complex scripts such as right-to-left reading order; the higher level
interfaces of RichEdit control that take advantage of Uniscribe; and finally Uniscribe
itself, which can be called directly by clients.
Uniscribe provides a large set of APIs to handle all aspects of text layout for supported
scripts, including cursor position and hit testing, advance width calculation, linebreaking,
complex script determination, localized digit substitution, etc..
We have already seen, in our Devanagari example in Part One, three of these APIs in
action. Uniscribe divided the text run into clusters and generated glyphs (ScriptShape

function), these glyphs are then positioned (ScriptPlace function), and displayed
(ScriptTextOut function). During this process, additional APIs such as ScriptStringValidate
might be called to confirm processing requirements.
The ScriptShape, ScriptPlace and ScriptTextOut APIs all interact with the Uniscribe
shaping engines. As discussed in Part One, each shaping engine contains specific
knowledge about a script or groups of related scripts. As support for new scripts is
added to Uniscribe, new shaping engines may be defined or existing shaping engines
may be extended to cover related scripts. For example, Syriac script support has been
added to the existing Arabic shaping engine, while the similar processing requirements
of Hebrew and Thaana allow the latter to be added to the Hebrew shaping engine. All
the script engines analyze text runs to isolate the basic unbreakable element, the cluster.
As we saw in the Devanagari example, clusters identified by the Indic shaping engine
correspond to syllables. In Arabic, each cluster corresponds to an adjacent pair of
characters, and the shaping engine moves along the text string classifying each
character relative to its neighbors. For example, the first Arabic letter (determined by
Unicode character properties) following a space character will first be classified as an
isolated form, but if the next character is also an Arabic letter, the first will be reclassified
as an initial form and the second classified as a final form. The shaping engine then
moves along the string, making this second letter the first character of the next cluster. If
the following character is a third letter, the second is reclassified as a medial form, the
new character is classified as a final form, and the engine moves on. Uniscribe calls OTLS
functions to render the correct forms using the OpenType Layout GSUB features “Initial
Forms”, “Medial Forms” and “Terminal Forms” (the isolated form is presumed to be the
default glyph form). This will result in basic minimum Arabic shaping. In the illustration
below, a ligature feature has been applied to render the cluster in the second line. In the
third line, however, the shaping engine finds another letter in the new cluster, so it goes
back and replaces the ligature form from line two with the initial and medial forms of
the first and second letters, to which the new final form letter is joined. The Unicode
codepoints to the right of the grey line are stored in logical order, left-to-right, while the
Arabic glyphs are rendered right-to-left. The cluster being processed in each line is
indicated by the red codepoints.

The Arabic shaping engine will automatically call all required OTL features, e.g. the
“Required Ligatures” feature to render the lam alef combination. A client application can
make optional features available to users; for Arabic typography, these will likely include
additional ligatures and swash forms. If vowel points or other marks are included in a
text string, the Arabic script engine will use the Unicode character properties and
shaping rules to ensure that these do not interfere with the rendering of the correct
letter forms. GPOS lookups can be used to dynamically and contextually reposition point
marks.

Note that, in addition to the complex script support described here, Uniscribe also
understands the non-OpenType layout font formats for Arabic, Hebrew and Thai that
were supported in previous localized versions of the operating system.
It is worth repeating that Uniscribe script engines implement Unicode Standard shaping
rules for complex scripts. This gives font and application developers a common set of
complex script expectations: font developers should be able to expect an application to
be able to execute—directly or by calling Uniscribe—script rules as defined in the
Unicode Standard, and application developers should be able to expect fonts with
glyphs and layout features that are responsive to these rules.

Uniscribe currently has shaping engines for the following scripts.
Arabic
Arabic, Syriac
Hebrew
Hebrew, Thaana
Indic
Bengali, Devanagari, Gujarati, Gurmukhi, Kannada, Malayalam, Oriya, Tamil,
Telugu
Old Hangul
Hangul Jamo
Thai
Thai
Note that not all of these scripts are actively supported in Windows 2000 yet, usually
due to the absence of fallback fonts. Fonts are in development for most of these scripts,
and are in the pipeline to be added to Windows along with appropriate keyboard
drivers, locale definitions, etc..
In addition to script support, Uniscribe provides processing for Unicode surrogate pairs
that extend the number of characters that can be encoded in Unicode to almost one
million. Among the first characters to be added to the surrogate extension planes are a
large number of additional Han ideographs, so surrogate support will be an important
aspect of East Asian text processing.
Uniscribe also implements the Unicode bidirectional (bidi) algorithm for mixed and
nested text directions. This is essential for correctly rendering Unicode text strings
containing characters with different direction properties, e.g. Arabic words within English
text. Use of the bidi algorithm is not limited to mixing scripts, however; Arabic and
Hebrew are both scripts with strong right-to-left reading direction, but which require
digits to be rendered from left-to-right.

Conclusion
We have seen in this article how glyph processing extends the capabilities of fonts and
text layout applications, and we have seen practical demonstrations of why this
technology is needed to process the world’s many complex writing systems and the
languages that use them. We’ve also seen, for example in the use of localized glyph
forms for Serbian, how this technology can respond to the typographical preferences of
particular user communities even as it provides a universal text processing solution
using the Unicode Standard for character encoding. Not least, we have seen how glyph
processing can enable rich typographic features that can be applied to text without font

switching, custom encodings or other primitive solutions that threaten the semantic
integrity of the text.
Many people will look at these capabilities and identify complex script support as an
obvious priority; after all, such support is necessary to allow users of these scripts to
communicate at a basic level. Text processing for complex scripts is glyph processing,
and the challenges of implementing OpenType Layout features simply cannot be
avoided. It seems likely then, that application developers looking to prioritize resource
allocation for implementing glyph processing support are likely to view correct Arabic
shaping as much more important than, for example, adding smallcaps support for the
Latin script.
It is indeed difficult to overestimate the importance of Arabic shaping, but it is easy to
underestimate the importance of Latin smallcaps. It is easy to think of typography as
simply making text look nice, and so to treat many elements of typography as frills:
luxuries that applications can get around to supporting when they have dealt with all
the more important things.
I want to conclude this article by suggesting why support for sophisticated typography
belongs among the important things, and not relegated to a frill. The role of typography
is not to prettify text, but to articulate it. That it does so in an aesthetic way—utilizing all
the art it can draw from its own heritage, the heritage of manuscript tradition, and
individual creative vision—should not disguise the expressive and organizational
relationship of typography to text. A typographic culture, such as the one in which you
engage as you read this article, is a system of visual indicators that helps readers
navigate text and helps writers express their ideas. In the 550 years since Gutenberg
developed metal type casting at Mainz, the printed Latin script has developed a
particularly rich typographic culture, using romans, italics, bold type, smallcaps,
ligatures, swash forms, etc., to organize and articulate the texts of hundreds of
languages around the world. Other scripts have developed equally complex and
adaptive systems, some more complex and sophisticated, while others are only just
beginning their typographic journey. Typography is part of how the human race
expresses itself, individually and collectively. Sadly, whenever support for a particular
aspect of a typographic culture is limited, texts are inevitably rendered less expressive of
the ideas they contain than they might be. As if we were forced to speak in a monotone,
we cannot fully articulate what we need to say.
Software developers, of course, have to prioritize, to allocate resources carefully, and
they need to ship a product in a marketplace that will not wait for them to do
everything they might like to do. The Windows glyph processing model provides such
developers with a powerful set of helper functions and system components to provide
users with rich, expressive typographical controls. The OpenType format provides font

developers with ways to add considerable typographic intelligence to their fonts:
intelligence that, with proper application support, can help users articulate their ideas
with the full register of their typographic voices.

The Science of Word Recognition
Article • 06/09/2022

Evidence from the last 20 years of work in cognitive psychology indicate that we use the
letters within a word to recognize a word. Many typographers and other text enthusiasts
I've met insist that words are recognized by the outline made around the word shape.
Some have used the term bouma as a synonym for word shape, though I was unfamiliar
with the term. The term bouma appears in Paul Saenger's 1997 book Space Between
Words: The Origins of Silent Reading. There I learned to my chagrin that we recognize
words from their word shape and that "Modern psychologists call this image the 'Bouma
shape.'"
This paper is written from the perspective of a reading psychologist. The data from
dozens of experiments all come from peer reviewed journals where the experiments are
well specified so that anyone could reproduce the experiment and expect to achieve the
same result. This paper was originally presented as a talk at the ATypI

conference in

Vancouver in September, 2003.
The goal of this paper is to review the history of why psychologists moved from a word
shape model of word recognition to a letter recognition model, and to help others to
come to the same conclusion. This paper will cover many topics in relatively few pages.
Along the way I will present experiments and models that I couldn't hope to cover
completely without boring the reader. If you want more details on an experiment, all of
the references are at the end of the paper as well as suggested readings for those
interested in more information on some topics. Most papers are widely available at
academic libraries.
I will start by describing three major categories of word recognition models: the word
shape model, and serial and parallel models of letter recognition. I will present
representative data that was used as evidence to support each model. After all the
evidence has been presented, I will evaluate the models in terms of their ability to
support the data. And finally I will describe some recent developments in word
recognition and a more detailed model that is currently popular among psychologists.

Model #1: Word Shape
The word recognition model that says words are recognized as complete units is the
oldest model in the psychological literature, and is likely much older than the
psychological literature. The general idea is that we see words as a complete patterns
rather than the sum of letter parts. Some claim that the information used to recognize a

word is the pattern of ascending, descending, and neutral characters. Another
formulation is to use the envelope created by the outline of the word. The word patterns
are recognizable to us as an image because we have seen each of the patterns many
times before. James Cattell (1886) was the first psychologist to propose this as a model
of word recognition. Cattell is recognized as an influential founder of the field of
psycholinguistics, which includes the scientific study of reading.

Figure 1: Word shape recognition using the pattern of ascending, descending, and
neutral characters

Figure 2: Word shape recognition using the envelope around the word
Cattell supported the word shape model because it provided the best explanation of the
available experimental evidence. Cattell had discovered a fascinating effect that today
we call the Word Superiority Effect. He presented letter and word stimuli to subjects for
a very brief period of time (5-10ms), and found that subjects were more accurate at
recognizing the words than the letters. He concluded that subjects were more accurate
at recognizing words in a short period of time because whole words are the units that
we recognize.
Cattell's study was sloppy by modern standards, but the same effect was replicated in
1969 by Reicher. He presented strings of letters – half the time real words, half the time
not – for brief periods. The subjects were asked if one of two letters were contained in
the string, for example D or K. Reicher found that subjects were more accurate at
recognizing D when it was in the context of WORD than when in the context of ORWD.
This supports the word shape model because the word allows the subject to quickly
recognize the familiar shape. Once the shape has been recognized, then the subject can
deduce the presence of the correct letter long after the stimulus presentation.
The second key piece of experimental data to support the word shape model is that
lowercase text is read faster than uppercase text. Woodworth (1938) was the first to
report this finding in his influential textbook Experimental Psychology. This finding has
been confirmed more recently by Smith (1969) and Fisher (1975). Participants were
asked to read comparable passages of text, half completely in uppercase text and half
presented in standard lowercase text. In each study, participants read reliably faster with
the lowercase text by a 5-10% speed difference. This supports the word shape model
because lowercase text enables unique patterns of ascending, descending, and neutral

characters. When text is presented in all uppercase, all letters have the same text size
and thus are more difficult and slower to read.
The patterns of errors that are missed while proofreading text provide the third key
piece of experimental evidence to support the word shape model. Subjects were asked
to carefully read passages of text for comprehension and at the same time mark any
misspelling they found in the passage. The passage had been carefully designed to have
an equal number of two kinds of misspellings: misspellings that are consistent with word
shape, and misspellings that are inconsistent with word shape. A misspelling that is
consistent with word shape is one that contains the same patterns of ascenders,
descenders, and neutral characters, while a misspelling that is inconsistent with word
shape changes the pattern of ascenders, descenders, and neutral characters. If test is the
correctly spelled word, tesf would be an example of a misspelling consistent with word
shape and tesc would be an example of a misspelling inconsistent with word shape. The
word shape model would predict that consistent word shapes would be caught less
often than an inconsistent word shape because words are more confusable if they have
the same shape. Haber & Schindler (1981) and Monk & Hulme (1983) found that
misspellings consistent with word shape were twice as likely to be missed as
misspellings inconsistent with word shape.
Target word: test

Error rate

Consistent word shape (__tesf)

13%

Inconsistent word shape (__tesc)

7%

Figure 3: Misspellings that are consistent with word shape are missed more often
The fourth piece of evidence supporting the word shape model is that it is difficult to
read text in alternating case. AlTeRnAtInG case is where the letters of a word change
from uppercase to lowercase multiple times within a word. The word shape model
predicts that this is difficult because it gives a pattern of ascending, descending, and
neutral characters that is different than exists in a word in its natural all lowercase form.
Alternating case has been shown to be more difficult than either lowercase or uppercase
text in a variety of studies. Smith (1969) showed that it slowed the reading speed of a
passage of text, Mason (1978) showed that the time to name a word was slowed,
Pollatsek, Well, & Schindler (1975) showed that same-difference matching was hindered,
and Meyer & Gutschera (1975) showed that category decision times were decreased.

Model #2: Serial Letter Recognition
The shortest lived model of word recognition is that words are read letter-by-letter
serially from left to right. Gough (1972) proposed this model because it was easy to

understand, and far more testable than the word shape model of reading. In essence,
recognizing a word in the mental lexicon was analogous to looking up a word in a
dictionary. You start off by finding the first letter, then the second, and so on until you
recognize the word.
This model is consistent with Sperling's (1963) finding that letters can be recognized at a
rate of 10-20ms per letter. Sperling showed participants strings of random letters for
brief periods of time, asking if a particular letter was contained in the string. He found
that if participants were given 10ms per letter, they could successfully complete the task.
For example, if the target letter was in the fourth position and the string was presented
for 30ms, the participant couldn't complete the task successfully, but if string was
presented for 40ms, they could complete the task successfully. Gough noted that a rate
of 10ms per letter would be consistent with a typical reading rate of 300 wpm.
The serial letter recognition model is also able to successfully predict that shorter words
are recognized faster than longer words. It is a very robust finding that word recognition
takes more time with longer words. It takes more time to recognize a 5-letter word than
a 4-letter word, and 6-letter words take more time to recognize than 5-letter words. The
serial letter recognition model predicts that this should happen, while a word shape
model does not make this prediction. In fact, the word shape model should expect
longer words with more unique patterns to be easier to recognize than shorter words.
The serial letter recognition model fails because it cannot explain the Word Superiority
Effect. The Word Superiority Effect showed that readers are better able to identify letters
in the context of a word than in isolation, while the serial letter recognition model would
expect that a letter in the third position in a word should take three times as long to
recognize as a letter in isolation.

Model #3: Parallel Letter Recognition
The model that most psychologists currently accept as most accurate is the parallel
letter recognition model. This model says that the letters within a word are recognized
simultaneously, and the letter information is used to recognize the words. This is a very
active area of research and there are many specific models that fit into this general
category. I will only discuss one popular formulation of this model.
Figure 4 shows a generic activation based parallel letter recognition model. In this
example, the reader is seeing the word work. Each of the stimulus letters are processed
simultaneously. The first step of processing is recognizing the features of the individual
letters, such as horizontal lines, diagonal lines, and curves. The details of this level are
not critical for our purposes. These features are then sent to the letter detector level,
where each of the letters in the stimulus word are recognized simultaneously. The letter

level then sends activation to the word detector level. The W in the first letter detector
position sends activation to all the words that have a W in the first position (WORD and
WORK). The O in the second letter detector position sends activation to all the words
that have an O in the second position (FORK, WORD, and WORK). While FORK and
WORD have activation from three of the four letters, WORK has the most activation
because it has all four letters activated, and is thus the recognized word.

Figure 4: Parallel Letter Recognition
Much of the evidence for the parallel letter recognition model comes from the eye
movement literature. A great deal has been learned about how we read with the advent
of fast eye trackers and computers. We now have the ability to make changes to text in
real time while people read, which has provided insights into reading processes that
weren't previously possible.
It has been known for over 100 years that when we read, our eyes don't move smoothly
across the page, but rather make discrete jumps from word to word. We fixate on a
word for a period of time, roughly 200-250ms, then make a ballistic movement to
another word. These movements are called saccades and usually take 20-35ms. Most
saccades are forward movements from 7 to 9 letters, but 10-15% of all saccades are
regressive or backwards movements.
(Average saccade length and fixation times vary by language. The data presented here
are for American English readers. While the values vary by language, it is remarkable
that reading cognitive processes change so little from language to language.)
Most readers are completely unaware of the frequency of regressive saccades while
reading. The location of the fixation is not random. Fixations never occur between
words, and usually occur just to the left of the middle of a word. Not all words are

fixated; short words and particularly function words are frequently skipped. Figure 5
shows a diagram of the fixation points of a typical reader.

Figure 5: Saccadic eye movements
During a single fixation, there is a limit to the amount of information that can be
recognized. The fovea, which is the clear center point of our vision, can only see three to
four letters to the left and right of fixation at normal reading distances. Visual acuity
decreases quickly in the parafovea, which extends out as far as 15 to 20 letters to the left
and right of the fixation point.
Eye movement studies that I will discuss shortly indicate that there are three zones of
visual identification. Readers collect information from all three zones during the span of
a fixation. Closest to the fixation point is where word recognition takes place. This zone
is usually large enough to capture the word being fixated, and often includes smaller
function words directly to the right of the fixated word. The next zone extends a few
letters past the word recognition zone, and readers gather preliminary information
about the next letters in this zone. The final zone extends out to 15 letters past the
fixation point. Information gathered out this far is used to identify the length of
upcoming words and to identify the best location for the next fixation point. For
example, in Figure 5, the first fixation point is on the s in Roadside. The reader is able to
recognize the word Roadside, beginning letter information from the first few letters in
joggers, as well as complete word length information about the word joggers. A more
interesting fixation in Figure 5 is the word sweat. In this fixation both the words sweat
and pain are short enough to be fully recognized, while beginning letter information is
gathered for and. Because and is a high frequency function word, this is enough
information to skip this word as well. Word length information is gathered all the way
out to angry, which becomes the location of the next fixation.
There are two experimental methodologies that have been critical for understanding the
fixation span: the moving window paradigm and the boundary study paradigm. These
methodologies make it possible to study readers while they are engaged in ordinary
reading. Both rely on fast eye trackers and computers to perform clever text
manipulations while a reader is making a saccade. While making a saccade, the reader is

functionally blind. The reader will not perceive that text has changed if the change is
completed before the saccade has finished.
Moving Window Study
In the moving window technique we restrict the amount of text that is visible to a
certain number of letters around the fixation point, and replace all of the other letters on
a page with the letter x. The readers task is simply to read the page of text. Interestingly
it is also possible to do the reverse and just replace the letters at the fixation point with
the letter x, but this is very frustrating to the reader. If just the three letters to the left
and right of the fixation point are replaced with x, then reading rate drops to 11 words
per minute. McConkie & Rayner (1975) examined how many letters around the fixation
point are needed to provide a normal reading experience. Figure 6 shows a snapshot of
what a reader would see if they are reading a passage and fixated on the second e in
experiment. If the reader is provided three letters past the fixation point, then they won't
see the entire word for experiment, and their average reading rate will be a slow 207
words per minute. If the reader is given 9 letters past the fixation point, they will see the
entire word experiment, and part of the word was. With 9 letters, reading rate is
moderately slowed. If the reader is given 15 letters past the fixation point, reading speed
is just as fast as if there was no moving window present. Up to 15 letters there is a linear
relation between the number of letters that are available to the reader and the speed of
reading.
Window Size

Sentence

Reading Rate

3 letters

An experimxxx xxx xxxxxxxxx xx

207 wpm

9 letters

An experiment wax xxxxxxxxx xx

308 wpm

15 letters

An experiment was condxxxxx xx

340 wpm

Figure 6: Linear relationship between letters available in moving window and reading
rate.
From this study we learned that our perceptual span is roughly 15 letters. This is
interesting as the average saccade length is 7-9 letters, or roughly half our perceptual
span. This indicates that while readers are recognizing words closer to the fovea, we are
using additional information further out to guide our reading. It should be noted that
we're only using information to the right of our fixation point, and that we don't use any
letters to the left of the word that is currently being fixated. In figure 6, where the user's
fixation point is on the second e in experiment, if the word An is removed, it will not
further slow reading rate.

The moving window study demonstrates the importance of letters in reading, but is not
airtight. The word shape model of reading would also expect that reading speed would
decrease as word shape information disappears. The word shape model would make the
additional prediction that reading would be significantly improved if information on the
whole word shape were always retained. This turns out to be false.
Figure 7 shows the reading rate when three letters are available. It is roughly equivalent
to the reading rate when the fixated word is entirely there. That's true even though the
entire word has 0.7 more letters available on average. When the fixated word and the
following word are entirely available, reading rate is equivalent to when 9 letters are
available. Reading rate is also equivalent when three words or 15 letters are available.
This means that reading is not necessarily faster when entire subsequent words are
available; similar reading speeds can be found when only a few letters are available.
Window Size

Sentence

Reading Rate

3 letters

An experimxxx xxx xxxxxxxxx xx

207 wpm

1 word (3.7 letters)

An experiment xxx xxxxxxxxx xx

212 wpm

9 letters

An experiment wax xxxxxxxxx xx

308 wpm

2 words (9.6 letters)

An experiment was xxxxxxxxx xx

309 wpm

15 letters

An experiment was condxxxxx xx

340 wpm

3 words (15.0 letters)

An experiment was conducted xx

339 wpm

Figure 7: Full word information does not improve reading rate.
Pollatsek & Rayner (1982) used the moving window paradigm to compare reading when
the word spaces were present to when they are replaced with an x. They found that
saccade length is shorter when word space information is not available.
Boundary Study
The boundary study (Rayner, 1975) is another innovative paradigm that eye trackers and
computers made possible. With the boundary study we can examine what information
the reader is using inside the perceptual span (15 letters), but outside of the word that is
being fixated. Figure 8 illustrates what the reader sees in this kind of study. While
reading the words The old captain, the reader will be performing ordinary reading. When
the reader reaches the word put, the key word of interest becomes available within the
reader's fixation span. In this example the key word is ebovf. When the reader saccades
from put to ebovf, the saccade will cross an invisible boundary which triggers a change
in the text. Before the saccade finishes, the text will change to the correct text for the

sentence, in this case chart. The reader will always fixate on the correct word for the
sentence.

Figure 8: The string of letters _ebovf_ after the boundary changes to _chart_ during the
saccade.
The critical word in this study is presented in different conditions including an identical
control condition (chart), similar word shape and some letters in common (chovt),
dissimilar word shape with some letters in common (chyft), and similar word shape with
no letters in common (ebovf). The fixation times for the words both before and after the
boundary are measured. The fixation times before the boundary are the same for the
control condition and the three experimental conditions. After the boundary, readers
were fastest reading with the control condition (chart), next fastest reading with similar
word shape and some letters in common (chovt), third fastest with the condition with
only some letters in common (chyft), and slowest with the condition with only similar
word shape (ebovf). This demonstrates that letter information is being collected within
the fixation span even when the entire word is not being recognized.
chart

Identical word (control)

210ms

chovt

Similar word shape

240ms

Some letters in common
chyft

Dissimilar word shape
Some letters in common

280ms

ebovf

Similar word shape
No letters in common

300ms

Figure 9: Relative speed of boundary study conditions
Having letters in common played greater role in fixation times in this study. But it does
not eliminate the role of word shape because of the combination of word shape and
letters in common facilitates word recognition. Rayner (1975) further investigated what
happens with a capitalized form of the critical word (CHART). This eliminates the role of
word shape, but retains perfect letter information. They found that the fixation times are

the same as the control condition! This demonstrates that it is not visual information
about either word shape or even letter shape that is being retained from saccade to
saccade, but rather abstracted information about which letters are coming up.
The eye movement literature demonstrates that we are using letter information to
recognize words, as we are better able to read when more letters are available to us. We
combine abstracted letter information across saccades to help facilitate word
recognition, so it is letter information that we are gathering in the periphery. And finally
we are using word space information to program the location of our next saccade.

Evidence for Word Shape Revisited
So far I've presented evidence that supports the word recognition model, evidence that
contradicts the serial word recognition model, and eye tracking data that contradicts the
word shape model while supporting the parallel letter recognition model. In this section
I will reexamine the data used to support the word shape model to see if it is
incongruent with the parallel letter recognition model.
The strongest evidence for the word shape model is perhaps the word superiority effect
which showed that letters can be more accurately recognized in the context of a word
than in isolation, for example subjects are more accurate at recognizing D in the context
of WORD than in the context of ORWD (Reicher, 1969). This supports word shape
because subjects are able to quickly recognize the familiar word shape, and deduce the
presence of letter information after the stimulus presentation has finished while the
nonword can only be read letter by letter. McClelland & Johnson (1977) demonstrated
that the reason for the word superiority effect wasn't the recognition of word shapes,
but rather the existence of regular letter combinations. Pseudowords are not words in
the English language, but have the phonetic regularity that make them easily
pronounceable. Mave and rint are two examples of pseudowords. Because pseudowords
do not have semantic content and have not been seen previously by the subjects, they
should not have a familiar word shape. McClelland & Johnson found that letters are
recognized faster in the context of pseudowords (mave) than in the context of nonwords
(amve). This demonstrates that the word superiority effect is caused by regular letter
combinations and not word shape.
The weakest evidence in support of word shape is that lowercase text is read faster than
uppercase text. This is entirely a practice effect. Most readers spend the bulk of their
time reading lowercase text and are therefore more proficient at it. When readers are
forced to read large quantities of uppercase text, their reading speed will eventually
increase to the rate of lowercase text. Even text oriented as if you were seeing it in a
mirror will quickly increase in reading speed with practice (Kolers & Perkins, 1975).

Haber & Schindler (1981) found that readers were twice as likely to fail to notice a
misspelling in a proofreading task when the misspelling was consistent with word shape
(tesf, 13% missed) than when it is inconsistent with word shape (tesc, 7% missed). This is
seemingly a convincing result until you realize that word shape and letter shape are
confounded. The study compared errors that were consistent both in word and letter
shape to errors that are inconsistent both in word and letter shape. Paap, Newsome, &
Noel (1984) determined the relative contribution of word shape and letter shape and
found that the entire effect is driven by letter shape.
Figure 10 shows the example word than _in each of the four permutations of same and
different word shape, and same and different letter shape. As with Haber & Schindler,
subjects fail to notice misspellings with the same word shape and same letter shape (_tban,
15% missed) far more often than when there is a different word shape and letter shape
(tman, 10% missed). The two in between conditions of different word shape with same
letter shape (tnan, 19% missed) and same word shape with different letter shape (tdan,
8% missed) are illuminating. There is a statistically reliable difference between the larger
number of proofreading errors when the letter shape is the same (tban and tnan) than
when the letter shape is different (tdan and tman). While there is no statistically reliable
difference between conditions with same word shape (tban and tdan) and different word
shape (tnan and tman), more errors are missed when the word shape is different. This
trend sharply contradicts the conclusions of the earlier studies.
t_h_an

Same word shape

Different word shape

Same letter shape

t_b_an

t_n_an

15% missed

19% missed

t_d_an

t_m_an

8% missed

10% missed

Different letter shape

Figure 10: Word shape and letter shape contributions to proofreading errors.
The final source of evidence supporting the word shape model is that text written in
alternating case is read slower than either text in lowercase or uppercase. This supports
the word shape model because subjects are able to quickly recognize the familiar
pattern of a word written entirely in lowercase or uppercase, while words written in
alternating case will have an entirely novel word shape. Adams (1979) showed that this
is not the case by examining the effect of alternating case on words, which should have
a familiar pattern when written in lowercase or uppercase words, and pseudowords,
which should not have a familiar pattern in any form because the subjects would never
have come across that sequence of letters before. Adams found that both words and
pseudowords are equally hurt by alternating case. Since pseudowords are also impacted
by alternating case, then the effect is not caused by word shape.

Further examination of the evidence used to support the word shape model has
demonstrated that the case for the word shape model was not as strong as it seemed.
The word superiority effect is caused by familiar letter sequences and not word shapes.
Lowercase is faster than uppercase because of practice. Letter shape similarities rather
than word shape similarities drive mistakes in the proofreading task. And pseudowords
also suffer from decreased reading speed with alternating case text. All of these findings
make more sense with the parallel letter recognition model of reading than the word
shape model.
In the next section I will describe an active area of research within the parallel letter
recognition model of reading. There are many models of reading within parallel letter
recognition, but it is beyond the scope of this paper to discuss them all. Neural network
modeling, sometimes called connectionist modeling or parallel distributed processing,
has been particularly successful in advancing our understanding of reading processes.

Neural Network Modeling
In neural network modeling we use simple, low-level mechanisms that we know to exist
in the brain in order to model complex, human behavior. Two of the core biological
principles have been known for a long time. McCulloch & Pitts (1943, 1947) showed that
neurons sum data from other neurons. Figure 11 shows a tiny two dimensional field of
neurons (the dark triangles) and more importantly the many, many input and output
connections for each neuron. Current estimates say that every neuron in the cerebral
cortex has 4,000 synapses. Every synapse has a baseline rate of communication between
neurons and can either increase that rate of communication to indicate an excitatory
event or decrease the rate of communication to indicate an inhibitory event. When a
neuron gets more excitatory information than inhibitory information, it will become
active. The other core biological principle is that learning is based on the modification of
synaptic connections (Hebb, 1949). When the information coming from a synapse is
important the connection between the two neurons will become physically stronger, and
when information from a synapse is less important the synapse will weaken or even die
off.

Figure 11: A field of neurons and synapses in the cerebral cortex
The first well-known neural network model of reading was McClelland & Rumelhart's
Interactive Activation model (1981). Figure 12 diagrams how this model works. The
reader here is processing the letter T in the first position in a word. The flow of
information here starts at the bottom where there are visual feature detectors. The two
nodes on the left are active because they match the features of an uppercase T, while
the three nodes on the right are not active because they don't match. Every node in the
visual feature detector level is connected to every node in the letter detector level. The
letters seen here apply only to the first letter of a word. The connections between the
visual feature detector level and the letter level are all either excitatory (represented with
an arrow at the end of the connection) or inhibitory (represented with a circle at the end
of the connection). The letters A, T, and S all received some excitatory activation from
the two left feature detectors because all three have a crossbar at the top of the letter
(at least in this font). The inhibitory connections between each of the letters will result in
the T being the most activated letter node because it has the most incoming excitatory
activation. The letter node for T will then send excitatory activation to all the words that
start with T and inhibitory activation to all the other words. As word nodes gain in
activation, they will send inhibitory activation to all other words, excitatory activation
back to letter nodes from letters in the word, and inhibitory activation to all other letter
nodes. Letters in positions other than the first are needed in order to figure out which of
the words that start with T is being read.

Figure 12: McClelland and Rumelhart's Interactive Activation model: A few of the
neighbors of the node for the letter T in the first position in a word, and their
interconnections.
One of the joys of neural network modeling is that it's specific enough to be
programmed into a computer and tested. The interactive activation model is able to
explain human behaviors that it was not specifically designed for. For example when a
human is shown the degraded stimulus in figure 13, it is very easy to figure out that
WORK is the degraded word, but the computer simulation of this model can also solve
this problem.

Figure 13: This degraded stimulus is easily read as _WORK_ by human readers.
The computer simulation does not attempt to solve the visual perception problem, but
rather is told which of the visual feature detectors are on for each letter position. For the
fourth letter position the computer simulation is told that there is a vertical line on the
left, a crossbar in the middle, and a diagonal pointing towards the bottom right. Figures
14 and 15 show the activation levels of certain letter and word nodes over time. Time in
the computer is measured in epochs of activation events. Figure 14 shows the early
activation equally rising for the k and r letter nodes. This is because the visual feature
information supports both of those letters, while the d letter node is unsupported.

During the early epochs the letter nodes are only receiving activation from the visual
feature nodes, but later activation is provided by the word nodes. Figure 15 shows the
activation among four words: work, word, weak, and wear. Since the first three letters of
the word are not degraded, the letter nodes easily recognized them as w, o, and r for
the first three positions respectively. These letters provide early activation for the words
work and word, but not for weak and wear. The word nodes then start to send activation
back down to the letter node level indicating that the fourth letter could be k or d. Since
k is already an active letter node while d is an inactive node, the k node is further
strengthened. This allows the k letter node and the word work to continuously increase
in activation and send inhibitory activation to their competitors, the letter r and the
word word. Similar activation patterns can also explain the word superiority effect.

Figure 14: The activation level over time for letter nodes in the fourth position of a word.

Figure 15: The activation level over time for four word nodes.
Seidenberg & McClelland (1989) and Plaut, McClelland, Seidenberg, & Patterson (1996)
have made great progress in developing neural network models of reading that can
account for more human reading behaviors. Both of these models concentrate on the
reading processes that start after each of the letters in a word have been recognized.
The internal representations for these models convert the letter information to
phonemic information, which is seen as a mandatory step for word recognition. It is well

known that words that have a consistent spelling to sound correspondence such as
mint, tint, and hint are recognized faster than words that have an inconsistent spelling to
sound correspondence such as pint (Glushko, 1979). These models are able to generate
correct word pronunciations (i.e. read) without the use of specific word nodes. The more
recent model is also able to read pseudowords at a near human rate and account for
consistency and frequency effects.
The Seidenberg & McClelland and Plaut et. al. models are able to simulate not only
adult reading, but can also simulate a child learning to read. Initially the neural network
model starts out with no knowledge about the relationship between letters and
pronunciations, only that letters and sounds exist. The neural net goes through a
training phase where the network is given examples of correct pronunciations for
different words. After seeing a correct sample, the network will calculate the error in its
guess of the pronunciation, and then modifies the strength of each of the nodes that
are connected to it so that the error will be slightly less next time. This is analogous to
what the brain does. After a few rounds of training, the model may be able to read a few
of the most high frequency, regular words. After many rounds of training the model will
be able to read not only words it has seen before, but words it hasn't seen before as
well.

Conclusions
Given that all the reading research psychologists I know support some version of the
parallel letter recognition model of reading, how is it that all the typographers I know
say that we read by matching whole word shapes? It appears to be a grand
misunderstanding. The paper by Bouma that is most frequently cited does not support a
word shape model of reading. Bouma (1973) presented words and unpronounceable
letter strings to subjects away from the fixation point and measured their ability to name
the first and last letters. He found that:
A) Subjects are more successful at naming letters to the right of fixation than to the left
of fixation.
B) When distance to the right of the fixation point is controlled, subjects are better able
to recognize the last letter of a word than the first letter of word. This data explains why
it is that we tend to fixate just to the left of the middle of a word.
Bouwhuis & Bouma (1979) extended the Bouma (1973) paper by not only finding the
probability of recognizing the first and last letters of a word, but also the middle letters.
They used this data to develop a model of word recognition based on the probability of
recognizing each of the letters within a word. They conclude that 'word shape … might
be satisfactorily described in terms of the letters in their positions.' This model of word

recognition clearly influenced the McClelland & Rumelhart neural network model
discussed earlier which also used letters in their positions to probabilistically recognize
words.
Word shape is no longer a viable model of word recognition. The bulk of scientific
evidence says that we recognize a word's component letters, then use that visual
information to recognize a word. In addition to perceptual information, we also use
contextual information to help recognize words during ordinary reading, but that has no
bearing on the word shape versus parallel letter recognition debate. It is hopefully clear
that the readability and legibility of a typeface should not be evaluated on its ability to
generate a good bouma shape.

Why I wrote this paper
I (Kevin Larson) am a psychologist who has been working for Microsoft in different
capacities since 1996. In 2000 I completed my PhD in cognitive psychology from the
University of Texas at Austin studying word recognition and reading acquisition. I joined
the ClearType team in 2002 to help get a better scientific understanding of the benefits
of ClearType and other reading technologies with the goal of achieving a great onscreen reading experience.
During my first year with the team I gave a series of talks on relevant psychological
topics, some of which instigated strong disagreement. At the crux of the disagreement
was that the team believed that we recognized words by looking at the outline that
goes around a whole word, while I believed that we recognize individual letters. In my
young career as a reading psychologist I had never encountered a model of reading that
used word shape as perceptual units, and knew of no psychologists who were working
on such a model. But it turns out that the model had a very long history that I was
unfamiliar with.

References
Adams, M.J. (1979). Models of word recognition. Cognitive Psychology, 11, 133-176.
Bouma, H. (1973). Visual Interference in the Parafoveal Recognition of Initial and Final
Letters of Words, Vision Research, 13, 762-782.
Bouwhuis, D. & Bouma, H. (1979). Visual word recognition of three letter words as
derived from the recognition of the constituent letters, Perception and Psychophysics, 25,
12-22.
Cattell, J. (1886). The time taken up by cerebral operations. Mind, 11, 277-282, 524-538.

Fisher, D.F. (1975). Reading and visual search. Memory and Cognition, 3, 188-196.
Glushko, R.J. (1979). The organization and activation of orthographic knowledge in
reading aloud. Journal of Experimental Psychology: Human Perception and Performance,
5, 674-691.
Gough, P.B. (1972). One second of reading. In Kavanagh & Mattingly's Language by ear
and by eye. Cambridge, MA: MIT Press.
Haber, R.N. & Schindler, R.M. (1981). Errors in proofreading: Evidence of syntactic
control of letter processing? Journal of Experimental Psychology: Human Perception and
Performance, 7, 573-579.
Hebb, D.O. (1949). The organization of behavior. New York: Wiley.
Mason, M. (1978). From print to sound in mature readers as a function of reader ability
and two forms of orthographic regularity, Memory and Cognition, 6, 568-581.
Kolers, P.A. & Perkins, D.N. (1975). Spatial and ordinal components of form perception
and literacy. Cognitive Psychology, 7, 228-267.
McClelland, J.L. & Johnson, J.C. (1977). The role of familiar units in perception of words
and nonwords. Perception and Psychophysics, 22, 249-261.
McClelland, J.L. & Rumelhart, D.E. (1981). An interactive activation model of context
effects in letter perception: Part 1. An account of basic findings. Psychological Review, 88,
375–407.
McCulloch, W.S. & Pitts, W. (1943). A logical calculus of the ideas immanent in nervous
activity. Bulletin of Mathematical Biophysics, 5, 115-133.
McConkie, G.W. & Rayner, K. (1975). The span of the effective stimulus during a fixation
in reading. Perception and Psychophysics, 17, 578-586.
Meyer, D.E. & Gutschera, K.D. (1975). Orthographic versus phonemic processing of
printed words. Psychonomic Society Presentation.
Monk, A.F. & Hulme, C. (1983). Errors in proofreading: Evidence for the use of word
shape in word recognition. Memory and Cognition, 11, 16-23.
Paap, K.R., Newsome, S.L., & Noel, R.W. (1984). Word shape's in poor shape for the race
to the lexicon. Journal of Experimental Psychology: Human Perception and Performance,
10, 413-428.
Pitts, W. & McCulloch, W.S. (1947). How we know universals: the perception of auditory
and visual form. Bulletin of Mathematical Biophysics 9: 127-147.

Plaut, D.C., McClelland, J.L., Seidenberg, M.S., & Patterson, K. (1996). Understanding
normal and impaired word reading: Computational principles in quasi-regular domains.
Psychological Review, 103, 56–115.
Pollatsek, A. & Rayner, K. (1982). Eye movement control in reading: The role of word
boundaries. Journal of Experimental Psychology: Human Perception and Performance, 8,
817-833.
Pollatsek, A., Well, A.D., & Schindler, R.M. (1975). Effects of segmentation and expectancy
on matching time for words and nonwords. Journal of Experimental Psychology: Human
Perception and Performance, 1, 328-338.
Rayner, K. (1975). The perceptual span and peripheral cues in reading. Cognitive
Psychology, 7, 65-81.
Rayner, K., McConkie, G.W., & Zola, D. (1980). Integrating information across eye
movements. Cognitive Psychology, 12, 206-226.
Reicher, G.M. (1969). Perceptual recognition as a function of meaningfulness of stimulus
material. Journal of Experimental Psychology, 81, 275-280.
Seidenberg, M.S., & McClelland, J.L. (1989). A distributed, developmental model of word
recognition and naming. Psychological Review, 96, 523–568.
Smith, F. (1969). Familiarity of configuration vs. discriminability of features in the visual
identification of words. Psychonomic Science, 14, 261-262.
Sperling, G. (1963). A model for visual memory tasks. Human Factors, 5, 19-31.
Woodworth, R.S. (1938). Experimental psychology. New York; Holt.

Suggested Readings
If you're just looking for a couple of papers on reading psychology. I recommend these
four:
1. Rayner, K. (1998). Eye movements in reading and information processing: 20 years of
research. Psychological Review, 124 (3), 372-422.
This paper is an account of the eye movement field from the premier eye tracking
researcher.
2. Plaut, D.C., McClelland, J.L., Seidenberg, M.S., & Patterson, K. (1996). Understanding
normal and impaired word reading: Computational principles in quasi-regular domains.
Psychological Review, 103, 56–115.

This is the most recent of the major neural network papers, and is available on David
Plaut's website. http://www.cnbc.cmu.edu/~plaut/
3. Stanovich, K.E (1986). Matthew effects in reading: Some consequences of individual
differences in the acquisition of literacy. Reading Research Quarterly, 21, 360-407.
This is one of the most cited reading papers of all time. If you are interested in reading
acquisition this is the place to start.
4. Hoover, W.A. & Gough, P.B. (1990). The simple view of reading. Reading & Writing,
2(2), 127-160.
This paper demonstrates that word recognition and context are two separate skills that
are both necessary for reading.

OpenType development
Article • 11/13/2021
⚠ Legacy information: We're no longer updating this content regularly.

Introduction
The OpenType Layout model provides a powerful architecture for supporting complex
scripts and advanced typography. The infrastructure has three components:
A publicly specified file format that supports advanced typographic layout
information (OpenType)
Windows System Services that produce "shaped" and positioned glyph strings
from character strings (RichEdit and Uniscribe, the Unicode Script Processor)
A freely available, cross-platform library for low-level access to layout information
and layout operations (OpenType Layout Services Library) OpenType font format
OpenType fonts may contain either TrueType or PostScript outlines. The fonts are
Unicode-based and allow a rich mapping between characters and glyphs. This enables
support for ligatures, positional forms, alternates, and other substitutions. OpenType
fonts also may include information that supports two-dimensional glyph positioning
and glyph attachment.
Layout features within OpenType fonts are organized by scripts and languages. Thus
allowing a single font to support multiple writing systems, even within the same script.
OpenType fonts are not dependent on a single character-encoding scheme, and in fact
the format supports all the encoding schemes in common use today. Internally,
however, all OpenType fonts are "plumbed" with Unicode.

Windows system services
Windows provides service libraries that assist applications in text-layout operations.
Many Microsoft applications now use these libraries, which provide consistency, save
development time, and insulate product developers from many complex script issues.
These libraries are publicly exposed as a part of the operating system, are documented
in the Windows SDK, and are governed by the same licensing restrictions as the rest of
the operating system.
Although any text layout client may use these services to perform the bulk of text
layout, the interfaces are also designed to allow clients to use the services to augment

the operation of their own proprietary text engines.

Unicode script processor
The Unicode Script Processor (USP10.DLL) is a collection of API's that enable a textlayout client to format complex scripts. The Unicode Script Processor, aka "Uniscribe,"
supports the complex rules found in scripts such as Arabic, Indian, and Thai. Uniscribe
also handles scripts written from right-to-left, such as Arabic or Hebrew, and supports
the mixing of scripts.
Uniscribe has multiple shaping engines that contain the layout knowledge for particular
scripts (for example, Arabic, Hebrew, Thai, Hindi, Tamil). In addition, there is an
OpenType Layout shaping engine for handling script features unknown to Uniscribe.
Uniscribe provides character-to-glyph mapping; dx,dy positioning; line breaking at word
boundaries; hit testing and cursor positioning.
Uniscribe subdivides strings of characters into "items" (a character string having all the
same script and direction attributes), "runs" (portions of an item that have continuous
formatting attributes), and "clusters" (script-defined, indivisible character groupings). A
client builds runs based on its own stored formatting attributes, and on the item
boundaries obtained from Uniscribe.
Using Uniscribe, clients need only manage a backing store of Unicode character codes,
typed by the user in "logical order" (as defined by Unicode). Text-layout clients do not
need to maintain any other buffer or mapping table to track character order, and the
backing store never changes as a result of layout operations.
Clients of Uniscribe include: Win32 API's, plain text applets, edit controls, RichEdit 3.0,
Wordpad, Office9, Internet Explorer 4.0+, FrontPage Express, Outlook Express. It ships
with Windows 2000, Internet Explorer 4.0 and greater. Uniscribe may also be used on
NT4, Windows 95 and Windows 98 systems.

RichEdit
RichEdit is a higher-level collection of interfaces that may be used to call Uniscribe or
other shaping engines or routines. RichEdit serves to further insulate text-layout clients
from the complexities of certain scripts.
RichEdit 3.0 provides fast, versatile editing of rich Unicode multilingual text and simple
plain text. It includes extensive message and COM interfaces. Features include text
editing, formatting, line breaking, simple table layout, vertical text layout, bidirectional
text layout, Indic and Thai support, a Word edit UI, and Text Object Model interfaces.

RichEdit is the simplest way for a client to support features of complex scripts. Clients
use the TextOut function of RichEdit to automatically parse, shape, position, and break
lines.
RichEdit is designed for clients whose primary purpose is not necessarily text layout, but
who nonetheless need to display complex scripts.

OpenType Layout Services Library (OTLS)
The OTLS is a set of text-processing helper functions. The services simplify the job of
text processing by insulating a client application from the details of the font file format.
The services library is freely available under license from Microsoft, and will ultimately be
distributed with the operating system.
Although any text-layout client may use these services to perform the bulk of text
layout, the interfaces are also designed to allow clients to use the services to augment
the operation of their own proprietary text engines.
The OTLS allow clients to work at the more familiar level of features and characters. The
OTLS will handle the details of lookup tables and glyph ID's, which may not be as
familiar.
The simplest way to use the OTLS is to identify sections of text with OTLS features and
use the text layout functions for all text-processing operations. In this approach, the
client is still responsible for deciding where to break lines, whether to do justification,
and whether to layout text in a device-dependent or device-independent fashion.
A more sophisticated client may directly manipulate the data structures of the text,
enabling the management of glyph substitution or positioning. Sophisticated clients
may also choose to intercept or replace resource management calls in order to handle
memory allocation or access font tables.
The OTLS can be used as a set of shareable functions (as a DLL), or used indirectly by
applications calling Uniscribe or RichEdit.

Encoding
Much of the knowledge about laying out text and the semantics of languages is
embodied in the system components. This model ensures consistency in the layout
operations that are required to arrive at the basic form, and relieves a font developer
from having to define generalized script rules within a font (as is the case with Apple
TrueType GX fonts).

Some clients may introduce their own knowledge or preferences regarding script layout;
and OpenType Layout fonts may contain layout features that duplicate or override those
applied by OS services. The layered structure of OS services supporting text-layout
allows a client to choose what layout information to use, and how to apply it. However,
such architecture also presents the possibility that duplicate feature information and
layout intelligence may exist in more than one place.
At a minimum, font developers should be able to expect that applications have
knowledge of (or services for executing) script rules as defined in the Unicode Standard.
Application developers should be able to expect that fonts have glyphs and positioning
information representing layout features as defined by the Unicode Standard.

Features
All of the features described in each of the script or language documents are
"registered" and supported by Uniscribe and clients of USP, such as RichEdit. Thus, they
provide a means for applications to work with operating system services to layout
complex scripts.
Regardless of the model an application chooses for supporting layout of complex
scripts, Uniscribe requires a fixed order for executing features within a run of text to
consistently obtain the proper basic form. The feature order is different for each script
or language system and is described within those documents.

Ordering lookups
Following the OpenType specification, the font developer defines the lookup sequence
in the lookup array to control the order a text processing client uses to apply lookup
data to glyph substitution and positioning operations. The order of the lookup within
the feature tag is critical for desired processing. The lookup you define first will take
priority.

Example: If you had 2 ligatures AB + BC defined in your lookup table, with the BC
listed first, and you typed ‘ABC’, you would only get the BC ligature, and not the
AB, because the B was already converted into the BC ligature.

Ordering ligatures and conjuncts

To ensure that ligatures and conjuncts are formed properly, substitutions must be
ordered so those with higher priority take precedence. It is also important to form
longer lookups before shorter ones.
When forming ligatures, lookups must be encoded as follows:
The first substitution in a lookup maps the longest string of component characters
to the appropriate glyph. The next substitution provides the glyph corresponding
to the next longest string of characters, and so on. This is very important because
the search process through the lookups terminates with the first match.
For consonant conjuncts, full-form conjuncts must precede half forms.

For fi & ffi ligatures, feature tag ‘liga’, if you ordered 'uni0066, uni0069 -> uniFB00'
before 'uni0066, uni0066, uni0069 -> uniFB03' the ffi ligature would not be
formed, because the search process stopped with the fi.

When the longer lookup is listed first, the ffi ligature is formed correctly.

Client support
Supporting dx, dy arrays
Developing fonts > Specifications
OpenType development (3 of 5): Client support
Supporting dx, dy arrays
Applications can support dx, dy positioning of glyphs if they are running on Windows
NT5 and using USP and/or RichEdit 3.0 to create and position the glyph string.
ExtTextOut does not support delta y positioning on Windows NT4, Windows 98, or
Windows 95. Applications running on these platforms must call ExtTextOut multiple
times in order to support dx, dy positioning arrays, as follows:

1. Use the OTLS to produce the glyph string from character string.
2. Use the OTLS to obtain the advance width information for each glyph.
3. Create a buffer containing only glyphs with the same delta y value (say, dy1).
Replace glyphs having other delta y values with placeholders of the associated
advance widths.
4. Call ExtTextOut to position the glyphs with the same delta y (dy1).
5. Replace appropriate placeholders with next group of glyphs, all of which have the
same delta y (say, dy2).
6. Call ExtTextOut to position the glyphs with the same delta y (dy2).
7. Replace appropriate placeholders with next group of glyphs, all of which have the
same delta y (say, dy3).
8. Call ExtTextOut to position the glyphs with the same delta y (dy3).
9. Continue replacing placeholders and calling ExtTextOut for each group of glyphs
with discrete delta y values.
This process is illustrated in the diagram below.
Making multiple ExtTextOutcalls to perform dy positioning on systems without dx, dy
support:

Suggested glyphs
General punctuation and ‘Latin’ numbers
In addition to script and language specific punctuation and native numbers, general
punctuation and 'Latin' numbers are highly recommended for inclusion in all OpenType
Layout fonts.

Unicode range 0020 to 003F

The euro
The European currency sign called the 'euro', should also be included in all OpenType
Layout fonts. The Unicode assignment of the 'euro' symbol is U+20AC.

Suggested glyphs for Microsoft Office
These 41 glyphs are recommended for inclusion in all OpenType Layout fonts so they
will function properly in Microsoft Office applications:

Suggested glyphs for complex scripts
Combining marks and signs that appear in text not in conjunction with a valid
consonant base are considered invalid. Uniscribe displays these marks using the fallback
rendering mechanism, on a dotted circle. For the fallback mechanism to work properly,
an OTL font should contain a glyph for the dotted circle (U+25CC). In case this glyph is

missing from the font, the invalid signs will be displayed on the missing glyph shape
(white box).
To render a sign standalone (in apparent isolation from any base) one should apply it on
a space. Uniscribe requires a ZWJ (zero width joiner U+200C) to be placed between the
space and a mark for them to combine into a standalone sign. A ZWNJ (zero width nonjoiner; U+200D) can be used between two letters to prevent them from forming a
cursive connection.

Suggested glyphs for right-to-left scripts
In addition to the above glyphs for complex scripts, directional marks for right-to-left
scripts should be included: LTR (left-to-right mark; U+200E), and RTL (right-to-left mark;
U+200F).

Tools
Tools available for building OpenType fonts supporting Arabic fonts are the same used
for the creation of all OpenType Layout fonts. Click through the links for download or
availability information.
ADDTABLE - A tool for adding tables to existing fonts. The tool properly updates
offset entries and checksum values.
TTOASM and TTODASM - Assembler/disassembler of OpenType Layout tables.
These tools create binary table files that can then be added to an existing font
using the ADDTABLE tool.
VOLT Visual OpenType Layout Tool (VOLT) - This tool is used to visually specify
ligatures, other glyph substitution operations, and glyph positioning operations.
The tool automatically builds the source files required for the TTOASM assembler.
VTT Visual TrueType (VTT) - This tool is used for hinting OpenType fonts, and also
includes the TTOASM tool.
SIGNCODE (OpenType Font Signing Tool) - This tool is used to add a digital
signature to OpenType fonts, indicating the publisher and "sealing" the bits of the

font.
End of OpenType Development document.

Windows Glyph List Version 4.0
Character Set (WGL4)
Article • 09/23/2020

The Windows Glyph List is a list of characters that are recommended to be supported in
fonts designed for Windows that support Latin script.
The details are provided in separate pages broken down by Unicode character ranges,
as follows:
Unicode range U+0020 through U+00BB
Unicode range U+00BC through U+017E
Unicode range U+017F through U+1EF3
Unicode range U+2013 through U+FB02
The following resources provide other related information:
Notes about the Euro Currency Symbol
Adobe Glyph List Specification

Convert a Devanagari font to Unicode /
OTL
Article • 09/23/2020

Whichever way you look at it, having only Mangal is hardly sufficient for all text
processing purposes and for all the languages that use the script. We would like to see
many more Unicode Devanagari fonts appear, and hope that appropriate standards will
emerge along the way.
So, suppose you have a font that was used to print Devanagari in some proprietary
encoding. What does it take to convert it to Unicode? Where do I start?
There are several steps involved. This posting will briefly outline them. For more details
one would refer to the Unicode Standard , the OpenType specification and the VOLT
release notes. Different approaches are of course possible so please take my writings
with a grain of salt. They only reflect one person's limited experience.

Glyph set
1. Examine your font and make sure it covers the Unicode range for Devanagari.
There should be at least one glyph for each code point in the Devanagari range. If,
for example, your encoding assumed that DEVANAGARI LETTER O is coded as
DEVANAGARI LETTER A plus DEVANAGARI VOWEL SIGN O, you would probably
need to create a new glyph for DEVANAGARI LETTER O.
As a result of this step, you may be creating several new glyphs that are, in fact,
composites of already existing shapes (so you don't really need to design new
shapes for them).
You may end up creating composite glyphs from already existing shapes for the
steps below as well. In fact, creating composites in your font as an alternative to
complex OTL processing may significantly decrease complexity of your VOLT
tables. Which is a good thing. So whenever you face an alternative of introducing a
new complex (e.g. context-based) lookup or a dozen new composite glyphs in the
font, I suggest you always choose the latter. (Of course if you need to create
several hundred new glyphs, it's different)
2. Make sure your font has all forms prescribed by the Creating and supporting
OpenType fonts for Devanagari specification. E.g. (this list is most probably
incomplete):

you should have glyphs for half forms for all consonants (for those that do
not have a distinctive half form, e.g. TTA or TTHA, use a composite with
halant)
nukta forms should be made as single glyphs as well
make sure you have glyphs for vattu ligatures (ligatures with below-base Ra)
for both full and half forms, with or without nuktas.
add glyphs for full and half forms of akhand forms: Kssa and Dnya.
This step will, again, most probably require you to produce quite a few of new
composite glyphs. The gain is simplicity of your VOLT tables and the help you get
from Uniscribe that controls application of those features.
3. It is also a good time to revisit your choice of conjuncts and alternate letterforms.
Now, you can load your font into VOLT and proceed with conversion.

Assign the right Unicode values to glyphs (in
VOLT)
Make sure that each Unicode code point from the Devanagari range is assigned the
correct glyph from your font. If your font had a CMAP table for your proprietary
encoding, the 'Unicode' fields for the glyphs will contain wrong values. You will need to
erase those and type in Unicode values instead. Glyphs that have no Unicode points
assigned to them should have the Unicode field left blank ("---"). They will be reached
through application of OT features.

Name your glyphs (in VOLT)
If you are doing multiple fonts, it is easy to share names through the export/import
glyph definitions feature. By sticking to one name convention you enable yourself to
share glyph, group and lookup definitions between fonts.

Make substitution lookups for standard
linguistic features
Akhands (2 substitutions for Devanagari), nukta forms, half forms, reph (1 substitution),
below-base forms (ra-vattu only, so this lookup will have only 1 substitution) and vattu
variants (ligatures with ra-vattu).

７ Note
These lookups are standard: what goes in there is pre-determined. They can 100%
be shared between your fonts as long as you use the same naming convention. E.g.
the lookup for half-forms ('half' feature) has substitutions of type:
<name for the full-form> halant -> <name for the half-form>

and there is really no deviation from it. Uniscribe controls the application of these
features so you do not need to worry when they need to be applied: the feature will
only be applied to the consonants that need to be in half form, and so on. (Again,
please see the specification for details on each feature type).
Now you can create appropriate features under Script: Devanagari, Language System:
Default and link them to the lookups you have created.

Create a ligature lookup for your conjuncts and
input all of them'
A typical ligature for a full-form conjunct would look like

"name for consonant 1 in half form"
"name for consonant 2" ->
"name for conjunct consonant1-consonant2"

When arranging these ligatures, follow 2 rules:
input longer sequences first, and
input substitutions for full form conjuncts before those for half-form conjuncts
Observance of these two rules will ensure linguistically correct usage of conjuncts.
Now, create a feature for pre-base substitutions ('pres') and link your new lookup to it.
At this point, if you compile and save your font, it is already capable of producing
legible text!! Do save it and try it out!

Typographical fine-tuning

Your font is already producing linguistically correct forms, the only job left is to make
sure it is pretty: forms connect properly, do not clash etc. This can basically be done by
using two techniques:
substituting alternate letterforms in presence of other glyphs. E.g. substituting the
right form of short-i matra, or the right form of other matras on certain
consonants, or ligating matras with vowel signs. Use features "pre-base
substitutions", "above-base substitutions", "below-base substitutions" and "postbase substitutions" for this kind of processing.
positioning. The basic example is anchoring matras on full consonants, or adjusting
their positions in presence of vowel signs. Use features "above-base marks" and
"below-base marks" from these lookups.
What is nice about this step is that it is incremental: you can improve the quality of your
font by adjusting positions or introducing new lookups for as long as you like. Please
have a look at Mangal to see what lookups can go in here.
A good rule of thumb for Typographical fine-tuning is: go through your glyph set and
look for any glyphs (alternate forms) you have not "used" yet. Think of what situations
they should appear in, and code these situations via contextual lookups. Then fine tune
with positioning.
If you had a font that could be used without OTL support to start with, very little will
need to be done at this step (because the font has already been designed to work as is
without adjustment). If the encoding was relying on the user choosing the right forms
manually (e.g. choosing the right form of matra E on top of consonants like KA), now
these rules need to be coded as lookups.

OpenType® Specification Version 1.9.1
Article • 05/31/2024

Core specification
OpenType overview
The OpenType font file
Font file tables
Advanced typographic extensions (OpenType layout)
OpenType layout common table formats
OpenType font variations overview
OpenType font variations common table formats

Errata
OpenType 1.9.1 errata

Appendices
Recommendations
OpenType Layout Tag Registry
OpenType Design-Variation Axis Tag Registry
TrueType outlines and instructions
TrueType fundamentals
Instructing TrueType Glyphs
The TrueType Instruction Set
Graphics State Summary
OpenType Mirroring Pairs list
Adobe technical note #5176: “The Compact Font Format Specification”
Adobe technical note #5177: “Type 2 Charstring Format”
Adobe Technical Note #5902: “PostScript Name Generation for Variation Fonts”
Comparison of 'glyf', 'CFF ' and CFF2 tables
Specification changes log file
OpenType 1.9.1 incorporates revisions in a preliminary working draft of the 5th edition of
the ISO/IEC 14496-22 “Open Font Format” standard. Current editions and amendments
of ISO/IEC 14496-22 are freely available for download from the ISO website
Updates to this specification are noted in the change log.

.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

OpenType Overview
Article • 05/31/2024

The OpenType font format is a widely-supported format for font data with a rich set of
capabilities for digital typography. It was developed as an extension of the original
TrueType format, using the same 'sfnt' container structure, and maintaining compatibility
for fonts created following the original TrueType specification. But several additional
capabilities are also supported, including the following:
Glyph outline data can use the CFF or CFF version 2 (“CFF2”) formats, as well as the
TrueType glyph format.
Multicolor glyph presentation is supported using embedded color bitmaps or SVG
documents, or using 2D graphic compositions defined in the font using a binary
format that combines outline-format glyphs with various graphics operations.
All Unicode® characters can be supported, including supplementary-plane
characters, as well as Unicode variation sequences.
OpenType Layout tables provide the advanced typographic capabilities needed for
high-quality typography as well as for international text using the wide variety of
scripts supported in The Unicode Standard® .
The mathematical typesetting table allows a font to include data required for layout
of complex, math formulas.
OpenType collection files enable multiple fonts that share common data to be
housed within a single file, allowing for de-duplication of data. This is especially
useful, for example, for sets of CJK (Chinese, Japanese, Korean) fonts of the same
design that share most glyphs in common but that vary with locale-specific glyphs
for certain characters.
Font variations (“variable fonts”) enable glyph outlines or other font data to be
variable based on one or more design-axis parameters. Whereas a collection file
can contain multiple discrete, static font resources, a variable font can provide
continuous variation in design along each of its axes. This can provide great
flexibility for content authors and designers while also allowing the font data for an
entire font family to be represented in an efficient format.
This specification is intended to be used in conjunction with other specifications.
While various legacy character encoding standards are supported, it is primarily
designed for use with The Unicode Standard

, which provides the universal

encoding for written characters and symbols, as well as specifications for how text
in different scripts is to be represented.

This specification defines OpenType Layout tables and low-level glyph substitution
and positioning operations needed for high-quality typography and for correct
display of Unicode text in various scripts. (See OpenType Layout Overview.) The
OpenType Layout feature registry defines various features that represent specific
typographic capabilities that may be supported in a font, and that are used to
activate those capabilities in a given font. Many features expose optional
capabilities that authors and typographers can choose to use at their discretion; for
example, small cap forms, or kerning. But many other features are used to activate
capabilities that are required for correct display of text; for example, required
ligatures for Arabic script, or positioning of mark glyphs. Many scripts supported in
Unicode have complex structural behaviors that require non-trivial operations,
implemented in applications or in text-layout and “shaping” libraries, to derive a
correct sequence of positioned glyphs for presentation of an underlying Unicode
string. The feature registry will include features that can be used in those
operations. However, complete specification of shaping algorithms for different
scripts is beyond the scope of this specification. Such algorithms can be
proprietary, “closed-source” implementations in particular applications; or they can
be defined in vendor-specific specifications or in other industry specifications.
Support for mathematical text involving complex formulas requires a content
format to describe text semantics combined with layout and presentation
capabilities. This specification defines the font-specific data that would be needed
for presentation. In this way, OpenType can be used to implement presentation
capabilities for other document format specifications, such as TEX or MathML

.

Certain features can be defined in the OpenType Layout feature tag registry to
support math layout operations.
Text layout involves operations within individual lines of text but also control over
arrangement of lines into larger blocks within a page or similar context. This
specification defines certain data that is used in block-level layout, such as default
line metrics (ascent, descent, leading). Also, certain features can be defined in the
OpenType Layout feature tag registry to support layout of text blocks for either
horizontal or vertical layout orientation. Complete specification of block level
layout is beyond the scope of this specification, however. It can be used in
conjunction with other specifications, such as Unicode Standard Annex #50:
Unicode Vertical Text Layout

.

Some font capabilities can be subject to tailoring by applications or other higherlevel protocols. For example, the TrueType instructions defined in this specification
define operations used in rasterization of glyph outlines, but applications can
supplement their own algorithms for final rasterization (for example, using oversampling, or control of sub-pixel display elements) to optimize legibility of glyphs.

Also, while the descriptions of features in the OpenType Layout feature tag registry
can specify expected usage, applications may tailor their usage of features subject
to other specifications or according to their own needs.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

OpenType Layout Overview
Article • 05/30/2024

OpenType Layout tables provide advanced typographic capabilities for high-quality
international typography:
A rich mapping between characters and glyphs, allowing for ligatures, positional
forms, alternates, and other substitutions.
Ability to perform two-dimensional positioning and glyph attachment.
Explicit script and language information, so a text-processing application can
adjust its behavior accordingly.
An open format that allows font developers to define their own typographical
features.
This overview introduces the power and flexibility of the OpenType Layout font model.
The OpenType Layout tables are described in more detail in separate sections of the
OpenType specification. See Advanced Typgraphic Tables.
Common formats used in different OpenType Layout tables are documented in the
“OpenType Layout Common Table Formats” chapter.
Registered OpenType Layout tags for scripts, languages, features and baselines are
documented in the chapter OpenType Layout Tag Registry.

OpenType Layout at a glance
OpenType Layout addresses complex typographic requirements for correct display of
many different scripts as well as for fine typography in any script.
Using OpenType Layout tables, fonts can support alternative forms of characters and
provide data used for accessing them. For example, in Arabic, the shape of a character
often varies with the character’s position in a word. As shown in the following figure, the
ha character will take any of four shapes, depending on whether it stands alone or
whether it falls at the beginning, middle, or end of a word. When performing text layout,
a text-processing application evaluates the word-position contexts in which the ha
character occurs, and then OpenType Layout data informs the application which glyph
to substitute for each context.

Figure 1a Isolated, initial, medial, and final forms of the Arabic character ha.

Similarly, OpenType Layout data can be used by an application to substitute the correct
forms of characters when text is positioned vertically instead of horizontally, such as
with Kanji. For example, Kanji uses alternative forms of parentheses when positioned
vertically.

Figure 1b Alternative forms of parentheses used when positioning Kanji vertically.
OpenType Layout data also supports the composition and decomposition of ligatures.
For example, English, French, and other languages written with Latin script can
substitute a single ligature, such as “fi”, for its component glyphs - in this case, “f” and
“i”. Conversely, the individual “f” and “i” glyphs could replace the ligature, possibly to
give a text-processing application more flexibility when spacing glyphs to fill a line of
justified text. Or similarly, many Arabic script glyph sequences may be substituted by a
single ligature glyph.

Figure 1c Two Latin glyphs and their associated ligature.

Figure 1d Three Arabic glyphs and their associated ligature.
Glyph substitution is just one way OpenType Layout extends font capabilities. Fonts
containing OpenType Layout tables can also specify how glyphs are to be attached to
one another. X and Y coordinates are used to specify the attachment points between
glyphs. This functionality can be used to attach diacritical marks to glyphs, as well as to
create connected (cursive) text.
OpenType Layout fonts also may contain baseline information that specifies how to
position glyphs horizontally or vertically. Because baselines may vary from one script
(set of characters) to another, this information is especially useful for aligning text that
mixes glyphs from scripts for different languages.

Figure 1e A line of text, baselines adjusted, mixing Latin and Arabic scripts.
As much as possible, OpenType Layout tables define only the information that is specific
to a particular font. The tables do not try to encode information that remains constant

within the conventions of a particular language or the typography of a particular script.
Such information that would be replicated across all fonts in a given language belongs
in a text-processing application for that language, not in the fonts.

OpenType Layout terminology
The OpenType Layout model is organized around glyphs, scripts, language systems,
features, and lookups.

Characters versus glyphs
Users don’t view or print characters: a user views or prints glyphs. A character is an
abstract entity with a numeric representation in data; a glyph is a visualization of a
character. For example, the character CAPITAL LETTER A is visually depicted by the glyph
“A” in a font such as Times New Roman Bold. A font contains a collection of glyphs. To
retrieve glyphs, the client uses information in the 'cmap' table of the font, which maps
the client’s character codes to glyph indices in the table.
Glyphs can also represent combinations of characters and alternative forms of
characters: glyphs and characters do not strictly correspond one-to-one. For example, a
user might type two characters, which might be better represented with a single ligature
glyph. Conversely, the same character might take different forms at the beginning,
middle, or end of a word, so a font would need several different glyphs to represent a
single character. OpenType Layout fonts contain a table that provides a client with
information about possible glyph substitutions.

Figure 1f Multiple glyphs for the ampersand character.

Scripts
A script is composed of a group of related characters, which may be used by one or
more languages. Latin, Arabic, and Thai are examples of scripts. A font may support
characters from a single script, or from many scripts. Within an OpenType Layout font,
scripts are identified by unique 4-byte tags.

Figure 1g Glyphs in the Latin, Kanji, and Arabic scripts.

Language systems
Scripts, in turn, can be divided into language systems. For example, the Latin script is
used to write English, French, or German, but each language has its own special
requirements for text processing. A font developer can choose to provide information
that is tailored to the script, to the language system, or to both.
Language systems, unlike scripts, are not necessarily evident when a text-processing
client examines the characters being used. To avoid ambiguity, the user or the operating
system needs to identify the language system. Otherwise, the client will use the default
language-system information provided with each script.

Figure 1h Differences between the English and Turkish language systems.

Features and lookups
Features define typographic capabilities of the font, and are the means that applications
use to invoke those capabilities. These can include essential capabilities required for
display of some scripts, as well as other capabilities for fine typography. A font that
supports positioning of diacritical marks will implement a 'mark' feature. A font that
supports substitution of vertical glyphs will implement a 'vert' feature.
Lookups are data used to implement the capabilities invoked by features. Lookup tables
describe glyph substitution or glyph positioning actions that an application should apply
to achieve the desired typographic effect. A feature can be used to refer to a
typographic capability in a font-independent way, but lookups provide the font-specific
data used to implement that capability.
The OpenType Layout feature model provides flexibility for font developers, allowing
them to choose capabilities to support in a font as appropriate for a given design or the
requirements of their customers. The model also provides extensibility for future
enhancements: on-going innovation can lead to features for new capabilities being
defined over time.

Figure 1i The relationship of scripts, language systems, features, and lookups for
substitution and positioning tables.

OpenType Layout tables
OpenType Layout makes use of five tables: GSUB, GPOS, BASE, JSTF, and GDEF. These
tables and their formats are discussed in separate chapters. The following paragraphs
provide a brief overview.
GSUB: Contains information about glyph substitutions to handle single glyph
substitution, one-to-many substitution (ligature decomposition), aesthetic alternatives,
multiple glyph substitution (ligatures), and contextual glyph substitution.
GPOS: Contains information about X and Y positioning of glyphs to handle single glyph
adjustment, adjustment of paired glyphs, cursive attachment, mark attachment, and
contextual glyph positioning.
BASE: Contains information about baseline offsets on a script-by-script basis.
JSTF: Contains justification information, including whitespace and Kashida adjustments.

GDEF: Contains information about all individual glyphs in the font: type (simple glyph,
ligature, or combining mark), attachment points (if any), and ligature caret (if a ligature
glyph).
The MATH table is an additional advanced layout table containing special metric values
and other data required for layout of mathematical expressions and formulas.
Common Table Formats: Several common table formats are used by the OpenType
Layout tables.

Text processing with OpenType Layout
A text-processing client follows a standard process to convert the string of characters
entered by a user into positioned glyphs. To produce text with OpenType Layout fonts:
1. Using the 'cmap' table in the font, the client converts the character codes into a
sequence of glyph indices.
2. Using information in the GSUB table, the client modifies the resulting glyph
sequence, substituting positional or vertical glyphs, ligatures, or other alternatives
as appropriate.
3. Using positioning information in the GPOS table and baseline offset information in
the BASE table, the client then positions the glyphs.
4. Using design coordinates the client determines device-independent line breaks.
Design coordinates are high-resolution and device independent.
5. Using information in the JSTF table, the client justifies the lines, if the user has
specified such alignment.
6. The client rasterizes the line of glyphs and renders the glyphs in device coordinates
that correspond to the resolution of the output device.
Throughout this process the text-processing client keeps track of the association
between the characters of the original string and the glyph indices of the final, rendered
text. In addition, the client can save language and script information within the text
stream to clearly associate runs in the original text with specific typographical behavior.

Left-to-right and right-to-left text
When an OpenType text layout engine applies the Unicode bidi algorithm and gets to
the point where mirroring needs to be performed on runs with an even, i.e. left-to-right
(LTR), resolved level, it does the following:
1. Glyph-level mirroring:

Apply feature 'ltrm' to the entire LTR run to substitute mirrored forms.
2. LTR glyph alternates:
Apply feature 'ltra' to the entire LTR run to finesse glyph selection.
For runs with an odd, i.e. right-to-left (RTL), resolved level, the engine does the
following:
1. Character-level mirroring:
For each character i in the RTL run:
If it is mapped to character j by the OMPL and cmap(j) is non-zero:
Use glyph cmap(j) at character i.

Here OMPL refers to the OpenType Mirroring Pairs List, and cmap(j) refers to the
glyph mapped from code point j in the Unicode 'cmap' subtable.
For example, suppose U+0028, LEFT PARENTHESIS, occurred in the run at resolved
level 1. The glyph at that code point in the run will be replaced by cmap(U+0029),
since {U+0028, U+0029} is a pair in the OMPL.
2. Glyph-level mirroring:
The engine applies the 'rtlm' feature to the entire RTL run. The feature, if present,
substitutes mirrored forms for characters other than those covered by the first
elements of OMPL pairs (otherwise, it could cancel the effects of character-level
mirroring).
The data contents of the OMPL are identical to the Bidi Mirroring Glyph Property
file of Unicode 5.1, and will never be revised. Thus, it will be up to the 'rtlm' feature
to provide, if needed, mirrored forms for both (a) Unicode 5.1 code points with the
“mirrored” property but no appropriate Unicode 5.1 character mirrors, as well as
(b) all future “mirrored” property additions to Unicode, whether or not character
mirrors exist for them.
With such a division of labor between the layout engine and the font, most fonts
will not need to include an 'rtlm' feature, since the mirrored forms in their Unicode
'cmap' subtable would be adequate.
3. RTL glyph alternates:
The engine applies the 'rtla' feature to the entire RTL run. The feature, if present,
substitutes variants appropriate for right-to-left text (other than mirrored forms).

In practice, the engine may apply features simultaneously; thus, it is up to the font
vendor to ensure that the features’ lookups are ordered to achieve the desired effect of
the algorithms described above. The engine may optimize its implementation in various
ways, e.g. by taking advantage of the fact that character- and glyph-level mirroring
won’t both apply on the same element in the run.

OpenType Layout and Font Variations
OpenType Font Variations allow a single font to support many design variations along
one or more axes of variation. For example, a font with weight and width variations
might support weights from thin to black, and widths from ultra-condensed to ultraexpanded. For general information on OpenType Font Variations, see the chapter
OpenType Font Variations overview.
Data used to support Font Variations are integrated into the tables used for OpenType
Layout. Variation of glyph outlines and metrics across a font’s variation space can impact
the design-grid distances that get used in OpenType Layout tables, such as anchor
positions used in a GPOS attachment lookup. Data elements in OpenType Layout
formats can be associated with variation data that describes how the default value is
adjusted for different variation instances.
In some variable fonts, it may be desirable to have different glyph-substitution or glyphpositioning actions used for different regions within the font’s variation space. For
example, for narrow or heavy instances in which counters become small, it may be
desirable to make certain glyph substitutions to use alternate glyphs with certain strokes
removed or outlines simplified to allow for larger counters. Such effects can be achieved
using a feature variations table within either the GSUB or GPOS table. The feature
variations table is described in the chapter, OpenType Layout Common Table Formats.
See also the Required Variation Alternates ('rvrn') feature in the OpenType Layout tag
registry.
Different variation instances of a variable font have the same glyph IDs. For that reason,
it might seem possible for lookups to be applied across a glyph sequence in which
glyphs are formatted using different variation instances of a variable font. Doing so,
however, could lead to unpredictable behaviors since font developers might not have
sufficient control over how lookup tables are generated, and it would not be feasible to
test the vast number of possible cross-instance interactions. For these reasons, layout
processing implementations must treat different variation instances of a variable font as
distinct style runs for purposes of OpenType Layout processing.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

OpenType Font Variations Overview
Article • 05/30/2024

This chapter of the OpenType Specification provides an overview of OpenType Font
Variations, including an introduction to essential concepts, a glossary of terminology,
and a specification of key algorithms: coordinate normalization, and interpolation of
instance values.

Introduction
OpenType Font Variations allow a font designer to incorporate multiple font faces within
a font family into a single font resource. Variable fonts — fonts that use OpenType Font
Variations mechanisms — provide great flexibility for content authors and designers
while also allowing the font data to be represented in an efficient format.
A variable font allows for continuous variation along some given design axis, such as
weight:

Continuous variation along a design axis
Conceptually, variable fonts define one or more axes over which design characteristics
can vary. Weight is one possible axis of variation, but many different kinds of variation
are possible. Variable fonts can combine two or more different axes of variation. For
example, the following illustrates a combination of weight and width variation:

Continuous variation along multiple design axes
Typically, variable fonts will vary the design of glyph outlines. In general, however,
potentially any aspect of the visual appearance may vary. For example, a font could vary
line height metrics or appearance of gradients in color glyphs rather than (or in addition
to) glyph outlines.
A variable font includes a table, the font variations ('fvar') table, that describes the axes
of variation used by that font. This table determines how a variable font and its variation
parameters will be presented to users and applications. Each axis is defined by a
numeric range, using fractional values represented using the Fixed (16.16) data type.
Conceptually, this provides a continuous gradient of variation, allowing for a large
number of design-variation instances to be selected. Each instance would be designated
by a coordinates array within the design-variation space — a specific value along each
of the design axes. So, for instance, if a user or application requires small adjustments to
width or slightly more pronounced serifs, fine control over such axes of variation is
available.
Every axis allows for a continuous range of instance-selection values, and typically there
will be continuous variation in appearance for a given axis. In some cases, however,
appearance can vary in discrete steps as the axis setting is changed. For example, an axis

could trigger substitution to different alternate glyphs for discrete sub-ranges of axis
values.
A font designer can pre-define certain instances to have particular names. For example,
a font can have continuous variation on a weight axis, but the designer may identify
particular variation instances as “Light” or “Semibold”. Named instances can be used for
any instance in the supported design-variation space. For example, in a font with weight
and width axes, named instances might include “Light”, “Extended”, or “Semibold
Condensed”. Details regarding named instances are also included in the font variations
table.
Weight and width are commonly-used axes of design variation, but a variable font may
use a wide range of other, possible axes of variation. For more information regarding
supported axes, see the font variations ('fvar') table chapter.
In addition to a font variations table, a variable font also includes a style attributes
(STAT) table that describes additional details about each axis of variation and about
particular values (chosen by the designer) along each axis. These details include
descriptor strings for those values, such as “Bold”, “Extended” or “Semi-sans”. For
example, a weight/width variable font might support a “Bold Extended” variation, and
the STAT table would provide strings for “Bold” and “Extended” corresponding to the
particular values along the weight and width axes, respectively. These strings can be
used in the creation of font-picker user interfaces. They can also be used for projecting
members of a multi-axis font family into different models for font families that assume a
limited number of axes of sub-family variation, such as a weight/width/slant model. (See
the STAT table chapter for more information.) Because the STAT table identifies values
on each axis, software never needs to parse subfamily strings and guess that string
tokens such as “Halbfett” refer to a particular value on some axis.
Note: The style attributes table makes it possible for fonts with many design axes to
be defined as a single, multi-axis family, yet still have instances across all of those
axes supported in older applications that may only recognize a limited set of axes of
variation, or a limited number of values on an axis. The host platform, which must
support the style attributes table, can translate instances in a multi-axis family into
fewer instances in multiple families that older applications will recognize.
As different variation instances of a font are selected, various items of data within a font
can be adjusted accordingly. For example, a 'glyf' table can provide the default outline
of a given glyph, but the outline can be adjusted in some manner to reflect different
design variations. Several other data items besides glyph outlines may also need similar
adjustments, including font-wide metrics, CVT values, or anchor positions within glyphpositioning lookup tables. A variable font includes required and optional tables that

describe how such items within the font change from default values to different values
as needed for different design-variation instances. For example, while a 'glyf' table can
provide default outlines for glyphs, a glyph variations ('gvar') table would provide
corresponding data that describes how each glyph outline changes for different
variation instances.
A variable font has a default instance, with axis parameter values set to the defaults
defined for each axis in the 'fvar' table. Several tables in the font provide default values
for many different data items — such as positions of glyph outline points in the 'glyf'
table, or a font-wide ascender distance in the OS/2 table. The default instance of a font
uses the default values for such items without any adjustments, and the variationspecific tables are not needed. If the variation-specific tables — 'fvar', 'gvar', MVAR, etc.
— were to be removed from the font or ignored, the remaining data would comprise a
complete font for the default instance.
Font variation mechanisms for fonts using TrueType outlines were first introduced by
Apple in “TrueType GX”. Some of the tables used for OpenType Font Variations have
been adapted from Apple’s earlier specifications with some enhancements and revisions.
(In particular, there are significant changes in the 'fvar' table specification in regard to
both format and data values used, and the 'fmtx' table is not used.) Other extensions
have also been created in order to integrate variation mechanisms into OpenType.
Implementers may wish to refer to Apple’s specifications for historical insights, but
should refer to the OpenType specification as the reference for implementation of
OpenType Font Variations.

Terminology
Several terms are useful in discussing OpenType Font Variations and will be used in this
specification.
OpenType Font Variations: The name of the technology described in this chapter.
Font face: A logical collection of glyph data sharing specific design parameters, along
with associated metric data, and names or other metadata.
Font resource: OpenType data that includes (at least) the minimal set of tables needed
to comprise a functional font face.
Note: Within OpenType font files, each table directory and the tables it references
comprise a font resource. A well-formed .OTF or .TTF file includes a single font
resource; a well-formed .OTC or .TTC file includes one or more font resources. A font
resource without variation-related tables provides data for a single font face. A

single font resource that includes variation-related tables can provide data for
multiple font faces.
Font family: A set of font resources that have a common family name — the same string
values for name ID 16 (Typographic Family Name) or name ID 1.
Note: It is assumed that all fonts within a family will share certain design
characteristics, but differ in others. The design characteristics that are different
potentially might be supported using OpenType Font Variations mechanisms.
Axis of variation: A designer-determined variable in a font face design that can be used
to derive multiple, variant designs within a family.
Variable font: A font resource that supports multiple font faces in a family along
designer-defined axes of variation using OpenType Font Variations mechanisms — that
is, by means of variation tables and other variation data in tables generally.
Glyph design grid: The visual, two-dimensional space in which a font’s glyph outlines
are designed.
Design-variation space: An abstract, multi-dimensional space defined by the axes of
variation used by a font designer when designing a font family. In the context of a
variable font, the variation space refers to the n-dimensional space defined by the axes
of variation specified in the font’s 'fvar' table.
Note: A variation space can have one or more axes. In a variable font, the variation
space is bounded by minimum and maximum values specified in the 'fvar' table. The
zero origin has no special significance within a design-variation space. Within a
variable font, however, the zero origin (using normalized coordinate scales —
defined below) is a marked position since it corresponds to the font face
represented directly by the font resource’s name, glyph and metric tables without
reference to any variation tables or other variation data.
Variation data: Data used in a variable font to describe the way that values for data
items in the font are adjusted from default values to alternate values needed for
different instances within the variation space.
Variation tables: OpenType tables specifically related to Font Variations, including the
following:
Axis variations ('avar') table
CVT (control value table) variations ('cvar') table

Font variations ('fvar') table
Glyph variations ('gvar') table
Horizontal metrics variations (HVAR) table
Metrics variations (MVAR) table
Vertical metrics variations (VVAR) table
Note: The 'fvar' table describes a font’s variation space, and other variation tables
provide variation data to describe how different data items are varied across the
font’s variation space. Note that not all of these tables are required in a variable
font. Also note that variation data for certain font data items may be contained in
other tables not specifically related to Font Variations. In addition, certain tables not
specifically related to Font Variations are required in variable fonts. See the section,
Variation data tables and miscellaneous requirements below for more details.
Point: In order to avoid ambiguity, point will be used only to refer to (X, Y) positions
within the glyph design grid. When discussing the design-variation space, position will
be used to refer to positions within that space.
Variation instance: A font face corresponding to a particular position within the
variation space of a variable font.
Named instance: A variation instance that is specifically defined and assigned a name
within the 'fvar' table.
User coordinate scale: The numeric scale used to characterize a given axis of variation,
and the scale used by applications when selecting instances of a variable font.
Note: Some axes of variation have a prescribed, limited range, expressed in terms of
the user scale. When using a particular variable font, the user scale for a given axis is
bounded by minimum and maximum specified within the 'fvar' table, and may be a
sub-range of the valid range for that axis generally.
Normalized coordinate scale: When processing variation data in a variable font to
derive values for particular instances, a normalization process is applied to map userscale values on each axis to a normalized scale applicable within that font that ranges
from -1 to 1.
Note: The 'fvar' table specifies user-scale minimum, default and maximum values for
each axis. In the normalization process, these get mapped to -1, 0 and 1
respectively, with other values along each axis mapping to intervening points.
Mapping of other values is modulated by the 'avar' table, if present. All of the

variation data within the font makes reference to axis values or positions within the
font’s variation space in terms of normalized-scale values.
Tuple / N-tuple: An ordered set of coordinate values used to designate a position within
the variation space of a font.
Note: “Tuple” is used here with a meaning that is consistent with conventional usage
in computer science and mathematics. In Apple TrueType specifications, “tuple” has
been used with a different meaning to refer to sets of variation data associated with
a particular region of the font’s design-variation space. In the OpenType
specification, “tuple variation data” is used for that meaning, and “n-tuple” is used in
many cases so as to avoid confusion with usage in Apple specifications.
Region: A sub-space (that is, some portion or subset) of the design-variation space over
which a variation adjustment is described.
Note: A region involves all of the axes of the font’s variation space; it is not a “subspace” in the sense of involving only a subset of axes. In normalized coordinates,
regions are always rectilinear: they have straight edges and right-angled corners.
Variation data may be defined for up to 65,535 regions in a font’s variation space.
Master: A set of source font data that includes complete outline data for a particular
font face, used in a font-development workflow.
Note: Some font-development workflows utilize several masters as source data for
creating font resources for different faces within a family. Multiple source masters
might also be used to create a variable font. Each source master would correspond
to a single instance in the variation space, and possibly might correspond to
variation data for a particular region in the variable font. Whereas each master
includes complete outline data, however, the variable font includes only a single set
of complete outline data (in the 'glyf' or CFF2 table), which is complemented with
variation data for different regions to represent the full range of instances
supported by the font.
Deltas / Adjustment deltas: Numeric values in variation data that specify adjustments to
default values of data items for particular regions within the variation space or for subranges within a particular axis.
Delta set: A set of adjustment deltas associated with a particular region of the variation
space.

Scalars: Co-efficient values applied to deltas to derive adjustment values needed for a
particular variation instance.
Interpolation: The process of deriving adjusted values for some font data items, such as
the X and Y coordinates of glyph outline points, for a particular variation instance.

Variation Space, Default Instances and
Adjustment Deltas
A variable font supports one or more axes of variation. Commonly-used axes of
variation should be registered, though custom, designer-defined axes can also be used.
Each axis has a distinct tag that is used to identify it in the 'fvar' table. See the 'fvar' table
specification for more details about axis tags.
The specification of axes used for a variable font is given in the 'fvar' table, along with
minimum, default and maximum values for each axis. This defines a variation space for
the font. It is entirely up to the designer what range of design variation is supported for
each axis, and how the designs align with the scale for each axis.
For example, a variable font may support a full range of weights from thin to black:

Font A: Thin to black weight variation
But a designer might also choose to support only a limited weight range:

Font B: Regular to black weight variation
The variable font has a default instance, which corresponds to the position in the
variation space with coordinates set to the default values for each axis specified in the
'fvar' table. The default instance uses default values for various data items that are
provided directly in non-variations-specific font tables, such as the grid coordinates of
outlines points for a glyph in the 'glyf' table.

Default glyph outline data in a 'glyf' table entry
All other instances have non-default coordinate values for one or more axes. These
other instances are supported by variation data that provide adjustment deltas for
various font data items that produce an adjustment from their default values.

Default glyph outline and adjusted point positions for a non-default instance

Detail inset showing contour point adjustments

Typically, deltas are provided for the extremes on each variation axis, though deltas can
be provided for other positions in the variation space as well. (See below for more
details.) For axis positions between the default and minimum or maximum extreme,
other values are interpolated.
The font designer can determine which design is considered the default, and what deltas
are provided. For example, a font with thin-to-black weight variation might be
implemented with Regular (400) as the default, and Thin (100) and Black (900) as
minimum/maximum values. In this case, variation data would include deltas for the Thin
extreme and also deltas for the Black extreme.

Default near axis mid-point with deltas at minimum and maximum extremes
But a different font with thin-to-black weight variation might be implemented with Thin
as the default and minimum value and Black as the maximum. In this case, variation data
might include deltas for only the Black extreme.

Default at axis minimum with deltas at maximum extreme
Note that a consideration in the choice of default is desired behavior in legacy
applications or platforms that do not support Font Variations: in such software, only the
default instance of a variable font will be supported.
A common process for developing a variable font involves the use of multiple, master
source fonts. Each master provides complete glyph outline data for designs for a
different position within a variation space. For example, a font designer might create
fonts for thin and heavy extremes along a weight axis.

Thin and Black source master outlines for font development workflow

From these two source masters, font tools can derive a variable font that has complete
glyph outlines for a default weight plus deltas for one or more non-default weights,
including the minimum or maximum weights.

Production variable font with single outline data plus deltas
Note that each of the source, master fonts has complete outline data for a particular
design variant. In contrast, the variable font has complete outlines for only one variation
instance, with all other instances derived using the default outlines plus deltas. Each
source master may correspond to a region with associated variation data in the variable
font, though the relationship between source masters and the sets of variation data
within the font will depend on the nature of the designs and on the tools used to
produce the variable font.
Also note that a requirement for using multiple, master, font sources to derive a variable
font is that corresponding glyph outlines must be point-compatible: they must have the
same number of contours and the same number of points in each contour.

Coordinate Scales and Normalization
Positions within the variation space can be represented as an n-tuple — an ordered list
of coordinate values. Examples will be seen below. The coordinate values of an n-tuple
may use user-axis scales, or may use normalized scales. The precise relationship
between these scales will be described.
User coordinates refers to an n-tuple of coordinate values expressed using user axis
scales. User scales refer to the numeric scales used to describe a variation axis within the
'fvar' table. Each variation axis uses its own numeric scale, as appropriate to the nature
of that axis of variation. The scales for registered axis tags are defined as part of the axis
tag registration, though different fonts may support different sub-ranges of an axis
scale. In this way, the 'fvar' table of a given font defines a particular coordinate system
for the variation space of that font that may be unlike that of other fonts.
Whereas the definitions in the 'fvar' table are expressed in user coordinates, the
variation data formats used within a variable font use a normalized coordinate system —
normalized coordinates — in which the minimum, default and maximum values specified
for each axis in the 'fvar' table are mapped to -1, 0 and 1, respectively.

For example, the following figure illustrates the user coordinate system of the variation
space for a possible font with weight and width axes of variation. Various positions
within the design space are indicated, including positions corresponding to the default,
minimum and maximum values for each axis defined in the 'fvar' table.

The following figure illustrates the normalized coordinate system for the same positions
in the design space:

The normalization transformation uses a default transformation followed by a secondary
modification of the transformation defined in the 'avar' table, if present. An 'avar' table
does not affect the mapping of minimum, default, and maximum values to -1, 0 and 1; it
can only affect mapping of intervening values. This is described in more detail below.
The default normalization mapping divides the variation range for each axis into two
segments: minimum value to default value, and default value to maximum value. The
minimum, default and maximum values are mapped into -1, 0 and 1 respectively. Within
each segment, all other values are interpolated linearly, as follows:
1. Let userValue be the user-scale coordinate value for a user-selected instance value
for a given axis, let defaultNormalizedValue be the default normalized instance
value, let axisMin be the minimum value for the axis specified in the 'fvar' table,
etc.
2. Force the user-scale coordinate value to be in range by clamping to the minimum
and maximum values:

if userValue < axisMin
userValue = axisMin;
if userValue > axisMax
userValue = axisMax;

3. Interpolate values linearly within the different segments:

if (userValue < axisDefault)
{
defaultNormalizedValue = -(axisDefault - userValue) / (axisDefault
- axisMin);
}
else if (userValue > axisDefault)
{
defaultNormalizedValue = (userValue - axisDefault) / (axisMax axisDefault);
}
else
{
defaultNormalizedValue = 0;
}

If an 'avar' table is present, then an additional normalization step is performed for each
axis to compute the final normalized value. Within the 'avar' table, AxisValueMap records
map default normalized values for an axis to modified normalized values. Pairs of
consecutive AxisValueMap records define segments within the range for a given axis.
Within a segment, intermediate values are interpreted linearly. Starting with the
defaultNormalizedValue computed as above, the additional normalization step proceeds

as follows:
1. Retrieve the SegmentMaps record for a given axis from the avar.axisSegmentMaps
array using the index for the axis as defined in the 'fvar' table.
2. Scan the AxisValueMaps records in the SegmentMaps.axisValueMaps array to find the
first record that has an AxisValueMaps.fromCoordinate value greater than or equal
to defaultNormalizedValue . Designate this record as endSeg . (Note that endSeg
cannot be the first map record, which is for -1.)
3. If endSeg.fromCoordinate equals defaultNormalizedValue , then set
finalNormalizedValue to endSeg.toCoordinate . Return this value and end.

4. Else endSeg.fromCoordinate is strictly greater than defaultNormalizedValue ):
designate the preceding AxisValueMaps record as startSeg .
5. finalNormalizedValue is computed as follows:

ratio = (defaultNormalizedValue - startSeg.fromCoordinate) /
(endSeg.fromCoordinate - startSeg.fromCoordinate)
finalNormalizedValue = startSeg.toCoordinate + ratio *
(endSeg.toCoordinate - startSeg.toCoordinate)

See the Table formats section of the 'avar' table chapter for details on the structures
mentioned above.
When processing variation instance coordinates and variation data, the amount of
precision used and the handling of rounding can potentially have noticeable impacts on
visual results. In order to ensure consistent behavior for a given font across
implementations, implementations must observe the following requirements in relation
to precision and rounding:
1. The input to normalization must be in 16.16 format. If an application provides an
input value represented as either a float or double data type, the method described
below must be used for conversion to 16.16.
2. The math calculations for normalization, specified above, are done in 16.16.
3. After the default normalization calculation is performed, some results may be
slightly outside the range [-1, +1]. Values must be clamped to this range:

if result < -1
result = -1;
if result > 1
result = 1;

4. If an 'avar' table is present, math calculations are done in 16.16, and results are
clamped to the range [-1, +1] as above.
5. Convert the final, normalized 16.16 coordinate value to 2.14 by this method: add
0x00000002, and sign-extend shift to the right by 2.
6. The 2.14 result must be stored and returned in certain operations, as described
below.
7. For subsequent calculations — calculation of interpolation scalars or accumulation
of scaled delta values — the 2.14 representation may be converted to float, 16.16
or other implementation-specific representations. It is recommended that at least
16 fractional bits of precision be maintained, and that any rounding be done at the
last point before a value is used.

When converting from float or double data types to 16.16, the following method must
be used:
1. Multiply the fractional component by 65536, and round the result to the nearest
integer (for fractional values of 0.5 and higher, take the next higher integer; for
other fractional values, truncate). Store the result in the low-order word.
2. Move the two’s-complement representation of the integer component into the
high-order word.
Note: Apart from conversion of higher-precision representations to 16.16, this
specification has no other requirements for instance coordinates, scaled deltas or
derived instance values to be rounded. For example, for contour point coordinates
after deltas have been applied, a rasterizer implementation can use a high-precision
floating type or can round to a lower-precision representation depending on
implementation-specific requirements. Different implementations can use different
precision for calculation of instance values, resulting in minor visual differences. If
data for a font instance is converted or exported to another representation — for
example, in dynamic generation of a static font for a given instance — there can be
minor differences between the derived static font versus the source variable font
with that instance selected.
A normalized value in 2.14 representation must be obtained exactly as specified in steps
1–5 above. In fonts with TrueType instructions, this exact value must be returned by the
GET VARIATION instruction. (See The TrueType Instruction Set.) If a font has OpenType
Layout tables in which FeatureVariation tables are used, this exact value must be used
when comparing with axis range values specified in a condition table.

'avar' normalization example
The following example illustrates how normalization using 'avar' mappings works.
Suppose that an axis in a font has minimum value of 100, a default of 400, and
maximum of 900. And suppose that the instance selected has a user coordinate of 250.
By the algorithm described above, the default normalized value will be calculated as
follows:

defaultNormalizedValue = -(axisDefault - userValue) / (axisDefault axisMin)
= -(400 - 250) / (400 - 100)

= -150 / 300
= -0.5

Suppose also that the font has an 'avar' table with the following mappings
(AxisValueMap records) for this axis:
ﾉ

Record index

fromCoordinate

toCoordinate

0

-1.0

-1.0

1

-0.75

-0.5

2

0

0

3

0.4

0.4

4

0.6

0.9

5

1.0

1.0

Expand table

Given the default normalized value of -0.5, the relevant segment is defined by record 1
and record 2:
The first record having a fromCoordinate greater than or equal to
defaultNormalizedValue is record index 2. Thus, record 2 is endSeg .
endSeg.fromCoordinate is strictly greater than defaultNormalizedValue . Thus, the

preceding record, record 1, is startSeg .
Thus, the final normalized value is computed as follows:

ratio = (defaultNormalizedValue - startSeg.fromCoordinate) /
(endSeg.fromCoordinate - startSeg.fromCoordinate)
= (-0.5 - (-0.75)) / (0 - (-0.75))
= 0.3333
finalNormalizedValue = startSeg.toCoordinate + ratio *
(endSeg.toCoordinate - startSeg.toCoordinate)
= -0.5 + 0.3333 * (0 - (-0.5))
= -0.3333

The following table shows how several normalized coordinate values would be modified
by this 'avar' data:

ﾉ

Default normalized value

Final normalized value

-1.0

-1.0

-0.75

-0.5

-0.5

-0.3333

-0.25

-0.1667

0

0

0.25

0.25

0.5

0.65

0.75

0.9375

1.0

1.0

Expand table

Variation Data
Variation data provides data that describes variation of particular font values over the
variation space. For example, variation data in the 'gvar' table describes how glyph
outlines in the 'glyf' table are transformed by specifying how individual points in a glyph
outline get moved for different variation instances.
Variation for a given font value is expressed as combinations of deltas that apply to
different regions of the variation space, and that are combined in a weighted manner to
derive adjustments for instances at different positions in the variation space. Each delta
in the variation data is associated with a specific region of the variation space over
which it has an effect. The aggregate combination of deltas and their associated regions
comprise the variation data. The variation data for different items in a font are stored in
different locations. For example, variation data for entries in a 'glyf' table are stored in a
'gvar' table; variation data for certain entries in the OS/2 table is stored in an MVAR
table. In the case of outline data in a CFF2 table, variation data is stored within the CFF2
table itself. See the following section below for more details.
As mentioned, each delta value is associated with a particular region of the variation
space over which it applies. The effective region for a delta is always rectilinear (in
normalized coordinates). Therefore, this region can always be specified by a pair of ntuples designating positions at diagonal-opposite corners of the region. Within the
specified region, variation effects will vary from zero change to some peak change at a
particular position within the region. Thus, in the general case, there are three positions

that matter: the diagonal-opposite corners that define the extent of the region, and a
position at which the peak change occurs.
Note: The figures shown below will use two axes of variation. The concepts and the
statements made, however, apply to fonts with any number of axes of variation:
regions are always rectilinear, and the diagonal-opposite corners plus a peak are the
positions that describe a region.

This general case is not the most common in practice. In most cases, there is a need to
describe a maximal variation at an outer position of the variation space that diminishes
to zero change at the zero origin — the default instance. In this case, then, the zero
origin is one of the corner positions for the applicable region, and the peak change
occurs at the diagonal-opposite position. For this common case, then, the effective
region and peak position can be described using a single n-tuple.

The more general, but less common, case involves arbitrary regions, illustrated earlier;
these are referred to as intermediate regions. In these cases, the variation data requires
three n-tuples: one for the peak-change position, and two for start and end positions at
diagonal-opposite corners.
Delta values in the variation data specify a maximal adjustment for an instance at the
peak position. The effects taper off for other instances, falling to zero adjustment for
instances outside the region of applicability. When a given variation instance is selected,
a scalar value is calculated and applied to a given delta to derive a net adjustment
associated with that delta for that instance. These scalars will always be in the range 0
(zero adjustment) to 1 (maximal adjustment). Specific details on this scalar calculation
are provided below.
An example will help to explain these concepts. Consider a single-axis font with weight
variation. A particular glyph outline defined in the 'glyf' table might have a pair of points
(among others) that are on-curve points on opposite sides of a stem. The entry in the
'glyf' table would specify glyph-design-grid coordinates for these points for the default
instance of the font, perhaps corresponding to the regular weight:

Variation data would be defined for the maximum value on the weight axis,
corresponding to 1.0 in the normalized weight scale. This data would provide X and Y
deltas for the two contour points to shift their positions as needed for the heaviestsupported weight instance:

In this example, the first point would have X and Y deltas of +40 and +10, respectively;
the second point would have deltas of +140 and +10. These provide a maximal
adjustment of the outline points, applied when the user-selected instance is at the
maximum weight. For weights between the default and the maximum, such as a
normalized weight value of 0.5, the effect is scaled back.

In this case, a scalar co-efficient of 0.5 is applied to the delta values.
The scalar calculation can be thought of as a function that maps each normalized axis
value from -1 to 1 onto a scalar range of 0 to 1. Each region that has associated
variation data has its own scalar function, and the scalar function is defined precisely by
the region description.
For example, in a single-axis font, if a delta is provided for the region from 0 to 1 with
the peak effect at 1, the scalar function would be as follows:

This example considers a non-intermediate region. The same concepts can be
generalized to intermediate regions. An intermediate region has start and end axis
values between which there is some adjustment effect, and a peak axis value at which
the full adjustment effect is applied. The scalar function has a triangular shape within the

applicable range, with a value of 1.0 at the peak axis value, 0 at or below the start axis
value, and 0 above the end axis value.

When generalizing to two or more axes, similar concepts apply, but contributions for
each axis are combined into an overall effect. Scalars are calculated for each axis, and
the per-axis scalars are multiplied together to produce an overall scalar for the given
delta and the given instance. For example, the following graph illustrates an
approximation of the scalar function for a region in a two-axis font with peak at (1, 1):

Since the scalar value calculated for each axis is between 0 and 1, the product when
scalars for each axis are multiplied together is also between 0 and 1. The maximal
adjustment effect for a given delta is obtained only when the instance axis values for all
axes align with the peak coordinate values for the region associated with that delta.
The minimum and maximum values specified for an axis in the 'fvar' table determine
limits on instances that can be selected by a user. If a user requests an instance with an
axis value below the minimum, the minimum value is used; or if an axis value above the

maximum is requested, the maximum is used. Thus, when processing variation data for a
selected instance, the normalized axis values will always be between -1 and 1.
With that constraint assumed, let us consider the scalar value for a given delta when
instance axis values are outside the region of applicability. If the selected instance is out
of range on any axis, then the scalar value pertaining to that axis will be 0. As
mentioned, per-axis scalars are multiplied together to produce an overall scalar. Thus, if
the selected instance is out of range on any axis, then the overall scalar for that delta will
be 0, and no adjustment from that delta will be applied.
When a delta is provided for a region defined by n-tuples that have a peak value of 0 for
some axis, then that axis does not factor into scalar calculations. This means that the
adjustment effect is the same for any value in that axis, if other axis values remain
constant. In effect, the region of applicability spans the full range for the zeroed axis. For
example, suppose a font has two axes, weight and width, and that deltas are provided
for a region from (0, 0) to (1, 0). In this case, the deltas are applicable for any instance
value on the second axis (width), so long as the instance value in the first axis (weight) is
in range:

In this case, the scalar function for the second axis (width) is, effectively, a constant value
of 1, with no effect on the net scalar calculation. The following graphs illustrate the
scalar functions for each of the two axes, weight and width, in this example:

For a given font value, deltas may be provided for several different regions in the
variation space. When a particular variation instance is selected, zero, one or many of
those deltas may have an effect, according to whether the position of the instance falls
within the region of applicability for each delta. Different scalars are calculated for each
applicable delta, and the scaled values for applicable deltas are combined to derive a
net adjustment.
When creating a single-axis font, deltas will be required for both the minimum and
maximum extremes of that axis. (Both extremes, that is, unless one is also the default.)
Additional intermediate-region deltas may also be provided. When creating a multi-axis
font, deltas would typically be provided for the minimum and maximum extremes on
each axis. The following figure illustrates this for a two-axis font:

Two-axis font with deltas at minimum/maximum extremes on each axis
As noted above, when deltas are specified for a region with some axis value being zero,
then the deltas apply to all values on that axis. Therefore, for the instance at position (1,
1), deltas for (1, 0) and (0, 1) will both apply. This means that the adjustments for the (1,
0) deltas and the adjustments for the (0, 1) deltas will both be applied to produce a
combined effect. If the adjustments made for each axis are entirely independent of the
adjustments for the other axis, then the two sets of deltas may be sufficient to provide
the intended values for the (1, 1) instance.
Often, however, these two sets of deltas alone will not be sufficient to provide the
desired results for all instances, and that additional deltas are required for the (1, 1)
position in addition. Generalizing, in a multi-axis font, it will often be the case that at
least some deltas are needed for the corner extremes as well as for the axis end points.

Deltas at minimum/maximum extreme plus extrema-intersection corners
As noted in the Variation Space, Default Instances and Adjustment Deltas section above,
the default instance can correspond to the minimum or maximum value on one or more
axes. This can allow variations across a variation space to be implemented using fewer
regions and associated delta data. The following figures illustrate some additional
possibilities for a two-axis font.

Two-axis font with default at minimum for one axis

Two-axis font with default at minimum for both axes
Note: Deltas for corner extremes are optional. Depending upon the needs of a
particular font design, deltas can be added for none, some or all of the corner
extremes. In the first example above, the design-space corners in the upper left and
lower left of the diagram correspond to the minimum and maximum values for one
of the axes, and so deltas in those corners are needed to provide variation on that
axis. But deltas for the upper right and lower right corners are optional; in this
example, supplemental deltas are added only for the upper right corner.
As noted above, an intermediate region provides an axis scalar function with a
triangular, or “tooth”, shape. A pair of intermediate regions that barely overlap and that
have a sharp incline at the overlap can be used to provide an inflection point along an
axis in regard to some variation behavior.

Note that each intermediate region has its own associated delta values, and deltas can
be used to give some sharp transition at the overlap point. For example, contour points
could suddenly shift to make some element of a glyph’s structure appear or disappear,
as illustrated in the following figure.

Glyph structure simplified at heavier weights
Note: When using such techniques, placement of such a transition point along an
axis and placement of named instances should be considered together so that sharp
transitions do not occur close to a named instance. This will avoid any possibility of
inconsistent behavior in different applications when using named instances that
might arise due to small discrepancies in processing the numeric values.
Note: When using such techniques, it is important to bear in mind that some
applications will support selection of arbitrary instances, including those with axis
values in the overlapping range, and that, in the overlapping range, scaled deltas for
both of the intermediate regions will apply with cumulative effect. Some design
iteration may be needed, with small adjustments to delta values or the way that the
regions overlap, in order to avoid unexpected or undesired results in the transitional
range.
Note: The above figure illustrates the use of intermediate regions to implement a
“stroke-reduction” effect. Another implementation technique that can be used to
change the structure of a glyph for particular variation-axis value ranges is glyph
substitution. The OpenType Layout Required Variation Alternates feature in
combination with a FeatureVariations table within the GSUB table can be used to
perform glyph substitutions when a variation instance is selected in some range
along one or more axes. This may be an easier and more-easily maintained
technique, and is generally recommended for achieving such effects.
The above has provided an overview of the basic concepts involved in variation data:
regions of applicability, per-axis and overall scalars, and combined effects of multiple,
applicable deltas. A detailed specification of the interpolation process is provided below.

Variation Data Tables and Miscellaneous
Requirements

The previous section identified X and Y coordinates of glyph outline points as data items
that can be adjusted for different variation instances. Many other data items in a font
can also be adjusted, including the following:
Font-wide metric values in the OS/2, 'hhea', 'vhea' or 'post' tables.
Glyph metric values in the 'hmtx', 'vmtx' or VORG tables.
PPEM ranges in the 'gasp' table.
Anchor positions, and adjustments to glyph positions or advance in the GPOS or
JSTF tables.
X or Y coordinates for ligature caret positions in the GDEF table.
X or Y coordinates for baseline metrics in the BASE table.
CVT values.
Gradient placement and color stop offsets, color alpha values, and transformations
for color glyphs in the COLR table.
A variable font may contain variation data for any or all of these. The variation data for
different items is provided in various tables within a font.
Note: While several data items in a font may require adjustment for different
instances, there will be other items that do not change across instances. For
example, the font family and unitsPerEm are not impacted by variation. It should be
noted in particular, however, that certain values that can potentially be impacted by
variations are not supported with variation data. In particular, the xMin, yMin, xMax,
yMax, macStyle and lowestRecPPEM fields in the font header ('head') table are not
supported by variation data and should only be used in relation to the default
instance for the font. Also, variations for values in the kerning ('kern') table are not
supported; variable fonts should handle kerning using the GPOS table.
Two tables are required in all variable fonts:
A font variations ('fvar') table is required to describe the variations supported by
the font.
A style attributes (STAT) table is required and is used to establish relationships
between different fonts belonging to a family and to provide some degree of
compatibility with legacy applications by allowing platforms to project variation
instances involving many axes into older font-family models that assume a limited
set of axes.
A variable font must contain some other variation-related data, according to the ways in
which the design varies, but no other specific type of variation-related data is required
in all variable fonts.

If a variable font has TrueType outlines in a 'glyf' table, the outline variation data can be
provided in the glyph variations ('gvar') table. Variation data for CVT values can be
provided in the optional CVT variations ('cvar') table.
If a variable font has PostScript-style outlines in a Compact Font Format 2.0 (CFF2) table,
the CFF2 table itself can also contain the associated variation data.
Note: A CFF2 table can be used in non-variable fonts as well as in variable fonts. Also
note that variations for outlines using the Compact Font Format version 1.0 ('CFF ')
table are not supported.
The metrics variations (MVAR) table is used to provide variation data for various fontwide metrics or other numeric values in the 'gasp', 'hhea', OS/2, 'post' and 'vhea' tables.
An MVAR table should be added if adjustments to any of these values are required.
Note that it is not required to provide variation data for all of the data items covered by
the MVAR table: variation data is optional for all items. If there is no variation data for a
given item, the default value applies to all instances.
Note: Apple platforms allow for use of a font metrics ('fmtx') table to specify various
font-wide metric values by reference to the X or Y coordinates of contour points for
a specified glyph. OpenType Font Variations does not use the font metrics table.
The 'hmtx' and 'vmtx' tables provide horizontal and vertical glyph metrics. Variation data
for horizontal and vertical glyph metrics can be provided using the horizontal metrics
variations (HVAR) and vertical metrics variations (VVAR) tables.
In a font with TrueType outlines, the rasterizer combines 'hmtx' and 'vmtx' values with
glyph xMin, xMax, yMin and yMax values in the 'glyf' table to generate four “phantom”
points that correspond to the glyph horizontal and vertical metric values. (See the
chapter Instructing TrueType Glyphs for more background on phantom points.) In a
variable font, the variation data for a glyph in the 'gvar' table will include adjustment
deltas for the glyph’s phantom points. As a result, interpolated glyph metrics for a given
instance can be obtained by interpolating the phantom point positions for the instance.
This may be costly for some text-layout operations, however. In order to provide the
best performance on all platforms, it is recommended that all variable fonts with
TrueType outlines include an HVAR table. If the font supports vertical layout and
includes 'vhea' and 'vmtx' tables, it is recommended that the font include a VVAR table.
The CFF2 rasterizer does not generate phantom points, and CFF2 variation data will not
include adjustment deltas for phantom points. For this reason, in a variable font with
CFF2 outlines, 'hmtx' and HVAR tables are required. Similarly, if the font supports vertical
layout, then 'vmtx' and VVAR tables are required.

Note: The 'hdmx' and VDMX tables are not used in variable fonts.
If a font has OpenType Layout tables, variation data for values from the GDEF, GPOS or
JSTF table will be included, as needed, within the GDEF table. Variation data for the BASE
table will be included, as needed, within the BASE table itself.
In some variable fonts, it may be desirable to have different glyph-substitution or glyphpositioning actions used for different regions within the font’s variation space. For
example, for narrow-width or heavy-weight instances in which counters become small, it
may be desirable to make certain glyph substitutions to use alternate glyphs with
certain strokes removed or outlines simplified to allow for larger counters. Such effects
can be achieved using a feature variations subtable within either the GSUB or GPOS
table. See the chapter OpenType Layout Common Table Formats for more information.
In a color font using the COLR table, variation data can be included in the COLR table, as
needed, for variable items in color glyph descriptions.
In a variable font with TrueType outlines, the left side bearing for each glyph must equal
xMin, and bit 1 in the flags field of the 'head' table must be set.
In all variable fonts, bit 5 in the flags field of the 'head' table must be cleared. (On
certain platforms, bit 5 affects metrics in vertical layout. Bit 5 must be clear to ensure
compatible behavior on all platforms.)

Algorithm for Interpolation of Instance Values
The process of interpolating adjusted values for different variation instances is used for
all font data items that require variation — positions of outline glyph points, ascender or
other font-wide metrics, etc. The interpolation process involves the following:
Determining the deltas that are applicable for that instance.
For each applicable delta, calculating per-axis scalars for that instance, then
multiplying the per-axis scalars together to produce an overall scalar for that delta.
Scaling each applicable delta by the calculated scalar for that delta.
Combining all of the scaled deltas to produce an overall adjustment.
When processing the 'gvar' table, there is an additional step in calculations, which is to
infer delta adjustments for points when deltas are not given explicitly. This applies only
to the 'gvar' table, and is described in the 'gvar' table chapter.
As described earlier, an instance axis value that is outside the region of applicability for a
given delta is equivalent to having a per-axis scalar value of zero. Also, having an axis
that has no effect in relation to a given delta (the n-tuples have a peak value of zero for

that axis) is equivalent to having a per-axis scalar value of one. Thus, determination of
applicability and axis interactions can all be combined into a step of deriving an overall
scalar.
The description of the interpolation process below will refer to start, peak, and end
coordinate values. As described earlier, an intermediate region is described using three
n-tuples, two for diagonal-opposite corners (start and end) that specify the extent of the
region, and a peak. Non-intermediate regions have one of the corners at the peak and
the other corner at the zero origin. In some variation data structures, a non-intermediate
region is specified using a single n-tuple, that of the peak. In this case, the start and end
coordinates are implicit: one is the same as the peak, and the other is the zero origin.
In order for the definition of a region within variation data to be valid, start, peak and
end values must be well ordered. That is, for each axis, the start axis coordinate must be
less than or equal to the peak coordinate, and the peak coordinate must be less than or
equal to the end. Also, the start and end coordinates must both be non-negative or
non-positive — they cannot cross zero.
In the discussion to this point, individual deltas have been described as having an
associated region of applicability. Variation data can be organized in different ways. In
some cases, as in the 'gvar' table, several deltas corresponding to many target items (all
the outline points of a glyph) and a single region of the variation space are organized
together. In some other cases, as in the MVAR or CFF2 tables, deltas covering multiple
regions are organized together by individual target items. In either case, each individual
delta is associated with a particular region of the variation space. The following
description of the interpolation process will refer to interpolating a value for an
individual item, but when applied to particular contexts such as the 'gvar' table, it should
be understood that the same calculations are applied to many different items in parallel.
As described above, the effect of a given delta is modulated by a scalar function ranging
from 0 to 1, with a value of 1 for an instance at the peak position of the region
associated with that delta. The overall scalar is the product of per-axis scalars, and each
per-axis scalar is calculated as a proportion of the proximity of the instance coordinate
value to the peak coordinate value relative to the distance of the peak from the edges of
the region.
For example, consider an intermediate region (green in the figure below) in a two-axis
variation space, with corners at (0.3, 0.15) and (1, 1), and a peak (blue in the figure
below) at (0.7, 0.5):

Then consider the instance (red in the figure below) at (0.5, 0.35). The per-axis scalars
will be the ratio of the distance of the instance coordinate value from the nearest edge
of the region divided by the distance of the peak from that edge:

The overall scalar for the instance in relation to this region will be the product of the two
axis scalars: 0.5 × 0.571429 = 0.285714.
The detailed algorithm for calculating the interpolated value for a given target item and
for a given instance is as follows.
Let instanceCoords be the normalized instance coordinate n-tuple for the instance,
with axis elements instanceCoords[i].
Let Regions be the set of regions for which associated deltas are provided for the
given item, and let R be a region within that set.

Let startCoords, peakCoords and endCoords be the start, peak and end n-tuples
for some specified region, R. Let startCoords[i], etc. be coordinate values for a
given axis.
Let AS be a per-axis scalar, and let S be an overall scalar for a given region.
Let delta be the delta value in the variation data associated with a given region,
and let scaledDelta be the scaled delta for a given region and instance.
Let netAdjustment be the accumulated adjustment for the given item.
Let defaultValue be the default value of the item specified in the font, and let
interpolatedValue be the interpolated value of the item for a given instance.
The following pseudo-code provides a specification of the interpolation algorithm:
C#

netAdjustment = 0; /* initialize the accumulated adjustment to zero */
(for each R in Regions) /* For each region, calculate a scalar S */
{
S = 1; /* initialize the overall scalar for the region to one */
/* for each axis, calculate a per-axis scalar AS */
(for i = 0; i < axisCount; i++)
{
/* If a region definition is not valid in relation to some axis,
then ignore the axis. For a region to be valid in relation to a
given axis, it must have a peak that is between the start and
end values, and the start and end values cannot have different
signs if the peak is non-zero. (Start and end can have different
signs if the peak is zero, however: this can be used if an axis is
to be ignored in the scalar calculation.) */
if (startCoords[i] > peakCoords[i] || peakCoords[i] > endCoords[i])
AS = 1;
else if (startCoords[i] < 0 && endCoords[i] > 0 && peakCoords[i] !=
0)
AS = 1;
/* Note: for remaining cases, start, peak and end will all be <= 0
or
will all be >= 0, or else peak will be == 0. */
/* If the peak is zero for some axis, then ignore the axis. */
else if (peakCoords[i] == 0)
AS = 1;
/* If the instance coordinate is out of range for some axis, then
the
region and its associated deltas are not applicable. */
else if (instanceCoords[i] < startCoords[i]
|| instanceCoords[i] > endCoords[i])
AS = 0;

/* The region is applicable: calculate a per-axis scalar as a
proportion
of the proximity of the instance to the peak within the region. */
else
{
if (instanceCoords[i] == peakCoords[i])
AS = 1;
else if (instanceCoords[i] < peakCoords[i])
{
AS = (instanceCoords[i] - startCoords[i])
/ (peakCoords[i] - startCoords[i]);
}
else /* instanceCoords[i] > peakCoords[i] */
{
AS = (endCoords[i] - instanceCoords[i])
/ (endCoords[i] - peakCoords[i]);
}
}
/* The overall scalar is the product of all per-axis scalars.
Note: the axis scalar and the overall scalar will always be
>= 0 and <= 1. */
S = S * AS;
} /* per-axis loop */
/* get the scaled delta for this region */
scaledDelta = S * delta;
/* accumulate the adjustments from each region */
netAdjustment = netAdjustment + scaledDelta;
} /* per-region loop */
/* apply the accumulated adjustment to the default to derive the
interpolated value */
interpolatedValue = defaultValue + netAdjustment;

When scaled deltas are applied to a default value, it is possible that the combined result
will be outside the range of the data type used in the font for the default value. For
example, the default value could be represented in the font as a 16-bit value, but the
instance value after applying deltas might require more bits to represent it. An
implementation-determined representation may be used during calculation and for the
final result (interpolatedValue). The numeric range used in calculation must be at least
that of the data type of the item to which deltas are applied; for example, at least
[-32768, 32767] when applying scaled deltas to an FWORD value.
Applying scaled variation deltas to a scalar value requires calculations that involve
fractional values. In calculation of scalars (S, AS) and of interpolated values (scaledDelta,
netAjustment, interpolatedValue), at least 16 fractional bits of precision should be
maintained. If required for the internal representation, rounding should be done only
when the final result is used, and may retain greater fractional bit-depth than that of the

data type of the item to which deltas are applied. See also Coordinate Scales and
Normalization, above, for related discussion of precision and rounding.
Depending on the internal representation used, there is a possibility that the result of
arithmetic operations when applying deltas could exceed the range supported by the
internal representation. The order in which deltas are added is not prescribed, but can
also be a factor in whether overflow occurs and, if it does, what the final result could be.
If resources permit, applications should allow for larger ranges to avoid the possibility of
overflow at any point during calculation, and to ensure that the order in which deltas are
applied does not affect the final result. Regardless of the type used in the font
representation for the default value, at least 32 significant bits should be used for
calculations.
If overflow of the internal representation is inevitable, saturation arithmetic (clamping,
rather than wrapping) may be used to mitigate error artifacts. In general, however,
behavior on overflow is not defined. For this reason, font developers should take note of
situations in which a combination of deltas could exceed the range of the data type of
the font data to which the deltas are applied, and anticipate that resulting behavior
could be inconsistent in different applications. In particular, font developers should not
depend on the overflow behavior of particular applications.

Interpolation Example
The following example illustrates the interpolation process for a particular instance. This
example is based on glyph 45 of the Skia font (glyph name “hyphen.oldstyle”), which is
the glyph for the character U+002D HYPHEN-MINUS.
Note: The Skia font is included in Apple’s OSX platform. At the time of publication of
the OpenType 1.8 specification, existing versions of the Skia font did not conform to
the OpenType 1.8 specification as a whole, but the implementation of variation data
in the 'gvar' table, which is what is illustrated here, did conform.
The glyph entry in the 'glyf' table has one contour with four points. Based on values for
glyph 45 in the 'hmtx' table, “phantom” points are inferred in the rasterizer to represent
left and right side-bearings. (For this example, horizontal layout is assumed, and so top
and bottom phantom points are ignored.) These phantom points are at (0, 0) and (698,
0). Thus, there are six points requiring interpolation.

The Skia font has weight and width axes. The variation data for glyph 45 in the 'gvar'
table has deltas associated with 8 regions within the weight-width variation space. Three
of these will be considered, and will be referred to as R1, R2 and R3. Each of these is a
non-intermediate region, and so is defined using a single n-tuple. The n-tuples for each
are as follows:
ﾉ

Region

(weight, width)

R1

(1, 0)

R2

(0, 1)

R3

(1, 1)

Expand table

The following figures illustrate the range of applicability over the variation space for
each of these regions:

R1 has a zero coordinate value for the width axis, which means that changes in width for
the variation instance have no effect on the scalar calculations for this region.

R2 has a zero coordinate value for the weight axis, which means that changes in weight
for the variation instance have no effect on the scalar calculations for this region.

R3 has non-zero coordinate values for both weight and width axes, which means that
changes for the variation instance in either weight or width will affect the scalar
calculations for this region.
Now consider the delta values specified in the font for each point in association with
these three regions. X and Y deltas are specified for each point.
R1 has the following associated deltas:
ﾉ

Expand table

pt 0

pt 1

pt 2

pt 3

pt 4

pt 5

X

234

-26

-26

234

0

209

Y

-135

-135

175

175

0

0

Applying these deltas to the original point positions, the maximal effect of deltas
associated with R1 would be to modify the outline as follows:

For a variation instance of (1, 0) (heaviest weight, default width), the scalars for other
regions would be zero, and so this would be the resulting glyph outline for that
instance. Reducing the weight value of the instance would attenuate the extent of the
change, with the outline interpolated in between the original outline and this maximal
modification of the outline.
Now consider R2: it has the following deltas associated with it:
ﾉ

Expand table

pt 0

pt 1

pt 2

pt 3

pt 4

pt 5

X

165

20

20

165

0

187

Y

-2

-2

2

2

0

0

Applying these deltas to the original point positions, the maximal effect of deltas
associated with R2 would be to modify the outline as follows:

For a variation instance of (0, 1) (regular weight, widest width), the scalars for other
regions would be zero, and so this would be the resulting, interpolated glyph outline for
that instance.
Now consider R3: it has the following associated deltas:
ﾉ

Expand table

pt 0

pt 1

pt 2

pt 3

pt 4

pt 5

X

0

0

0

0

0

0

Y

0

0

0

0

0

0

Since all of the delta values are zero, the data associated with this region has no effect at
all on the glyph outline. (In fact, this data is superfluous.)
Now, consider a variation instance of (1, 1) (heaviest weight, widest width). All three
regions, R1, R2 and R3, are applicable for this instance. As noted, the variation data
associated with R3 will have no effect on the glyph. But the data for regions R1 and R2
would also be applicable for this instance, and their maximal effects would be
combined. That is, the X and Y deltas for each point from data associated with both R1

and R2 would be applied to the point X and Y coordinates. This would result in the
glyph outline being modified as follows:

For other variation instances with weight > 0 and < 1 and with width > 0 and < 1, the
data for regions R1 and R2 would both be applied, but scalars for the two regions would
vary, resulting in different proportional effects on the outline of the data for each region.
For example, consider a variation instance with coordinates (0.2, 0.7) — a slight weight
increase and a large width increase. The region scalars for R1 and R2 would be 0.2 and
0.7. Each of these would be applied to the deltas for each region, and the scaled delta
values for a given point combined:
ﾉ

Expand table

pt 0

pt 1

pt 2

pt 3

pt 4

pt 5

X

0.2 × 234
+ 0.7 × 165
= 162.3

0.2 × -26
+ 0.7 × 20
= 8.8

0.2 × -26
+ 0.7 × 20
= 8.8

0.2 × 234
+ 0.7 × 165
= 162.3

0.2 × 0
+ 0.7 × 0
=0

0.2 × 209
+ 0.7 × 187
= 172.7

Y

0.2 × -135
+ 0.7 × -2
= -28.4

0.2 × -135
+ 0.7 × -2
= -28.4

0.2 × 175
+ 0.7 × 2
= 36.4

0.2 × 175
+ 0.7 × 2
= 36.4

0.2 × 0
+ 0.7 × 0
=0

0.2 × 0
+ 0.7 × 0
=0

This would result in the glyph outline being modified as follows:

Dynamic Generation of Static Instance Fonts
In certain application workflows, it may be necessary to dynamically generate a static
font resource for a particular instance — that is, conventional, non-variation font tables
that use interpolated values for a particular instance. This may be needed in order to
provide font data to legacy software or data formats that do not understand or support
variable fonts, such as legacy printer drivers, or PDF or XPS files with embedded font
data.
For example, it may be necessary to process 'glyf' and 'gvar' tables in a variable font to
generate a new 'glyf' table that has interpolated outline data for a particular instance; or
to process 'hhea' and MVAR tables to generate a new 'hhea' table with data for a
particular instance.
Different application scenarios may require more- or less-complete font data, entailing
different sets of non-variations-specific font tables that need to be generated. No
minimal requirements are specified here. The following points should be noted,
however:
Some scenarios may require use of a PostScript name (name ID 6) in instance font
data, with distinct names for each instance that is used. An Adobe technical note

provides a specification for Postscript name generation that can be used for
instance fonts derived from variable fonts. See Adobe Technical Note #5902:
“PostScript Name Generation for Variation Fonts”

.

For a variable font with CFF2 outlines, some workflows — for example, printing —
may require an instance font to be generated with a 'CFF ' table. In such cases, if
the variable font has more than one Font DICT in the FontDICTINDEX, then a CIDkeyed CFF font should be generated, with an ROS of “Adobe-Identity-0”. If the
variable font has one Font DICT in the FontDICTINDEX, then a name-keyed CFF
font can be generated if glyph names are supplied in the 'post' table (some legacy
workflows look to a glyph name for semantics); otherwise, a CID-keyed CFF can be
generated as above. Converting CFF2 CharStrings to Type2 CharStrings would
involve re-optimizing the CharString arguments and operators to avoid exceeding
the maximum permitted stack depth. Most of the CFF fields removed from the
CFF2 specification can be omitted, so that they will inherit the CFF default values.
For a summary of differences between CFF2 and CFF, see Comparison of 'glyf', 'CFF
' and CFF2 tables.
A variable font that has TrueType outlines may utilize the GET VARIATION
instruction to provide current variation axis coordinates to the glyph program. In
scenarios that require dynamic generation of instance font data, it should be
assumed that this instruction will not be supported. In the process for generating
an interpolated 'glyf' table, special treatment of the GET VARIATION instruction will
be needed to ensure that the program gets appropriate axis coordinate values for
the given instance. For details, see The TrueType Instruction Set.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

The OpenType Font File
Article • 05/29/2024

An OpenType font file contains data, in table format, used for rendering of text. Portions
of the data are used by applications to calculate the layout of text using the font; that is,
the selection of glyphs and their placement within a line. Other data provide
descriptions of glyphs as TrueType or Compact Font Format (CFF) outlines. Still other
data can provide monochromatic or color bitmaps, SVG documents or binary, 2D vector
graphics compositions as alternate glyph descriptions. The font data also includes metainformation, such as name strings that can be used to present the font as an available
choice in a font-picker user interface. Each of these types of data is stored in one or
more tables, each designed for a particular purpose.

Filenames
OpenType font files may have the extension .OTF, .TTF, .OTC or .TTC. (The extension may
be upper or lower case.) The extensions .OTC and .TTC should only be used for font
collection files. For additional information on filename extension conventions, see
“Filenames” in Recommendations for OpenType fonts.

Data Types
The following data types are used in the OpenType font file. All OpenType fonts use bigendian (network) byte order:
ﾉ

Data Type

Description

uint8

8-bit unsigned integer.

int8

8-bit signed integer.

uint16

16-bit unsigned integer.

int16

16-bit signed integer.

uint24

24-bit unsigned integer.

uint32

32-bit unsigned integer.

int32

32-bit signed integer.

Expand table

Fixed

32-bit signed fixed-point number (16.16)

FWORD

int16 that describes a quantity in font design units.

UFWORD

uint16 that describes a quantity in font design units.

F2DOT14

16-bit signed fixed number with the low 14 bits of fraction (2.14).

LONGDATETIME

Date and time represented in number of seconds since 12:00 midnight, January
1, 1904, UTC. The value is represented as a signed 64-bit integer.

Tag

Array of four uint8s (length = 32 bits) used to identify a table, design-variation
axis, script, language system, feature, or baseline.

Offset8

8-bit offset to a table, same as uint8, NULL offset = 0x00

Offset16

Short offset to a table, same as uint16, NULL offset = 0x0000

Offset24

24-bit offset to a table, same as uint24, NULL offset = 0x000000

Offset32

Long offset to a table, same as uint32, NULL offset = 0x00000000

Version16Dot16

Packed 32-bit value with major and minor version numbers. (See Table Version
Numbers.)

The F2DOT14 format consists of a signed, 2’s complement integer and an unsigned
fraction. To compute the actual value, take the integer and add the fraction. Examples of
2.14 values are:
ﾉ

Expand table

Decimal Value

Hex Value

Integer

Fraction

1.999939

0x7fff

1

16383/16384

1.75

0x7000

1

12288/16384

0.000061

0x0001

0

1/16384

0.0

0x0000

0

0/16384

-0.000061

0xffff

-1

16383/16384

-2.0

0x8000

-2

0/16384

A Tag value is a uint8 array. Each byte within the array must have a value in the range
0x20 to 0x7E. This corresponds to the range of values of Unicode Basic Latin characters
in UTF-8 encoding, which is the same as the printable ASCII characters. As a result, a Tag
value can be re-interpreted as a four-character sequence, which is conventionally how
they are referred to. Formally, however, the value is a byte array. When re-interpreted as

characters, the Tag value is case sensitive. It must have one to four non-space characters,
padded with trailing spaces (byte value 0x20). A space character must not be followed
by a non-space character.
Within this specification, many structures are defined in terms of the data types listed
above. Structures are characterized as either records or tables. The distinction between
records and tables is based on these general criteria:
Tables are referenced by offsets. If a table contains an offset to a sub-structure, the
offset is normally from the start of that table.
Records occur sequentially within a parent structure, either within a sequence of
table fields or within an array of records of a given type. If a record contains an
offset to a sub-structure, that structure is logically a subtable of the record’s parent
table and the offset is normally from the start of the parent table.
In some cases, fields for subtable offsets are documented as permitting NULL values
when the given subtable is optional. For example, in the BASE table header, the
horizAxisOffset and vertAxisOffset fields may be NULL, meaning that either subtable (or
both) is optional. A NULL subtable offset always indicates that the given subtable is not
present. Applications must never interpret a NULL offset value as the offset to subtable
data. For cases in which subtable offset fields are not documented as permitting NULL
values, font compilers must include a subtable of the indicated format, even if it is a
header stub without further data (for example, a coverage table with no glyph IDs).
Applications parsing font data should, however, anticipate non-conformant font data
that has a NULL subtable offset where only a non-NULL value is expected.

Table Version Numbers
Most tables have version numbers, and the version number for the entire font is
contained in the table directory. Note that there are five different table version number
types, each with its own numbering scheme.
A single uint16 field. This is used in a number of tables, usually with versions
starting at zero (0).
Separate, uint16 major and minor version fields. This is used in a number of tables,
usually with versions starting at 1.0.
A uint32 field with enumerated values.
A uint32 field with a numeric value. This is used only in the DSIG and 'meta' tables.
A Version16Dot16 field for major/minor version numbers. This is used only in the
'maxp', 'post' and 'vhea' tables.

The Version16Dot16 type is used for the version field of certain tables, and only for
reasons of backward compatibility. (In earlier versions, these fields were documented as
using a Fixed value, but had minor version numbers that did not follow the definition of
the Fixed type.) Version16Dot16 is a packed value: the upper 16 bits comprise a major
version number, and the lower 16 bits, a minor version. Non-zero minor version
numbers are represented using digits 0 to 9 in the highest-order nibbles of the lower 16
bits. For example, the version field of 'maxp' table version 0.5 is 0x00005000, and that of
'vhea' table version 1.1 is 0x00011000. This type is used only in the 'maxp', 'post' and
'vhea' tables, and will not be used for any other tables in the future.
The table directory uses a uint32 field, sfntVersion, with an enumeration of defined
values, some of which represent four-character tags; see the section below,
“Organization of an OpenType Font”, for details.
Implementations reading tables must include code to check version numbers so that, if
and when the format and version number changes, older implementations will handle
newer versions gracefully.
Minor version number changes always imply format changes that are compatible
extensions. If an implementation understands a major version number, then it can safely
proceed with reading the table. If the minor version is greater than the latest version
recognized by the implementation, then the extension fields will be undetectable to the
implementation.
For purposes of compatibility, version numbers that are represented using a single
uint16 or uint32 value are treated like a minor version number, and any format changes
are compatible extensions.
Note that some field values that were undefined or reserved in an earlier revision may
be assigned meanings in a minor version change. Implementations should never make
assumptions regarding reserved or unassigned values or bits in bit fields, and can ignore
them if encountered. When writing font data, tools should always write zero for reserved
fields or bits. Validators should warn of any non-zero values for fields or bits that are not
defined for the given version against which data is being validated.
If the major version is not recognized, the implementation must not read the table as it
can make no assumptions regarding interpretation of the binary data. The
implementation should treat the table as missing.

Organization of an OpenType Font
Table Directory

A key characteristic of the OpenType format is the TrueType sfnt “wrapper”, which
provides organization for a collection of tables in a general and extensible manner.
The OpenType font starts with the table directory, which is a directory of the top-level
tables in a font. If the font file contains only one font, the table directory will begin at
byte 0 of the file. If the font file is an OpenType Font Collection file (see below), the
beginning point of the table directory for each font is indicated in the TTCHeader.
TableDirectory:
ﾉ

Expand table

Type

Name

Description

uint32

sfntVersion

0x00010000 or 0x4F54544F ('OTTO') — see below.

uint16

numTables

Number of tables.

uint16

searchRange

Maximum power of 2 less than or equal to numTables,
times 16 ((2**floor(log2(numTables))) * 16, where “**” is
an exponentiation operator).

uint16

entrySelector

Log2 of the maximum power of 2 less than or equal to
numTables (log2(searchRange/16), which is equal to
floor(log2(numTables))).

uint16

rangeShift

numTables times 16, minus searchRange ((numTables *
16) - searchRange).

TableRecord

tableRecords[numTables]

Table records array—one for each top-level table in the
font.

Note: In the preceding table, the symbol “**” is an exponentiation operator, as used
in several programming languages.
OpenType fonts that contain TrueType outlines should use the value of 0x00010000 for
sfntVersion. OpenType fonts containing CFF data (version 1 or 2) should use 0x4F54544F
('OTTO', when re-interpreted as a Tag) for sfntVersion.
Note: Apple's TrueType Reference Manual

allows for 'true' and 'typ1' for

sfntVersion. These version tags should not be used for OpenType fonts.
The table directory format allows for a large number of tables. To assist in quick binary
searches, the searchRange, entrySelector and rangeShift fields are included as
parameters that may be used in configuring search algorithms. Binary search is optimal

when the number of entries is a power of two. The searchRange field provides the
largest number of items that can be searched with that constraint (maximum power of
two). The rangeShift field provides the remaining number of items that would also need
to be searched. The entrySelector field indicates the maximum number of levels into the
binary tree will need to be entered. Values are multiplied by 16, which is the size of each
TableRecord.
In early implementations on devices with limited hardware capabilities, optimizations
provided by the searchRange, entrySelector and rangeShift fields were of high
importance. They have less importance on modern devices, but may still be used in
some implementations. However, incorrect values could potentially be used as an attack
vector against some implementations. Since these values can be derived from the
numTables field when the file is parsed, it is strongly recommended that parsing
implementations not rely on the searchRange, entrySelector and rangeShift fields in the
font but derive them independently from numTables. Font files, however, should
continue to provide valid values for these fields to maintain compatibility with all
existing implementations.
The table directory ends with the tableRecords array. The TableRecord format is as
follows.
TableRecord:
ﾉ

Type

Name

Description

Tag

tableTag

Table identifier.

uint32

checksum

Checksum for this table.

Offset32

offset

Offset from beginning of font file.

uint32

length

Length of this table.

Expand table

Table tags are the names given to tables in the OpenType font file. The tableRecords
array makes it possible for a given font to contain only those tables it actually needs. As
a result, there is no standard value for numTables. The records in the array must be
sorted in ascending order by tag.
For requirements of Tag values, see Data Types, above. Several tags and their associated
table formats are defined in this specification. For table tags defined in this specification,
a font resource should have at most one table record using a given tag. If a font
resource does contain more than one table of a given type, behaviour is unpredictable:

apps or platforms may select one of the tables arbitrarily, or may reject the font as
invalid.
Platform vendors may define additional tables and associated tags to provide platformspecific functionality See, for example, Apple’s TrueType Reference Manual

which

defines various tables with associated tags not defined in OpenType. Some font
development tools may also define special tables. Fonts that contain such additional
tables can still qualify as OpenType fonts if they satisfy the requirements of this
specification. For custom tables defined outside this specification, an external
specification of such a table may permit multiple tables of that type within a single font
resource.
Note: Vendors should notify Microsoft when they define custom tags to ensure
forward compatibility in the event of future expansion of OpenType.
Note: Apple’s specification

stipulates that tag names consisting of all lower case

letters are reserved for Apple’s use.
All tables must begin on four-byte boundaries, and any remaining space between tables
must be padded with zeros. The length of each table should be recorded in the table
record with the actual length of data, not the padded length.
Note: The requirement for four-byte alignment applies to top-level tables only and
does not extend to sub-table offsets, records, or fields within tables or records.
Some tables have an internal structure with subtables located at specified offsets, and as
a result, it is possible to construct a font with data for different tables interleaved. In
general, tables should be arranged contiguously without overlapping the ranges of
distinct tables. In any case, however, table lengths measure a contiguous range of bytes
that encompasses all of the data for a table. This applies to any subtables as well as to
top-level tables.

Calculating Checksums
Table checksums are the unsigned sum of the uint32 units of a given table. In C, the
following function can be used to determine a checksum:

uint32
CalcTableChecksum(uint32 *Table, uint32 Length)
{

uint32 Sum = 0L;
uint32 *EndPtr = Table+((Length+3) & ~3) / sizeof(uint32);
while (Table < EndPtr)
Sum += *Table++;
return Sum;
}

Note: This function assumes that the length of any table is a multiple of four bytes,
or that tables are padded with zero to four-byte aligned offsets. Actual table lengths
recorded in the table directory should not include padding, however. To
accommodate data with a length that is not a multiple of four, the above algorithm
must be modified to treat the data as though it contains zero padding to a length
that is a multiple of four.
The 'head' table is a special case in checksum calculations, as it includes a
checksumAdjustment field that is calculated and written after the table’s checksum is
calculated and written into the table directory entry, necessarily invalidating that
checksum value.
When generating font data, to calculate and write the 'head' table checksum and
checksumAdjustment field, do the following:
1. Set the checksumAdjustment field to 0.
2. Calculate the checksum for all tables including the 'head' table and enter the value
for each table into the corresponding record in the table directory.
3. Calculate the checksum for the entire font.
4. Subtract that value from 0xB1B0AFBA.
5. Store the result in the 'head' table checksumAdjustment field.
An application attempting to verify that the 'head' table has not changed should
calculate the checksum for that table assuming that the checksumAdjustment value is
zero, rather than the actual value in the font, before comparing the result with the 'head'
table record in the table directory.
Within a font collection file (see below), table checksums must reflect the tables as they
are in the collection file. The checksumAdjustment field in the 'head' table is not used
for collection files and may be set to zero.

Font Collections
An OpenType Font Collection (either TTC or OTC, formerly known as TrueType
Collection) is a means of delivering multiple OpenType font resources in a single file
structure. The format for font collections allows font tables that are identical between

two or more fonts to be shared. Font collections containing outline glyph data
(TrueType, CFF, CFF2 or SVG) are most useful when the fonts to be delivered together
share many glyphs in common. By allowing multiple fonts to share glyph sets and other
common font tables, font collections can result in a significant saving of file space.
For example, a group of Japanese fonts may each have their own designs for the kana
glyphs, but share identical designs for the kanji. With ordinary OpenType font files, the
only way to include the common kanji glyphs is to copy their glyph data into each font.
Since the kanji represent much more data than the kana, this results in a great deal of
wasteful duplication of glyph data. Font collections were defined to solve this problem.
Note: Even though the original definition of Font Collection (as part of the TrueType
specification) was intended to be used with fonts containing TrueType outlines, and
this constraint was maintained in earlier OpenType versions, this is no longer a
constraint in OpenType. Font collection files may contain various types of outlines
(or a mix of them), regardless of whether or not fonts have layout tables present. For
backward compatibility and simplicity, the description of the font collection file
structure is using the term “TrueType Collection”, or “TTC”, though it is understood
that it is used to identify a generic font collection structure containing any type of
outline tables.
Note: An OpenType variable font is functionally equivalent to multiple non-variable
fonts. Variable fonts do not need to be contained within a collection file. A collection
file can include one or even multiple variable fonts, however, and may even combine
variable and non-variable fonts.

The Font Collection File Structure
A font collection file consists of a single TTC header table, one or more table directories
(each corresponding to a different font resource), and a number of OpenType tables.
The TTC header must be located at the beginning of the TTC file.
The TTC file must contain a complete table directory for each font resource. The same
TableDirectory format is used for each font resource in a collection file as is used in a
non-collection file. The table offsets in all table directories within a TTC file are measured
from the beginning of the TTC file.
Each OpenType table in a TTC file is referenced through the table directory of each font
which uses that table. Some of the OpenType tables must appear multiple times, once
for each font included in the TTC; while other tables may be shared by multiple fonts in
the TTC.

As an example, consider a TTC file which combines two Japanese fonts (Font1 and
Font2). The fonts have different kana designs (Kana1 and Kana2) but use the same
design for kanji. The TTC file contains a single 'glyf' table which includes both designs of
kana together with the kanji; both fonts’ table directories point to this 'glyf' table. But
each font’s table directory points to a different 'cmap' table, which identifies the glyph
set to use. Font1’s 'cmap' table points to the Kana1 region of the 'loca' and 'glyf' tables
for kana glyphs, and to the kanji region for the kanji. Font2’s 'cmap' table points to the
Kana2 region of the 'loca' and 'glyf' tables for kana glyphs, and to the same kanji region
for the kanji.
The tables that should have a unique copy per font are those that are used by the
system in identifying the font and its character mapping, including 'cmap', 'name', and
OS/2. The tables that should be shared by fonts in the TTC are those that define glyph
and instruction data or use glyph indices to access data: 'glyf', 'loca', 'hmtx', 'hdmx',
LTSH, 'cvt ', 'fpgm', 'prep', EBLC, EBDT, EBSC, 'maxp', and so on. In practice, any tables
which have identical data for two or more fonts may be shared.
Note: When building a collection file from separate font files, close attention needs
to be paid to the issue of glyph renumbering in a font and the side effects that can
result in the 'cmap' table and elsewhere. The fonts to be merged also need to have
compatible TrueType instructions; that is, their preprograms, function definitions,
and control values cannot conflict.
Collection files containing TrueType glyph outlines should use the file extension .TTC.
Collection files containing CFF or CFF2 outlines should use the file extension .OTC.

TTC Header
There are two versions of the TTC header: Version 1.0 has been used for TTC files
without digital signatures. Version 2.0 can be used for TTC files with or without digital
signatures — if there’s no signature, then the last three fields of the version 2.0 header
are left null.
If a digital signature is used, the DSIG table for the file must be located at the end of the
TTC file, following any other font tables. Signatures in a TTC file are expected to be
Format 1 signatures.
The purpose of the TTC header table is to locate the different table directories within a
TTC file. The TTC header is located at the beginning of the TTC file (offset = 0). It consists
of an identification tag, a version number, a count of the number of OpenType fonts in
the file, and an array of offsets to each table directory.

TTCHeader Version 1.0:
ﾉ

Expand table

Type

Name

Description

Tag

ttcTag

Font Collection ID string: 'ttcf' (used for fonts with
CFF or CFF2 outlines, as well as TrueType outlines)

uint16

majorVersion

Major version of the TTCHeader, = 1.

uint16

minorVersion

Minor version of the TTCHeader, = 0.

uint32

numFonts

Number of fonts in TTC

Offset32

tableDirectoryOffsets[numFonts]

Array of offsets to the TableDirectory for each font
from the beginning of the file

TTCHeader Version 2.0:
ﾉ

Expand table

Type

Name

Description

Tag

ttcTag

Font Collection ID string: 'ttcf'

uint16

majorVersion

Major version of the TTCHeader, = 2.

uint16

minorVersion

Minor version of the TTCHeader, = 0.

uint32

numFonts

Number of fonts in TTC

Offset32

tableDirectoryOffsets[numFonts]

Array of offsets to the TableDirectory for each font
from the beginning of the file

uint32

dsigTag

Tag indicating that a DSIG table exists, 0x44534947
('DSIG') (null if no signature)

uint32

dsigLength

The length (in bytes) of the DSIG table (null if no
signature)

uint32

dsigOffset

Font Tables
Required Tables

The offset (in bytes) of the DSIG table from the
beginning of the TTC file (null if no signature)

Whether TrueType or CFF outlines are used in an OpenType font, the following tables are
required for the font to function correctly:
ﾉ

Tag

Name

'cmap'

Character to glyph mapping

'head'

Font header

'hhea'

Horizontal header

'hmtx'

Horizontal metrics

'maxp'

Maximum profile

'name'

Naming table

OS/2

OS/2 and Windows specific metrics

'post'

PostScript information

Expand table

Tables Related to TrueType Outlines
For OpenType fonts based on TrueType outlines, the following tables are used:
ﾉ

Tag

Name

'cvt '

Control Value Table (optional table)

'fpgm'

Font program (optional table)

'glyf'

Glyph data

'loca'

Index to location

'prep'

Control Value Program (optional table)

'gasp'

Grid-fitting/Scan-conversion (optional table)

Tables Related to CFF Outlines
For OpenType fonts based on CFF outlines, the following tables are used:

Expand table

ﾉ

Tag

Name

'CFF '

Compact Font Format 1.0

CFF2

Compact Font Format 2.0

VORG

Vertical Origin (optional table)

Expand table

It is strongly recommended that CFF OpenType fonts that are used for vertical writing
include a Vertical Origin (VORG) table.

Table Related to SVG Outlines

Tag

Name

'SVG '

The SVG (Scalable Vector Graphics) table

ﾉ

Expand table

ﾉ

Expand table

Tables Related to Bitmap Glyphs

Tag

Name

EBDT

Embedded bitmap data

EBLC

Embedded bitmap location data

EBSC

Embedded bitmap scaling data

CBDT

Color bitmap data

CBLC

Color bitmap location data

'sbix'

Standard bitmap graphics

OpenType fonts may also contain bitmaps of glyphs, in addition to outlines. Hand-tuned
bitmaps are especially useful in OpenType fonts for representing complex glyphs at very
small sizes. If a bitmap for a particular size is provided in a font, it will be used by the
system instead of the outline when rendering the glyph.

Advanced Typographic Tables

Several optional tables support advanced typographic functions:
ﾉ

Tag

Name

BASE

Baseline data

GDEF

Glyph definition data

GPOS

Glyph positioning data

GSUB

Glyph substitution data

JSTF

Justification data

MATH

Math layout data

Expand table

For information on common table formats, please see OpenType Layout Common Table
Formats .

Tables used for OpenType Font Variations
ﾉ

Expand table

Tag

Name

'avar'

Axis variations

'cvar'

CVT variations (TrueType outlines only)

'fvar'

Font variations

'gvar'

Glyph variations (TrueType outlines only)

HVAR

Horizontal metrics variations

MVAR

Metrics variations

STAT

Style attributes (required for variable fonts, optional for non-variable fonts)

VVAR

Vertical metrics variations

For an overview of OpenType Font Variations and the specification of the interpolation
algorithm used for variations, see OpenType Font Variations Overview. For details
regarding which tables are required or optional in variable fonts, see Variation Data
Tables and Miscellaneous Requirements in the Overview chapter.

For information on common table formats used for variations, see OpenType Font
Variations Common Table Formats.
Note that some variation-related formats may be used in tables other than the
variations-specific tables listed above. In particular, the GDEF, BASE or COLR tables in a
variable font can include variation data using common table formats. A CFF2 table in a
variable font can also include variation data, though using formats that are specific to
the CFF2 table.

Tables Related to Color Fonts
ﾉ

Tag

Name

COLR

Color table

CPAL

Color palette table

CBDT

Color bitmap data

CBLC

Color bitmap location data

'sbix'

Standard bitmap graphics

'SVG '

The SVG (Scalable Vector Graphics) table

Expand table

Note that several of these tables were also listed in other sections for tables related to
SVG outlines, and for tables related to bitmap glyphs.

Other OpenType Tables
ﾉ

Tag

Name

DSIG

Digital signature

'hdmx'

Horizontal device metrics

'kern'

Kerning

LTSH

Linear threshold data

MERG

Merge

'meta'

Metadata

Expand table

STAT

Style attributes

PCLT

PCL 5 data

VDMX

Vertical device metrics

'vhea'

Vertical Metrics header

'vmtx'

Vertical Metrics

Note that the STAT table is required in variable fonts. Also, the 'hdmx' and VDMX tables
are not used in variable fonts.

OpenType™ Layout Common Table
Formats
Article • 07/06/2024

OpenType Layout makes use of five tables: the Glyph Substitution table (GSUB), the Glyph
Positioning table (GPOS), the Baseline table (BASE), the Justification table (JSTF), and the
Glyph Definition table (GDEF). These tables use some of the same data formats. This chapter
defines these common formats and explains conventions used in all OpenType Layout
tables. The common formats are also used in the Mathematical Typesetting table (MATH).
Separate chapters provide all other details of the GSUB, GPOS, BASE, JSTF, GDEF and MATH
tables.
Example tables and lists that illustrate the common data formats are supplied at the end of
this chapter.

Overview
The OpenType Layout tables provide typographic information for substituting and
positioning glyphs, operations that are required for correct text display of many scripts as
well as for high quality typography. OpenType Layout data is organized by script, language
system, typographic feature, and lookup.
At the top level, data is organized by script. A script is a collection of glyphs used to
represent one or more languages in written form (see Figure 2a). For instance, a single
script, Latin, is used to write English, French, German, and many other languages. In contrast,
Japanese is written using three scripts: Hiragana, Katakana, and Kanji. With OpenType
Layout, multiple scripts can be supported by a single font.

Figure 2a. Glyphs in the Latin, Kanji, and Arabic scripts
For each script, data is then organized by one or more language systems, which allows a font
to support different typographic conventions for different language contexts. For example,
Turkish has different upper and lower case relationships from most other languages written
with Latin script, and that affects the glyph selection that is needed when a small caps
feature ('smcp') is used.

Figure 2b. Differences in the English and Turkish language systems
A language system specifies features, which represent typographic effects on glyphs. Some
examples of features are a 'vert' feature for substituting vertical glyphs in Japanese, a 'liga'
feature for using ligatures in place of separate glyphs, and a 'mark' feature for positioning
diacritical marks with respect to base glyphs in Arabic.

Figure 2c. A ligature glyph feature substitutes the <et> ligature for individual glyphs, and a
'mark' feature positions diacritical marks above an Arabic ligature glyph.
In the absence of language-specific rules, a default language system specifies features to be
applied for the given script. For instance, a default language system feature for the Arabic
script would specify features to substitute initial, medial, and final glyph forms based on a
glyph’s position in a word.
An application may use its own criteria to determine when to use a specific language system
or the default language system. When doing layout for a run of text, it uses features
specified by one or the other, but not both.
Features are implemented with lookup data that the text-processing client uses to substitute
and position glyphs. Lookups describe the glyphs affected by an operation, the type of
operation to be applied to these glyphs, and the resulting glyph output.
A font may also include FeatureVariations data within a GPOS or GSUB table that allows the
default lookup data associated with a feature to be substituted by alternate lookup data
when particular conditions apply. Currently, this mechanism is used only for variable fonts
using OpenType Font Variations.

OpenType Layout and Font Variations

OpenType Font Variations allow a single font to support many design variations along one
or more axes of design variation. For example, a font with weight and width variations might
support weights from thin to black, and widths from ultra-condensed to ultra-expanded. For
general information on OpenType Font Variations, see the chapter, OpenType Font
Variations Overview.
When different variation instances are selected, the design and metrics of individual glyphs
changes. This can impact font-unit values given in GPOS, BASE, JSTF or GDEF tables, such as
the X and Y coordinates of an attachment anchor position. The font-unit values given in
these tables apply to the default instance of a variable font. If adjustments are needed for
different variation instances, this is done using variation data with processes similar to those
used for glyph outlines and other font data, as described in the chapter, OpenType Font
Variations Overview. The variation data for GPOS, JSTF or GDEF values is contained in an
ItemVariationStore table which, in turn, is contained within the GDEF table; variation data for
BASE values is contained in an ItemVariationStore table within the BASE table itself. The
format of the ItemVariationStore is described in detail in the chapter, OpenType Font
Variations Common Table Formats. For font-unit values within the GPOS, BASE, JSTF or GDEF
tables that require variation, references to specific variation data within the
ItemVariationStore are provided in VariationIndex tables, described below.
In some variable fonts, it might be desirable to have different glyph-substitution or glyphpositioning actions used for different regions within the font’s variation space. For example,
for narrow or heavy instances in which counters become small, it might be desirable to
make certain glyph substitutions to use alternate glyphs with certain strokes removed or
outlines simplified to allow for larger counters. Such effects can be achieved using a
FeatureVariations table within either the GSUB or GPOS table. The FeatureVariations table is
described below.

Table organization
Two OpenType Layout tables, GSUB and GPOS, use the same data formats to describe the
scripts and languages they support, and the typographic glyph operations used for each
supported script and language: a ScriptList table, a FeatureList table, a LookupList table, and
an optional FeatureVariations table. In GSUB, the tables define glyph substitution data. In
GPOS, they define glyph positioning data. This section describes the organization and
relationship between these formats; the following sections describe the formats in detail.
The ScriptList identifies the scripts in a font, each of which is represented by a Script table.
Each Script table has a default language system table plus zero or more tables for specific
language systems. Language system tables reference Feature tables defined in the
FeatureList. Each Feature table references Lookup tables defined in the LookupList that
describes glyph actions that implement the feature.

Figure 2d. The relationship of scripts, language systems, features, and lookups for
substitution and positioning tables
Note: The data in the BASE and JSTF tables also is organized by script and language
system. However, the data formats differ from those in GSUB and GPOS, and they do
not include a FeatureList or LookupList. The BASE and JSTF data formats are described in
the BASE and JSTF chapters.
The information used to substitute and position glyphs is defined in Lookup subtables. Each
subtable supplies one type of information, depending upon whether the lookup is part of a
GSUB or GPOS table. For instance, a GSUB lookup might specify the glyphs to be substituted
and the context in which a substitution occurs, and a GPOS lookup might specify glyph
position adjustments for kerning. OpenType Layout has eight types of GSUB lookups
(described in the GSUB chapter) and nine types of GPOS lookups (described in the GPOS
chapter).
Each subtable (except for an Extension LookupType subtable) includes a Coverage table that
lists the “covered” glyphs that will result in a glyph substitution or positioning operation.
The Coverage table formats are described in a later section of this chapter.
Some substitution or positioning operations could apply to groups, or classes, of glyphs.
GSUB and GPOS Lookup subtables use the Class Definition table to assign glyphs to classes.

A description of the Class Definition table formats is provided later in this chapter.
In non-variable fonts, GPOS Lookup subtables may also contain Device tables to adjust
scaled contour glyph coordinates for particular output sizes and resolutions. Device tables
can also be used for similar adjustments to baseline metric or caret offset values in the BASE
and GDEF tables. Similarly, in variable fonts, GPOS lookup subtables, BaseCoord tables and
CaretValue tables may contain VariationIndex tables that reference variation data to adjust
font-unit values as needed for different variation instances within a font’s design variation
space. Device and VariationIndex tables are described in a later section of this chapter.
As mentioned above, a feature table references a set of lookups in the lookup list. The
FeatureVariations table allows the default set of lookups used for a given feature to be
substituted by a different set of lookups under particular conditions. This can be used in
variable fonts to provide different substitution or positioning actions for different variation
instances. For example, for narrow or heavy instances in which counters become small, it
may be desirable to make certain glyph substitutions to use alternate glyphs with certain
strokes removed or outlines simplified to allow for larger counters.

Scripts and languages
Three tables and their associated records apply to scripts and languages: the ScriptList table
and its script record (ScriptRecord), the Script table and its language system record
(LangSysRecord), and the Language System table (LangSys).

ScriptList table
A font may contain one or more groups of glyphs used to render various scripts, which are
enumerated in a ScriptList table. Both the GSUB and GPOS tables define ScriptList tables:
The GSUB table uses the ScriptList table to access the glyph substitution features that
apply to a script. For details, see the chapter, The Glyph Substitution Table (GSUB).
The GPOS table uses the ScriptList table to access the glyph positioning features that
apply to a script. For details, see the chapter, The Glyph Positioning Table (GPOS).
A ScriptList table consists of a count of the scripts represented by the glyphs in the font
(ScriptCount) and an array of records (ScriptRecord), one for each script for which the font
defines script-specific features (a script without script-specific features does not need a
ScriptRecord). Each ScriptRecord consists of a ScriptTag that identifies a script, and an offset
to a Script table. The ScriptRecord array is stored in alphabetic order of the script tags.
A Script table with the script tag DFLT (default) may be used in a font to define features that
are not script-specific. An application should use a DFLT script table if there is not a script
table associated with the specific script of the text being formatted, or if the text does not
have a specific script (for example, it contains only symbols or punctuation).

Note: If symbols or punctuation have a Unicode script property “Common” but are used
together with characters of a specific script, features that apply to those symbol or
punctuation characters should not necessarily be organized under the DFLT script, but
can be organized under the specific script. Applications may process script-neutral
characters together with immediately-preceding or following script-specific characters
for better processing efficiency. In that case, an application would look for features that
operate on the neutral characters by using the Script table for the specific script. The
DFLT script would still be used if the text contained only the neutral characters, however.
If there is a DFLT script table, it must have a default language system table
(defaultLangSysOffset must not equal NULL—see below).
As languages are written using particular scripts, it is normally expected that languagespecific typographic effects will be associated with a particular script, not with the generic
DFLT script. For this reason, a DFLT script table should normally have only the default
language system table, not language-specific tables. However, a font may have a DFLT script
table with non-default language system tables, and an application may use features
associated with one of these if the DFLT script table is applicable — no script table is present
for the specific script, or there is no specific script in the text context — and if one of the
particular language systems is specified. Under such conditions, applications should support
use of a non-default language system table that is associated with DFLT script if a font
includes tables with this configuration.
Example 1 at the end of this chapter shows a ScriptList table and ScriptRecords for a
Japanese font that uses three scripts.
ScriptList table
ﾉ

Expand table

Type

Name

Description

uint16

scriptCount

Number of ScriptRecords

ScriptRecord

scriptRecords[scriptCount]

Array of ScriptRecords, listed alphabetically by script tag

ScriptRecord
ﾉ

Type

Name

Description

Tag

scriptTag

4-byte script tag identifier

Offset16

scriptOffset

Offset to Script table, from beginning of ScriptList

Expand table

Script table
A Script table may specify one or more language systems that define behaviors of the
glyphs in a script for a particular language. It also references a default language system that
defines behaviors of the script’s glyphs to be used in the absence of language-specific
information.
A Script table begins with an offset to the default language system table
(defaultLangSysOffset), which defines the set of features that regulate the default behavior
for the script. Next, a count of language-specific language systems is given (langSysCount),
followed by a corresponding array of language system records (LangSysRecord). Each record
specifies a language system using a language system tag (langSysTag), and specifies an
offset to a language system table (LangSys). The LangSysRecord array must be sorted
alphabetically by language system tag. If no language-specific behavior is defined, the
langSysCount field is set to zero and the LangSysRecord array is empty.
Script table
ﾉ

Expand table

Type

Name

Description

Offset16

defaultLangSysOffset

Offset to default LangSys table, from beginning of
Script table — may be NULL.

uint16

langSysCount

Number of records in the langSysRecords array.

LangSysRecord

langSysRecords[langSysCount]

Array of LangSysRecords, sorted alphabetically by
LangSys tag.

LangSysRecord
ﾉ

Type

Name

Description

Tag

langSysTag

4-byte LangSysTag identifier.

Offset16

langSysOffset

Offset to LangSys table, from beginning of Script table.

Expand table

Language system table
The language system table (LangSys) identifies features used for layout of the glyphs in a
script. Features are specified as zero-based indices into a FeatureList table, defined in the
next section of this chapter.

Optionally, a LangSys table may define a required feature index (the requiredFeatureIndex
field) to specify one feature as required within the context of a particular language system.
For example, in the Cyrillic script, the Serbian language system uses different glyphs for
certain characters than the Russian language system. Only one feature index value can be
specified as a required feature. This is not a functional limitation, however, because feature
and lookup definitions are structured so that one feature table can reference many glyph
substitution or positioning lookups. When no required features are defined, then
requiredFeatureIndex is set to 0xFFFF.
All other features are considered optional with respect to the general requirements for
processing the language system table. Applications, however, may treat certain features as
required in certain contexts, regardless of whether a feature is referenced using the
requiredFeatureIndex field. In particular, applications may treat certain features as required
for correct layout of certain Unicode characters or scripts. Such higher-level requirements
are outside the scope of this specification.
Example 2 at the end of this chapter shows a Script table, LangSysRecord, and LangSys table
used for contextual positioning in the Arabic script.
LangSys table
ﾉ

Expand table

Type

Name

Description

Offset16

lookupOrderOffset

Reserved—set to NULL.

uint16

requiredFeatureIndex

Index of a feature required for this language system; if
no required features, set to 0xFFFF.

uint16

featureIndexCount

Number of elements in the featureIndices array.

uint16

featureIndices[featureIndexCount]

Array of indices into the FeatureList, in arbitrary order.

The lookupOrderOffset field is reserved for future use. Indices in the featureIndices array
may be in arbitrary order.

Features and lookups
Overview
Features define the advanced layout capabilities of a font and are named to convey
meaning to the text-processing client. Consider a feature identified using the tag 'liga' to
create ligatures. Because of its name, the client knows what the feature does and can decide
whether to apply it. Several features have been defined and can be used in fonts and

applications; see the Feature Tags section of the OpenType Layout Tag Registry for more
information. Font developers can also define their own features.
When designing a font, the font developer selects features according to the typographic
capabilities the font will support. For each feature, they then implement one or more
lookups that describe the glyph substitution or glyph positioning actions to be performed.
Multiple lookups may be used for a given feature; in that case the lookup actions will be
performed in sequential order. In some cases, multiple lookups applied in a specific order
could be needed to obtain a desired effect.
When performing layout on a run of text, a client chooses the features to be applied to the
run and then processes the lookups referenced by these features in the order the lookup
definitions occur in the LookupList. As a result, within the GSUB or GPOS table, lookups from
several different features may be interleaved during text processing. It is up to the font
developer to determine the proper order of actions performed by the lookups.
A client may process GSUB features in ordered stages, with particular features processed in
each stage. A client may also perform certain operations on glyph sequences, such as
reordering of glyphs, before or between these stages. Such processing is required for
correct support of many scripts. Details on such script-specific processing is outside the
scope of this specification. Within any such feature-processing stage, however, lookups
referenced by the features applied in that stage must be processed in LookupList order.
Lookup data is defined in one or more subtables that contain information about specific
glyphs and the operations to be performed on them. Different lookup types support
different types of operation; for example, positioning adjustment on a single glyph versus
positioning adjustments on pairs of glyphs. Each type of lookup has one or more
corresponding subtable format definitions. The choice of a subtable type and format
depends upon two factors: the precise content of the information being applied to an
operation, and the required storage efficiency. For complete definitions of all lookup types
and subtables, see the GSUB and GPOS chapters of this document.
Processing of a lookup is finished when the client locates a target glyph or glyph context
and performs the substitution or positioning action described.
Features and lookups define information that is specific to the glyphs in a given font. They
do not encode information that is constant within the conventions of a particular language
or the typography of a particular script. Information that would be replicated across all fonts
for a given script or language belongs in the text-processing application for that language,
not in the fonts.

FeatureList table

The headers of the GSUB and GPOS tables contain offsets to FeatureList tables that
enumerate all the features in a font. Features in a FeatureList are not limited to any single
script. A FeatureList contains the entire list of either the GSUB or GPOS features that are
used for layout of glyphs for all the scripts supported by the font.
The FeatureList table enumerates features in an array of records (FeatureRecord). Every
feature requires a FeatureRecord, which consists of a feature tag that identifies the feature
and an offset to a Feature table (described in the next section).
Note: The values stored in the FeatureIndex array of a LangSys table are zero-based
indices used to locate records in the FeatureRecord array of a FeatureList table.
A Feature table describes the lookups used to implement a given feature for a given script
and language system. The implementation for a feature will typically be different for
different scripts or language systems, requiring distinct Feature tables. Thus, the FeatureList
table may include two or more records with the same feature tag when the feature is
implemented for multiple scripts or language systems.
The FeatureRecord array should be sorted alphabetically by feature tag. If two or more
records have the same feature tag, their relative order is arbitrary.
FeatureList table
ﾉ

Expand table

Type

Name

Description

uint16

featureCount

Number of records in the featureRecords array.

FeatureRecord

featureRecords[featureCount]

Array of FeatureRecords.

FeatureRecord
ﾉ

Type

Name

Description

Tag

featureTag

4-byte feature identification tag.

Offset16

featureOffset

Offset to Feature table, from beginning of FeatureList.

Expand table

Feature table
A feature table defines the implementation of a feature using one or more lookups. Feature
tables defined within the GSUB table contain references to glyph substitution lookups;
feature tables defined within the GPOS table contain references to glyph positioning

lookups. If a feature requires both glyph substitution and positioning actions, then Feature
tables referenced using the same feature tag will need to be defined in both the GSUB and
GPOS tables.
A Feature table consists of an offset to a feature parameters table, a count of the lookups
listed for the feature, and an arbitrarily ordered array of indices into a LookupList (described
in the next section).
Feature parameters tables may only be used for certain features. The format of a features
parameters table is specific to a particular feature and is specified in the description for that
feature in the Feature Tags section of the OpenType Layout Tag Registry. Currently, feature
parameters tables are defined only for the following features:
'cv01' – 'cv99'
'size'
'ss01' – 'ss20'
A feature parameters table may be required or optional, according to the specifications for a
given feature. The length of a feature parameters table must be implicitly or explicitly
specified in the table itself. The featureParamsOffset field in the Feature table gives the
offset relative to the beginning of the Feature table. If a feature parameters table is not
defined for a given feature, or if a feature parameters table is defined but not used in a
given font, the featureParamsOffset field must be set to NULL.
To identify the features in a GSUB or GPOS table for a given script and language system, a
text-processing client reads the feature tag of each FeatureRecord referenced in the given
LangSys table. Then the client selects the features it wants to implement and uses the
lookupListIndices arrays from the Feature tables for the selected features to obtain a list of
Lookup indices for the chosen features. Next, the client arranges the indices numerically into
their LookupList order. Finally, the client retrieves the referenced Lookup tables from the
LookupList and applies the lookup data to substitute or position glyphs.
Example 3 at the end of this chapter shows the FeatureList and Feature tables used to
substitute ligatures in two languages.
Feature table
ﾉ

Expand table

Type

Name

Description

Offset16

featureParamsOffset

Offset from start of Feature table to feature
parameters table, if defined for the feature and
present, else NULL.

uint16

lookupIndexCount

Number of elements in the lookupListIndices array.

uint16

lookupListIndices[lookupIndexCount]

Array of indices into the LookupList — zero-based.

LookupList table
The headers of the GSUB and GPOS tables contain offsets to LookupList tables for glyph
substitution and glyph positioning lookups. The LookupList table contains an array of offsets
to Lookup tables. The font developer defines the order of offsets in the array to control the
order in which a text-processing client processes lookup data to perform glyph substitution
or positioning operations.
Example 4 at the end of this chapter shows three ligature lookups in a LookupList table.
LookupList table
ﾉ

Expand table

Type

Name

Description

uint16

lookupCount

Number of elements in the lookupOffsets array.

Offset16

lookupOffsets[lookupCount]

Array of offsets to Lookup tables, from beginning of
LookupList.

Lookup table
A Lookup table defines the specific conditions, type, and results of substitution or
positioning actions that are used to implement a feature. For example, a substitution
operation requires a list of target glyph indices to be replaced, a list of replacement glyph
indices, and a description of the type of substitution action.
The data describing the actions of a lookup are contained in one or more lookup subtables.
Different lookup types support different types of operation; for example, positioning
adjustment on a single glyph versus positioning adjustments on pairs of glyphs. The type of
operation determines the information that needs to be included in the lookup subtables. A
given lookup table may support only one type of operation, and so may contain only
subtables of the same lookup type.
The GSUB table supports eight lookup types; the GPOS table supports nine lookup types.
See the GSUB and GPOS chapters for details about the various types of substitution and
positioning lookups.
For each lookup type, one or more subtable formats are defined. Each format is determined
by the content of the information required for an operation and by required storage
efficiency. When glyph information is best presented in more than one format, a single

lookup may contain more than one subtable, as long as all the subtables are the same
lookup type. For example, within a given lookup, a glyph index array format may best
represent one set of target glyphs, whereas a glyph index range format may be better for
another set of target glyphs.
During text processing, a client applies a feature to some sequence of glyphs for a string. It
then processes the lookups referenced by that feature in their lookup list order. For each
lookup, the client processes that lookup over each glyph in the sequence to which the
feature has been applied. After that lookup has been processed over the entire glyph
sequence, it then processes the next lookup referenced by the feature in the same manner.
As each lookup is processed, it acts on the substitution or positioning results of the previous
lookups. This continues until all lookups referenced by the feature have been processed.
An application may process lookups for multiple features simultaneously. In this case, the list
of lookups is the union of lookups referenced by all of those features, and these are all
processed in their lookup list order. If the different features have been applied to different
glyph sub-sequences for a string, each lookup is applied only to the sub-sequence to which
the feature that referenced that lookup was applied.
A lookup specifies one or more input sequence patterns, each with one or more glyphs.
When the lookup is processed over a glyph sequence within a string, the client starts with
the first glyph in the sequence, testing for a match with the input sequence patterns
specified by the lookup. If the glyph sequence does not match any of the lookup input
sequence patterns, processing of the lookup is finished for that glyph, and the client
advances to the next glyph in the glyph sequence. If the glyph sequence does match a
lookup input sequence pattern, then the corresponding substitution or position operation is
performed on the matched input sequence. A lookup is finished for a glyph after the client
has performed the substitution or positioning operation. To move to the “next” glyph, the
client skips all the glyphs that participated in the lookup operation: glyphs that were
substituted/positioned as well as any other glyphs in the matched input sequence. However,
an exception to this rule is made in the case of pair positioning operations (for example,
kerning): the “next” glyph in a sequence may be the second glyph of the input sequence
pair, rather than skipping over the entire input sequence. (See the pair positioning lookup
type for details.)
If a Lookup table has multiple subtables, the subtables are processed in order, testing the
glyph sequence at the current glyph position for a match with the input sequence patterns
specified by each subtable in turn. If there is no match with the pattern of a subtable, then
processing moves to the next subtable. If the glyph sequence does not match the patterns
of any lookup subtable, processing of the lookup is finished for that glyph position. If the
glyph sequence does match the pattern of a subtable, then the operations of that subtable
are performed and processing of the lookup is finished—no further subtables are processed
for that position in the glyph sequence.

Both the GPOS and GSUB tables include lookup types that allow chained contexts: GSUB
lookup type 6, and GPOS lookup type 8. Chained context lookup types support specifying
backtrack and lookahead sequence patterns that precede and follow the input sequence
pattern. These must also be matched in the glyph sequence for a lookup to apply at a given
position in the glyph sequence. Unlike the input sequence pattern, matching of the
backtrack and lookahead sequences is not restricted to the glyph sequence to which the
associated feature was applied. A chained context lookup can specify actions for glyphs in
the matched input sequence, but not in the backtrack or lookahead sequences. After a
chained context lookup has been processed, the client sets the “next” glyph by skipping
over the input sequence, but not the lookahead sequence.
A Lookup table specifies a lookup type that defines the type of information stored in lookup
subtables. A lookup flag specifies lookup qualifiers that indicate to a text-processing client
certain processing options to use when substituting or positioning glyphs. An array of
offsets provides offsets from the start of the Lookup table to one or more lookup subtables
of the specified lookup type. An optional field provides an additional qualifier on mark
glyphs.
Lookup table
ﾉ

Expand table

Type

Name

Description

uint16

lookupType

Different enumerations for GSUB and GPOS.

uint16

lookupFlag

Lookup qualifiers.

uint16

subTableCount

Number of elements in the subtableOffsets array.

Offset16

subtableOffsets[subTableCount]

Array of offsets to lookup subtables, from beginning of
Lookup table.

uint16

markFilteringSet

Index (base 0) into GDEF mark glyph sets structure. This
field is only present if the USE_MARK_FILTERING_SET
lookup flag is set.

The order of offsets in the subtableOffsets array determines the order in which lookup
subtables will be processed.
The lookup flag uses two bytes of data:
Each of the first four low-order bits can be set in order to specify additional
instructions for applying a lookup to a glyph sequence. The table below provides
details about the use of these bits.
The fifth bit indicates the presence of a markFilteringSet field in the Lookup table.
The next three bits are reserved for future use.

The high byte can be used to specify a class of mark glyphs as a glyph filter.
LookupFlag bit enumeration
ﾉ

Expand table

Mask

Name

Description

0x0001

RIGHT_TO_LEFT

This bit is used only in relation to cursive attachment
positioning (GPOS lookup type 3). When this bit is set,
the last glyph in a matched input sequence will be
positioned on the baseline.

0x0002

IGNORE_BASE_GLYPHS

If set, skips over base glyphs

0x0004

IGNORE_LIGATURES

If set, skips over ligatures

0x0008

IGNORE_MARKS

If set, skips over all combining marks

0x0010

USE_MARK_FILTERING_SET

If set, indicates that the Lookup table structure
includes the markFilteringSet field. The layout engine
skips over all mark glyphs not in the mark filtering set
indicated.

0x00E0

reserved

For future use (Set to zero)

0xFF00

MARK_ATTACHMENT_CLASS_FILTER

If not zero, skips over all marks not in the specified
mark attachment class.

The RIGHT_TO_LEFT flag is used only for GPOS type 3 lookups and is ignored otherwise. It is
not used by client software in determining text direction.
As described above, lookups are processed for each glyph in a glyph sequence to which a
feature has been applied. Each lookup type specifies an input sequence pattern to be
matched: single glyphs, or sequences of glyphs, depending upon the lookup type. The
current glyph in the lookup processing loop is always tested against the first glyph in a
lookup's input glyph sequence pattern. Lookup flags affect pattern matching for other
glyphs in the input sequence but not the current glyph. For chained context lookups, the
flags also affect matching of backtrack and lookahead sequences.
IGNORE_BASE_GLYPHS, IGNORE_LIGATURES, or IGNORE_MARKS refer to base glyphs,
ligatures and marks as defined in the Glyph Class Definition table in the GDEF table. If any of
these flags are set, a Glyph Class Definition table must be present. If any of these bits is set,
then lookups must ignore glyphs of the respective type; that is, the other glyphs must be
processed just as though these glyphs were not present in the glyph sequence.
If MARK_ATTACHMENT_CLASS_FILTER is non-zero, then mark attachment classes must be
defined in the Mark Attachment Class Definition table in the GDEF table. When processing

glyph sequences, a lookup must ignore any mark glyphs that are not in the specified mark
attachment class; only marks in the specified class are processed.
If any lookup has the USE_MARK_FILTERING_SET flag set, then the Lookup header must
include the markFilteringSet field and a MarkGlyphSets table must be present in GDEF table.
The lookup must ignore any mark glyphs that are not in the specified mark glyph set; only
glyphs in the specified mark glyph set are processed.
If a mark filtering set is specified, this supersedes any mark attachment class indication in
the lookup flag. If the IGNORE_MARKS bit is set, this supersedes any mark filtering set or
mark attachment class indications.
For example, in Arabic text, a character string might have the pattern base mark base. That
string could be converted into a ligature composed of two components, one for each base
character, with the combining mark glyph over the first component. To produce this ligature,
the font developer would set the IGNORE_MARKS bit of the ligature substitution lookup to
tell the client to ignore the mark, substitute the ligature glyph first, and then position the
mark glyph over the ligature glyph in a subsequent GPOS lookup. Alternatively, a
substitution lookup which did not set the IGNORE_MARKS bit could be used to describe a
three-component ligature glyph, composed of the first base glyph, the mark glyph, and the
second base glyph.
For another example, a lookup that creates a ligature of a base glyph with an above mark
could skip over all below marks by specifying a mark attachment class that includes only
above marks.
Contextual lookup types support a nested organization of lookup data. In this structure, a
lookup subtable specifies an input sequence pattern for glyph sequences that can be
modified, and then references one or more “nested” lookup tables in the LookupList that
describe the actions to be applied to individual glyphs within a matching sequence. In these
cases, there is a lookupFlag field in the main lookup table, and separate lookupFlag fields in
the nested lookups.
GPOS lookup type 7 and type 8 have this nature, as well as GSUB lookup type 5, type 6, and
type 8. For these lookup types, the effect of the main lookup is to filter glyph sequences to
which they apply, but not directly to modify glyphs in a matched sequence. The lookup flags
in the main lookup table will affect this initial matching process. For example, the
IGNORE_MARKS flag will cause mark glyphs to be ignored when evaluating if a glyph
sequence matches the pattern specified by the lookup. Note that the RIGHT_TO_LEFT flag is
never used in the main lookup.
Once a sequence is matched against the pattern in the main lookup, the nested lookups are
then processed on glyphs in the sequence. Lookup flags in the main lookup table are not
considered while the nested lookups are being processed. Instead, lookup flags in the

nested lookups are considered. Note that the flags in the nested lookup can result in a
secondary level of filtering over sequences initially matched by the main lookup table.

Coverage table
Each subtable in a Lookup table (except an Extension lookup type subtable) references a
Coverage table, which specifies all the glyphs affected by a substitution or positioning
operation described in the subtable. The GSUB, GPOS, and GDEF tables rely on this notion of
coverage. If a glyph does not appear in a Coverage table, the client can skip that subtable
and move immediately to the next subtable.
A Coverage table identifies glyphs by glyph IDs in either of two ways:
As a list of individual glyph IDs in the glyph set.
As ranges of consecutive glyph IDs. The range format gives one or more start and end
glyph ID pairs to denote the consecutive glyphs covered by the table.
In a Coverage table, a format field specifies the format as an integer: 1 = lists, and 2 =
ranges.
A Coverage table defines a unique index value, the Coverage Index, for each covered glyph.
The Coverage Indexes are sequential, from 0 to the number of covered glyphs minus 1. This
unique value specifies the position of the covered glyph in the Coverage table. The client
uses the Coverage Index to look up values in the subtable for each glyph.

Coverage format 1
Coverage format 1 consists of a format field and a count of covered glyphs, followed by an
array of glyph indices (glyphArray). The glyph indices must be in numerical order for binary
searching of the list. When a glyph is found in the Coverage table, its position in the
glyphArray determines the Coverage Index that is returned — the first glyph has a Coverage
Index = 0, and the last glyph has a Coverage Index = GlyphCount -1.
Example 5 at the end of this chapter shows a Coverage table that uses format 1 to list the
glyph IDs of all lowercase descender glyphs in a font.
CoverageFormat1 table: Individual glyph indices
ﾉ

Type

Name

Description

uint16

format

Format identifier — format = 1.

uint16

glyphCount

Number of glyphs in the glyph array.

Expand table

uint16

glyphArray[glyphCount]

Array of glyph IDs — in numerical order.

Coverage format 2
Format 2 consists of a format field and a count of glyph index ranges, followed by an array
of records (rangeRecords). Each RangeRecord consists of a start glyph index, an end glyph
index, and the Coverage Index associated with the range’s start glyph. Ranges must be in
startGlyphID order, and they must be distinct, with no overlapping.
The Coverage Indexes for the first range begin with zero (0) and increase sequentially to
(endGlyphId - startGlyphId). For each successive range, the starting Coverage Index is one
greater than the ending Coverage Index of the preceding range. Thus, startCoverageIndex
for each non-initial range must equal the length of the preceding range (endGlyphID startGlyphID + 1) added to the startCoverageIndex of the preceding range. This allows for a
quick calculation of the Coverage Index for any glyph in any range using the formula:
Coverage Index (glyphID) = startCoverageIndex + glyphID - startGlyphID.
Example 6 at the end of this chapter shows a Coverage table that uses format 2 to identify a
range of numeral glyphs in a font.
CoverageFormat2 table: Range of glyphs
ﾉ

Expand table

Type

Name

Description

uint16

format

Format identifier — format = 2.

uint16

rangeCount

Number of RangeRecords.

RangeRecord

rangeRecords[rangeCount]

Array of glyph ranges — ordered by startGlyphID.

RangeRecord
ﾉ

Type

Name

Description

uint16

startGlyphID

First glyph ID in the range.

uint16

endGlyphID

Last glyph ID in the range.

uint16

startCoverageIndex

Coverage Index of first glyph ID in range.

Class definition table

Expand table

For efficiency and ease of representation in lookups, a font developer can group glyphs into
glyph classes. Classes can be used in GSUB and GPOS lookups for various purposes
including describing glyph contexts or sets of marks to be processed or ignored.
Consider a substitution action that replaces only the lowercase ascender glyphs in a glyph
string. To describe the appropriate context for the substitution more easily, the font
developer could divide the font’s lowercase glyphs into two classes, one that contains the
ascenders and one that contains the glyphs without ascenders.
A font developer can assign any glyph to any class, each identified with an integer. A class
definition table (ClassDef) assigns glyphs into classes, beginning with Class 1, then Class 2,
and so on. All glyphs not assigned to a class fall into Class 0. Within a given class definition
table, each glyph in the font belongs to exactly one class.
The ClassDef table can have either of two formats: one that assigns a range of consecutive
glyph indices to different classes, or one that puts groups of consecutive glyph indices into
the same class.

Class definition format 1
The first class definition format (ClassDefFormat1) specifies a range of consecutive glyph
indices and a list of corresponding glyph class values. This table is useful for assigning each
glyph to a different class because the glyph indices in each class are not grouped together.
A ClassDefFormat1 table begins with a format identifier. The range of glyph IDs covered by
the table is identified by two values: the glyph ID of the first glyph (startGlyphID) and the
number of consecutive glyph IDs (including the first one) that will be assigned class values.
An array of integers lists the class value assigned to each glyph ID, starting with the class
value for startGlyphID and following the same order as the glyph IDs. Any glyph not
included in the range of covered glyph IDs is assigned to Class 0.
Example 7 at the end of this chapter uses format 1 to assign class values to the lowercase, xheight, ascender, and descender glyphs in a font.
ClassDefFormat1 table: Class array
ﾉ

Expand table

Type

Name

Description

uint16

format

Format identifier — format = 1.

uint16

startGlyphID

First glyph ID assigned to a class.

uint16

glyphCount

Number of elements in the classValues array.

uint16

classValues[glyphCount]

Array of class values — one per glyph ID.

Class definition format 2
The second class definition format (ClassDefFormat2) defines multiple groups of glyph
indices that belong to the same class. Each group consists of a range of glyph indices in
consecutive order. The glyph ranges must not overlap.
The ClassDefFormat2 table contains a format identifier and an array of ClassRange records
that specify a range of glyph IDs and the class to which they are assigned. The records must
be sorted by the first glyph ID in each range.
Any glyph not covered by a ClassRange record is assigned to Class 0.
Example 8 at the end of this chapter uses format 2 to assign class values to four types of
glyphs in the Arabic script.
ClassDefFormat2 table: Class ranges
ﾉ

Expand table

Type

Name

Description

uint16

format

Format identifier — format = 2.

uint16

classRangeCount

Number of ClassRange records.

ClassRange

classRangeRecords[classRangeCount]

Array of ClassRangeRecords — ordered by
startGlyphID.

ClassRange record
ﾉ

Type

Name

Description

uint16

startGlyphID

First glyph ID in the range.

uint16

endGlyphID

Last glyph ID in the range.

uint16

class

Applied to all glyphs in the range.

Common formats for contextual lookup
subtables

Expand table

The GSUB and GPOS tables each use different lookup types for various substitution and
positioning operations. For both GSUB and GPOS, a contextual lookup type is defined:
GSUB type 5: contextual substitution
GPOS type 7: contextual positioning
The contextual lookup types support specifying input glyph sequences that are acted upon,
as well as a list of actions to be taken on any glyph within the sequence. Actions are
specified as references to separate nested lookups (an index into the LookupList). The
actions are specified for each glyph position, but the entire sequence must be matched, and
so the actions are specified in a context-sensitive manner.
Because contextual lookup tables link to “nested” lookup tables that describe the
substitution actions to be performed, there are lookupFlag fields in each nested lookup
table as well as in the main lookup table. See the Lookup table section above for details
regarding the effect of lookup flags in the main and nested lookup tables.
Note: Glyph sequences are given in logical order. For text written from right to left, the
right-most glyph will be first; conversely, for text written from left to right, the left-most
glyph will be first.
For both GSUB type 5 and GPOS type 7, there are three subtable formats defined, which
describe the input sequences in different ways:
1. In terms of specific glyph IDs (“simple glyph contexts”).
2. In terms of sets of glyphs defined using Class Definition tables (“class-based glyph
contexts”).
3. In terms of sets of glyphs defined using Coverage tables (“coverage-based glyph
contexts”).
The three different subtable formats use different structures, but for each subtable format
the structures are common to both the GSUB and GPOS tables.
Also, for both GSUB and GPOS, a chained context lookup type is defined:
GSUB type 6: chained contexts substitution
GPOS type 8: chained contexts positioning
The chained contextual lookups are functionally similar to the contextual lookups, but add
chained glyph-sequence contexts: a backtrack glyph sequence that precedes the input
sequence, and a lookahead sequence that follows the input sequence. (The backtrack and
lookahead sequences are described in greater detail below: see Chained sequence context
format 1: simple glyph contexts.) Actions can be specified only for glyphs in the input
sequence, but backtrack, input and lookahead sequence must match the current glyph
sequence being processed for the lookup to apply. Once the specified actions are

completed, the client advances to the glyph position immediately following the matched
input sequence (with special consideration in the case that a nested lookup is a GPOS type
2, paired positioning, lookup); in particular, the client does not advance past the matched
lookahead sequence.
Three formats are defined for chained contextual lookups, analogous to the three formats
for the contextual lookups. The structures differ from those used for the contextual lookup
types because they incorporate the chained contexts. But the chained context structures are
common to both the GSUB and GPOS tables.
Note: While substitution and positioning operations are distinct between GSUB and
GPOS lookups, for contextual lookup types that difference is reflected in the nested
lookups. For instance, the actions specified by a GSUB contextual lookup are specified
by reference to a nested lookup within the GSUB table. In this way, the contextual
lookup subtable structures used in the GSUB and GPOS tables can be identical, but the
resulting operations that are specified will still be distinct.
For both contextual and chained contextual lookup types, input sequence patterns are
defined, and actions on matching glyph sequences are performed. Note that patterns are
matched against the current glyph sequence before any actions are performed. Within the
GSUB table, substitution actions will change the current glyph sequence, but this does not
affect the initial matching operation.

Sequence lookup record
For all formats for both contextual and chained contextual lookups, a common record
format is used to specify an action—a nested lookup—to be applied to a glyph at a
particular sequence position within the input sequence.
SequenceLookup record
ﾉ

Type

Name

Description

uint16

sequenceIndex

Index (zero-based) into the input glyph sequence.

uint16

lookupListIndex

Index (zero-based) into the LookupList.

Expand table

The lookupListIndex field indicates the Lookup table to apply to the position in the input
glyph sequence indicated by sequenceIndex.

Sequence context format 1: simple glyph contexts

GSUB type 5 format 1 subtables and GPOS type 7 format 1 subtables define input
sequences in terms of specific glyph IDs. Several sequences may be specified, but each is
specified using glyph IDs.
The first glyph for each sequence is specified in a Coverage table. The remaining glyphs in
each sequence are defined in SequenceRule tables—one for each sequence. If multiple
sequences start with the same glyph, that glyph ID must be listed once in the Coverage
table, and the corresponding sequence rules are aggregated using a SequenceRuleSet table
—one for each initial glyph specified in the Coverage table.
When evaluating a SequenceContextFormat1 subtable for a given position in a glyph
sequence, the client searches for the current glyph in the Coverage table. If found, the
corresponding SequenceRuleSet table is retrieved, and the SequenceRule tables for that set
are examined to see if the current glyph sequence matches the input sequence pattern in
any of the sequence rules. The first matching rule subtable is used.
SequenceContextFormat1 table
ﾉ

Expand table

Type

Name

Description

uint16

format

Format identifier — format = 1.

Offset16

coverageOffset

Offset to Coverage table, from beginning of
SequenceContextFormat1 table.

uint16

seqRuleSetCount

Number of SequenceRuleSet tables.

Offset16

seqRuleSetOffsets[seqRuleSetCount]

Array of offsets to SequenceRuleSet tables, from
beginning of SequenceContextFormat1 table
(offsets may be NULL).

The Coverage table lists the initial glyphs from all of the supported input glyph sequences.
The seqRuleSetCount should match the number of glyphs in the Coverage table. If these
differ, the extra coverage glyphs or extra sequence rule sets are ignored.
There is one SequenceRuleSet table for each covered glyph. The offsets in the
seqRuleSetOffsets array must be ordered to match the order of glyphs in the Coverage
table.
SequenceRuleSet table—all contexts beginning with the same glyph
ﾉ

Expand table

Type

Name

Description

uint16

seqRuleCount

Number of SequenceRule tables.

Offset16

seqRuleOffsets[seqRuleCount]

Array of offsets to SequenceRule tables, from beginning of
the SequenceRuleSet table.

Offsets to SequenceRule subtables are ordered according to the desired results. The
subtables are evaluated in the order the offsets are listed, and the first sequence rule that
matches the current glyph sequence is used. Rules for longer, more specific sequences are
typically ordered before shorter rules.
Note: If a rule specifies a sequence that is an initial sub-sequence of a longer sequence
specified in another rule and the shorter is ordered before the longer, the rule for the
longer sequence will never be used. For example, consider two contexts <abc> and
<abcd>: if <abc> is first in the sequence rule array, all instances of <abc> in the text,
including all instances of <abcd>, will be matched. The second sequence rule, for
<abcd>, will never be used.
SequenceRule table
ﾉ

Expand table

Type

Name

Description

uint16

glyphCount

Number of glyphs in the input glyph
sequence.

uint16

seqLookupCount

Number of SequenceLookup.

uint16

inputSequence[glyphCount - 1]

Array of input glyph IDs—starting with the
second glyph.

SequenceLookup

seqLookupRecords[seqLookupCount]

Array of sequence lookup records.

The glyphCount value is the total number of glyphs in the input sequence, including the first
glyph. The inputSequence array specifies the remaining glyphs in the input sequence, in
order. (The glyph at inputSequence index 0 corresponds to glyph sequence index 1.)
The seqLookupRecords array lists the sequence lookup records that specify actions to be
taken on glyphs at various positions within the input sequence. These do not have to be
ordered in sequence position order; they are ordered according to the desired result. All of
the sequence lookup records are processed in order, and each applies to the results of the
actions indicated by the preceding record.

Sequence context format 2: class-based glyph contexts

GSUB type 5 format 2 subtables and GPOS type 7 format 2 subtables define input
sequences patterns in terms of glyph classes defined using a Class Definition table. Several
sequence patterns may be specified, with each pattern specifying a class of glyphs for each
input sequence position.
Classes are assigned an integer number, the class value. An input sequence pattern is
specified as a sequence of class values. For example, a pattern 1, 4, 3 specifies the set of
glyph sequences with three glyphs, the first from class 1, the second from class 4, and the
third from class 3.
Each pattern is specified in a ClassSequenceRule table. Patterns that start with the same class
value in the first position are aggregated using a ClassSequenceRuleSet table.
The SequenceContextFormat2 table has an offset to a Coverage table. The Coverage table
includes all glyph IDs for glyphs that occur as the first glyph in any of the class-based
patterns. That is, the Coverage table contains the list of glyph indices for all the glyphs in all
classes that are first in any of the specified input sequence patterns. For example, if the
patterns begin with either class 1 or class 2, then the Coverage table will list all glyphs in
either class 1 or class 2. Glyph IDs in the Coverage table are given once.
Note: Due to the way the class definition table is defined, each glyph ID belongs to
exactly one class.
When evaluating a SequenceContextFormat2 subtable for a given position in a glyph
sequence, the client searches for the current glyph in the Coverage table. If found, the client
then searches in the class definition table to find the class value assigned to the currently
glyph. The class value is used as the index into an array of offsets to ClassSequenceRuleSet
tables. The ClassSequenceRuleSet table for that class value is retrieved, and the
ClassSequenceRule tables for that set are examined to see if the current sequence matches
any of the specified patterns.
Note: The formats of the ClassSequenceRuleSet and ClassSequenceRule tables are
essentially the same as the formats of the SequenceRuleSet and SequenceRule tables,
but the semantics are different: The ClassSequenceRule table has a sequence of glyph
class values, while the SequenceRule table has a sequence of glyph IDs; therefore these
are distinguished. Accordingly, the ClassSequenceRuleSet and SequenceRuleSet tables
are distinguished by the subtables referenced by each.
SequenceContextFormat2 table
ﾉ

Expand table

Type

Name

Description

uint16

format

Format identifier — format = 2.

Offset16

coverageOffset

Offset to Coverage table, from beginning
of SequenceContextFormat2 table.

Offset16

classDefOffset

Offset to ClassDef table, from beginning
of SequenceContextFormat2 table.

uint16

classSeqRuleSetCount

Number of ClassSequenceRuleSet tables.

Offset16

classSeqRuleSetOffsets[classSeqRuleSetCount]

Array of offsets to ClassSequenceRuleSet
tables, from beginning of
SequenceContextFormat2 table (may be
NULL).

There is one offset to a ClassSequenceRuleSet subtable for each class defined in the class
definition table. The offsets are listed in class value order. If no patterns are defined that
begin with a particular class, then the offset for that class value may be set to NULL.
ClassSequenceRuleSet table
ﾉ

Expand table

Type

Name

Description

uint16

classSeqRuleCount

Number of ClassSequenceRule tables.

Offset16

classSeqRuleOffsets[classSeqRuleCount]

Array of offsets to ClassSequenceRule tables,
from beginning of ClassSequenceRuleSet table.

Offsets to ClassSequenceRule subtables are ordered according to the desired results. The
subtables are evaluated in the order the offsets are listed, and the first class sequence rule
that matches the current glyph sequence is used. Rules for longer, more specific sequences
are typically ordered before shorter rules.
ClassSequenceRule table
ﾉ

Expand table

Type

Name

Description

uint16

glyphCount

Number of glyphs to be matched.

uint16

seqLookupCount

Number of SequenceLookup records.

uint16

inputSequence[glyphCount - 1]

Sequence of classes to be matched to the
input glyph sequence, beginning with the
second glyph position.

Type

Name

Description

SequenceLookup

seqLookupRecords[seqLookupCount]

Array of SequenceLookup records.

The glyphCount value is the total number of glyph classes in the input sequence pattern,
including the first sequence position. The inputSequence array specifies the remaining class
values in the input sequence pattern, in order.
The seqLookupRecords array lists the sequence lookup records that specify actions to be
taken on glyphs at various positions within the input sequence. These do not have to be
ordered in sequence position order; they are ordered according to the desired result. All of
the sequence lookup records are processed in order, and each applies to the results of the
actions indicated by the preceding record.

Sequence context format 3: coverage-based glyph contexts
GSUB type 5 format 3 subtables and GPOS type 7 format 3 subtables define input
sequences patterns in terms of sets of glyphs defined using Coverage tables.
The SequenceContextFormat3 table specifies exactly one input sequence pattern. It has an
array of offsets to coverage tables. These correspond, in order, to the positions in the input
sequence pattern.
SequenceContextFormat3 table
ﾉ

Expand table

Type

Name

Description

uint16

format

Format identifier — format = 3.

uint16

glyphCount

Number of glyphs in the input sequence.

uint16

seqLookupCount

Number of SequenceLookup records.

Offset16

coverageOffsets[glyphCount]

Array of offsets to Coverage tables, from
beginning of SequenceContextFormat3
subtable.

SequenceLookup

seqLookupRecords[seqLookupCount]

Array of SequenceLookup records.

The seqLookupRecords array lists the sequence lookup records that specify actions to be
taken on glyphs at various positions within the input sequence. These do not have to be
ordered in sequence position order; they are ordered according to the desired result. All of
the sequence lookup records are processed in order, and each applies to the results of the
actions indicated by the preceding record.

Chained sequence context format 1: simple glyph contexts
GSUB type 6 format 1 and GPOS type 8 format 1 subtables define input sequences as well as
the chained backtrack and lookahead sequences in terms of specific glyph IDs; this is the
ChainedSequenceContextFormat1 table. Its subtable formats are similar to those used for the
SequenceContextFormat1 table, the key difference being that the ChainedSequenceRule
table includes the chained backtrack and lookahead sequences.
The first glyphs for the input sequences are specified in a Coverage table. The remaining
glyphs in each input sequence as well as the backtrack and lookahead sequences are
defined in ChainedSequenceRule tables—one for each combined backtrack + input +
lookahead sequence. If multiple sequence combinations have the same initial glyph in the
input sequence, that glyph ID must be listed once in the Coverage table, and the
corresponding rules are aggregated using a ChainedSequenceRuleSet table—one for each
initial input sequence glyph specified in the Coverage table.
When evaluating a ChainedSequenceContextFormat1 subtable for a given position in a
glyph sequence, the client searches for the current glyph in the Coverage table. If found, the
corresponding ChainedSequenceRuleSet table is retrieved, and the ChainedSequenceRule
tables for that set are examined to see if the current glyph sequence matches any of the
patterns in any of thechained sequence rules. The first matching rule subtable is used.
Matching of the sequence rules with the current glyph sequence requires matching of input,
backtrack and lookahead sequences. Lookup flags affect matching in backtrack and
lookahead sequences as well as the input sequence.
Note that the backtrack sequence is given in reverse logical order: if the current glyph is at
position i in the text glyph buffer, the backtrack sequence begins at i-1 and decrements
offset values moving away from i. The lookahead sequence begins after the input sequence
and increases in logical order.
To clarify the ordering of glyph arrays for input, backtrack and lookahead sequences, the
following illustration is provided. Suppose within a logically-ordered glyph sequence the
input sequence match begins at index i and has a length of 2.
ﾉ

Logical order:

a

b

Sequence index:

c

d

m

n

w

x

…

i-1

i

i+1

i+2

…

0

1

0

1

Input sequence index:
Backtrack sequence index:
Lookahead sequence index:

3

2

Expand table

1

y

z

2

3

0

Thus, in this example, the input sequence would comprise glyph IDs for “mn”; the backtrack
sequence would comprise glyph IDs for “dcba” in that order; and the lookahead sequence
would comprise glyph IDs for “wxyz”. Actions specified in sequence lookup records can be
specified only for glyphs in the input sequence, the glyphs for “mn”.
ChainedSequenceContextFormat1 table
ﾉ

Expand table

Type

Name

Description

uint16

format

Format identifier — format = 1.

Offset16

coverageOffset

Offset to Coverage table, from
beginning of
ChainSequenceContextFormat1
table.

uint16

chainedSeqRuleSetCount

Number of
ChainedSequenceRuleSet tables.

Offset16

chainedSeqRuleSetOffsets[chainedSeqRuleSetCount]

Array of offsets to
ChainedSeqRuleSet tables, from
beginning of
ChainedSequenceContextFormat1
table (may be NULL).

The Coverage table lists the initial glyphs from all of the supported input glyph sequences.
The chainedSeqRuleSetCount should match the number of glyphs in the Coverage table. If
these differ, the extra coverage glyphs or extra sequence rule sets are ignored.
There is one ChainedSequenceRuleSet table for each covered glyph. The offsets in the
chainedSeqRuleSetOffsets array must be ordered to match the order of glyphs in the
Coverage table.
ChainedSequenceRuleSet table
ﾉ

Expand table

Type

Name

Description

uint16

chainedSeqRuleCount

Number of ChainedSequenceRule tables.

Offset16

chainedSeqRuleOffsets[chainedSeqRuleCount]

Array of offsets to ChainedSequenceRule
tables, from beginning of
ChainedSequenceRuleSet table.

Offsets to ChainedSequenceRule subtables are ordered according to the desired results. The
subtables are evaluated in the order the offsets are listed, and the first chained sequence

rule that matches the current glyph sequence is used. Rules for longer, more specific
sequences are typically ordered before shorter rules.
ChainedSequenceRule table
ﾉ

Expand table

Type

Name

Description

uint16

backtrackGlyphCount

Number of glyphs in the backtrack
sequence.

uint16

backtrackSequence[backtrackGlyphCount]

Array of backtrack glyph IDs.

uint16

inputGlyphCount

Number of glyphs in the input
sequence.

uint16

inputSequence[inputGlyphCount - 1]

Array of input glyph IDs—start with
second glyph.

uint16

lookaheadGlyphCount

Number of glyphs in the lookahead
sequence.

uint16

lookaheadSequence[lookaheadGlyphCount]

Array of lookahead glyph IDs.

uint16

seqLookupCount

Number of SequenceLookup
records.

SequenceLookup

seqLookupRecords[seqLookupCount]

Array of SequenceLookup records.

The inputGlyphCount value is the total number of glyphs in the input sequence, including
the first glyph. The inputSequence array specifies the remaining glyphs in the input
sequence, in order.
The seqLookupRecords array lists the sequence lookup records that specify actions to be
taken on glyphs at various positions within the input sequence. These do not have to be
ordered in sequence position order; they are ordered according to the desired result. All of
the sequence lookup records are processed in order, and each applies to the results of the
actions indicated by the preceding record.

Chained sequence context format 2: class-based glyph
contexts
GSUB type 6 format 2 and GPOS type 8 format 2 subtables define input sequence patterns,
as well as chained backtrack and lookahead sequence patterns, in terms of glyph classes
defined using Class Definition tables. Three separate class definition tables are used to
define the classes for the input, backtrack and lookahead sequence patterns. Several

combined sequence patterns may be defined, with glyphs for each position with the
sequence patterns specified using a class value for the corresponding class definition table.
Each combined pattern is specified in a ChainedClassSequenceRule table. Pattern
combinations for which the first position of the input sequence uses the same class value
are aggregated using a ChainedClassSequenceRuleSet table.
The ChainedSequenceContextFormat2 table has an offset to a Coverage table. The Coverage
table includes all glyph IDs for glyphs that may occur as the first glyph in any of the classbased input sequence patterns. Glyph IDs in the Coverage table are given once.
When evaluating a ChainedSequenceContextFormat2 subtable for a given position in a
glyph sequence, the client searches for the current glyph in the Coverage table. If found, the
client then searches in the class definition table to find the class value assigned to the
current glyph. The class value is used as the index into an array of offsets to
ChainedClassSequenceRuleSet tables. The ChainedClassSequenceRuleSet table for that class
value is retrieved, and the ChainedClassSequenceRule tables for that set are examined to
see if the current glyph sequence matches any of the specified patterns.
Matching of the sequence rules with the current glyph sequence requires matching of input,
backtrack and lookahead sequences. Note that Lookup flags affect matching in backtrack
and lookahead sequences as well as the input sequence. Backtrack sequence patterns are
specified in reverse logical order. Specification of backtrack, input and lookahead sequences
is the same as described above for Chained sequence context format 1, except that
sequences are specified using class values rather than glyph IDs.
ChainedSequenceContextFormat2 table
ﾉ

Expand table

Type

Name

Description

uint16

format

Format identifier — format = 2.

Offset16

coverageOffset

Offset to Coverage table, from
beginning of
ChainedSequenceContextFormat2
table.

Offset16

backtrackClassDefOffset

Offset to ClassDef table
containing backtrack sequence
context, from beginning of
ChainedSequenceContextFormat2
table.

Offset16

inputClassDefOffset

Offset to ClassDef table
containing input sequence
context, from beginning of

Type

Name

Description
ChainedSequenceContextFormat2
table.

Offset16

lookaheadClassDefOffset

Offset to ClassDef table
containing lookahead sequence
context, from beginning of
ChainedSequenceContextFormat2
table.

uint16

chainedClassSeqRuleSetCount

Number of
ChainedClassSequenceRuleSet
tables.

Offset16

chainedClassSeqRuleSetOffsets[chainedClassSeqRuleSetCount]

Array of offsets to
ChainedClassSequenceRuleSet
tables, from beginning of
ChainedSequenceContextFormat2
table (may be NULL).

There is one offset to a ChainedClassSequenceRuleSet subtable for each class defined in the
input sequence class definition table. The offsets are listed in class value order. If no patterns
are defined with an input sequence beginning with a particular class, then the offset for that
class value may be set to NULL.
ChainedClassSequenceRuleSet table
ﾉ

Expand table

Type

Name

Description

uint16

chainedClassSeqRuleCount

Number of
ChainedClassSequenceRule
tables.

Offset16

chainedClassSeqRuleOffsets[chainedClassSeqRuleCount]

Array of offsets to
ChainedClassSequenceRule
tables, from beginning of
ChainedClassSequenceRuleSet.

Offsets to ChainedClassSequenceRule subtables are ordered according to the desired
results. The subtables are evaluated in the order the offsets are listed, and the first chained
class sequence rule that matches the current glyph sequence is used. Rules for longer, more
specific sequences are typically ordered before shorter rules.
ChainedClassSequenceRule table
ﾉ

Expand table

Type

Name

Description

uint16

backtrackGlyphCount

Number of glyphs in the backtrack
sequence.

uint16

backtrackSequence[backtrackGlyphCount]

Array of backtrack-sequence classes.

uint16

inputGlyphCount

Total number of glyphs in the input
sequence.

uint16

inputSequence[inputGlyphCount - 1]

Array of input sequence classes,
beginning with the second glyph
position.

uint16

lookaheadGlyphCount

Number of glyphs in the lookahead
sequence.

uint16

lookaheadSequence[lookaheadGlyphCount]

Array of lookahead-sequence
classes.

uint16

seqLookupCount

Number of SequenceLookup
records.

SequenceLookup

seqLookupRecords[seqLookupCount]

Array of SequenceLookup records.

The inputGlyphCount value is the total number of glyph classes in the input sequence
pattern, including the first sequence position. The inputSequence array specifies the
remaining class values in the input sequence pattern, in order.
The seqLookupRecords array lists the sequence lookup records that specify actions to be
taken on glyphs at various positions within the input sequence. These do not have to be
ordered in sequence position order; they are ordered according to the desired result. All of
the sequence lookup records are processed in order, and each applies to the results of the
actions indicated by the preceding record.

Chained sequence context format 3: coverage-based glyph
contexts
GSUB type 6 format 3 subtables and GPOS type 8 format 3 subtables define input
sequences patterns, as well as chained backtrack and lookahead sequence patterns, in terms
of sets of glyphs defined using Coverage tables.
The ChainedSequenceContextFormat3 table specifies exactly one input sequence pattern. It
has three arrays of offsets to coverage tables: one for the input sequence pattern, one for
the backtrack sequence pattern, and one for the lookahead sequence pattern. For each
array, the offsets correspond, in order, to the positions in the sequence pattern.
ChainedSequenceContextFormat3 table

ﾉ

Expand table

Type

Name

Description

uint16

format

Format identifier — format =
3.

uint16

backtrackGlyphCount

Number of glyphs in the
backtrack sequence.

Offset16

backtrackCoverageOffsets[backtrackGlyphCount]

Array of offsets to coverage
tables for the backtrack
sequence.

uint16

inputGlyphCount

Number of glyphs in the
input sequence.

Offset16

inputCoverageOffsets[inputGlyphCount]

Array of offsets to coverage
tables for the input sequence.

uint16

lookaheadGlyphCount

Number of glyphs in the
lookahead sequence.

Offset16

lookaheadCoverageOffsets[lookaheadGlyphCount]

Array of offsets to coverage
tables for the lookahead
sequence.

uint16

seqLookupCount

Number of SequenceLookup
records.

SequenceLookup

seqLookupRecords[seqLookupCount]

Array of SequenceLookup
records.

All offsets are from the start of the ChainedSequenceContextFormat3 table.
The seqLookupRecords array lists the sequence lookup records that specify actions to be
taken on glyphs at various positions within the input sequence. These do not have to be
ordered in sequence position order; they are ordered according to the desired result. All of
the sequence lookup records are processed in order, and each applies to the results of the
actions indicated by the preceding record.

Device and VariationIndex tables
Device tables and VariationIndex tables are used to provide adjustments to font-unit values
in GPOS, JSTF, GDEF or BASE tables, such as the X and Y coordinates of an attachment
anchor position. Device tables are used only in non-variable fonts. VariationIndex tables are
used only in variable fonts and are a variant format of the Device table. When values require
adjustment data, the table containing that value will also include an offset to a Device table
or VariationIndex table.

Note: Because the same fields are used to provide an offset to a Device table or an
offset to a VariationIndex table, Device tables and VariationIndex tables cannot both be
used for a given positioning value. Device tables should only be used in non-variable
fonts; VariationIndex tables can only be used in variable fonts.
Glyphs in a font are defined in design units specified by the font developer. Font scaling
increases or decreases a glyph’s size and rounds it to the nearest whole pixel. However,
precise glyph positioning often requires adjustment of these scaled and rounded values,
particularly at small PPEM sizes. Hinting, applied to points in the glyph outline, is an
effective solution to this problem, but it may require the font developer to redesign or rehint glyphs.
Another solution, used by the GPOS, BASE, JSTF, and GDEF tables in non-variable fonts, is to
use a Device table to specify correction values to adjust the scaled design units. A Device
table applies the correction values to the range of sizes identified by StartSize and EndSize,
which specify the smallest and largest pixel-per-em (ppem) sizes needing adjustment.
Because Device table adjustments often are very small (a pixel or two), the correction can be
compressed into a 2-, 4-, or 8-bit representation per size. Two bits can represent a number
in the range {-2, -1, 0, or 1}, four bits can represent a number in the range {-8 to 7}, and
eight bits can represent a number in the range {-128 to 127}.
In variable fonts, X or Y font-unit values in GPOS, JSTF, or GDEF data may require adjustment
for different variation instances within a font’s variation space. The variation data for this is
contained in an ItemVariationStore table contained within the GDEF table. Similarly, values in
a BASE table may require adjustment, and the variation data for this is contained in an
ItemVariationStore table within the BASE table. The format of the ItemVariationStore is
described in detail in the chapter, OpenType Font Variations Common Table Formats. It
contains a number of delta values organized into sets that are referenced using a delta-set
index. Data stored outside the ItemVariationStore provides delta-set indices for each of
target items requiring variation. Within the GPOS, JSTF, GDEF and BASE tables, delta-set
indices are stored in VariationIndex tables.
The Device and VariationIndex tables contain a DeltaFormat field that identifies the format
of data contained. Format values 0x0001 to 0x0003 are used for Device tables, and indicate
the format of delta adjustment values contained directly within the device table: signed 2-,
4,- or 8-bit values. A format value of 0x8000 is used for the VariationIndex table, and
indicates that a delta-set index is used to reference delta data in an ItemVariationStore table.
DeltaFormat values
ﾉ

Mask

Name

Description

Expand table

0x0001

LOCAL_2_BIT_DELTAS

Signed 2-bit value, 8 values per uint16.

0x0002

LOCAL_4_BIT_DELTAS

Signed 4-bit value, 4 values per uint16.

0x0003

LOCAL_8_BIT_DELTAS

Signed 8-bit value, 2 values per uint16.

0x8000

VARIATION_INDEX

VariationIndex table, contains a delta-set index pair.

0x7FFC

Reserved

For future use — set to 0.

The Device table includes an array of uint16 values (deltaValue) that stores the adjustment
delta values in a packed representation. The 2-, 4-, or 8-bit signed values are packed into
uint16 values starting with the most significant bits first. For example, using a DeltaFormat
of 2 (4-bit values), an array of values equal to {1, 2, 3, -1} would be represented by a
deltaValue entry 0x123F.
A single Device table provides delta information for one target value at a range of sizes. The
deltaValue array lists the number of pixels to adjust specified X or Y values at each ppem
size in the targeted range. In the array, the first index position specifies the number of pixels
to add or subtract from the coordinate at the smallest ppem size that needs correction, the
second index position specifies the number of pixels to add or subtract from the coordinate
at the next ppem size, and so on for each ppem size in the range.
There is one delta value represented for each ppem size in the specified range. The number
of uint16 elements required will depend on the number of values to be represented and the
bit-size used. If the number of delta values times the bit-size used for each value is not a
multiple of 16, then remaining low-order bits of the last uint16 element are set to zero.
Device table
ﾉ

Type

Name

Description

uint16

startSize

Smallest size to correct, in ppem.

uint16

endSize

Largest size to correct, in ppem.

uint16

deltaFormat

Format of deltaValue array data: 0x0001, 0x0002, or 0x0003.

uint16

deltaValue[ ]

Array of compressed data.

Expand table

Example 9 at the end of this chapter shows a Device table as could be used in specifying the
minimum shift for superscripts in the MATH table.
In a variable font, the ItemVariationStore table uses a two-level organization for variation
data: a store can have multiple ItemVariationData subtables, and each subtable has multiple
delta-set rows. A delta-set index is a two-part index: an outer index that selects a particular

item variation data subtable, and an inner index that selects a particular delta-set row within
that subtable. A VariationIndex table specifies both the outer and inner portions of the
delta-set index.
VariationIndex table
ﾉ

Expand table

Type

Name

Description

uint16

deltaSetOuterIndex

A delta-set outer index — used to select an item variation data
subtable within the item variation store.

uint16

deltaSetInnerIndex

A delta-set inner index — used to select a delta-set row within an item
variation data subtable.

uint16

deltaFormat

Format, = 0x8000.

Note that the VariationIndex table is shorter than the Device table since it does not directly
contain an array of delta data. Its format is similar to a Device table with an empty delta
array. When applications get an offset to a Device or VariationIndex table, they should begin
by reading the first three fields and then testing the DeltaFormat field to determine the
interpretation of the first two fields and whether there is additional data to read.

Feature variations
FeatureVariations table
A feature variations table describes variations on the effects of features based on various
conditions. That is, it allows the default set of lookups for a given feature to be substituted
with alternates of lookups under particular conditions.
The feature list provides an array of feature tables and associated feature tags, and a
LangSys table identifies a particular set of the feature-table/tag pairs that will be supported
for a given script and language system. The feature tables specified in a LangSys table are
used by default when current conditions do not match any of the conditions for variation
defined in the feature variations table. Those defaults will also be used under all conditions
in implementations that do not support the feature variations table.
The feature variations table has an array of condition records, each of which references a set
of conditions (a condition set table), and a set of alternate feature tables to use when a
runtime context matches the condition set.
The substitutions given are replacements of one feature table for another. The alternate
feature tables are appended at the end of the feature variations table, and are not included

in the feature list table. Hence, there are no feature records in the feature list table that
correspond to the alternate feature tables. An alternate feature table maintains the same
feature tag association as the default feature table. Also, whereas the default feature tables
in the feature list table are referenced using 16-bit offsets, the alternate feature tables are
referenced using 32-bit offsets within the feature variations table.
When processing text, a default set of feature tables, each with an associated feature tag, is
obtained from a LangSys table for a given script and language system. Condition sets are
evaluated in order, testing for a condition set that matches the current runtime context.
When the first match is found, the corresponding feature table substitution table is used to
revise the set of feature tables obtained by default via the LangSys table, as described below
(see FeatureTableSubstitution table).
The format of the feature variations table is as follows.
FeatureVariations table
ﾉ

Expand table

Type

Name

Description

uint16

majorVersion

Major version of
the
FeatureVariations
table — set to 1.

uint16

minorVersion

Minor version of
the
FeatureVariations
table — set to 0.

uint32

featureVariationRecordCount

Number of feature
variation records.

FeatureVariationRecord

featureVariationRecords[featureVariationRecordCount]

Array of feature
variation records.

A feature variation record has offsets to a condition set table and to a feature table
substitution table.
If the ConditionSet offset is 0, there is no condition set table. This is treated as the universal
condition: all contexts are matched.
If the FeatureTableSubstitution offset is 0, there is no feature table substitution table, and no
substitutions are made.
Feature variation records must be ordered in the order of precedence for the condition sets.
During processing, the feature variation records will be read, and the corresponding

condition sets tested, in the order in which they occur. If the condition set for a given record
does not match the runtime context, then the next record is checked. The first feature
variation record for which the condition set matches the runtime context will be considered
as a candidate: if the version of the FeatureTableSubstitution table is supported, then this
feature variation record will be used, and no additional feature variation records will be
considered. If the version of the FeatureTableSubtitution table is not supported, then this
feature variation record is rejected and processing will move to the next feature variation
record.
FeatureVariationRecord
ﾉ

Expand table

Type

Name

Description

Offset32

conditionSetOffset

Offset to a condition set table, from beginning of
FeatureVariations table.

Offset32

featureTableSubstitutionOffset

Offset to a feature table substitution table, from beginning
of the FeatureVariations table.

ConditionSet table
A condition set table specifies a set of conditions under which a feature table substitution is
to be applied. A condition set may specify conditions related to various factors; currently,
one type of factor is supported: the variation instance of a variable font. Individual
conditions are represented in subtables, which may use different formats according to the
nature of the factor defining the condition.
For a given condition set, conditions are conjunctively related (boolean AND): all of the
specified conditions must be met in order for the associated feature table substitution to be
applied. A condition set does not need to specify conditional values for all possible factors.
If no values are specified for some factor, then the condition set matches all runtime values
for that factor.
If a given condition set contains no conditions, then it matches all contexts, and the
associated feature table substitution is always applied, unless there was a FeatureVariation
record earlier in the array with a condition set matching the current context.
ConditionSet Table
ﾉ

Type

Name

Description

Expand table

uint16

conditionCount

Number of conditions for this condition set.

Offset32

conditionOffsets[conditionCount]

Array of offsets to condition tables, from beginning of
the ConditionSet table.

Condition table
The condition table describes a particular condition. Different formats for the condition
table may be defined, with each format used for a particular kind of condition qualifier.
Currently, one format is defined: ConditionTableFormat1, which is used to specify a value
range for a variation axis value in a variable font.
New condition table formats for other condition qualifiers may be added in the future. If a
layout engine encounters a condition table with an unrecognized format, it should fail to
match the condition set, but continue to test other condition sets. In this way, new condition
formats can be defined and used in fonts that can work in a backward-compatible way in
existing implementations.

Condition table format 1: font variation axis range
A font variation axis range condition refers to a range of values for a design variation axis in
a variable font. The axes of variation are specified in the font variations ('fvar') table of a
font. If a format 1 condition table is used, there must be an 'fvar' table in the font, and the
axisIndex value (which is zero-based) must be less than the axisCount value in the 'fvar'
table. If the axisIndex is invalid, the feature variation record containing this condition table is
ignored.
A format 1 condition table specifies a matching range of variation instance values along a
single axis. Absence of a format 1 condition for a given variation axis implies that that axis is
not a factor in determining applicability of the condition set.
The 'fvar' table defines a range of valid values for each variation axis. During processing for a
particular variation instance, a normalization process is applied that maps user values in the
range defined within the 'fvar' table to a normalized scale with a range from -1 to 1. The
values specified in a format 1 condition table are expressed in terms of the normalized scale,
and so can be any value from -1 to 1.
A font variation axis range condition is met if the currently-selected variation instance has a
value for the given axis that is greater than or equal to the filterRangeMinValue, and that is
less than or equal to the filterRangeMaxValue.
ConditionFormat1 table

ﾉ

Expand table

Type

Name

Description

uint16

format

Format, = 1

uint16

axisIndex

Index (zero-based) for the variation axis within the 'fvar' table.

F2DOT14

filterRangeMinValue

Minimum value of the font variation instances that satisfy this
condition.

F2DOT14

filterRangeMaxValue

Maximum value of the font variation instances that satisfy this
condition.

FeatureTableSubstitution table
A feature table substitution table describes a set of feature table substitutions to be applied
when the corresponding condition set matches the current runtime context. These
substitutions are represented using an array of feature table substitution records. Each
record gives a simple substitution of one feature table for another. When checking for a
particular feature index, the first record having that index is matched, and searching ends if
a record is encountered with a higher index value.
Note that the records must be ordered in increasing order of the FeatureIndex values, and
no two records may have the same FeatureIndex value.
FeatureTableSubstitution table
ﾉ

Expand table

Type

Name

Description

uint16

majorVersion

Major version of the feature table
substitution table — set to 1

uint16

minorVersion

Minor version of the feature table
substitution table — set to 0.

uint16

substitutionCount

Number of feature table
substitution records.

FeatureTableSubstitutionRecord

substitutions[substitutionCount]

Array of feature table substitution
records.

FeatureTableSubstitutionRecord
ﾉ

Expand table

Type

Name

Description

uint16

featureIndex

The feature table index to match.

Offset32

alternateFeatureOffset

Offset to an alternate feature table, from start of the
FeatureTableSubstitution table.

As described above, condition sets are evaluated and may be selected for processing of the
associated feature table substitution table to replace a default feature table obtained from a
LangSys table with an alternate feature table. Given a default array of feature tables for
selected features obtained from the LangSys table, substitution of alternate feature tables
can be done as follows:
1. For each feature index, evaluate the FeatureTableSubstitutionRecords in order.
2. If a matching record is encountered (FeatureIndex = the current feature index), then
replace the feature table for that feature index using the alternate feature table at the
offset given in the record. Stop processing for that feature index.
3. If a record is encountered with a higher feature index value, stop searching for that
feature index; no substitution is made.

Common table examples
The rest of this chapter describes and illustrates examples of all the common table formats.
All the examples reflect unique parameters, but the samples provide a useful reference for
building tables specific to other situations.
The examples have three columns showing hex data, source, and comments.

Example 1: ScriptList table and ScriptRecords
Example 1 illustrates a ScriptList table and ScriptRecord definitions for a Japanese font with
multiple scripts: Han Ideographic, Kana, and Latin. Each script has script-specific behavior.
Example 1
ﾉ

Hex Data

Source

Comment

ScriptList

ScriptList table definintion

TheScriptList
0003

3

scriptCount

scriptRecords[0]

In alphabetical order by script tag.

Expand table

68616E69

'hani'

scriptTag, Han Ideographic script

0014

HanIScriptTable

offset to Script table

scriptRecords[1]

In alphabetical order by script tag.

6B616E61

'kana'

scriptTag, Hiragana and Katakana scripts

0018

KanaScriptTable

offset to Script table

scriptRecords[2]

In alphabetical order by script tag.

6C61746E

'latn'

scriptTag, Latin script

001C

LatinScriptTable

offset to Script table

Example 2: Script table, LangSysRecord, and LangSys table
Example 2 illustrates the Script table, LangSysRecord, and LangSys table definitions for the
Arabic script and the Urdu language system. The default LangSys table defines three default
Arabic script features used to replace certain glyphs in words with their proper initial,
medial, and final glyph forms. These contextual substitutions are invariant and occur in all
language systems that use the Arabic script.
Many alternative glyphs in the Arabic script have language-specific uses. For instance, the
Arabic, Farsi, and Urdu language systems use different glyphs for numerals. To maintain
character-set compatibility, the Unicode standard includes separate character codes for the
Arabic and Farsi numeral glyphs. However, the standard uses the same character codes for
Farsi and Urdu numerals, even though three of the Urdu glyphs (4, 6, and 7) differ from the
Farsi glyphs. To access and display the proper glyphs for the Urdu numerals, users of the
text-processing client must enter the character codes for the Farsi numerals. Then the textprocessing client uses a required OpenType Layout glyph substitution feature, defined in the
Urdu LangSys table, to access the correct Urdu glyphs for the 4, 6, and 7 numerals.
Note that the Urdu LangSys table repeats the default script features. This repetition is
necessary because the Urdu language system also uses alternative glyphs in the initial,
medial, and final glyph positions in words.
Example 2
ﾉ

Hex Data

Source

Comment

Script
ArabicScriptTable

Script table definition

Expand table

000A

DefLangSys

offset to default LangSys table

0001

1

langSysCount

langSysRecords[0]

In alphabetical order by LangSys tag.

55524420

“URD ”

langSysTag, Urdu language

0016

UrduLangSys

offset to LangSys table for Urdu

LangSys

default LangSys table definition

DefLangSys
0000

NULL

lookupOrderOffset, reserved, null

FFFF

0xFFFF

requiredFeatureIndex, no required features

0003

3

featureIndexCount

0000

0

featureIndices[0], in arbitrary order
'init' feature (initial glyph)

0001

1

featureIndices[1], 'fina' feature (final glyph)

0002

2

featureIndices[2], for 'medi' feature (medial glyph)

LangSys

LangSys table definition

UrduLangSys
0000

NULL

lookupOrderOffset, reserved, null

0003

3

requiredFeatureIndex, numeral subsitution in Urdu

0003

3

featureIndexCount

0000

0

featureIndices[0], in arbitrary order
'init' feature (initial glyph)

0001

1

featureIndices[1], 'fina' feature (final glyph)

0002

2

featureIndices[2], 'medi' feature (medial glyph)

Example 3: FeatureList table and Feature table
Example 3 shows the FeatureList and Feature table definitions for ligatures in the Latin
script. The FeatureList has three features, all optional and named 'liga'. One feature, also a
default, implements ligatures in Latin if no language-specific feature specifies other
ligatures. Two other features implement ligatures in the Turkish and German languages,
respectively.
Three lookups define glyph substitutions for rendering ligatures in this font. The first lookup
produces the “ffi” and “fi” ligatures; the second produces the “ffl”, “fl”, and “ff” ligatures; and

the third produces the eszet ligature.
The ligatures that begin with an “f” are separated into two sets because Turkish has a
dotless “i” glyph and so does not use “ffi” and “fi” ligatures. However, Turkish does use the
“ffl”, “fl”, and “ff” ligatures, and the TurkishLigatures feature table lists this one lookup.
Only the German language system uses the eszet ligature, so the GermanLigatures feature
table includes a lookup for rendering that ligature.
Because the Latin script can use both sets of ligatures, the DefaultLigatures feature table
defines two LookupList indices: one for the “ffi” and “fi” ligatures, and one for the “ffl”, “fl”,
and “ff” ligatures. If the text-processing client selects this feature, then the font applies both
lookups.
Note that the TurkishLigatures and DefaultLigatures feature tables both list a
LookupListIndex of one (1) for the “ffl”, “fl”, and “ff” ligatures lookup. This is because
language-specific lookups override all default language-system lookups, and a languagesystem feature table must explicitly list all lookups that apply to the language.
Example 3
ﾉ

Hex Data

0003

Source

Comment

FeatureList
TheFeatureList

FeatureList table definition

3

featureCount

featureRecords[0]
6C696761

'liga'

featureTag

0014

TurkishLigatures

offset to Feature table, FflFfFlLiga

featureRecords[1]
6C696761

'liga'

featureTag

001A

DefaultLigatures

offset to Feature table, FfiFiLiga, FflFfFlLiga

featureRecords[2]
6C696761

'liga'

featureTag

0022

GermanLigatures

offset to Feature table, EszetLiga

Feature
TurkishLigatures

Feature table definition

Expand table

0000

NULL

featureParamsOffset, null

0001

1

lookupIndexCount

0001

1

lookupListIndices[1], ffl, fl, ff ligature substitution Lookup

Feature
DefaultLigatures

Feature table definition

0000

NULL

featureParamsOffset, null

0002

2

lookupIndexCount

0000

0

lookupListIndices[0], in arbitrary order, ffi, fi ligatures

0001

1

lookupListIndices[1], ffl, fl, ff ligature substitution Lookup

Feature
GermanLigatures

Feature table definition

0000

NULL

featureParamsOffset, null

0003

3

lookupIndexCount

0000

0

lookupListIndices[0], in arbitrary order, ffi, fi ligatures

0001

1

lookupListIndices[1], ffl, fl, ff ligature substitution Lookup

0002

2

lookupListIndices[2], eszet ligature substitution Lookup

Example 4: LookupList table and Lookup table
A continuation of Example 3, Example 4 shows three ligature lookups in the LookupList
table. The first generates the “ffi” and “fi” ligatures; the second produces the “ffl”, “fl”, and
“ff” ligatures; and the third generates the eszet ligature. Each lookup table defines an offset
to a subtable that contains data for the ligature substitution.
Example 4
ﾉ

Hex Data

Source

Comment

LookupList

LookupList table definition

TheLookupList
0003

3

lookupCount

0008

FfiFiLookup

offset to lookups[0] table, in design order

0010

FflFlFfLookup

offset to lookups[1] table

Expand table

0018

EszetLookup

offset to lookups[2] table

Lookup

lookups[0] table definition

FfiFiLookup
0004

4

lookupType: ligature subst

000C

0x000C

lookupFlag: IGNORE_LIGATURES, IGNORE_MARKS

0001

1

subTableCount

0018

FfiFiSubtable

offset to FfiFi ligature substitution subtable

Lookup

lookups[1] table definition

FflFlFfLookup
0004

4

lookupType: ligature subst

000C

0x000C

lookupFlag: IGNORE_LIGATURES, IGNORE_MARKS

0001

1

subTableCount

0028

FflFlFfSubtable

offset to FflFlFf ligature substitution subtable

Lookup
EszetLookup

lookups[2] table definition

0004

4

lookupType: ligature subst

000C

0x000C

lookupFlag: IGNORE_LIGATURES, IGNORE_MARKS

0001

1

subTableCount

0038

EszetSubtable

offset to Eszet ligature substitution subtable

Example 5: CoverageFormat1 table (glyph ID list)
Example 5 illustrates a Coverage table that lists the glyph IDs of all lowercase descender
glyphs in a font. The table uses the list format instead of the range format because the
glyph IDs for the descender glyphs are not consecutively ordered.
Example 5
ﾉ

Hex Data

0001

Source

Comment

CoverageFormat1
DescenderCoverage

Coverage table definition

1

format: glyph ID list

Expand table

0005

5

glyphCount

0038

gGlyphID

glyphArray[0], in glyph ID order

003B

jGlyphID

glyphArray[1]

0041

pGlyphID

glyphArray[2]

0042

qGlyphID

glyphArray[3]

004A

yGlyphID

glyphArray[4]

Example 6: CoverageFormat2 table (glyph ID ranges)
Example 6 shows a Coverage table that defines ten numeral glyphs (0 through 9). The table
uses the range format instead of the list format because the glyph IDs are ordered
consecutively in the font. The StartCoverageIndex of zero (0) indicates that the first glyph ID,
for the zero glyph, returns a Coverage Index of 0. The second glyph ID, for the numeral one
(1) glyph, returns a Coverage Index of 1, and so on.
Example 6
ﾉ

Hex Data

Source

Comment

CoverageFormat2
NumeralCoverage

Coverage table definition

0002

2

format: glyph ID ranges

0001

1

rangeCount

Expand table

rangeRecords[0]
004E

0glyphID

startGlyphID

0057

9glyphID

endGlyphID

0000

0

StartCoverageIndex, first CoverageIndex = 0

Example 7: ClassDefFormat1 table (class array)
The ClassDef table in Example 7 assigns class values to the lowercase glyphs in a font. The xheight glyphs are in Class 0, the ascender glyphs are in Class 1, and the descender glyphs
are in Class 2. The array begins with the index for the lowercase “a” glyph.
Example 7

ﾉ

Hex Data

Source

Comment

ClassDefFormat1

ClassDef table definition

LowercaseClassDef
0001

1

format: class array

0032

aGlyphID

startGlyph

001A

26

glyphCount

classValueArray
0000

0

aGlyph, Xheight Class 0

0001

1

bGlyph, Ascender Class 1

0000

0

cGlyph, Xheight Class 0

0001

1

dGlyph, Ascender Class 1

0000

0

eGlyph, Xheight Class 0

0001

1

fGlyph, Ascender Class 1

0002

2

gGlyph, Descender Class 2

0001

1

hGlyph, Ascender Class 1

0000

0

iGlyph, Ascender Class 1

0002

2

jGlyph, Descender Class 2

0001

1

kGlyph, Ascender Class 1

0001

1

lGlyph, Ascender Class 1

0000

0

mGlyph, Xheight Class 0

0000

0

nGlyph, Xheight Class 0

0000

0

oGlyph, Xheight Class 0

0002

2

pGlyph, Descender Class 2

0002

2

qGlyph, Descender Class 2

0000

0

rGlyph, Xheight Class 0

0000

0

sGlyph, Xheight Class 0

0001

1

tGlyph, Ascender Class 1

0000

0

uGlyph, Xheight Class 0

Expand table

0000

0

vGlyph, Xheight Class 0

0000

0

wGlyph, Xheight Class 0

0000

0

xGlyph, Xheight Class 0

0002

2

yGlyph, Descender Class 2

0000

0

zGlyph, Xheight Class 0

Example 8: ClassDefFormat2 table (class ranges)
In Example 8, the ClassDef table assigns class values to four types of glyphs in the Arabic
script: medium-height base glyphs, high base glyphs, very high base glyphs, and default
mark glyphs. The table lists only Class 1, Class 2, and Class 3; all glyphs not explicitly
assigned a class fall into Class 0.
The table uses the range format because the glyph IDs in each class are ordered
consecutively in the font. In the ClassRange array, ClassRange definitions are ordered by the
Start glyph index in each range. The indices of the high base glyphs, defined in
ClassRange[0], are first in the font and have a class value of 2. ClassRange[1] defines all the
very high base glyphs and assigns a class value of 3. ClassRange[2] contains all default mark
glyphs; the class value is 1. Class 0 consists of all the medium-height base glyphs, which are
not explicitly assigned a class value.
Example 8
ﾉ

Hex Data

Source

Comment

ClassDefFormat2

Class table definition

Expand table

GlyphHeightClassDef
0002

2

format: ranges

0003

3

classRangeCount

classRangeRecords[0]

ordered by startGlyphID

0030

tahGlyphID

startGlyphID — first glyph ID in the range

0031

dhahGlyphID

endGlyphID — last glyph ID in the range

0002

2

class: high base glyphs

classRangeRecords[1]
0040

cafGlyphID

startGlyphID

0041

gafGlyphID

endGlyphID

0003

3

class: very high base glyphs

classRangeRecords[2]
00D2

fathatanDefaultGlyphID

startGlyphID

00D3

dammatanDefaultGlyphID

endGlyphID

0001

1

class: default marks

Example 9: Device table
Example 9 defines the minimum extent value for a math script, using a Device table to
adjust the value according to the size of the output font. Here, the Device table defines
single-pixel adjustments for font sizes from 11 ppem to 15 ppem. The DeltaFormat is 1,
which signifies a packed array of signed 2-bit values, eight values per uint16.
Example 9
ﾉ

Hex Data

Source

Comment

DeviceTableFormat1

Device Table definition

Expand table

MinCoordDeviceTable
000B

11

startSize: 11 ppem

000F

15

endSize: 15 ppem

0001

1

deltaFormat: signed 2 bit value (8 values per uint16)

1

increase 11ppem by 1 pixel

1

increase 12ppem by 1 pixel

1

increase 13ppem by 1 pixel

1

increase 14ppem by 1 pixel

1

increase 15ppem by 1 pixel

5540

OpenType Font Variations Common
Table Formats
Article • 05/29/2024

OpenType Font Variations allow continuous variation along one or more design axes,
such as weight or width. An overview of OpenType Font Variations and a specification of
the algorithm for interpolating variation instance values is provided in the chapter,
OpenType Font Variations Overview; that chapter should be read first. This chapter
documents the formats for variation data that are used in various font tables, such as
the 'gvar' or MVAR tables.

Overview
A font has many different data items found in several different font tables that provide
values that are specific to a particular font face. Examples include glyph-specific values,
such as the positions of glyph outline points and glyph advance widths, and face-wide
values, such as a sub-family name, a weight class, or ascender and descender values. In a
variable font, most or all of these values may need to vary for different variation
instances. When an application selects a variation instance within the font’s variation
space, new values for such items appropriate to that instance need to be derived. This is
done using delta adjustment values.
For example, the OS/2 table of a font may provide a default sxHeight value of 970. The
MVAR table might provide a delta value of +50 that is used for weight-axis values from
the default to the heaviest-supported weight. For a particular instance, the interpolation
process might scale that delta with a scalar co-efficient of 0.4, deriving an instance
sxHeight value of 990.
These concepts and the interpolation algorithm for deriving instance values are
described in detail in the chapter, OpenType Font Variations Overview.
The variation data for a font consists of a number of delta adjustment values. Each
individual delta applies to a particular, target data item; for instance, the X coordinate of
a point in a glyph outline, or the font’s sTypoAscender. Each delta is also associated with
a specific region within the font’s design variation space over which it is applicable.
Thus, a given delta is logically keyed by the target data item and the applicable region.
The variation data for a font consists of a number of delta adjustment values. Each
individual delta applies to a particular, target data item; for instance, the X coordinate of
a point in a glyph outline, or the font’s sTypoAscender. Each delta is also associated with

a specific region within the font’s design variation space over which it is applicable.
Thus, a given delta is logically keyed by the target data item and the applicable region.
A variable font includes many deltas. At the highest level, deltas are organized into
collections for different target item sets:
Deltas for positions of points of a 'glyf' table are stored in a 'gvar' table.
Deltas for positions of points of a CFF2 table are stored within the CFF2 table.
Deltas for CVT values in the 'cvt ' table are stored in a 'cvar' table.
Deltas for glyph metrics in an 'hmtx' table are stored in an HVAR table; and deltas
for glyph metrics in a 'vmtx' or VORG table are stored in a VVAR table.
Deltas for anchor positions in GPOS lookups and other items used in GDEF, GPOS
or JSTF tables are stored within variation data contained in the GDEF table.
Deltas for font-wide metrics and other items from the OS/2, 'hhea', 'gasp', 'post' or
'vhea' tables are stored in an MVAR table.
Deltas for values in other tables are stored in the respective table: deltas for
baseline metrics in the BASE table and for various items in the COLR table are
stored in each table.
In a variable font, the largest group of deltas are for the positions of glyph outline
points. For TrueType outlines in a 'glyf' table, the deltas are stored within the 'gvar' table,
with a second level of organization grouping deltas by glyph ID. See the 'gvar' table
specification for details.
Below these higher levels of organization, most variation data is organized in one of two
ways. (Variation data for CFF2 outlines is a partial exception — see below.)
Organize sets of deltas for several target items into groupings by the variationspace region over which they apply. Since regions are defined using n-tuples (or
“tuples”), such data sets will be referred to as tuple variation stores.
Organize sets of deltas associated with different regions into groupings by the
target items to which they apply. Such data sets will be referred to as item
variation stores.
The two formats have different ways of representing n-tuples that define regions of
applicability, and different ways of associating deltas with target font-data items. The
tuple variation store format is optimized for compact representation of glyph outline
variation data that is all processed for a given variation instance. The ItemVariationStore
format, on the other hand, is designed to allow direct access to variation data for
arbitrary target items, allowing more efficient processing in contexts that do not require
interpolated values for all items to be computed. (Additional details are provided
below.) The 'gvar' and 'cvar' tables use the tuple variation store format, while variation

data in most other tables, including the MVAR, HVAR and GDEF tables, use the
ItemVariationStore format.
Variation data for CFF2 outlines are handled slightly differently than other cases. The
deltas for glyph outline descriptions are interleaved directly within the outline
descriptions in the Compact Font Format 2 (CFF2) table. But the sets of regions that are
associated with the delta sets are defined in an item variation store, contained as a
subtable within the CFF2 table.

Tuple Variation Store
Tuple variation stores are used in the 'gvar' and 'cvar' tables, and organize sets of
variation data into groupings, each of which is associated with a region of applicability
within the variation space. Within the 'gvar' table, there is a separate variation store for
each glyph. Within the 'cvar' table, there is one variation store providing variations for all
CVT values.
There is a minor difference in the top-level structure of the store in these two contexts.
Within the 'cvar' table, it is the entire 'cvar' table that comprises the specific variation
store format, with a header that begins with major/minor version fields. The specific
variation store format for glyph-specific data within the 'gvar' table is the
GlyphVariationData table (one per glyph ID), which does not include any version fields.
In other respects, the 'cvar' table and GlyphVariationData table formats are the same.
There is also a minor difference in certain data that can occur in a GlyphVariationData
table versus a 'cvar' table. Differences between the 'gvar' and 'cvar' tables will be
summarized later in this section.
In terms of logical information content, the GlyphVariationData and 'cvar' tables consist
of a set of logical, tuple variation data tables, each for a different region of the variation
space. In physical layout, however, the logical tuple variation tables are divided into
separate parts that get stored separately: a header portion, and a serialized-data
portion.
In terms of overall structure, the GlyphVariationData table and the 'cvar' table each
begin with a header, which is followed by serialized data. The header includes an array
with the tuple variation headers. The serialized data includes deltas and other data that
will be explained below.

Figure: High-level organization of tuple variation stores

Tuple Records
The tuple variation store formats reference regions within the font’s variation space
using tuple records. A tuple record identifies a position in terms of normalized
coordinates, which use F2DOT14 values.
Tuple record:
ﾉ

Expand table

Type

Name

Description

F2DOT14

coordinates[axisCount]

Coordinate array specifying a position within the font’s
variation space. The number of elements must match the
axisCount specified in the 'fvar' table.

Note: The Tuple record and UserTuple record (used in the 'fvar' table) both describe
a position in the variation space but are distinct: UserTuple uses Fixed values to
represent user scale coordinates, while Tuple record uses F2DOT14 values to
represent normalized coordinates.

Tuple Variation Store Header
The two variants of a tuple variation store header, the GlyphVariationData table header
and the 'cvar' header, are only slightly different. The formats of each are as follows:
GlyphVariationData header:

ﾉ

Expand table

Type

Name

Description

uint16

tupleVariationCount

A packed field. The high 4
bits are flags (see below),
and the low 12 bits are the
number of tuple variation
tables for this glyph. The
count can be any number
between 1 and 4095.

Offset16

dataOffset

Offset from the start of the
GlyphVariationData table to
the serialized data.

TupleVariationHeader

tupleVariationHeaders[tupleVariationCount]

Array of tuple variation
headers.

'cvar' table header:
ﾉ

Expand table

Type

Name

Description

uint16

majorVersion

Major version number of
the 'cvar' table — set to 1.

uint16

minorVersion

Minor version number of
the 'cvar' table — set to 0.

uint16

tupleVariationCount

A packed field. The high 4
bits are flags (see below),
and the low 12 bits are the
number of tuple variation
tables. The count can be
any number between 1 and
4095.

Offset16

dataOffset

Offset from the start of the
'cvar' table to the serialized
data.

TupleVariationHeader

tupleVariationHeaders[tupleVariationCount]

Array of tuple variation
headers.

The tupleVariationCount field contains a packed value that includes flags and the
number of logical tuple variation tables — which is also the number of physical tuple
variation headers. The format of the tupleVariationCount value is as follows:

ﾉ

Expand table

Mask

Name

Description

0x8000

SHARED_POINT_NUMBERS

Flag indicating that some or all tuple variation tables
reference a shared set of “point” numbers. These shared
numbers are represented as packed point number data at
the start of the serialized data.

0x7000

Reserved

Reserved for future use — set to 0.

0x0FFF

COUNT_MASK

Mask for the low bits to give the number of tuple variation
tables.

If the SHARED_POINT_NUMBERS flag is set, then the serialized data following the
header begins with packed “point” number data. In the context of a GlyphVariationData
table within the 'gvar' table, these identify outline point numbers for which deltas are
explicitly provided. In the context of the 'cvar' table, these are interpreted as CVT indices
rather than point indices. The format of packed point number data is described below.

TupleVariationHeader
The GlyphVariationData and 'cvar' header formats include an array of tuple variation
headers. The TupleVariationHeader format is as follows.
TupleVariationHeader:
ﾉ

Expand table

Type

Name

Description

uint16

variationDataSize

The size in bytes of the serialized data for this tuple variation
table.

uint16

tupleIndex

A packed field. The high 4 bits are flags (see below). The low 12
bits are an index into a shared tuple records array.

Tuple

peakTuple

Peak tuple record for this tuple variation table — optional,
determined by flags in the tupleIndex value.
Note that this must always be included in the 'cvar' table.

Tuple

intermediateStartTuple

Intermediate start tuple record for this tuple variation table —
optional, determined by flags in the tupleIndex value.

Tuple

intermediateEndTuple

Intermediate end tuple record for this tuple variation table —
optional, determined by flags in the tupleIndex value.

Note that the size of the TupleVariationHeader is variable, depending on whether peak
or intermediate tuple records are included. (See below for more information.)
The variationDataSize value indicates the size of serialized data for the given tuple
variation table that is contained in the serialized data. It does not include the size of the
TupleVariationHeader.
Every tuple variation table has an associated peak tuple record. Most tuple variation
tables use non-intermediate regions, and so require only the peak tuple record to define
the region. In the 'cvar' table, there is only one variation store, and so any given region
will only need to be referenced once. Within the 'gvar' table, however, there is a
GlyphVariationData table for each glyph ID, and so any region may be referenced
numerous times; in fact, most regions will be referenced within the GlyphVariationData
tables for most glyphs. To provide a more efficient representation, the tuple variation
store formats allow for an array of tuple records, stored outside the tuple variation store
structures, that can be shared across many tuple variation stores. This is used only within
the 'gvar' table; it is not needed or supported in the 'cvar' table. The formats alternately
allow for a peak tuple record that is non-shared, specific to the given tuple variation
table, to be embedded directly within a TupleVariationHeader. This is optional within the
'gvar' table, but required in the 'cvar' table, which does not use shared peak tuple
records.
See the 'gvar' chapter for details on the representation of shared tuple records within
that table.
The tupleIndex field contains a packed value that includes flags and an index into a
shared tuple records array (not used in the 'cvar' table). The format of the tupleIndex
field is as follows.
tupleIndex format:
ﾉ

Expand table

Mask

Name

Description

0x8000

EMBEDDED_PEAK_TUPLE

Flag indicating that this tuple variation header includes an
embedded peak tuple record, immediately after the
tupleIndex field. If set, the low 12 bits of the tupleIndex
value are ignored.
Note that this must always be set within the 'cvar' table.

0x4000

INTERMEDIATE_REGION

Flag indicating that this tuple variation table applies to an
intermediate region within the variation space. If set, the
header includes the two intermediate-region, start and

end tuple records, immediately after the peak tuple record
(if present).
0x2000

PRIVATE_POINT_NUMBERS

Flag indicating that the serialized data for this tuple
variation table includes packed “point” number data. If set,
this tuple variation table uses that number data; if clear,
this tuple variation table uses shared number data found
at the start of the serialized data for this glyph variation
data or 'cvar' table.

0x1000

Reserved

Flag reserved for future use — set to 0.

0x0FFF

TUPLE_INDEX_MASK

Mask for the low 12 bits to give the shared tuple records
index.

Note that the INTERMEDIATE_REGION flag is independent of the
EMBEDDED_PEAK_TUPLE flag or the shared tuple records index. Every tuple variation
table has a peak n-tuple indicated either by an embedded tuple record (always true in
the 'cvar' table) or by an index into a shared tuple records array (only in the 'gvar' table).
An intermediate-region tuple variation table additionally has start and end n-tuples that
also get used in the interpolation process; these are always represented using
embedded tuple records.
Also note that the PRIVATE_POINT_NUMBERS flag is independent of the
SHARED_POINT_NUMBERS flag in the tupleVariationCount field of the
GlyphVariationData or 'cvar' header. A GlyphVariationData or 'cvar' table may have
shared point number data used by multiple tuple variation tables, but any given tuple
variation table may have private point number data that it uses instead.
As noted, the size of tuple variation headers is variable. The next TupleVariationHeader
can be calculated as follows:

const TupleVariationHeader*
NextHeader( const TupleVariationHeader* currentHeader, int axisCount )
{
int bump = 2 * sizeof( uint16 );
int tupleIndex = currentHeader->tupleIndex;
if ( tupleIndex & embeddedPeakTuple )
bump += axisCount * sizeof( F2DOT14 );
if ( tupleIndex & intermediateRegion )
bump += 2 * axisCount * sizeof( F2DOT14 );
return (const TupleVariationHeader*)((char*)currentHeader + bump);
}

Serialized Data
After the GlyphVariationData or 'cvar' header (including the TupleVariationHeader array)
is a block of serialized data. The offset to this block of data is provided in the header.
The serialized data block begins with shared “point” number data, followed by the
variation data for the tuple variation tables. The shared point number data is optional: it
is present if the corresponding flag is set in the tupleVariationCount field of the header.
If present, the shared number data is represented as packed point numbers, described
below.

Figure: Organization of serialized data
The remaining data contains runs of data specific to individual tuple variation tables, in
order of the tuple variation headers. Each TupleVariationHeader indicates the data size
for the corresponding run of data for that tuple variation table.
The per-tuple-variation-table data optionally begins with private “point” numbers,
present if the privatePointNumbers flag is set in the tupleIndex field of the
TupleVariationHeader. Private point numbers are represented as packed point numbers,
described below.
After the private point number data (if present), the tuple variation data will include
packed delta data. The format for packed deltas is given below. Within the 'gvar' table,
there are packed deltas for X coordinates, followed by packed deltas for Y coordinates.

Figure: Organization 'gvar' per-tuple variation data
Within the 'cvar' table, there is one set of packed deltas.

Figure: Organization 'cvar' per-tuple variation data
The data size indicated in the TupleVariationHeader includes the size of the private point
number data, if present, plus the size of the packed deltas.

Packed “Point” Numbers
Tuple variation data specify deltas to be applied to specific items: X and Y coordinates
for glyph outline points within the 'gvar' table, and CVT values in the 'cvar' table. For a
given glyph, deltas may be provided for any or all of a glyph’s points, including
“phantom” points generated within the rasterizer that represent glyph side bearing
points. (See the chapter Instructing TrueType Glyphs for more background on phantom
points.) Similarly, within the 'cvar' table, deltas may be provided for any or all CVTs. The
set of glyph points or CVTs for which deltas are provided is specified by packed point
numbers.
Note: If a glyph is a composite glyph, then “point” numbers are interpreted as
indices for the components that make up the composite glyph. See the 'gvar' table

chapter for complete details. Likewise, in the context of the 'cvar' table, “point”
numbers are indices for CVT entries.
Note: Within the 'gvar' table, if deltas are not provided explicitly for some points,
then inferred delta values may need to be calculated — see the 'gvar' table chapter
for details. This does not apply to the 'cvar' table, however: if deltas are not provided
for some CVT values, then no adjustments are made to those CVTs in connection
with the particular tuple variation table.
Packed point numbers are stored as a count followed by one or more runs of point
number data.
The count may be stored in one or two bytes. After reading the first byte, the need for a
second byte can be determined. The count bytes are processed as follows:
If the first byte is 0, then a second count byte is not used. This value has a special
meaning: the tuple variation data provides deltas for all glyph points (including the
“phantom” points), or for all CVTs.
If the first byte is non-zero and the high bit is clear (value is 1 to 127), then a
second count byte is not used. The point count is equal to the value of the first
byte.
If the high bit of the first byte is set, then a second byte is used. The count is read
from interpreting the two bytes as a big-endian uint16 value with the high-order
bit masked out.
Thus, if the count fits in 7 bits, it is stored in a single byte, with the value 0 having a
special interpretation. If the count does not fit in 7 bits, then the count is stored in the
first two bytes with the high bit of the first byte set as a flag that is not part of the count
— the count uses 15 bits.
For example, a count of 0x00 indicates that deltas are provided for all point numbers /
all CVTs, with no additional point number data required; a count of 0x32 indicates that
there are a total of 50 point numbers specified; a count of 0x81 0x22 indicates that there
are a total of 290 (= 0x0122) point numbers specified.
Point number data runs follow after the count. Each data run begins with a control byte
that specifies the number of point numbers defined in the run, and a flag bit indicating
the format of the run data. The control byte’s high bit specifies whether the run is
represented in 8-bit or 16-bit values. The low 7 bits specify the number of elements in
the run minus 1. The format of the control byte is as follows:
ﾉ

Expand table

Mask

Name

Description

0x80

POINTS_ARE_WORDS

Flag indicating the data type used for point numbers in this
run. If set, the point numbers are stored as unsigned 16-bit
values (uint16); if clear, the point numbers are stored as
unsigned bytes (uint8).

0x7F

POINT_RUN_COUNT_MASK

Mask for the low 7 bits of the control byte to give the
number of point number elements, minus 1.

For example, a control byte of 0x02 indicates that the run has three elements
represented as uint8 values; a control byte of 0xD4 indicates that the run has 0x54 + 1 =
85 elements represented as uint16 values.
In the first point run, the first point number is represented directly (that is, as a
difference from zero). Each subsequent point number in that run is stored as the
difference between it and the previous point number. In subsequent runs, all elements,
including the first, represent a difference from the last point number.
Since the values in the packed data are all unsigned, point numbers will be given in
increasing order. Since the packed representation can include zero values, it is possible
for a given point number to be repeated in the derived point number list. In that case,
there will be multiple delta values in the deltas data associated with that point number.
All of these deltas must be applied cumulatively to the given point.

Packed Deltas
Tuple variation data specify deltas to be applied to glyph point coordinates or to CVT
values. As in the case of point number data, deltas are stored in a packed format.
Packed delta data does not include the total number of delta values within the data.
Logically, there are deltas for every point number or CVT index specified in the pointnumber data. Thus, the count of logical deltas is equal to the count of point numbers
specified for that tuple variation table. But since the deltas are represented in a packed
format, the actual count of stored values is typically less than the logical count. The data
is read until the expected logic count of deltas is obtained.
Note: In the 'gvar' table, there will be two logical deltas for each point number: one
that applies to the X coordinate, and one that applies to the Y coordinate. Therefore,
the total logical delta count is two times the point number count. The packed deltas
are arranged with the deltas for X coordinates first, followed by the deltas for Y
coordinates.

Packed deltas are stored as a series of runs. Each delta run consists of a control byte
followed by the actual delta values of that run. The control byte is a packed value with
flags in the high two bits and a count in the low six bits. The flags specify the data size
of the delta values in the run. The format of the control byte is as follows:
ﾉ

Expand table

Mask

Name

Description

0x80

DELTAS_ARE_ZERO

Flag indicating that this run contains no data (no explicit
delta values are stored), and that all of the deltas for this
run are zero.

0x40

DELTAS_ARE_WORDS

Flag indicating the data type for delta values in the run. If
set, the run contains 16-bit signed deltas (int16); if clear, the
run contains 8-bit signed deltas (int8).

0x3F

DELTA_RUN_COUNT_MASK

Mask for the low 6 bits to provide the number of delta
values in the run, minus one.

For example, a control byte of 0x03 indicates that there are four 8-bit signed delta
values following the control byte; a control byte of 0x40 indicates that there is one 16bit signed delta value following the control byte; a control byte of 0x94 indicates that
there is no additional data for this run, and that the run represents a sequence of 0x14 +
1 = 21 deltas equal to zero.
The following is an example of a block of packed delta data:
03 0A 97 00 C6 87 41 10 22 FB 34
This data has three runs: a run of four 8-bit values, a run interpreted as eight zeroes, and
a run of two 16-bit values:
Run 1: 03 0A 97 00 C6
Run 2: 87
Run 3: 41 10 22 FB 34
This packed data would represent the following logical sequence of delta values:
10, -105, 0, -58, 0, 0, 0, 0, 0, 0, 0, 0, 4130, -1228

Processing Tuple Variation Store Data

When a variation instance has been selected, an application needs to process the
variation store data to derive interpolated values for that instance — interpolated grid
coordinates for outline points, or interpolated CVT values. In the case of the 'gvar' table,
this will be done glyph-by-glyph as needed. The application can process the
TupleVariationHeaders to filter the tuple variation tables that are applicable for the
current instance, or to calculate a scalar for each tuple variation table directly. Scalars
can then be applied to deltas in each tuple variation table, and the net adjustments
applied to the target items.
Note: In the 'cvar' table, there is a logical delta for each CVT index given in the
packed point number data. In the 'gvar' table, there are two logical deltas for each
point number: one for the point’s X coordinate, and one for the Y coordinate. The
delta data is organized with all of the deltas for X coordinates first, followed by
deltas for Y coordinates.
Note: In the 'gvar' table, if the data for a given glyph lists point numbers for some
points in a contour but not others, then delta values for the omitted point numbers
must be inferred. See the 'gvar' table chapter for details.
For details on determining applicability of a given tuple variation table, and on
calculation of scalars and net adjustments to target items, see the chapter OpenType
Font Variations Overview.
Because point number and delta data are stored in a packed representation, the data
must be processed from the start in order to determine the presence of any particular
point number, or to retrieve the delta for a particular item. For this reason, the format is
best suited to processing all the data in a given tuple variation table at once rather than
processing data for individual target items. In the case of glyph outlines, this is
reasonable since there is no common application scenario for interpolating an adjusted
position of a single outline point.
The “phantom” points, which provide side-bearing and advance width information, are a
possible exception to that generalization, however. (See the chapter, Instructing
TrueType Glyphs for more background on phantom points.) In particular, some textlayout operations require glyph metrics (advance widths or side bearings) without
necessarily requiring glyph outline data. Yet the tuple variation store formats used in the
'gvar' table require that interpolated outlines be computed in order to obtain the
interpolated glyph metrics. The HVAR table and VVAR table provide an alternate way to
represent horizontal and vertical glyph metric variation data, and these use the
ItemVariationStore format which is specifically designed to be suitable for processing
data for particular target items.

Differences Between 'gvar' and 'cvar' Tables
The following is a summary of key differences between tuple variation stores in the
'gvar' and 'cvar' tables.
The 'gvar' table is a parent table for tuple variation stores, and contains one tuple
variation store (the glyph variation data table) for each glyph ID. In contrast, the
entire 'cvar' table is comprised of a single, slightly extended (with version fields)
tuple variation store.
Because the 'gvar' table contains multiple tuple variation stores, sharing of data
between tuple variation stores is possible, and is used for shared tuple records.
Because the 'cvar' table has a single tuple variation store, no possibility of shared
data arises.
The tupleIndex field of TupleVariationHeader structures within a tuple variation
store includes a flag that indicates whether the structure instance includes an
embedded peak tuple record. In the 'gvar' table, this is optional. In the 'cvar' table,
a peak tuple record is mandatory.
The serialized data includes packed “point” numbers. In the 'gvar' table, these refer
to glyph contour point numbers or, in the case of a composite glyph, to
component indices. In the context of the 'cvar' table, these are indices for CVT
entries.
In the 'gvar' table, point numbers cover the points or components defined in a
'glyf' entry plus four additional “phantom” points that represent the glyph’s
horizontal and vertical advance and side bearings. (See the chapter, Instructing
TrueType Glyphs for more background on phantom points.) The last four point
numbers for any glyph, including composite glyphs, are for the phantom points.
In the 'gvar' table, if deltas are not provided for some points and the point indices
are not represented in the point number data, then interpolated deltas for those
points will in some cases be inferred. This is not done in the 'cvar' table, however.
In the 'gvar' table, the serialized data for a given region has two logical deltas for
each point number: one for the X coordinate, and one for the Y coordinate. Hence
the total number of deltas is twice the count of control points. In the 'cvar' table,
however, there is only one delta for each point number.

Item Variation Store
Item variation stores are used for most variation data other than that used for TrueType
glyph outlines, including the variation data in MVAR, HVAR, VVAR, BASE, GDEF and
COLR tables.

Note: For CFF2 glyph outlines, delta values are interleaved directly within the glyph
outline description in the CFF2 table. The sets of regions which are associated with
the delta sets are defined in an item variation store, contained as a subtable within
the CFF2 table. See the CFF2 chapter for additional details.
The ItemVariationStore format organizes sets of variation data into groupings by the
target items. This makes the formats well-suited to computing interpolated instance
values for individual font data items. This is useful for certain text layout operations in
which only certain data items are required, such as the advance widths of specific glyphs
or anchor positions used in specific GPOS lookup tables.
The different tables that use item variation stores have their own top-level formats. Each
will include an offset to an ItemVariationStore table, containing the variation data. This
chapter describes the shared formats: the ItemVariationStore and its component
structures.

Associating Target Items to Variation Data
Variation data is comprised of delta adjustment values that apply to particular target
items. Some mechanism is needed to associate delta values with target items. In the
item variation store, a block of delta values has an implicit delta-set index, and separate
data outside the item variation store is provided that indicates the delta-set index
associated with a given target item. Depending on the parent table in which an item
variation store is used, different means are used to provide these associations:
In the MVAR table, an array of records identifies target data items in various other
tables, along with the delta-set index for each respective item.
In the HVAR and VVAR tables, the target data items are glyph metric arrays in the
'hmtx' and 'vmtx' tables. Mapping subtables in the HVAR and VVAR tables provide
the mapping between the target data items and delta-set indices.
In the COLR table, a mapping subtable is used, as in the HVAR and VVAR tables.
Structures that support variable items provide a starting index into the mapping
subtable, and use a slice of consecutive mapping entries.
For the BASE, GDEF, GPOS, and JSTF tables, a target data item is associated with a
delta-set index using a related VariationIndex table within the same subtable that
contains the target item.
In the COLR, HVAR and VVAR tables, DeltaSetIndexMap tables are used to provide the
mapping to delta set indices. Two formats for the DeltaSetIndexMap are defined: format
0 uses a 16-bit count field, and so is limited to 65,535 entries; format 1 uses a 32-bit
count field.

DeltaSetIndexMap format 0:
ﾉ

Expand table

Type

Name

Description

uint8

format

DeltaSetIndexMap format: set to 0.

uint8

entryFormat

A packed field that describes the compressed representation of
delta-set indices. See details below.

uint16

mapCount

The number of mapping entries.

uint8

mapData[variable]

The delta-set index mapping data. See details below.

DeltaSetIndexMap format 1:
ﾉ

Expand table

Type

Name

Description

uint8

format

DeltaSetIndexMap format: set to 1.

uint8

entryFormat

A packed field that describes the compressed representation of
delta-set indices. See details below.

uint32

mapCount

The number of mapping entries.

uint8

mapData[variable]

The delta-set index mapping data. See details below.

Note: In previous versions of this specification, only one format of the
DeltaSetIndexMap table was defined, and it began with a single, 16-bit entryFormat
field. That single 16-bit field has been subdivided into separate 8-bit format and
entryFormat fields. In the prior definition, the high-order byte of the 16-bit field was
reserved and set to zero. Thus, format 0 is backward compatible with the definition
used in previous versions.
The mapCount field indicates the number of delta-set index mapping entries. The logical
entries in the mapData array use a base-zero index. In the context in which a
DeltaSetIndexMap table is used, if an index into the mapping array is used that is
greater than or equal to mapCount, then the last logical entry of the mapping array is
used.
Each mapping entry represents a delta-set outer-level index and inner-level index
combination. Logically, each of these indices is a 16-bit, unsigned value. These are
represented in a packed format that uses one, two, three or four bytes. The entryFormat

field is a packed bitfield that describes the compressed representation used in the
mapData field of the given DeltaSetIndexMap table. The format of the entryFormat field
is as follows:
entryFormat field masks:
ﾉ

Expand table

Mask

Name

Description

0x0F

INNER_INDEX_BIT_COUNT_MASK

Mask for the low 4 bits, which give the count of bits
minus one that are used in each entry for the innerlevel index.

0x30

MAP_ENTRY_SIZE_MASK

Mask for bits that indicate the size in bytes minus one
of each entry.

0xC0

Reserved

Reserved for future use — set to 0.

The INNER_INDEX_BIT_COUNT_MASK and MAP_ENTRY_SIZE_MASK values enable the
inner index to range in size from 1 to 16 bits, and the outer index to range in size from 0
to 31 bits, with the combined size determined by the MAP_ENTRY_SIZE_MASK value. The
size of each mapping entry is:
entrySize = ((entryFormat & MAP_ENTRY_SIZE_MASK) >> 4) + 1
The mapCount value gives the number of logical entries in the map data array; the total
size of the map data array, in bytes, is:
entrySize * mapCount
For a given entry, the outer-level and inner-level indices can be obtained as follows:

outerIndex = entry >> ((entryFormat & INNER_INDEX_BIT_COUNT_MASK) + 1)
innerIndex = entry & ((1 << ((entryFormat & INNER_INDEX_BIT_COUNT_MASK) +
1)) - 1)

For larger sets of variation data, such as may be needed for COLR, HVAR or VVAR tables,
optimization of the indices data as well as the delta data may have a significant impact
on overall size. Optimizing compilers may need to consider the impact on
representation of indices in tandem as it optimizes the item variation store to achieve
the best overall results.

Variation Data
The ItemVariationStore table includes a variation region list, which defines the different
regions of the font’s variation space for which variation data is defined. It also includes a
set of item variation data subtables, each of which provides a portion of the total
variation data. Each subtable is associated with some subset of the defined regions, and
will include deltas used for one or more target items. Conceptually, the deltas form a
two-dimensional array, with delta-set rows that include a delta for each of the regions
referenced by that subtable. From this perspective, the delta-set columns correspond to
regions.
The following figure illustrates the overall structure of the ItemVariationStore table.

High-level organization of ItemVariationStore table
Note that multiple subtables are necessary only if the number of distinct delta-set data
exceeds 65,536. Multiple subtables may also be used, however, to provide more
compact data representation. There are different ways that the delta data can be made
more compact.
First, deltas with a value of zero have no impact on their target items. If there are several
delta-set rows that have a zero delta for the same region, then those rows could be
moved into a subtable that does not reference that region. As a result, there will be
fewer delta values in each row, making the size of data for those rows smaller.
Also, some delta values require 16-bit representations, but some require only 8 bits. For
a given subtable, deltas in each row correspond, in order, to the regions that are
referenced, but the ordering of regions has no effect. Hence, regions and corresponding
deltas within each row can be re-ordered. Thus, regions that require 16-bit delta
representations can be ordered together. The ItemVariationData format specifies a
count of regions (columns) for which a 16-bit delta representation is used, with the
remaining deltas in each row using 8 bits. By reordering columns, the size required for a

given delta-set row can potentially be reduced. If a set of rows have similar
requirements in regard to which columns have deltas requiring 16-bit versus 8-bit
representations, then those rows can be moved into a subtable with a column order that
allows a maximal number of deltas using 8-bit rather than 16-bit representations.
Similarly, ItemVariationData subtables can also combine delta values with 32-bit and 16bit representations. An optimizing compiler can organize deltas into different subtables
using 32-bit and 16-bit representations in some, but 16-bit and 8-bit representations in
others, with columns re-ordered in each case to provide the most efficient
representation of deltas.
Note that there is minimal overhead for each subtable: 10 bytes (6 bytes in the subtable
header and 4 bytes for the offset in the parent table) plus 2 bytes for each region that is
referenced.
A complete delta-set index involves an outer-level index into the ItemVariationData
subtable array, plus an inner-level index to a delta-set row within that subtable. A special
meaning is assigned to a delta-set index 0xFFFF/0xFFFF (that is, outer-level and innerlevel portions are both 0xFFFF): this is used to indicate that there is no variation data for
a given item. Functionally, this would be equivalent to referencing delta-set data
consisting of only deltas of 0 for all regions.

Variation Regions
As noted above, variation data is comprised of delta adjustment values that have effect
over particular regions within the font’s variation space. In a tuple variation store
(described earlier in this chapter), the deltas are organized into groupings by region of
applicability, with each grouping associated with a particular region. In contrast, the
ItemVariationStore format organizes deltas into groupings by the target items to which
they apply, with each grouping having deltas for several regions. Accordingly, the item
variation store uses different formats for describing the regions in which a set of deltas
apply.
For a given item variation store, a set of regions is specified using a VariationRegionList.
VariationRegionList:
ﾉ

Expand table

Type

Name

Description

uint16

axisCount

The number of variation axes for this font. This
must be the same number as axisCount in the

'fvar' table.
uint16

regionCount

The number of variation region tables in the
variation region list. Must be less than 32,768.

VariationRegion

variationRegions[regionCount]

Array of variation regions.

The high-order bit of the regionCount field is reserved for future use and must be
cleared.
The regions can be in any order. Each region is defined using an array of
RegionAxisCoordinates records, one for each axis defined in the 'fvar' table:
VariationRegion record:
ﾉ

Expand table

Type

Name

Description

RegionAxisCoordinates

regionAxes[axisCount]

Array of region axis coordinates records, in the
order of axes given in the 'fvar' table.

Each RegionAxisCoordinates record provides coordinate values for a region along a
single axis:
RegionAxisCoordinates record:
ﾉ

Expand table

Type

Name

Description

F2DOT14

startCoord

The region start coordinate value for the current axis.

F2DOT14

peakCoord

The region peak coordinate value for the current axis.

F2DOT14

endCoord

The region end coordinate value for the current axis.

The three values must all be within the range -1.0 to +1.0. startCoord must be less than
or equal to peakCoord, and peakCoord must be less than or equal to endCoord. The
three values must be either all non-positive or all non-negative with one possible
exception: if peakCoord is zero, then startCoord can be negative or 0 while endCoord
can be positive or zero.
Note: The following guidelines are used for setting the three values in different
scenarios:

In the case of a non-intermediate region for which the given axis should factor
into the scalar calculation for the region, either startCoord and peakCoord are
set to a negative value (typically, -1.0) and endCoord is set to zero, or
startCoord is set to zero and peakCoord and endCoord are set to a positive
value (typically +1.0).
In the case of an intermediate region for which the given axis should factor
into the scalar calculation for the region, startCoord, peakCoord and endCoord
are all set to non-positive values or are all set to non-negative values.
If the given axis should not factor into the scalar calculation for a region, then
this is achieved by setting peakCoord to zero. In this case, startCoord can be
any non-positive value, and endCoord can be any non-negative value. It is
recommended either that all three be set to zero, or that startCoord be set to
-1.0 and endCoord be set to +1.0.
The full algorithm for interpolation of instance values is given in the chapter, OpenType
Font Variations Overview. The logical algorithm involves computing per-axis scalar
values for a given region and a given instance. The per-axis scalars for a region are then
combined to yield an overall scalar for the region that is then applied to delta
adjustment values. Given a selected variation instance, a per-axis scalar can be
calculated for each RegionAxisCoordinates record. The overall scalar for a region can be
calculated by combining the per-axis scalars for that region.

Item Variation Store Header and Item Variation Data
Subtables
The item variation store table has a header with the following structure.
ItemVariationStore table:
ﾉ

Expand table

Type

Name

Description

uint16

format

Set to 1

Offset32

variationRegionListOffset

Offset in bytes from the start of
the item variation store to the
variation region list.

uint16

itemVariationDataCount

The number of item variation data
subtables.

Type

Name

Description

Offset32

itemVariationDataOffsets[itemVariationDataCount]

Offsets in bytes from the start of
the item variation store to each
item variation data subtable.

The item variation store includes an offset to a variation region list and an array of
offsets to item variation data subtables. A NULL offset in the array indicates that there is
no item variation data subtable for that index into the array.
Note: Indices into the itemVariationDataOffsets array are stored in parent tables as
delta-set “outer” indices with each such index having a corresponding “inner” index.
If the outer index points to a NULL offset, then any inner index will be invalid and
can be ignored: items associated with this index do not have any variation.
Each item variation data subtable includes deltas for some number of items, and some
subset of regions. The regions are indicated by an array of indices into the variation
region list.
ItemVariationData subtable:
ﾉ

Expand table

Type

Name

Description

uint16

itemCount

The number of delta sets for distinct items.

uint16

wordDeltaCount

A packed field: the high bit is a flag—see details
below.

uint16

regionIndexCount

The number of variation regions referenced.

uint16

regionIndexes[regionIndexCount]

Array of indices into the variation region list for the
regions referenced by this item variation data
table.

DeltaSet

deltaSets[itemCount]

Delta-set rows.

The wordDeltaCount field contains a packed value that includes a flag and a “word”
delta count. The format of this value is as follows:
ﾉ

Expand table

Mask

Name

Description

0x8000

LONG_WORDS

Flag indicating that “word” deltas are long (int32)

Mask

Name

Description

0x7FFF

WORD_DELTA_COUNT_MASK

Count of “word” deltas

The representation of delta values uses a mix of long types (“words”) and short types. If
the LONG_WORDS flag is set, deltas are represented using a mix of int32 and int16
values. If the flag is not set, deltas are presented using a mix of int16 and int8 values.
See the description of the DeltaSet record below for additional details.
The LONG_WORDS flag should only be used in top-level tables that include 32-bit
values that can be variable — currently, only the COLR table.
The count value indicated by WORD_DELTA_COUNT_MASK is a count of the number of
deltas that use the long (“word”) representation, and must be less than or equal to
regionIndexCount.
The deltaSets array represents a logical two-dimensional table of delta values with
itemCount rows and regionIndexCount columns. Rows in the table provide sets of deltas
for particular target items, and columns correspond to regions of the variation space.
Each DeltaSet record in the array represents one row of the delta-value table — one
delta set.
DeltaSet record:
ﾉ

Expand table

Type

Name

Description

int16 and int8
or
int32 and int16

deltaData​[regionIndexCount]

Variation delta values.

Logically, each DeltaSet record has regionIndexCount number of elements. The
elements are represented using long and short types, as described above. These are
either int16 and int8, or int32 and int16, according to whether the LONG_WORDS flag is
set. The delta array has a sequence of deltas using the long type followed by a sequence
of deltas using the short type. The count of deltas using the long type is derived using
WORD_DELTA_COUNT_MASK. The remaining elements use the short type. The length of
the data for each row, in bytes, is regionIndexCount + (wordDeltaCount &
WORD_DELTA_COUNT_MASK) if the LONG_WORDS flag is not set, or 2 x that amount if
the flag is set.
Note: Delta values are each represented directly. They are not packed as in the tuple
variation store.

In general, variation deltas are, logically, signed 16-bit integers, and in most cases, they
are applied to signed 16-bit values (FWORDs) or unsigned 16-bit values (UFWORDs). In
the COLR table, however, scaled deltas can be applied to F2DOT14 or Fixed items, which
are fixed-size floating types.
When applying scaled deltas to an F2DOT14 value, the F2DOT14 value is treated like a
16-bit integer. (In this sense, the delta and the F2DOT14 value can be viewed as integer
values in units of 1/16384ths.) In some contexts in which F2DOT14 is used, values may
be constrained to a certain range, such as [0, 1]. If the context constrains the valid range
for values, then any variations by applying deltas are clamped to that range.
Fixed is a 32-bit (16.16) type and, in the general case, requires 32-bit deltas. As
described above, the DeltaSet record can accommodate deltas that are, logically, either
16-bit or 32-bit. When scaled deltas are applied to Fixed values, the Fixed value is
treated like a 32-bit integer. (In this sense, the delta and the Fixed value can be viewed
as integer values in units of 1/65536ths.)

Processing Item Variation Store Data
When a particular variation instance has been selected, an application needs to process
the variation store data associated with particular target items to derive interpolated
values for those items and that instance.
To compute the interpolated instance value for a given target item, the application first
obtains the delta-set index for that item. It uses the outer-level index portion to select
an item variation data subtable within the item variation store, and the inner-level index
portion to select a delta-set row within that subtable. The delta set contains one delta
for each region referenced by the subtable, in order of the region indices given in the
regionIndices array. The application uses the regionIndices array for that subtable to
identify applicable regions and to compute a scalar for each of these regions based on
the selected instance. Each of the scalars is then applied to the corresponding delta
within the delta set to derive a scaled adjustment. The scaled adjustments for the row
are then combined to obtain the overall adjustment for the item.
Complete details on the interpolation algorithm logic are provided in the chapter,
OpenType Font Variations Overview.
For a given variation instance, an application will often need to interpolate values for
several items that may use deltas in different item variation data subtables. The
subtables will reference region definitions in the shared variation region list. When the
instance has been selected, applications can pre-compute and cache a scalar for that
instance for each region in the region list. Then when processing different target items,

the cached scalar array can be used without needing to re-compute region scalars for
each target item.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

avar — Axis Variations Table
Article • 05/31/2024

The axis variations table ('avar') is an optional table used in variable fonts. It can be used
to modify aspects of how a design varies for different instances along a particular
design-variation axis. Specifically, it allows modification of the coordinate normalization
that is used when processing variation data for a particular variation instance.
For a general overview of OpenType Font Variations and of coordinates and
normalization, see the chapter, OpenType Font Variations Overview.
The 'avar' table is used in combination with a font variations ('fvar') table and other
required or optional tables used in variable fonts.

Overview
The 'fvar' table defines a font’s axes and the numeric range for each axis supported by
the font. The numeric range for each axis is defined in terms of a “user” scale
appropriate to each axis. When processing a font’s variation data to derive glyph
outlines or other values for an instance, the instance coordinate for each axis must be
mapped from the user scale to a normalized scale. A default normalization is defined
that maps the minimum, default and maximum user values int the 'fvar' table to -1, 0,
and 1, respectively. (See Coordinate scales and normalization in the OpenType Font
Variations Overview chapter for a detailed specification.)

if (userValue < axisDefaultValue)
{
defaultNormalizedValue = -(axisDefault - userValue) / (axisDefault axisMin);
}
else if (userValue > axisDefaultValue)
{
defaultNormalizedValue = (userValue - axisDefault) / (axisMax axisDefault);
}
else
{
defaultNormalizedValue = 0;
}

If an 'avar' table is present, then the output of the default normalization can be further
modified by allowing mappings to be defined for additional positions along each scale,

creating multiple segments, with other values within each segment interpolated. The
following figure illustrates an example of such a modification—the blue line shows the
default mapping, with two segments, and the orange line shows the modified mapping,
with additional segments.

Example of 'avar'-modified normalization — horizontal axis is user scale, vertical axis is
normalized scale
The conceptual effect of these additional scale mappings is to make the variation along
an axis less linear. Values change linearly within each segment, but additional segments
make the way that values change across the entire axis range less linear overall. The
effect might also be described as compressing some portions of the scale while making
other portions less compressed.
The visual effects of additional axis-value mappings in the 'avar' table are seen in how
glyph outlines or other visual elements change as the user-scale values for an axis
change. The same amount of change in the user-scale value may correspond to a subtle
visual change in one portion of the axis range, but more dramatic changes in another
portion of the axis range.
Note that it may be possible to achieve the same or similar effects by adding variation
data for additional regions of the variation space. That approach requires more work
and more font data, however, and tedious design iteration may be needed to obtain the
desired results. The 'avar' table may provide a simple and lightweight way to achieve a
particular effect.
Note also that the variation data created by the font designer will also have a significant
effect on whether user-scale values and visual elements change uniformly. When an

'avar' table is used, the 'avar' table and the variation data are both factors in the
variation behavior that the user will see.

Table formats
The 'avar' table is comprised of a small header plus segment maps for each axis.
Axis variation table:
ﾉ

Expand table

Type

Name

Description

uint16

majorVersion

Major version number of the axis variations table
— set to 1.

uint16

minorVersion

Minor version number of the axis variations table
— set to 0.

uint16

(reserved)

Permanently reserved; set to 0.

uint16

axisCount

The number of variation axes for this font. This
must be the same number as axisCount in the
'fvar' table.

SegmentMaps

axisSegmentMaps[axisCount]

The segment maps array — one segment map
for each axis, in the order of axes specified in the
'fvar' table.

There must be one segment map for each axis defined in the 'fvar' table, and the
segment maps for the different axes must be given in the order of axes specified in the
'fvar' table. The segment map for each axis is comprised of a list of axis-value mapping
records.
SegmentMaps record:
ﾉ

Expand table

Type

Name

Description

uint16

positionMapCount

The number of correspondence pairs for
this axis.

AxisValueMap

axisValueMaps[positionMapCount]

The array of axis value map records for this
axis.

Each axis value map record provides a single axis-value mapping correspondence.

AxisValueMap record:
ﾉ

Type

Name

Description

F2DOT14

fromCoordinate

A normalized coordinate value obtained using default

Expand table

normalization.
F2DOT14

toCoordinate

The modified, normalized coordinate value.

Axis value maps can be provided for any axis but are required only if the normalization
mapping for an axis is being modified. If the segment map for a given axis has any value
maps, then it must include at least three value maps: -1 to -1, 0 to 0, and 1 to 1. These
value mappings are essential to the design of the variation mechanisms and are
required even if no additional maps are specified for a given axis. If any of these is
missing, then no modification to axis coordinate values will be made for that axis.
All of the axis value map records for a given axis must have different fromCoordinate
values, and axis value map records must be arranged in increasing order of the
fromCoordinate value. If the fromCoordinate value of a record is less than or equal to
the fromCoordinate value of a previous record in the array, then the given record may
be ignored.
Also, for any given record except the first, the toCoordinate value must be greater than
or equal to the toCoordinate value of the preceding record. This requirement ensures
that there are no retrograde behaviors as the user-scale value range is traversed. If a
toCoordinate value of a record is less than that of the previous record, then the given
record may be ignored.

Processing
The complete axis coordinate normalization process, with or without an 'avar' table is
described in the OpenType Font Variations Overview chapter. The process begins with a
default normalization computation. Then if an 'avar' table is present, the normalized
value is modified using data in this table.
Each pair of consecutive AxisValueMap records for a given axis defines a segment within
the range for that axis, and a mapping from default normalized values for start and end
points of the given segment to the final normalized values. Within a segment,
intermediate values are interpolated linearly. For complete details of the normalization
process, as well as an example using 'avar' data, see Coordinate scales and
normalization.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

BASE — Baseline Table
Article • 07/06/2024

Overview
The Baseline table (BASE) provides information used to align glyphs of different scripts
and sizes in a line of text, whether the glyphs are in the same font or in different fonts.
To improve text layout, the Baseline table also provides minimum (min) and maximum
(max) glyph extent values for each script, language system, or feature in a font.
Lines of text composed with glyphs of different scripts and point sizes need adjustment
to correct interline spacing and alignment. For example, glyphs designed to be the same
point size often differ in height and depth from one font to another (see figure 5a). This
variation can produce interline spacing that looks too large or too small, and diacritical
marks, math symbols, subscripts, and superscripts may be clipped.

Figure 5a. Incorrect alignment of glyphs from Latin and Kanji (Latin dominant)
In addition, different baselines can cause text lines to waver visually as glyphs from
different scripts are placed next to one another. For example, ideographic scripts
position all glyphs on a low baseline. With Latin scripts, however, the baseline is higher,
and some glyphs descend below it. Finally, several Indic scripts use a high “hanging
baseline” to align the tops of the glyphs.
To solve these composition problems, the BASE table recommends baseline positions
and min/max extents for each script (see figure 5b). Script min/max extents can be
modified for particular language systems or features.

Figure 5b. Proper alignment of glyphs from Latin and Kanji (Latin dominant)

Baseline values
The BASE table uses a model that assumes one script at one size is the “dominant run”
during text processing—that is, all other baselines are defined in relation to this the
dominant run.
For example, Latin glyphs and the ideographic Kanji glyphs have different baselines. If a
Latin script of a particular size is specified as the dominant run, then all Latin glyphs of

all sizes will be aligned on the roman baseline, and all Kanji glyphs will be aligned on the
lower ideographic baseline defined for use with Latin text. As a result, all glyphs will look
aligned within each line of text.
The BASE table supplies recommended baseline positions; a client can specify others.
For instance, the client may want to assign baseline positions different from those in the
font.

Figure 5c. Comparing Latin and Kanji baselines, with characters aligned according to the
dominant run
Within the BASE table, different baseline types are identified using baseline tags,
described in the OpenType Layout tag registry. Positioning for each baseline type is
specified on a script-by-script basis; the baseline coordinate values to be used are those
for the script of the dominant run.

Min/max extent values
The BASE table gives clients the option of using script, language system, or featurespecific extent values to improve composition (see figure 5c). For example, suppose a
font contains glyphs in Latin and Arabic scripts, and the min/max extents defined for the
Arabic script are larger than the Latin extents. The font also supports Urdu, a language
system that includes specific variants of the Arabic glyphs, and some Urdu variants
require larger min/max extents than the default Arabic extents. To accommodate the
Urdu glyphs, the BASE table can define language-specific min/max extent values that
will override the default Arabic extents-but only when rendering Urdu glyphs.
The BASE table also can define feature-specific min/max values that apply only when a
particular feature is enabled. Suppose that the font described earlier also supports the
Farsi language system, which has one feature that requires a minor alteration of the
Arabic script extents to display properly. The BASE table can specify these extent values
and apply them only when that feature is enabled in the Farsi language.

BASE table and OpenType Font Variations
OpenType Font Variations allow a single font to support many design variations along
one or more axes of design variation. For example, a font with weight and width
variations might support weights from thin to black, and widths from ultra-condensed
to ultra-expanded. For general information on OpenType Font Variations, see the
chapter OpenType Font Variations Overview.
When different variation instances are selected, the design of individual glyphs changes,
and the metric characteristics of the font as a whole may also change. As a result,
corresponding changes may also be required for metric values in the BASE table.
Metrics in the BASE table are expressed directly in BaseCoord tables using explicit X or Y
font-unit values. In a variable font, these X and Y values apply to the default instance
and may need to be adjusted for the current variation instance. This is done using
variation data with processes similar to those used for glyph outlines and other font
data, as described in the OpenType Font Variations Overview chapter.
Note: Some BASE metrics can be expressed indirectly by reference to specific glyph
outline points. In a variable font, use of glyph points to specify a metric value would
require invoking the rasterizer to process the glyph-outline variation data in order to
obtain the adjusted position of the point before the BASE metric value can be used.
This may have a significant, negative impact on performance of text-layout
processing. For this reason, it is recommended that, in a variable font, any BASE
metric values that require adjustment for different variation instances should always
be expressed directly as X and Y values.
Variation data for adjustment of BASE values is stored within an ItemVariationStore table
within the BASE table. The item variation store and constituent formats are described in
the chapter, OpenType Font Variations Common Table Formats. The item variation store
is also used in the GDEF table, as well as in the MVAR and other tables, but is different
from the formats for variation data used in the 'cvar' or 'gvar' tables.
The variation data within an item variation store is comprised of a number of adjustment
deltas that get applied to the default values of target items for variation instances within
particular regions of the font’s variation space. The ItemVariationStore format use deltaset indices to reference variation delta data for particular target, font-data items to which
they are applied. Data external to the item variation store identifies the delta-set index
to be used for each given target item. Within the BASE table, these indices are specified
within VariationIndex tables, with one VariationIndex table referenced for each item that
requires variation adjustment.

Note that the VariationIndex table is a variant of a Device table, with a distinct format
value. (For full details on the Device and VariationIndex table formats, see the OpenType
Layout Common Table Formats chapter.) This is done so that the default instance of a
variable font can be compatible with applications that do not support Font Variations. As
a result, variable fonts cannot use device tables. A VariationIndex table will be ignored in
applications that do not support Font Variations, or if the font is not a variable font.
The ItemVariationStore format uses a two-level organization for variation data: a store
can have multiple ItemVariationData subtables, and each subtable has multiple delta-set
rows. A delta-set index is a two-part index: an outer index that selects a particular item
variation data subtable, and an inner index that selects a particular delta-set row within
that subtable. A VariationIndex table specifies both the outer and inner portions of the
delta-set index.

BASE table organization
The BASE table begins with offsets to Axis tables that describe layout data for the
horizontal and vertical layout directions of text. A font can provide layout data for both
text directions or for only one text direction:
The horizontal Axis table (“HorizAxis”) defines information used to lay out text
horizontally. All baseline and min/max values refer to the Y direction.
The vertical Axis table (“VertAxis”) defines information used to lay out text
vertically. All baseline and min/max values refer to the X direction.
In a variable font, the offsets to axis tables may be followed by an offset to an
ItemVariationStore table, which is used to provide variation data for adjustment of BASE
metric values for different variation instances within the font’s variation space.
Figure 5d shows how the BASE table is organized.

Figure 5d. High-level organization of BASE table

Text direction
The HorizAxis and VertAxis tables organize layout information by script in BaseScriptList
tables. A BaseScriptList enumerates all scripts in the font that are written in a particular
direction (horizontal or vertical).
For example, consider a Japanese font that contains Kanji, Kana, and Latin scripts.
Because all three scripts are rendered horizontally, all three are defined in the
BaseScriptList of the HorizAxis table. Kanji and Kana also are rendered vertically, so
those two scripts are defined in the BaseScriptList of the VertAxis table, too.
The same baseline tags may be used for both horizontal and vertical axes. For example,
the 'romn' tag description used for the vertical axis would indicate the baseline of
rotated Latin text.

Baseline data
Each Axis table also references a BaseTagList, which identifies all the baselines for all
scripts written in the same direction (horizontal or vertical). The BaseTagList may also
include baseline tags for scripts supported in other fonts.
Each script in a BaseScriptList is represented by a BaseScriptRecord. This record
references a BaseScript table, which contains layout data for the script. In turn, the
BaseScript table references a BaseValues table, which contains baseline information, and
several MinMax tables that define min/max extent values.

The BaseValues table specifies the coordinate values for all baselines in the BaseTagList.
In addition, it identifies one of these baselines as the default baseline for the script. As
glyphs in a script are scaled, they grow or shrink from the script’s default baseline
position. Each baseline can have unique coordinates. This contrasts with TrueType 1.0,
which implies a single, fixed baseline for all scripts in a font. With the OpenType™ Layout
tables, each script can be aligned independently, although more than one script may
use the same baseline values.
Baseline coordinates for scripts in the same font must be specified in relation to each
other for correct alignment of the glyphs. Consider the font, discussed earlier,
containing both Latin and Kanji glyphs. If the BaseTagList of the HorizAxis table specifies
two baselines, the roman and the ideographic, then the layout data for both the Latin
and Kanji scripts will specify coordinate positions for both baselines:
The BaseValues table for the Latin script will give coordinates for both baselines
and specify the roman baseline as the default.
The BaseValues table for the Kanji script will give coordinates for both baselines
and specify the ideographic baseline as the default.

Min/max extents
The BaseScript table can define minimum and maximum extent values for each script,
language system, or feature. These values are distinct from the min/max extent values
recorded for the font as a whole in the 'head', 'hhea', 'vhea', and OS/2 tables. These
extent values appear in three tables:
A default MinMax table defines the default min/max extents for the script.
A script- and language-specific MinMax table, referenced through a BaseLangSys
record, which specifies min/max extents to accommodate the glyphs in a specific
language system.
A FeatMinMax record, within a MinMax table, provides min/max extent values to
support feature-specific glyph actions.
Note: Language-system or feature-specific extent values could be essential to define
some fonts. However, the default min/max extent values specified for each script
should usually be enough to support high-quality text layout.
The actual baseline and min/max extent values used by the BASE table reside in
BaseCoord tables. Three formats are defined for BaseCoord table data. All formats
define single X or Y coordinate values in design units, but two formats support fine
adjustments to these values based on a contour point or a Device table.

The rest of this chapter describes all the tables defined within the BASE table. Sample
tables and lists that illustrate typical data for a font are supplied at the end of the
chapter.

BASE table structures
BASE Header
The BASE table begins with a header that starts with a version number. Two versions are
defined. Version 1.0 contains offsets to horizontal and vertical Axis tables (HorizAxis and
VertAxis). Version 1.1 also includes an offset to an ItemVariationStore table.
Each Axis table stores all baseline information and min/max extents for one layout
direction. The HorizAxis table contains Y values for horizontal text layout; the VertAxis
table contains X values for vertical text layout.
A font may supply information for both layout directions. If a font has values for only
one text direction, the Axis table offset value for the other direction will be set to NULL.
The optional ItemVariationStore table is used in variable fonts to provide variation data
for BASE metric values within the Axis tables.
Example 1 at the end of this chapter shows a sample BASE Header.
BASE Header, version 1.0
ﾉ

Expand table

Type

Name

Description

uint16

majorVersion

Major version of the BASE table, = 1.

uint16

minorVersion

Minor version of the BASE table, = 0<./td>

Offset16

horizAxisOffset

Offset to horizontal Axis table, from beginning of BASE table (may be
NULL).

Offset16

vertAxisOffset

Offset to vertical Axis table, from beginning of BASE table (may be
NULL).

BASE Header, version 1.1
ﾉ

Expand table

Type

Name

Description

uint16

majorVersion

Major version of the BASE table, = 1.

uint16

minorVersion

Minor version of the BASE table, = 1.

Offset16

horizAxisOffset

Offset to horizontal Axis table, from beginning of BASE table
(may be NULL).

Offset16

vertAxisOffset

Offset to vertical Axis table, from beginning of BASE table (may
be NULL).

Offset32

itemVarStoreOffset

Offset to ItemVariationStore table, from beginning of BASE table
(may be null).

Axis table
An Axis table is used to render scripts either horizontally or vertically. It consists of
offsets, measured from the beginning of the Axis table, to a BaseTagList and a
BaseScriptList:
The BaseScriptList enumerates all scripts rendered in the text layout direction.
The BaseTagList enumerates all baselines used to render the scripts in the text
layout direction. If no baseline data is available for a text direction, the offset to the
corresponding BaseTagList may be set to NULL.
Example 1 at the end of this chapter shows an example of an Axis table.
Axis table
ﾉ

Expand table

Type

Name

Description

Offset16

baseTagListOffset

Offset to BaseTagList table, from beginning of Axis table (may be
NULL).

Offset16

baseScriptListOffset

Offset to BaseScriptList table, from beginning of Axis table.

BaseTagList table
The BaseTagList table identifies the baselines for all scripts in the font that are rendered
in the same text direction. Each baseline is identified with a 4-byte baseline tag. The
Baseline Tags section of the OpenType Layout Tag Registry lists currently registered

baseline tags. The BaseTagList can define any number of baselines, and it may include
baseline tags for scripts supported in other fonts.
Each script in the BaseScriptList table must designate one of these BaseTagList baselines
as its default, which a layout engine uses to align all glyphs in the script. Even though
the BaseScriptList and the BaseTagList are defined independently of one another, the
BaseTagList typically includes a tag for each different default baseline needed to render
the scripts in the layout direction. If some scripts use the same default baseline, the
BaseTagList needs to list the common baseline tag only once.
The BaseTagList table consists of an array of baseline identification tags (baselineTags),
listed alphabetically, and a count of the total number of baseline Tags in the array
(baseTagCount).
Example 1 at the end of this chapter shows a sample BaseTagList table.
BaseTagList table
ﾉ

Expand table

Type

Name

Description

uint16

baseTagCount

Number of baseline identification tags in this text
direction — may be zero (0).

Tag

baselineTags[baseTagCount]

Array of 4-byte baseline identification tags — must be in
alphabetical order.

BaseScriptList table
The BaseScriptList table identifies all scripts in the font that are rendered in the same
layout direction. If a script is not listed here, then the text-processing client will render
the script using the layout information specified for the entire font.
For each script listed in the BaseScriptList table, a BaseScriptRecord must be defined that
identifies the script and references its layout data. BaseScriptRecords are stored in the
baseScriptRecords array, ordered alphabetically by the baseScriptTag in each record. The
baseScriptCount specifies the total number of BaseScriptRecords in the array.
Example 1 at the end of this chapter shows a sample BaseScriptList table.
BaseScriptList table
ﾉ

Expand table

Type

Name

Description

uint16

baseScriptCount

Number of BaseScriptRecords defined.

BaseScriptRecord

baseScriptRecords[baseScriptCount]

Array of BaseScriptRecords, in
alphabetical order by baseScriptTag.

A BaseScriptRecord contains a script identification tag (baseScriptTag), which must be
identical to the ScriptTag used to define the script in the ScriptList of a GSUB or GPOS
table. Each record also must include an offset to a BaseScript table that defines the
baseline and min/max extent data for the script.
Example 1 at the end of this chapter shows a sample BaseScriptRecord.
BaseScriptRecord
ﾉ

Expand table

Type

Name

Description

Tag

baseScriptTag

4-byte script identification tag.

Offset16

baseScriptOffset

Offset to BaseScript table, from beginning of BaseScriptList.

BaseScript table
A BaseScript table organizes and specifies the baseline data and min/max extent data
for one script. Within a BaseScript table, the BaseValues table contains baseline
information, and one or more MinMax tables contain min/max extent data.
The BaseValues table identifies the default baseline for the script and lists coordinate
positions for each baseline named in the corresponding BaseTagList. Each script can
assign a different position to each baseline, so each script can be aligned independently
in relation to any other script. (For more details, see the BaseValues table description
later in this chapter.)
The default MinMax table defines the default min/max extent values for the script. (For
details, see the MinMax table description below.) If no language system or feature
defined for the script has an effect on the script’s default min/max extents, the layout
engine uses the default min/max values for the script.
Sometimes language-specific overrides for min/max extents are needed to properly
render the glyphs in a specific language system. For example, a glyph substitution
required in a language system can result in a glyph whose extents exceed the script’s

default min/max extents. For each language system requiring different min/max extent
values, a BaseLangSys record is required. The record should identify the language
system (baseLangSysTag) and contain an offset to a MinMax table of language-specific
extent coordinates.
Feature-specific overrides for min/max extents also could be needed to accommodate
the effects of glyph actions used to implement a specific feature. For example,
superscript or subscript features may require changes to the default script or language
system extents. Feature-specific extent values not limited to a specific language system
may be specified in the default MinMax table. However, extent values used for a specific
language system require a BaseLangSys record and a MinMax table. In addition to
specifying coordinate data, the MinMax table may contain one or more FeatMinMax
records that define the feature-specific min/max data.
A BaseScript table has four components:
An offset to a BaseValues table (baseValuesOffset). If no baseline data is defined
for the script or the corresponding BaseTagList is set to NULL, the offset to the
BaseValues table may be set to NULL.
An offset to the default MinMax table. If no default min/max extent data is defined
for the script, this offset may be set to NULL.
An array of BaseLangSys records (baseLangSysRecords). The individual records
stored in the BaseLangSys record array are listed alphabetically by baseLangSysTag.
A count of the BaseLangSys records is included (baseLangSysCount). If no
language system or language-specific feature min/max values are defined, the
baseLangSysCount may be set to zero (0).
Example 2 at the end of this chapter shows a sample BaseScript table.
BaseScript table
ﾉ

Expand table

Type

Name

Description

Offset16

baseValuesOffset

Offset to BaseValues table, from
beginning of BaseScript table (may be
NULL).

Offset16

defaultMinMaxOffset

Offset to MinMax table, from
beginning of BaseScript table (may be
NULL).

uint16

baseLangSysCount

Number of BaseLangSys records
defined — may be zero (0).

BaseLangSys

baseLangSysRecords[baseLangSysCount]

Array of BaseLangSys records, in
alphabetical order by BaseLangSysTag.

A BaseLangSys record defines min/max extents for a language system or a languagespecific feature. Each record contains an identification tag for the language system
(baseLangSysTag) and an offset to a MinMax table (MinMax) that defines extent
coordinate values for the language system and references feature-specific extent data.
Example 2 at the end of this chapter shows a BaseLangSys record.
BaseLangSys record
ﾉ

Expand table

Type

Name

Description

Tag

baseLangSysTag

4-byte language system identification tag.

Offset16

minMaxOffset

Offset to MinMax table, from beginning of BaseScript table.

BaseValues table
For each script, a BaseValues table lists the coordinate positions of all baselines named
in the baselineTags array of the corresponding BaseTagList and identifies a default
baseline for that script.
When the offset to the corresponding BaseTagList is NULL, a BaseValues table is not
needed. However, if the offset is not NULL, then each script must specify coordinate
positions for all baselines named in the BaseTagList.
The default baseline of a script is the baseline used to lay out and align the glyphs for
that script. The defaultBaselineIndex field in the BaseValues table identifies the default
baseline for a script using an index into the baselineTags array of the BaseTagList table
for the given text direction.
For example, the Han and Latin scripts use different baselines to align text. If a font
supports both of these scripts, the baselineTags array in the BaseTagList of the HorizAxis
table will contain two tags, listed alphabetically: 'ideo' in baselineTags[0] for the Han
ideographic baseline, and 'romn' in baselineTags[1] for the Latin baseline. The
BaseValues table for the Latin script will specify the roman baseline as the default, so the
defaultBaselineIndex in the BaseValues table for Latin will be “1” to indicate the roman
baseline tag. In the BaseValues table for the Han script, the defaultBaselineIndex will be
“0” to indicate the ideographic baseline tag.

Two or more scripts may share a default baseline. For instance, if the font described
above also supports the Cyrillic script, the baselineTags array does not need a distinct
baseline tag for Cyrillic because Cyrillic and Latin share the same baseline. The
defaultBaselineIndex defined in the BaseValues table for the Cyrillic script will specify “1”
to indicate the roman baseline tag, listed in the second position in the baselineTags
array.
In addition to identifying the default baseline, the BaseValues table contains offsets to
BaseCoord tables that list the coordinate positions for all baselines, including the default
baseline, named in the associated baselineTags array. One BaseCoord table is defined
for each baseline. The baseCoordCount field defines the total number of BaseCoord
tables, which must equal the number of baseline tags in the BaseTagList table.
Each baseline coordinate is defined as a single X or Y value in design units measured
from the zero position on the relevant X or Y axis. For example, a BaseCoord table
defined in the HorizAxis table will contain a Y value because horizontal baselines are
positioned vertically. BaseCoord values may be negative. Each script may assign a
different coordinate to each baseline.
Offsets to each BaseCoord table are stored in the baseCoordOffsets array within the
BaseValues table. The order of the stored offsets corresponds to the order of the tags
listed in the baselineTags array of the BaseTagList. In other words, the first entry in the
baseCoordOffsets array will define the offset to the BaseCoord table for the first
baseline named in the baselineTags array, the second position will define the offset to
the BaseCoord table for the second baseline named in the baselineTags array, and so on.
Example 3 at the end of the chapter has two parts, one that shows a BaseValues table
and one that shows a chart with different baseline positions defined for several scripts.
BaseValues table
ﾉ

Expand table

Type

Name

Description

uint16

defaultBaselineIndex

Index number of default baseline for this script
— equals index position of baseline tag in
baselineTags array of the BaseTagList.

uint16

baseCoordCount

Number of BaseCoord tables defined — should
equal baseTagCount in the BaseTagList.

Offset16

baseCoordOffsets[baseCoordCount]

Array of offsets to BaseCoord tables, from
beginning of BaseValues table — order matches
baselineTags array in the BaseTagList.

The MinMax table and FeatMinMax record
The MinMax table specifies extents for scripts and language systems. It also contains an
array of FeatMinMax records used to define feature-specific extents.
Both the MinMax table and the FeatMinMax record define offsets to two BaseCoord
tables: one that defines the mimimum extent value (minCoord), and one that defines the
maximum extent value (maxCoord). Each extent value is a single X or Y value, depending
upon the text direction, and is specified in design units. Coordinate values may be
negative.
Different tables define the min/max extent values for scripts, language systems, and
features:
Min/max extent values for a script are defined in the default MinMax table
referenced in a BaseScript table.
Within the default MinMax table, FeatMinMax records can specify extent values for
features that apply to the entire script.
Min/max extent values for a language system are defined in the MinMax table
referenced in a BaseLangSys record.
FeatMinMax records can be defined within the MinMax table for a language
system to specify extent values for features applied within that language system.
The FeatMinMax record contains a tag indicating a feature from the GSUB or GPOS
table it relates to. Each feature that exceeds the default min/max values should have a
FeatMinMax record. All FeatMinMax records are listed alphabetically by feature tag in an
array (featMinMaxRecords) within the MinMax table. The featMinMaxCount field defines
the total number of FeatMinMax records.
Text-processing clients should use the following procedure to access the script,
language system, and feature-specific extent data:
1. Determine script extents in relation to the text content.
2. Select language-specific extent values with respect to the language system in use.
3. Have the application or user choose feature-specific extent values.
4. If no extent values are defined for a language system or for language-specific
features, use the default min/max extent values for the script.
Example 4 at the end of this chapter has two parts. One shows MinMax tables and a
FeatMinMax record for different script, language system, and feature extents. The
second part shows how to define these tables when a language system needs featurespecific extent values for an obscure feature, but otherwise the language system and
script extent values match.

MinMax table
ﾉ

Expand table

Type

Name

Description

Offset16

minCoordOffset

Offset to BaseCoord table that defines
the minimum extent value, from the
beginning of MinMax table (may be
NULL).

Offset16

maxCoordOffset

Offset to BaseCoord table that defines
maximum extent value, from the
beginning of MinMax table (may be
NULL).

uint16

featMinMaxCount

Number of FeatMinMaxRecords — may
be zero (0).

FeatMinMax

featMinMaxRecords[featMinMaxCount]

Array of FeatMinMax records, in
alphabetical order by featureTag.

FeatMinMax record
ﾉ

Expand table

Type

Name

Description

Tag

featureTag

4-byte feature identification tag — must match feature tag in
FeatureList.

Offset16

minCoordOffset

Offset to BaseCoord table that defines the minimum extent value,
from beginning of MinMax table (may be NULL).

Offset16

maxCoordOffset

Offset to BaseCoord table that defines the maximum extent value,
from beginning of MinMax table (may be NULL).

BaseCoord tables
Within the BASE table, a BaseCoord table is used to specify a baseline, a min extent or a
max extent. Each BaseCoord table defines one X or Y value:
If defined within the HorizAxis table, then the BaseCoord table contains a Y value.
If defined within the VertAxis table, then the BaseCoord table contains an X value.
All values are defined in design units, which typically are scaled and rounded to the
nearest integer when scaling the glyphs. Values may be negative.

Three formats available for BaseCoord table data define single X or Y coordinate values
in design units. Two of the formats also support fine adjustments to the X or Y values
based on a contour point or a Device table. In a variable font, the third format uses a
VariationIndex table (a variant of a Device table), as needed, to reference variation data
for adjustment of the X or Y values for the current variation instance.

BaseCoord format 1
The first BaseCoord format (BaseCoordFormat1) consists of a format identifier, followed
by a single design unit coordinate that specifies the BaseCoord value. This format has
the benefits of small size and simplicity, but the BaseCoord value cannot be hinted for
fine adjustments at different sizes or device resolutions.
Example 5 at the end of the chapter shows a sample of a BaseCoordFormat1 table.
BaseCoordFormat1 table: Design units only
ﾉ

Type

Name

Description

uint16

format

Format identifier — format = 1.

int16

coordinate

X or Y value, in design units.

Expand table

BaseCoord format 2
The second BaseCoord format (BaseCoordFormat2) specifies the BaseCoord value in
design units, but also supplies a glyph index and a contour point for reference. During
font hinting, the contour point on the glyph outline may move. The point’s final position
after hinting provides the final value for rendering a given font size.
Note: Glyph positioning operations defined in the GPOS table do not affect the
point’s final position.
Example 6 shows a sample of a BaseCoordFormat2 table.
BaseCoordFormat2 table: Design units plus contour point
ﾉ

Type

Name

Description

Expand table

uint16

format

Format identifier — format = 2.

int16

coordinate

X or Y value, in design units.

uint16

referenceGlyph

Glyph ID of control glyph.

uint16

baseCoordPoint

Index of contour point on the reference glyph.

BaseCoord format 3
The third BaseCoord format (BaseCoordFormat3) also specifies the BaseCoord value in
design units, but, in a non-variable font, it uses a Device table rather than a contour
point to adjust the value. This format offers the advantage of fine-tuning the BaseCoord
value for any font size and device resolution. (For more information about Device tables,
see the chapter, Common Table Formats.)
In a variable font, BaseCoordFormat3 must be used to reference variation data to adjust
the X or Y value for different variation instances, if needed. In this case,
BaseCoordFormat3 specifies an offset to a VariationIndex table, which is a variant of the
Device table that is used for referencing variation data.
Note: While separate VariationIndex table references are required for each
Coordinate value that requires variation, two or more values that require the same
variation-data values can have offsets that point to the same VariationIndex table,
and two or more VariationIndex tables can reference the same variation data entries.
Note: If no VariationIndex table is used for a particular X or Y value (the offset is
zero, or a different BaseCoord format is used), then that value is used for all
variation instances.
Example 7 at the end of this chapter shows a sample of a BaseCoordFormat3 table.
BaseCoordFormat3 table: Design units plus Device or VariationIndex table
ﾉ

Expand table

Type

Name

Description

uint16

format

Format identifier — format = 3.

int16

coordinate

X or Y value, in design units.

Offset16

deviceOffset

Offset to Device table (non-variable font) / Variation Index table
(variable font) for X or Y value, from beginning of BaseCoord table (may

be NULL).

ItemVariationStore table
The format and processing of the ItemVariationStore table and its constituent formats is
described in the chapter, OpenType Font Variations Common Table Formats.
Specification of the interpolation algorithm used to derive values for particular variation
instances is given in the chapter, OpenType Font Variations Overview.
The ItemVariationStore contains adjustment-delta values arranged in one or more sets
of deltas that are referenced using delta-set indices. For values that require variation
adjustment, a delta-set index is used to reference the particular variation data needed
for that target value. Within the BASE table, delta-set indices are provided in
VariationIndex tables contained within a BaseCoordFormat3 table. For a description of
the VariationIndex table, see the OpenType Layout Common Table Formats chapter. For
details on use of VariationIndex tables within BaseCoord tables, see discussion earlier in
this chapter.

BASE table examples
The rest of this chapter describes and illustrates examples of all the BASE tables. All the
examples reflect unique parameters described below, but the samples provide a useful
reference for building tables specific to other situations.
Most of the examples have three columns showing hex data, source, and comments.

Example 1: BASE Header, Axis, BaseTagList and
BaseScriptList tables, and BaseScriptRecord
Example 1 describes a sample font that contains four scripts: Cyrillic, Devanagari, Han,
and Latin. All four scripts are rendered horizontally; only one script, Han, is rendered
vertically. As a result, the BASE header gives offsets to two Axis tables: HorizAxis and
VertAxis. Example 1 only shows data defined in the HorizAxis table.
In the HorizAxis table, the BaseScriptList enumerates all four scripts. The BaseTagList
table names three horizontal baselines for rendering these scripts: hanging, ideographic,
and roman. The hanging baseline is the default for Devanagari, the ideographic baseline
is the default for Han, and the roman baseline is the default for both Latin and Cyrillic.
The VertAxis table (not shown) would be defined similarly: its BaseScriptList would
enumerate one script, Han, and its BaseTagList would specify the vertically centered

baseline for rendering the Han script.
Example 1
ﾉ

Hex Data

Source

Comments

BASEHeader

BASE table header definition

Expand table

TheBASEHeader
00010000

0x00010000

Version

0008

HorizontalAxisTable

Offset to HorizAxis table

010C

VerticalAxisTable

Offset to VertAxis table

Axis
HorizontalAxisTable

Axis table definition

0004

HorizBaseTagList

Offset to BaseTagList table

0012

HorizBaseScriptList

Offset to BaseScriptList table

BaseTagList

BaseTagList table definition

HorizBaseTagList
0003

3

baseTagCount

68616E67

'hang'

baselineTags[0], in alphabetical order

6964656F

'ideo'

baselineTags[1]

726F6D6E

'romn'

baselineTags[2]

BaseScriptList

BaseScriptList table definition

HorizBaseScriptList
0004

4

baseScriptCount

baseScriptRecords[0]

Records in alphabetical order by baseScriptTag

6379726C

'cyrl'

baseScriptTag: Cyrillic script

001A

HorizCyrillicBaseScriptTable

Offset to BaseScript table for Cyrillic script

baseScriptRecords[1]
6465766E

'devn'

baseScriptTag: Devanagari script

0060

HorizDevanagariBaseScriptTable

Offset to BaseScript table for Devanagari script

baseScriptRecords[2]
68616E69

'hani'

baseScriptTag: Han script

008A

HorizHanBaseScriptTable

Offset to BaseScript table for Han script

baseScriptRecords[3]
6C61746E

'latn'

baseScriptTag: Latin script

00B4

HorizLatinBaseScriptTable

Offset to BaseScript table for Latin script

Example 2: BaseScript table and BaseLangSys record
Example 2 shows the BaseScript table and BaseLangSys record for the Cyrillic script, one
of the four scripts included in the sample font described in Example 1. The BaseScript
table specifies offsets to tables that contain the baseline and min/max extent data for
Cyrillic. (The BaseScript tables for the other three scripts in the font would be defined
similarly.) Again, the table specifies only the horizontal text-layout information.
The HorizCyrillicBaseValues table contains the baseline information for the script, and
the HorizCyrillicDefaultMinMax table contains the default script extents. In addition, a
BaseLangSys record defines min/max extent data for the Russian language system.
Example 2
ﾉ

Hex

Expand table

Source

Comments

BaseScript

BaseScript table definition for Cyrillic script

Data

HorizCyrillicBaseScriptTable
000C

HorizCyrillicBaseValuesTable

Offset to BaseValues table

0022

HorizCyrillicDefault
MinMaxTable

Offset to default MinMax table — default script extents

0001

1

baseLangSysCount — BaseLangSys records for
language-specific extents

baseLangSysRecords[0]

Records in alphabetical order by baseLangSysTag.

52555320

“RUS ”

BaseLangSysTag, Russian language system

0030

HorizRussianMinMaxTable

Offset to MinMax table — language-specific extents

Example 3: BaseValues table
Example 3 extends the BASE table definition for the Cyrillic script described in Examples
1 and 2. It contains two parts:
Example 3A illustrates a fully defined BaseValues table for Cyrillic. The table
includes the corresponding BaseCoord table definitions.
Example 3B shows two different sets of baseline values that can be defined for
each of the four scripts in the sample font.
The examples show only horizontal text-layout data, and the font uses 2,048 design
units/em.

Example 3A: BaseValues table for Cyrillic
The BaseValues table of Example 3A identifies the default baseline for Cyrillic and
specifies coordinate positions for each baseline listed in the BaseTagList shown in
Example 1:
The hanging baseline is the default for the Devanagari script, and it has the highest
baseline position.
The ideographic baseline is the default for the Han script, and it has the lowest
baseline position.
The roman baseline is the default for both the Latin and Cyrillic scripts, and its
position lies between the hanging and ideographic baselines.
Example 3A
ﾉ

Hex

Expand table

Source

Comments

BaseValues

BaseValues table definition for Cyrillic script

Data

HorizCyrillicBaseValuesTable
0002

2

defaultBaselineIndex: BaseTagList index for roman
baseline

0003

3

baseCoordCount, equals baseTagCount

000A

HorizHangingBaseCoordForCyrl

baseCoordOffsets[0]: offset to BaseCoord table for
hanging baseline coordinate — order matches
order of baselineTags array in BaseTagList

000E

HorizIdeographicBaseCoordForCyrl

baseCoordOffsets[1]: offset to BaseCoord table for
ideographic baseline coordinate

0012

HorizRomanBaseCoordForCyrl

baseCoordOffsets[2]: offset to BaseCoord table for
roman baseline coordinate

BaseCoordFormat1
HorizHangingBaseCoordForCyrl

BaseCoord table definition

0001

1

format: design units only

05DC

1500

coordinate — Y value, in design units

BaseCoordFormat1
HorizIdeographicBaseCoordForCyrl

BaseCoord table definition

0001

1

format: design units only

FEE0

-288

coordinate — Y value, in design units

BaseCoordFormat1

BaseCoord table definition

HorizRomanBaseCoordinateForCyrl
0001

1

format: design units only

0000

0

coordinate — Y value, in design units

Example 3B: Baseline values for four scripts
Example 3B shows two tables that contain baseline values for each of the four scripts in
the sample font described in Example 1:
The first table shows what might happen if the baseline values in all four scripts are
designed consistently. Their respective BaseValues tables list identical baseline
values with the roman baseline positioned at a Y value of zero (0), the ideographic
baseline at -288, and the hanging baseline at 1500.
The second table shows what might happen if the baseline values in the scripts are
designed differently with the default baseline for each script at the zero (0)
coordinate.
Either method of assigning baseline values can be used in the BASE table.
Example 3B: Identical baseline values
ﾉ

Baseline type

Han

Latin

Cyrillic

Expand table

Devanagari

hanging

1500

1500

1500

1500

roman

0

0

0

0

ideographic

-288

-288

-288

-288

Example 3B: Assigned baseline values with default baselines at 0
ﾉ

Expand table

Baseline type

Han

Latin

Cyrillic

Devanagari

hanging

1788

1500

1500

0

roman

288

0

0

-1500

ideographic

0

-288

-288

-1788

Example 4: MinMax table and FeatMinMax record
Example 4 shows MinMax table and FeatMinMax record definitions for the same Cyrillic
script described in the previous example. It contains two parts:
Example 4A defines tables with different script, language system, and feature
extents.
Example 4B shows these same table definitions written when the language system
extents match the script extents, but an obscure feature of the language system
requires feature-specific extents if that feature is implemented.
The examples show only horizontal text-layout data, and the font uses 2,048 design
units/em.

Example 4A: Min/Max extents for Cyrillic script, Russian language,
and Russian language feature
Example 4A shows two MinMax tables and a FeatMinMax record for the Cyrillic script,
along with sample BaseCoord tables. Only the minCoord extent data is included.
The default MinMax table defines the default minimum and maximum extents for the
Cyrillic script. Another MinMax table defines language-specific min/max extents for the
Russian language system to accommodate the height and width of certain glyphs used
in Russian. Also, a FeatMinMax record is used to specify min/max extents for a single
feature in the Russian language system that substitutes a tall integral math symbol when
required.

Example 4A
ﾉ

Hex Data

Expand table

Source

Comments

MinMax

Default MinMax table definition, Cyrillic script

HorizCyrillicDefault
MinMaxTable
0006

HorizCyrillic
MinCoordTable

minCoordOffset — offset to BaseCoord table

000A

HorizCyrillic
MaxCoordTable

maxCoordOffset — offset to BaseCoord table

0000

0

featMinMaxCount: no default feature extents
featMinMaxRecords[] — no FeatMinMax records

BaseCoordFormat1
HorizCyrillic
MinCoordTable

BaseCoord table definition, default Cyrillic min extent
coordinate

0001

1

format: design units only

FF38

-200

coordinate — Y value, in design units

BaseCoordFormat1
HorizCyrillic
MaxCoordTable

BaseCoord table definition default Cyrillic max extent
coordinate

0001

1

format: design units only

0674

1652

coordinate — Y value, in design units

MinMax
HorizRussianMinMaxTable

MinMax table definition, Russian language extents

000E

HorizRussianLangSys
MinCoordTable

minCoordOffset — offset to BaseCoord table

0012

HorizRussianLangSys
MaxCoordTable

maxCoordOffset — offset to BaseCoord table

0001

1

featMinMaxCount

featMinMaxRecords[0]

Records in alphabetical order by featureTag.

'titl'

featureTag: Titling

7469746C

Feature must be same as Tag in FeatureList

0016

HorizRussianFeature
MinCoordTable

minCoordOffset — offset to BaseCoord table

001A

HorizRussianFeature
MaxCoordTable

maxCoordOffset — offset to BaseCoord table

BaseCoordFormat1
HorizRussianLangSys

BaseCoord table definition: Russian language min extent
coordinate

MinCoordTable
0001

1

format: design units only

FF08

-248

coordinate — Y value, in design units
Increased min extent beyond default Cyrillic min extent

BaseCoordFormat1

BaseCoord table definition: Russian language feature

HorizRussianLangSys
MaxCoordTable

max extent coordinate

0001

1

format: design units only

06A4

1700

coordinate — Y value, in design units
Increased max extent beyond default Cyrillic max extent

BaseCoordFormat1

BaseCoord table definition: Russian language min extent

HorizRussianFeature
MinCoordTable

coordinate

0001

1

format: design Units Only

FED8

-296

coordinate — Y value, in design units
Increased min extent beyond default Cyrillic script and
Russian language min extents

BaseCoordFormat1
HorizRussianFeature
MaxCoordTable

BaseCoord table definition: Russian language feature
Max extent coordinate

0001

1

format: design units only

06D8

1752

coordinate — Y value, in design units
Increased max extent beyond default Cyrillic script and
Russian language max extents

Example 4B: Min/Max extents for Cyrillic script and Russian
language feature
A particular language system does not need to define min/max extent coordinates if its
extents match the default extents defined for the script. However, an obscure or

infrequently used feature within the language system may require feature-specific
extent values for proper rendering.
Example 4B shows the MinMax table and FeatMinMax record definitions for this
situation. The example also includes a BaseScript table, but not a BaseValues table since
it is not relevant in this example. The example shows horizontal text layout extents for
the Cyrillic script and feature-specific extents for one feature in the Russian language
system. Much of the data is repeated from Example 4A and modified here for
comparison.
The BaseScript table includes a DefaultMinMax table for the Cyrillic script and a
BaseLangSys record that defines a BaseLangSysTag and an offset to a MinMax table for
the Russian language. The MinMax table includes a FeatMinMax record and specifies a
FeatMinMaxCount, but both the minCoord and maxCoord offsets in the MinMax table
are set to NULL since no language-specific extent values are defined for Russian. The
FeatMinMax record defines the min/max coordinates for the Russian feature and
specifies the correct feature tag.
Example 4B
ﾉ

Hex Data

Expand table

Source

Comments

BaseScript
HorizCyrillicBaseScriptTable

BaseScript table definition: Cyrillic script

0000

NULL

offset to BaseValues table

000C

HorizCyrillicDefault
MinMaxTable

offset to default MinMax table for default script extents

0001

1

baseLangSysCount

baseLangSysRecords[0]

For Russian language-specific extents.

52555320

'RUS '

baseLangSysTag: Russian

001A

HorizRussian
MinMaxTable

offset to MinMax table for language-specific extents

MinMax
HorizCyrillicDefault

Default MinMax table definition: Cyrillic script

MinMaxTable
0006

HorizCyrillic
MinCoordTable

minCoordOffset — offset to BaseCoord table

000A

HorizCyrillic

maxCoordOffset — offset to BaseCoord table

MaxCoordTable
0000

0

featMinMaxCount, no default feature extents
featMinMaxRecords[], no FeatMinMax records

BaseCoordFormat1

BaseCoord table definition: default Cyrillic min extent

HorizCyrillic
MinCoordTable

coordinate

0001

1

format: design units only

FF38

-200

coordinate — Y value, in design units

BaseCoordFormat1

BaseCoord table definition: default Cyrillic max extent

HorizCyrillic
MaxCoordTable

coordinate

0001

1

format: design units only

0674

1652

coordinate — Y value, in design units

MinMax
HorizRussian

MinMax table definition for Russian language — no
extent differences for Russian language itself

MinMaxTable
0000

NULL

minCoordOffset — offset to min BaseCoord table not
defined, matches script default

0000

NULL

maxCoordOffset — offset to max BaseCoord table not
defined, matches script default

0001

1

featMinMaxCount

featMinMaxRecords[0]

Records in alphabetical order by featureTag

7469746C

'titl'

featureTag: Titling
Feature must be same as Tag in FeatureList

000E

HorizRussianFeature

minCoordOffset — offset to BaseCoord table

MinCoordTable
0012

HorizRussianFeature

maxCoordOffset — offset to BaseCoord table

MaxCoordTable
BaseCoordFormat1

BaseCoord table definition: Russian 'titl' feature min

HorizRussianFeature
MinCoordTable

extent coordinate

0001

1

format: design units only

FED8

-296

coordinate — Y value, in design units

Increased min extent beyond default Cyrillic min extent
BaseCoordFormat1
HorizRussianFeature
MaxCoordTable

BaseCoord table definition: Russian 'titl' feature max
extent coordinate

0001

1

format: design units only

06D8

1752

coordinate — Y value, in design units
Increased max extent beyond default Cyrillic max
extent

Example 5: BaseCoordFormat1 table
Example 5 illustrates BaseCoordFormat1, which specifies single coordinate values in
design units only. The font uses 2,048 design units/em. The example defines the default
minimum extent coordinate for a math script.
Example 5
ﾉ

Hex Data

Expand table

Source

Comments

BaseCoordFormat1
HorizMathMinCoordTable

Definition of BaseCoord table for Math min coordinate

0001

1

format: design units only

FEE8

-280

coordinate — Y value, in design units

Example 6: BaseCoordFormat2 table
Example 6 illustrates the BaseCoord Format 2. Like Example 5, it specifies the minimum
extent coordinate for a math script. With this format, the coordinate value depends on
the final position of a specific contour point on one glyph, the integral math symbol,
after hinting. Again, the value is in design units (2,048 units/em).
Example 6
ﾉ

Hex Data

Expand table

Source

Comments

BaseCoordFormat2
HorizMathMinCoordTable

BaseCoord table definition for Math min coordinate

0002

2

format: design units plus contour point

FEE8

-280

coordinate — Y value, in design units

0128

IntegralSignGlyphID

referenceGlyph: math integral sign

0043

67

baseCoordPoint: glyph contour point index

Example 7: BaseCoordFormat3 table
Example 7 illustrates the BaseCoord Format 3. Like Examples 5 and 6, it specifies the
minimum extent coordinate for a math script in design units (2,048 units/em). This
format, however, uses a Device table to modify the coordinate value for the point size
and resolution of the output font. Here, the Device table defines pixel adjustments for
font sizes from 11 ppem to 15 ppem. The adjustments add one pixel at each size.
Example 7
ﾉ

Hex Data

Expand table

Source

Comments

BaseCoordFormat3
HorizMathMinCoordTable

BaseCoord table definition for Math min coordinate

3

format: design units plus device table

-280

coordinate — Y value, in design units

HorizMathMin
deviceOffset

Offset to Device table

DeviceTableFormat1
HorizMathMin
CoordDeviceTable

Device table definition for MinCoord

000B

11

startSize: 11 ppem

000F

15

endSize: 15 ppem

0001

1

deltaFormat: signed 2 bit value (8 values per uint16)

1

Increase 11ppem by 1 pixel

1

Increase 12ppem by 1 pixel

1

Increase 13ppem by 1 pixel

1

Increase 14ppem by 1 pixel

0003

000C

5540

1

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

Increase 15ppem by 1 pixel

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

CBDT — Color Bitmap Data Table
Article • 05/31/2024

The CBDT table is used to embed color bitmap glyph data. It is used together with the
CBLC table, which provides embedded bitmap locators. The formats of these two tables
are downward compatible extensions of the EBDT and EBLC tables used for embedded
monochrome and grayscale bitmaps.

Table structure
The CBDT table begins with a header containing simply the table version number.
CbdtHeader
ﾉ

Type

Name

Description

uint16

majorVersion

Major version of the CBDT table, = 3.

uint16

minorVersion

Minor version of the CBDT table, = 0.

Expand table

Note that the first version of the CBDT table is 3.0.
The rest of the CBDT table is a collection of bitmap data. The data can be presented in
three possible formats, indicated by information in the CBLC table. Some of the formats
contain metric information plus image data, and other formats contain only the image
data. Long word alignment is not required for these subtables; byte alignment is
sufficient.

Uncompressed color bitmaps
The value 32 may be used in the bitDepth field of BitmapSize records within the CBLC
table to identify color bitmaps with 8-bit blue/green/red/alpha (“BGRA”) channels per
pixel, encoded in that order for each pixel. The color channels represent pre-multiplied
color and must be encoded colors in the sRGB colorspace, as specified in IEC 61966-21:1999/Amd 1:2003

. For example, the color “full-green with half translucency” is

encoded as \x00\x80\x00\x80 (BGR values are pre-multiplied), and not \x00\xFF\x00\x80.
All bitmap image data formats defined in the EBDT / EBLC tables are valid for use with
the CBDT / CBLC tables.

Compressed color bitmaps
Images for each individual glyph may be stored as straight PNG data, as specified in
ISO/IEC 15948. Only the following chunks are allowed in such PNG data: IHDR, PLTE,
tRNS, sRGB, IDAT, and IEND. If other chunks are present, the behavior is undefined. The
image data must be in the sRGB colorspace, regardless of color information that could
be present in other chunks in the PNG data. The individual images must have the same
size as expected by the table in the bitmap metrics.

Glyph metrics
There are also two different formats for glyph metrics: big glyph metrics and small glyph
metrics. Big glyph metrics define metrics information for both horizontal and vertical
layouts. This is important in fonts (such as Kanji) where both types of layout may be
used. Small glyph metrics define metrics information for one layout direction only.
Which direction applies, horizontal or vertical, is determined by the flags field of
BitmapSize records within the CBLC table.
BigGlyphMetrics record
ﾉ

Expand table

Type

Name

Description

uint8

height

Number of rows in the bitmap.

uint8

width

Number of columns in the bitmap.

int8

horiBearingX

Distance in pixels from the horizontal origin to the left edge of the bitmap.

int8

horiBearingY

Distance in pixels from the horizontal origin to the top edge of the bitmap.

uint8

horiAdvance

Horizontal advance width in pixels.

int8

vertBearingX

Distance in pixels from the vertical origin to the left edge of the bitmap.

int8

vertBearingY

Distance in pixels from the vertical origin to the top edge of the bitmap.

uint8

vertAdvance

Vertical advance width in pixels.

SmallGlyphMetrics record
ﾉ

Type

Name

Description

Expand table

uint8

height

Number of rows in the bitmap.

uint8

width

Number of columns in the bitmap.

int8

bearingX

Distance in pixels from the horizontal origin to the left edge of the bitmap (for
horizontal text); or distance in pixels from the vertical origin to the top edge of
the bitmap (for vertical text).

int8

bearingY

Distance in pixels from the horizontal origin to the top edge of the bitmap (for
horizontal text); or distance in pixels from the vertical origin to the left edge of
the bitmap (for vertical text).

uint8

advance

Horizontal or vertical advance width in pixels.

Glyph bitmap data formats
In addition to nine different formats already defined for glyph bitmap data in the EBDT
table, there are three additional formats for use in the CBDT table, described below.

Format 17: small metrics, PNG image data
GlyphBitmapFormat17 table
ﾉ

Expand table

Type

Name

Description

smallGlyphMetrics

glyphMetrics

Metrics information for the glyph

uint32

dataLen

Length of data in bytes

uint8

data[dataLen]

Raw PNG data

Format 18: big metrics, PNG image data
GlyphBitmapFormat18 table
ﾉ

Type

Name

Description

bigGlyphMetrics

glyphMetrics

Metrics information for the glyph

uint32

dataLen

Length of data in bytes

Expand table

uint8

data[dataLen]

Raw PNG data

Format 19: metrics in CBLC table, PNG image data
GlyphBitmapFormat19 table
ﾉ

Type

Name

Description

uint32

dataLen

Length of data in bytes

uint8

data[dataLen]

Raw PNG data

Expand table

Scaling behavior
Applications using these glyphs may need to scale them to fit the raster size available
for display. How this scaling takes place is application dependent. It is recommended
that where possible the application downscale using the closest sized bitmap that is
larger than the desired end raster size.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

CBLC — Color Bitmap Location Table
Article • 05/31/2024

The CBLC table provides embedded bitmap locators. It is used together with the CBDT
table, which provides embedded, color bitmap glyph data. The formats of these two
tables are downward compatible extensions of the EBDT and EBLC tables used for
embedded monochrome and grayscale bitmaps.
The CBLC table begins with a header containing the table version and number of strikes.
An OpenType font may have one or more strikes embedded in the 'CBDT' table.
CblcHeader
ﾉ

Expand table

Type

Name

Description

uint16

majorVersion

Major version of the CBLC table, = 3.

uint16

minorVersion

Minor version of the CBLC table, = 0.

uint32

numSizes

Number of BitmapSize records.

BitmapSize

bitmapSizes[numSizes]

BitmapSize records array.

Note that the first version of the CBLC table is 3.0.
Each strike is defined by a BitmapSize record.
BitmapSize record
ﾉ

Expand table

Type

Name

Description

Offset32

indexSubtableListOffset

Offset to index subtable from beginning of CBLC.

uint32

indexSubtableListSize

Number of bytes in corresponding index subtables
and array.

uint32

numberOfIndexSubtables

There is an index subtable for each range or format
change.

uint32

colorRef

Not used; set to 0.

SbitLineMetrics

hori

Line metrics for text rendered horizontally.

SbitLineMetrics

vert

Line metrics for text rendered vertically.

uint16

startGlyphIndex

Lowest glyph index for this size.

uint16

endGlyphIndex

Highest glyph index for this size.

uint8

ppemX

Horizontal pixels per em.

uint8

ppemY

Vertical pixels per em.

uint8

bitDepth

In addition to already defined bitDepth values 1, 2,
4, and 8 used for monochrome and grayscale
bitmaps, the value of 32 is used to identify color
bitmaps with 8 bit per channel BGRA pixel data.

int8

flags

Vertical or horizontal (see the Bitmap flags section
of the EBLC table chapter).

The indexSubtableListOffset is the offset from the beginning of the CBLC table to an
IndexSubtableList. The indexSubtableListSize is the total size in bytes of the
IndexSubtableList data, including the array of IndexSubtables. Each strike has an
IndexSubtableList to support various formats and discontiguous ranges of bitmaps. Each
IndexSubtable provides the locations of the bitmap data for one or more glyphs within
the CBDT table, and may optionally provide glyph metrics to use for that set of glyphs.
Remaining details regarding the structure of the CBDT table are identical to those
defined for the EBLC table.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

CFF — Compact Font Format (Version 1)
Article • 05/31/2024

This table contains a Compact Font Format (CFF) font representation and is structured
according to Adobe Technical Note #5176: “The Compact Font Format Specification,”
and Adobe Technical Note #5177: “Type 2 Charstring Format.”
Note: See Adobe Technical Note #5176 for details regarding the CFF INDEX, DICT
and FontSet structures mentioned below.
The CFF font format existed as an independent font format prior to the development of
OpenType. When incorporated into the OpenType format, certain essential font
information continued to be represented using mechanisms defined in the CFF format,
duplicating other data representations available within OpenType for use in fonts with
TrueType outlines. For example, CFF incorporates glyph widths into glyph outline
descriptions, though these could otherwise be provided in the 'hmtx' table. OpenType
fonts with TrueType outlines use a glyph index in conjunction with offsets in the 'loca'
table to access glyph data within the 'glyf' table. This concept is retained in OpenType
CFF fonts, except that glyph data is accessed through a CharStrings INDEX structure
within the 'CFF ' table.
See Comparison of 'glyf', 'CFF ' and CFF2 tables for a summary of significant differences
between the 'glyf', 'CFF ' and CFF2 tables.
The Name INDEX in the 'CFF ' table must contain only one entry; that is, there must be
only one font in the CFF FontSet. It is not a requirement that this name be the same as
name ID 6 entries in the 'name' table. Note that, in an OpenType font collection file, a
single 'CFF ' table can be shared across multiple fonts; names used by applications must
be those provided in the 'name' table, not the Name INDEX entry.
The CFF Top DICT must specify a CharstringType value of 2.
The numGlyphs field in the 'maxp' table must be the same as the number of entries in
the CFF’s CharStrings INDEX. The OpenType font glyph index is the same as the CFF
glyph index for all glyphs in the font.

６ Collaborate with us on
GitHub

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:

The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

 Open a documentation issue
 Provide product feedback

CFF2 — Compact Font Format (CFF)
Version 2
Article • 10/09/2024

Introduction
The Compact Font Format table, version 2 (CFF2), is used for describing glyphs in an
OpenType font. It is an alternative to the 'glyf' table using an efficient format to
represent glyph outlines that has origins in the Adobe® Postscript® language.
In the CFF2 table, sequences of cubic (3rd-order) Bézier curves and straight lines are
used to define glyph outlines. CFF2 data can also include “blend” operations, controlled
by OpenType Font Variations mechanisms to change the shapes of glyphs. A
rasterization fill rule is used to provide the opaque, monochrome shape of each glyph.
CFF2 data can include “hint” operations that influence this rasterization. When combined
with the COLR and CPAL tables, the CFF2 table can be used to represent multi-color
glyphs.
CFF2 is a successor to and refinement of the 'CFF ' table and glyph format. Because of
the origins of CFF in the Postscript language, the data in a complete 'CFF ' table can be
used as a stand-alone font. When used within an OpenType font, however, that aspect
of CFF results in redundancy. CFF2 avoids redundancy by relying on data in other font
tables. CFF2 also adds new operators used in variable fonts and uses a new CFF2
CharString specification.
See Comparison of 'glyf', 'CFF ' and CFF2 tables for a summary of significant differences
between the 'glyf', 'CFF ' and 'CFF2' tables.

Organization of the CFF2 table
The CFF2 table is comprised of various required and optional subtables. The following
description summarizes the overall structure of the CFF2 table.
Two common, generic structures are used for various subtables:
A DICT structure is a binary dictionary format with one or more key-value pairs.
This format is used for TopDICT, FontDICT and PrivateDICT subtables.
An INDEX structure contains an array of one or more data objects of various types.
This format is used for CharStringINDEX, GlobalSubrINDEX, LocalSubrINDEX and

FontDICTINDEX subtables.
Note: the terms local and private are used in names for different structures or
operators with the same meaning: data applicable to a specific scope, as opposed to
global scope.
The DICT and INDEX formats and the various subtables that use them are described in
subsequent parts of this document.
The CFF2 table begins with a short header. The header is followed by the TopDICT
subtable, which stores offsets to other subtables. The TopDICT subtable is followed by
the GlobalSubrINDEX subtable, which stores CharString data (see below) that can be reused in multiple glyph descriptions.
The first three structures—Header, TopDICT and GlobalSubrINDEX—must occur in that
order at the start of the CFF2 table. Other subtables may occur in any order at offsets
indicated in the TopDICT subtable and elsewhere.
A CharStringINDEX subtable stores CharString data. A CharString is an encoded
representation of a glyph, including the glyph outline data as well as hinting and
variation data specific to the glyph. Within the CharStringINDEX, there is one CharString
for each glyph in the font.
CharStrings that have encoded data in common with other CharStrings may use
subroutines to save space. Subroutines can be stored in the GlobalSubrINDEX subtable
or in a LocalSubrINDEX subtable within a PrivateDICT table. Subroutines stored within
the GlobalSubrINDEX can be used by any CharString. Subroutines stored within a
PrivateDICT can only be used by CharStrings associated with that PrivateDICT.
Each CharString is dependent on metadata related to hinting that is also stored in a
PrivateDICT.
Each PrivateDICT has a corresponding FontDICT that provides the location of the
PrivateDICT. A CFF2 table requires only a single FontDICT / PrivateDICT pair, though
multiple FontDICT / PrivateDICT pairs may be used. In particular, if some CharStrings
require a different set of metadata from other CharStrings, then multiple FontDICT /
PrivateDICT pairs may be defined. In such cases, a FontDICTSelect subtable is included to
specify which FontDICT / PrivateDICT pair is used by each CharString.
Metadata relating to Font Variations is stored in a VariationStore subtable. If the font
does not support Font Variations, then the VariationStore must be omitted.
The following table illustrates the organization of the various subtables that can occur in
a CFF2 table. Required subtables are shown in bold type.

ﾉ

Data block

Required

Offset from start of CFF2 table

Header

Yes

0

TopDICT

Yes

5

GlobalSubrINDEX

Yes

5 + Header.topDICTSize

CharStringINDEX

Yes

TopDICT: CharStringINDEXOffset

FontDICTSelect

No

TopDICT: FontDICTSelectOffset

FontDICTINDEX

Yes

TopDICT: FontDICTINDEXOffset

FontDICT#0

Yes

+FontDICTINDEX.offsets[0]

FontDICT#1

—

+FontDICTINDEX.offsets[1]

FontDICT#n

—

+FontDICTINDEX.offsets[n]

PrivateDICT#0

Yes

FontDICT#0: PrivateDICTOffset

PrivateDICT#1

—

FontDICT#1: PrivateDICTOffset

PrivateDICT#n

—

FontDICT#n: PrivateDICTOffset

VariationStore

No

TopDICT: VariationStoreOffset

Expand table

…

…

An annotated example of a CFF2 table is shown at the end of this chapter.
Subtables and data types used within a CFF2 table are not subject to any bytealignment requirements.
DICT and CharString data are structured, binary data that use certain encoded
representations for numbers, along with certain operators that determine the
interpretation of the numeric values. For each operator, there is a defined syntactic
sequence for numeric arguments. A stack is used by a CFF2 decoder for processing the
binary operator/argument data in DICT and CharString data blocks. The various DICT
and CharString operators are described in the sections below that describe those two
types of structured data. The encoded representations of numbers and the decoding
stack are described in separate sections that follow.

Encoded numbers

Encoded number formats
Various CFF2 structures represent numeric values using the standard OpenType data
types, such as uint8 and Fixed (see Data Types). DICT and CharString data (including
CharString subroutines) use special encoded representations for numbers.
During decoding, byte sequences representing numbers or operators are encountered.
Numbers have various encodings that use one or more bytes to represent a numeric
value, depending on their magnitude and whether they are integers. The initial bytes
used for encoding of numbers do not overlap with the inital bytes used for operators.
Hence, for all number encodings, a byte sequence can be identified as being a number
by the initial byte of the encoded representation.
Most number encodings may be used in both DICT and Charstring data, though there
are exceptions. The following table shows how numbers are encoded based on an initial
byte, and also indicates whether each encoding is used in DICT or CharString data only,
or both. Each encoding uses an initial byte, b0, interpreted as uint8, and possible
subsequent bytes b1, b2, b3, etc. In the 2-byte formats, b1 is also interpreted as uint8.
Numerical value encoding
ﾉ

Initial

Value range

Value calculation

byte b0

Size in

Expand table
Usage

bytes

32 to 246

-107 to 107

b0 - 139

1

both

247 to 250

108 to 1131

(b0 - 247) * 256 + b1 + 108

2

both

251 to 254

-1131 to -108

-(b0 - 251) * 256 - b1 - 108

2

both

28

-32768 to 32767

interpret b1 and b2 as int16

3

both

255

-32768 to (32768 1/65536)

interpret b1 to b4 as Fixed

5

CharString
only

29

-(2^31) to (2^31 1)

interpret b1 to b4 as int32

5

DICT only

30

any real number

following bytes are binary coded

unlimited

DICT only

decimal (see below)

Note: For some of these encodings, b0 serves only to indicate the encoding used.
For some, however, b0 is used both to indicate the encoding used and also in the
calculation of the numeric value.

The Usage column indicates whether each encoded format may be used in DICT data, in
CharString data, or in both. Numbers encoded as int32 (b0 = 29) or binary coded
decimal (b0 = 30) are only permitted in DICT data. Numbers encoded as Fixed (b0 =
255) are only permitted in CharString data. It is not possible to represent numbers >=
32768 or < -32768 in CharString data.
If an initial byte b0 has a value not in this list, then either the byte encodes an operator,
or the data is invalid.

Binary coded decimal
Real numeric values of arbitrary precision can be represented in a binary coded decimal
form. This representation uses a binary encoding of a decimal numeric expression, such
as “123.456”. The numeric expression can optionally use decimal exponential notation,
such as “1.23456E2” (equivalent to “1.23456 × 102”). Binary coded decimal numbers may
only be used in DICT data.
The representation of binary coded decimal numbers begins with a prefix byte (b0)
value of 30. This is followed by a byte sequence in which each 4-bit nibble represents an
element. The two nibbles of each byte are interpreted in big-endian order: the first
element is stored in the most significant 4 bits, and the second element is stored in the
least significant 4 bits. The sequence is terminated with a nibble value of 0xf
(hexadecimal). If the terminating 0xf nibble is the first nibble of a byte, then an
additional 0xf nibble must be appended (hence, the byte is 0xff) so that the encoded
representation is always a whole number of bytes.
After the prefix byte of 30 is recognized, the value of the binary coded decimal number
is obtained by stepping through the nibbles, building up the decimal expression of the
number, until the termination nibble is encountered. Each nibble value is interpreted
according to the following table. Converted to ASCII, the string can then be converted
to a high-precision floating point number using standard functions in most
programming languages.
ﾉ

Nibble value

Nibble value (hex)

Represents in ASCII

0 to 9

0 to 9

0 to 9

10

a

. (decimal point)

11

b

E

12

c

E-

Expand table

Nibble value

Nibble value (hex)

Represents in ASCII

13

d

(reserved)

14

e

- (minus)

15

f

end of number

Negative exponents, as in the example “3E-5” (=0.00003), must be represented using
the nibble value 0xc, not by the nibble sequence 0xb followed by 0xe.
While the binary encoded decimal format can represent values with arbitrary precision,
the maximum degree of effective precision obtainable is implementation dependent.
Examples:
the value -2.25 is encoded by the byte 30 (decimal) followed by the byte sequence
0xe2 0xa2 0x5f (hexadecimal)
the value 0.140541E-3 is encoded by 30 (decimal) followed by the byte sequence
0x0a 0x14 0x05 0x41 0xc3 0xff (hexadecimal)
The following regular expression (using POSIX ERE or Perl Compatible RE syntax)
validates a binary coded decimal value represented as ASCII:

-?([1-9][0-9]*|0)?(\.[0-9]*)?(E-?[1-9][0-9]*)?

The following table shows some edge cases (represented as ASCII) and their decoded
values:
ﾉ

Input

Value

[empty]

0

.

0

.5

0.5

2.

2

E5

invalid

05

invalid

Expand table

Input

Value

E05

invalid

Decoding DICT and CharString data using a
stack
Two fundamental encoded data formats in the CFF2 table are the DICT and the
CharString. Each is a binary data block that represents a sequence of encoded numbers
and operators. In order to interpret those sequences, CFF2 decoders use a stack.
A stack is an array conceived as a physical stack of items, which can be manipulated in
only two ways:
place one new item on the top (“push an item onto the stack”)
remove one item from the top (“pop an item from the stack”)
When an item is popped from the stack, the item removed must be the last item that
was added.

Stack-based CFF2 decoding
A CFF2 decoder is expected to implement a stack in a suitable manner. The CFF2 stack
stores only numbers.
Starting with an empty stack, a decoder of DICT and CharString data processes bytes
sequentially from the start to the end, decoding numbers and operators.
Numbers in DICT and CharString data are represented using an encoding scheme of one
or more bytes, as described in the previous section. Decoded numbers are immediately
pushed to the stack, ready for use as operands for operators that follow.
Operators are encoded with one or two bytes. The byte ranges used for operators do
not overlap with the encodings used for numbers. All two-byte operators begin with
0x0c. A few operators also encode data in succeeding bytes.
Decoded operators pop one or more numbers from the stack, then store or process
them, and in some cases push new numbers back onto the stack. The maximum number
of operands on the CFF2 stack is 513.
Different operators are defined for use in the different types of DICT table and for use in
CharStrings. In any of these contexts, if an unrecognized operator is encountered while
decoding, it is ignored and the stack is cleared.

The function of operators in a DICT subtable is to create key-value pairs. During
decoding, the DICT key is identified by the operator, and the DICT value is obtained by
popping items (one or more numbers) from the stack. In well-formed CFF2 data, the
number of operands preceding a DICT key operator must be exactly the number
required for that operator; hence, the stack will be empty after the operator is
processed. The DICT blend operator is exceptional, neither creating a key-value pair nor
leaving the stack empty. Instead, its function is to modify operand values before they
are assigned to keys. See OpenType Font Variations in CFF2, below, for details on the
blend operator.
The function of operators in CharString data is the representation of glyph outlines,
hints and variations. During decoding, and assuming valid CharString data, most
CharString operators pop all the numbers on the stack and do not push any new
numbers to the stack. Thus, in CharString decoding, most operators will leave the stack
empty. There are three exceptions:
blend: Pops operands from the stack (but not necessarily all the operands on the
stack) and pushes processed numbers back to the stack.
callsubr: Pops a number from the stack and invokes a local subroutine.
callgsubr: Pops a number from the stack and invokes a global subroutine.
Subroutines are not restricted regarding the state of the stack. When the callsubr or
callgsubr operator is processed, the stack may have one operand or many operands.
After the subroutine is processed, the stack may be empty or may contain any number
of operands.
These operators are described in detail below (see CharString).

Stack notation
In specifications for DICT and CharString that follow, the following notation is used to
describe the state of the stack when particular operators are encountered.
[ — represents the bottom of the stack
] — represents the top of the stack
x , dx , etc. — values on the stack referred to in the description
<number> — a number, either an integer or real number
<integer> — an integer
( ) — delimiters for a group of items that is repeated or optional
* — an item or group occurs 0 or more times
+ — an item or group occurs 1 or more times

… — items at the bottom of the stack that are not involved in the current

operation
The following are some expressions using this notation:
[ <number> ] — the stack contains one number
[ <integer> ] — the stack contains one integer
[ <number>+ ] — the stack contains one or more numbers
[ (<number> <number>)+ ] — the stack contains an even number of numbers

(using the regular expression-style parentheses for grouping)
[… <number>* <integer> ] — at the top of the stack are 0 or more numbers,

followed by an integer
This notation is similarly used to describe the operands interpreted by operators. For
example:
The stack notation specified for the CharString hmoveto operator is [ dx ] ,
indicating that a single operand, dx, is expected.
The stack notation specified for the CharString rlineto operator is [ (dx dy)+ ] ,
indicating that one or more pairs of operands, dx dy, are expected.

Common formats: DICT and INDEX
DICT and INDEX are two common, generic structures that are used for various subtables.
This section describes the generic specifications common across various subtables;
details specific to particular subtables will follow in later sections.

DICT data
A DICT subtable defines a dictionary data structure consisting of key-value pairs. DICTs
are used in CFF2 to store offsets to other data blocks, and metadata used across
multiple glyphs. In each key-value pair:
The key is a string from a predefined vocabulary encoded as an operator of one or
two bytes. Each type of DICT subtable has a different set of valid keys. A given key
must not be defined more than once in any DICT.
The value is a number or a sequence of numbers.

DICT data is decoded using a stack, as described above. Starting from the beginning of
the DICT data, numbers and operators are parsed from the data sequentially until the
end of DICT data is reached. Decoded numbers are pushed onto the stack. DICT
operators pop numeric operands from the stack and assign those numbers as values for
the key identified by the operator itself. The number of operands that are popped is
specific to each operator.
With the exception of the blend operator, after a DICT operator and its values have
been decoded, the stack must be empty. If it is not empty, the subtable is invalid.
While decoding a DICT, if an operator is encountered that is not defined for the current
DICT type, the behavior is unspecified.
The DICT format is used for TopDICT, FontDICT and PrivateDICT subtables. In general,
the key-value pairs for a DICT may be specified in any order. However, some ordering
rules are specified for the PrivateDICT subtable. For each subtable type, default values
are specified for certain keys. For keys that have a specified default value, that default
value must be used if the corresponding operator for the key is not present with the
DICT. Details for each of these subtables is provided below.
Multiple DICT subtables may share encoded data with overlapping byte ranges within
the CFF2 table. In this way, one DICT could represent a subset of the data of another
DICT.

INDEX data
An INDEX is an array of data objects of some type. Objects in the array are accessed
using a 0-based index. Objects in the array are stored contiguously and in order. An
offset array provides the location and size of each object, which may be of arbitrary size.
The INDEX format is used in CharStringINDEX, GlobalSubrINDEX and LocalSubrINDEX,
and FontDICTINDEX subtables. These are described below.
The format of an INDEX is as follows.
INDEX table
ﾉ

Expand table

Type

Name

Description

uint32

count

Number of objects stored in INDEX

uint8

offsetSize

Offset array element size

Type

Name

Description

Offset8 or Offset16 or Offset24
or Offset32

offsets[count+1]

Array of offsets — offsets are from byte
preceding object data

uint8

data[variable]

Object data—total length is the last offset - 1

The offsetSize field specifies the number of bytes used to store each offset: 1 for Offset8,
2 for Offset16, 3 for Offset24, or 4 for Offset32.
The offsets array specifies the starting location for each data object according to its
index. Offsets in the offset array are relative to the byte that precedes the object data.
The first element of the offset array must always be 1. Data objects are stored
contiguously and in order, therefore each offset must be less than or equal to the
following offset.
An object is retrieved by using the object index to look up an offset in the offsets array
and fetching the binary data at the specified offset. The size for each object is
determined by subtracting the offset for a given object from the next offset in the offset
array. The offset array has count + 1 elements, which provides a length for the last
object. Hence, every object has a non-zero offset and a size (which may be zero).
An empty INDEX is represented by a count field with a 0 value and no additional fields.
Thus, the total size of an empty INDEX is 4 bytes.
The total size of a non-empty INDEX is:

4 + 1 + offsetSize × (count + 1) + offsets[count] - 1

When creating INDEX data blocks, the smallest possible representation for offsets
should be used. For example, if offsets[count] is greater than 255 and less than 65536,
then all offsets can be represented as Offset16, and so offsetSize should be set to 2.

Header
The CFF2 table begins with a header having the following format.
CFF2 Header
ﾉ

Type

Name

Description

Expand table

uint8

majorVersion

Format major version (set to 2).

uint8

minorVersion

Format minor version (set to 0).

uint8

headerSize

Header size (set to 5).

uint16

topDICTSize

Length of TopDICT subtable.

The TopDICT subtable must always start immediately after the header—for this version,
at offset 5 from the start of the CFF2 table. The headerSize field must be used when
locating the start of the TopDICT subtable. It is provided so that future versions of the
format can introduce additional data between the topDICTSize field and the TopDICT
subtable in a manner that is compatible with older implementations.
The sum headerSize + topDICTSize is the location within the CFF2 table of the required
GlobalSubrINDEX subtable.

TopDICT
The TopDICT subtable is a DICT that provides offsets to various subtables within the
CFF2 table. It also provides values relating to the unitsPerEm value in the 'head' table.
The TopDICT subtable immediately follows the CFF2 Header. Every CFF2 table requires
one TopDICT subtable.

TopDICT operator summary
The following table lists the five operators allowed in the TopDICT subtable, the bytes by
which they are encoded in DICT data (hexadecimal and decimal), and whether or not
they are required.
ﾉ

Expand table

Hex

Dec

Name

Required

Default

0x11

17

CharStringINDEXOffset

yes

—

0x18

24

VariationStoreOffset

only for fonts with variations

—

0x0c24

12,36

FontDICTINDEXOffset

yes

—

0x0c25

12,37

FontDICTSelectOffset

no

—

0x0c07

12,7

FontMatrix

no

0.001 0 0 0.001 0 0

TopDICT operator specifications
The following specifies details for the five key operators permitted in a TopDICT.
CharStringINDEXOffset
ﾉ

Expand table

Encoding

0x11 (17)

Stack

[<integer>]

Operands

[ offset ]

Description

Specifies the offset to the CharStringINDEX subtable, from the start of the CFF2
table.

Occurrence

Required

VariationStoreOffset
ﾉ

Expand table

Encoding

0x18 (24)

Stack

[<integer>]

Operands

[ offset ]

Description

Specifies the offset to the VariationStore subtable, from the start of the CFF2 table.

Occurrence

Required in fonts that have CFF2 glyph variations, otherwise forbidden.

FontDICTINDEXOffset
ﾉ

Expand table

Encoding

0x0c24 (12, 36)

Stack

[<integer>]

Operands

[ offset ]

Description

Specifies the offset to the FontDICTINDEX subtable, from the start of the CFF2
table.

Occurrence

Required

FontDICTSelectOffset

ﾉ

Expand table

Encoding

0x0c25 (12, 37)

Stack

[<integer>]

Operands

[ offset ]

Description

Specifies the offset to the FontDICTSelect subtable, from the start of the CFF2 table.

Occurrence

Optional. If the CFF2 table has only one FontDICT, there is no need for a
FontDICTSelect subtable, and the FontDICTSelectOffset operator must not be
used.

FontMatrix
ﾉ

Expand table

Encoding

0x0c07 (12, 7)

Stack

[ <number> 0 0 <number> 0 0 ]

Operands

[ scale 0 0 scale 0 0 ]

Default

0.001 0 0 0.001 0 0

Description

Numeric operands are encoded as binary coded decimal. Specifies the scale factor
for glyph coordinates within the em square, similar to the unitsPerEm field in the
'head' table. However, a reciprocal value is used (thus 1 / unitsPerEm). This value
occurs as the first and fourth operands—both scale operands must have the same
value. Other operands must be zero.

Occurrence

Required if unitsPerEm is not equal to 1000. For the common case in which
unitsPerEm is 1000, the key-value pair is created with the default value and the
FontMatrix operator should be omitted.

Note: The origin of the TopDICT FontMatrix operator is a 2×3 transformation matrix.
In the CFF2 table, however, only matrices with uniform horizontal and vertical
scaling without translation are permitted, hence the requirement that the 1st and
4th operands be identical and the remaining operands be zero.

FontDICTINDEX, FontDICTSelect and FontDICT
Overview

The FontDICTINDEX subtable is used in combination with other data structures for
storing metadata related to hinting, variation and subroutines for CharString glyph
descriptions. The metadata associated with a given glyph is stored in a PrivateDICT
table. Multiple PrivateDICT tables may be used, each holding the metadata for a subset
of CharStrings. For each PrivateDICT, there is a corresponding FontDICT table that
provides the location of the given PrivateDICT table. The FontDICTINDEX contains the
array of FontDICT tables. When multiple PrivateDICT tables are used, a FontDICTSelect
table indicates which FontDICT and corresponding PrivateDICT are used for each glyph.

FontDICTINDEX
The FontDICTINDEX is a required subtable. Its location within the CFF2 table is given by
the FontDICTINDEXOffset key in the TopDICT subtable. It uses the INDEX format.
The FontDICTINDEX must contain at least one FontDICT, but may contain multiple
FontDICTs. No upper limit to the number of FontDICTs is specified. If there is more than
one FontDICT, each FontDICT will be associated with some subset of glyphs. In this case,
a FontDICTSelect table must be used to assign glyphs to FontDICTs.

FontDICTSelect
The FontDICTSelect table is an optional table used when there are multiple FontDICT
tables to assign each CharString to a particular FontDICT. The location of the
FontDICTSelect table is given by the FontDICTSelectOffset key in the TopDICT subtable.
A font may use one FontDICT (and corresponding PrivateDICT) for all CharStrings. In
that case, no FontDICTSelect table is required, and the FontDICTSelectOffset entry is
omitted from the TopDICT.
There are three formats defined for FontDICTSelect: format 0, format 3 and format 4.
Each format provides mappings for all glyphs (CharStrings) to a FontDICT. That is, each
format provides numGlyphs mappings from a glyph index (or glyph ID) to a FontDICT
index, where numGlyphs is the number of CharStrings in the CharStringINDEX. Formats 3
and 4 map ranges of glyph IDs onto a single FontDICT index, which often makes those
formats a better choice for efficiency.
The first field in each format identifies the format.
FontDICTSelectFormat0 table
ﾉ

Expand table

Type

Name

Description

uint8

format

Set to 0

uint8

fontDICTIDs[numGlyphs]

FontDICT index array

In format 0, each element of the fontDICTIDs array represents the index for a FontDICT
in the FontDICTINDEX. This format should be used when the FontDICT indices are in a
fairly random order.
FontDICTSelectFormat3 table
ﾉ

Type

Name

Description

uint8

format

Set to 3

uint16

numRanges

Number of ranges

Range3

ranges[numRanges]

Array of Range3 records (see below)

uint16

sentinel

Sentinel glyph ID

Expand table

Range3 record
ﾉ

Type

Name

Description

uint16

first

First glyph ID in range

uint8

fontDICTID

FontDICT index for all glyphs in range

Expand table

Each Range3 record describes a group of sequential glyph IDs that have the same
FontDICT index. Each range includes glyph IDs from the first glyph ID in the range
record up to, but not including, the first glyph ID of the next range record. Records in
the ranges array must be in increasing order of first glyph IDs. The first range must have
a first glyph ID of 0. The sentinel glyph ID provides a final range in the array, and must
be set equal to numGlyphs, the number of glyphs in the font. That is, its value is 1
greater than the last glyph ID in the font.
The fontDICTID in each Range3 record cannot exceed 255. For this reason, a format 3
FontDICTSelect supports at most 255 FontDICT tables in the FontDICTINDEX.

Note: The sentinel glyph ID is encoded as a uint16, hence cannot exceed 65,535.
Since it delimits a final range in the ranges array, and the ending glyph ID is one less
than the start of the following range, the last glyph ID that can be mapped using
format 3 cannot exceed 65534.
FontDICTSelectFormat4 table
ﾉ

Type

Name

Description

uint8

format

Set to 4

uint32

numRanges

Number of ranges

Range4

ranges[numRanges]

Array of Range4 records (see below)

uint32

sentinel

Sentinel glyph ID

Expand table

Range4 record
ﾉ

Type

Name

Description

uint32

first

First glyph ID in range

uint16

fontDICTID

FontDICT index for all glyphs in range

Expand table

Format 4 is similar to format 3 except that it accommodates more than 65,534 glyphs by
using a uint32 type for the numRanges and sentinel fields, and a Range4 record array,
which accommodates up to 65,535 FontDICT tables in the FontDICTINDEX.
Note: While FontDICTSelect format 4 allows for more than 65,535 glyphs, other parts
of the OpenType format, such as the numGlyphs field of the 'maxp' table, are still
constrained to 65,535 glyphs.

FontDICT
A FontDICT is a DICT that provides the offset to a corresponding PrivateDICT. Since it
exists only to point to a PrivateDICT, it uses only one key operator, PrivateDICTOffset.
PrivateDICTOffset

ﾉ

Expand table

Encoding

0x12 (18)

Stack

[ <integer> <integer> ]

Operands

[ size offset ]

Description

The two operands are the size and offset of the corresponding PrivateDICT table.
The offset is from the start of the CFF2 table. If the corresponding PrivateDICT is
empty, then the numbers 0 0 must be specified.

Occurrence

Required.

PrivateDICT
A PrivateDICT is a DICT subtable providing metadata relating to hinting, subroutines and
variations used by one or more CharStrings. Many fonts use only one PrivateDICT,
whose metadata applies to all CharStrings. A font may also have multiple PrivateDICTs
used for different subsets of CharStrings, each CharString being associated with exactly
one PrivateDICT.
The location and size of a PrivateDICT is provided by the PrivateDICTOffset key in a
FontDICT. To have multiple PrivateDICTs, a FontDICTINDEX needs to have multiple
FontDICTs, one for each PrivateDICT. A FontDICTSelect table is also required to associate
each CharString with a FontDICT and its corresponding PrivateDICT. See FontDICTIndex,
FontDICTSelect and FontDICT for more information.
A PrivateDICT may be empty, requiring no storage. In this case, both the size and offset
given by the PrivateDICTOffset key of the FontDICT must be set to zero. If the
PrivateDICT is empty, default values will be used for certain PrivateDICT keys, as set out
in the description of PrivateDICT key operators below.
Values for some PrivateDICT keys relating to hinting can undergo interpolation with
OpenType variations using the blend operator. (This means is that the operand
sequence that precedes the key operator may have one or more blend operators
interspersed along with additional operands used for interpolation.) These are identified
as “blendable” in the operator descriptions below.
Some hinting operators—BlueValues and others—accept multiple operands. These
require values to be supplied on the stack as a deltaArray. This is a sequence of numbers
for which only the first number is expressed in absolute terms, while the second and
subsequent numbers are encoded as differences between successive values. In general,
the array a0, a1, a2, …, an is encoded as the deltaArray a0 (a1 - a0) (a2 - a1) … (an - an-1).

An example of deltaArray encoding is given in the definition for the BlueValues
operator.
Note: Some PrivateDICT operators, such as BlueScale and ExpansionFactor, take
non-integer operands. These are encoded as binary coded decimal byte sequences.
When to use multiple PrivateDICTs
A CFF2 table requires at least one FontDICT / PrivateDICT pair (even if the PrivateDICT is
empty), and many fonts only have one pair. However, it may be beneficial to use more
than one PrivateDICT (and hence more than one FontDICT) when the glyphs in the font
are of multiple distinct styles. For example, if a font contains both Latin and Emoji
glyphs, or Latin and Korean Hangul glyphs, the different glyphs sets may use different
hint metadata. In such cases, specifying the metadata for each glyph set in separate
PrivateDICTs will likely allow more compact and efficient CharString encoding. For
example, there could be better use of hinting zones, smaller index values in callsubr
subroutine calls, or fewer operands in blend operations, resulting in less data in total.
For similar reasons, the ability to support multiple FontDICT / PrivateDICT pairs can
allow for easier merging of multiple fonts whose glyphs already have hints, variation
data and subroutines.

PrivateDICT operator summary
The following table lists all valid PrivateDICT operators, together with their byte
encoding (hexadecimal and decimal), default values, their general purpose, and whether
they may be blended.
ﾉ

Expand table

Hex

Dec

Name

Default

Purpose

Blendable

0x13

19

LocalSubrINDEXOffset

—

subroutines

no

0x16

22

vsindex

0

variation

no

0x17

23

blend

—

variation

yes

0x06

6

BlueValues

—

hinting

yes

0x07

7

OtherBlues

—

hinting

yes

0x08

8

FamilyBlues

—

hinting

no

0x09

9

FamilyOtherBlues

—

hinting

no

Hex

Dec

Name

Default

Purpose

Blendable

0x0c09

12,9

BlueScale

0.039625

hinting

no

0x0c0a

12,10

BlueShift

7

hinting

no

0x0c0b

12,11

BlueFuzz

1

hinting

no

0x0a

10

StdHW

—

hinting

yes

0x0b

11

StdVW

—

hinting

yes

0x0c0c

12,12

StemSnapH

—

hinting

yes

0x0c0d

12,13

StemSnapV

—

hinting

yes

0x0c11

12,17

LanguageGroup

0

hinting

no

0x0c12

12,18

ExpansionFactor

0.06

hinting

no

PrivateDICT subroutine operator
There is one PrivateDICT operator used in relation to subroutines.
LocalSubrINDEXOffset
ﾉ

Expand table

Encoding

0x13 (19)

Stack

[ <integer> ]

Operands

[ offset ]

Description

Specifies the offset from the start of the PrivateDICT to a LocalSubrINDEX table
that stores subroutines that can be called by CharStrings associated with the same
PrivateDICT.

Occurrence

Optional. If there are no local subroutines, then the LocalSubrINDEXOffset
operator must not be used within the PrivateDICT.

Blendable

no

For more information on subroutines, see Charstring.

PrivateDICT variation operators

There are two PrivateDICT operators used in relation to variations. These depend on
other parts of the CFF2 table as other tables in the OpenType font. For full details on
their use, see OpenType Font Variations in CFF2.
vsindex
ﾉ

Expand table

Encoding

0x16 (22)

Stack

[ <integer> ]

Operands

[ ivd ]

Description

Activates a particular list of variation regions from a VariationStore subtable.

Occurrence

Optional. Used only when the CFF2 table includes a VariationStore subtable.

Blendable

no

The vsindex operator is used to select a set of active variation regions from the defined
set of variation regions. See OpenType Font Variations in CFF2 for complete details
about the effect of this operator.
When used within a PrivateDICT, it has effect not only for variation of values specified by
PrivateDICT keys but also for variation in all CharStrings associated with that
PrivateDICT. However, a vsindex operator can also be used within a CharString, taking
precedence over the vsindex specified in the PrivateDICT.
Note: The PrivateDICT vsindex operator is encoded as 0x16, whereas in CharString
data it is encoded as 0x0f.
blend
ﾉ

Expand table

Encoding

0x17 (23)

Stack

[ … <number>+ <number>+ <integer> ]

Operands

[ … <n default values> <n * k deltas> n ]

Description

Pops n + n * k + 1 operands from the stack, processes them according to the
OpenType variations interpolation algorithm, then pushes n result numbers back
onto the stack.

Occurrence

Optional. Used only when the CFF2 table includes a VariationStore subtable, and
only in connection with hinting values that are varied.

Blendable

yes

The blend operator may be used in a PrivateDICT to make operands of blendable key
operators variable. The number of operands that are popped by the blend operator is
determined by the last operand (n) and the number of active variation regions (k), with
an upper limit determined by the number of operands required by the next operator in
the data. See OpenType Font Variations in CFF2 for complete details about the
implementation of this operator and interpretation of its operands.
Note: The PrivateDICT blend operator is encoded as 0x17, whereas in CharString
data it is encoded as 0x10.

PrivateDICT hinting operators
There are 13 PrivateDICT operators used in relation to hinting.
BlueValues
ﾉ

Encoding

0x06 (6)

Stack

[ (<integer> <integer>)+ ] (numbers are a deltaArray)

Operands

[ (y1 y2)+ ]

Description

Vertical alignment zones—see below.

Occurrence

Optional.

Blendable

yes

Expand table

The value represented by BlueValues is an array containing an even number of integers
taken in pairs and which, when decoded out of deltaArray format into a list of integers,
follow certain rules:
The first integer in each pair must be less than or equal to the second integer in
that pair. In a variable font, if either integer is blended, the first must remain less
than or equal to the second for all variation instances.
The first pair is the baseline overshoot position and the baseline. This is a bottomzone.

All subsequent pairs describe top zones, that is, alignment zones for the tops of
glyph features. For example: x-height and x-height overshoot position, ascenderheight and ascender-height overshoot position, cap-height and cap-height
overshoot position, figure-height and figure-height overshoot position.
Up to seven pairs may be given in the BlueValues array; the first pair must be the
baseline pair.
Different pairs must be at least 3 font units apart from each other and from pairs in
OtherBlues, as described below. (This minimum distance can be modified by the
optional BlueFuzz entry in the PrivateDICT; see the definition of BlueFuzz, below.)
The maximum difference between values in one pair is constrained as described
under the description of BlueScale, given below.
Despite the names often given to the various alignment zones described for BlueValues,
renderers have no built-in notions of which parameters apply to which glyphs. Each
zone helps to control the alignment of any or all glyphs with glyph-level hints that fall
within the zone.
Example
Consider the following array that represents three alignment zones in a typeface, being
baseline (at 0 with negative overshoot at -15), cap-height (at 700 with overshoot at 715)
and x-height (at 547 with overshoot at 559):
[-15 0 700 715 547 559]

This needs to be stored as a deltaArray. Hence, the sequence of encoded numbers in the
PrivateDICT would, in fact, be:
[-15 15 700 15 -168 12]

Use of the deltaArray saves 2 bytes compared with storing the absolute numbers. This is
because smaller numbers are encoded using fewer bytes in DICT data.
OtherBlues
ﾉ

Encoding

0x07 (7)

Stack

[ (<integer> <integer>)+ ] (numbers are a deltaArray)

Operands

[ (y1 y2)+ ]

Description

Additional bottom vertical alignment zones.

Expand table

Occurrence

Optional.

Blendable

yes

The optional OtherBlues entry in the PrivateDICT is associated with an array of pairs of
integers similar to the BlueValues array. However, the OtherBlues array describes
bottom-zones only. For example, these can include descender-depth overshoot position
and descender-depth, superior baseline overshoot position and superior baseline, and
ordinal baseline overshoot position and ordinal baseline. Up to five pairs (10 integers)
may be specified in the OtherBlues array. When decoded out of deltaArray format,
numbers in a pair must be in ascending order; in a variable font, blended values must
remain in ascending order for all instances. Pairs must be at least 3 units apart from all
other pairs, including those in the BlueValues array. (This minimum distance can be
modified by the optional BlueFuzz entry in the PrivateDICT.) The restriction for the
BlueValues array on the maximum difference in a pair also applies to the OtherBlues
array.
FamilyBlues
ﾉ

Encoding

0x08 (8)

Stack

[ (<integer> <integer>)+ ] (numbers are a deltaArray)

Operands

[ (y1 y2)+ ]

Description

Family-wide vertical alignment zones.

Occurrence

Optional.

Blendable

no

Expand table

When different styles of the same font family are mixed in text, it is often desirable to
coordinate their x-heights, cap-heights, and other alignments so that they will be the
same at small sizes. For example, at 72 pixels per inch, the x-height of a 10-point roman
face might be 5.4 pixels while the boldface x-height might be 5.6 pixels. If the roman
face is the regular for the family, the renderer can render both faces with an x-height of
5 pixels instead of letting the boldface jump to 6 while the roman is still at 5. However,
at 100 points, the roman x-height will be 54 pixels and the bold x-height will be 56.
A font designer can include information about the dominant alignment zones in a font
family so that this consistency can be enforced. When enabled, if the difference between
a font’s alignment and its family’s standard alignment is less than 1 pixel, then the
renderer will use the standard alignment instead of the normal alignment for that font.

Thus at 10 points in the previous example, the difference is 5.6 − 5.4 = 0.2 pixels, so the
family x-height is used. At 100 points, the difference is 56 − 54 = 2, so the specific xheight for the font is used. Family alignment values are identical to individual font
alignment values; that is, they are things like x-height, x-height overshoot, etc.
Two PrivateDICT entries for family alignment zones can be used:
The value associated with FamilyBlues is an array containing an even number of
integers taken in pairs. The rules governing the contents of this array are
analogous to those of the BlueValues array.
The value associated with FamilyOtherBlues (described next) is an array containing
an even number of integers taken in pairs. The rules governing the contents of this
array are analogous to those of the OtherBlues array.
Typically, the FamilyBlues and FamilyOtherBlues entries will simply be copied from the
BlueValues and OtherBlues of the regular face in the family. Each font in a family
(except the regular) must have these entries if it is to have family alignment properties.
Of course, if these entries are not present, then only a font’s own alignment hints will be
considered.
FamilyOtherBlues
ﾉ

Expand table

Encoding

0x09 (9)

Stack

[ (<integer> <integer>)+ ] (numbers are a deltaArray)

Operands

[ (y1 y2)+ ]

Description

Family-wide bottom alignment zones. See FamilyBlues, above, for more
information.

Occurrence

Optional.

Blendable

no

BlueScale
ﾉ

Encoding

0x0c09 (12,9)

Stack

[ <number> ]

Operands

[ yPix ]

Expand table

Default

0.039625

Description

Text size at which to deactivate overshoot suppression.

Occurrence

Optional. The default value is used if omitted.

Blendable

no

The optional BlueScale entry in the PrivateDICT controls the text size (“point size”) at
which overshoot suppression ceases. This size varies with the number of device pixels
per inch available on the device where the font is being rendered.
For point sizes that occupy fewer device pixels than the BlueScale value results in
for a given device, overshoot suppression is performed. All features falling in an
alignment zone are rendered at the same pixel height.
For point sizes that occupy the same or a greater number of device pixels than the
BlueScale value results in, overshoot suppression is turned off, thus allowing
overshoots to occur.
(This behavior may be modified by the optional BlueShift setting—see below.)
The BlueScale value is a number directly related to the number of pixels tall that one
glyph space unit will be before overshoot suppression is turned off. The default value of
BlueScale is 0.039625, which corresponds to 10 points at 300 dpi. (Thus if that value is
acceptable, a PrivateDICT does not need to define BlueScale.) A simple formula that
relates point size as rendered on a 300-dpi device to the BlueScale value is:
BlueScale = (pointsize − 0.49) / 240
The formula provides a convenient number that font producers can use to determine at
what integer point size overshoot suppression should be off. However, the exact point
size at which overshoot suppression ceases is actually 0.49 points less (at 9.51 points
using the default value of BlueScale) than the value of pointsize used in the formula. The
adjustment shown in the formula is recommended so that the change in overshoot
suppression behavior occurs at an exact point size unlikely to be used in practice.
For example, if you wish overshoot suppression to turn off at 11 points on a 300-dpi
device, you should set BlueScale to (11 − 0.49) / 240, or 0.04379. With this one setting
of BlueScale, overshoot suppression will turn off at proportionately smaller point sizes
on higher resolution output devices or larger point sizes on lower-resolution devices
such as displays.
BlueShift

ﾉ

Expand table

Encoding

0x0c0a (12,10)

Stack

[ <integer> ]

Operands

[ dy ]

Default

7

Description

Overshoot enforcement.

Occurrence

Optional, but relevant even if CharString flex operators are not used.

Blendable

no

The optional BlueShift entry in the PrivateDICT adds another capability to the treatment
of overshoot behavior. The value of BlueShift is an integer that indicates a glyph space
distance beyond the flat position of alignment zones at which overshoot enforcement
for glyph features occurs. The default value of BlueShift is 7. The single setting of
BlueShift applies to all alignment zones, regardless of where their overshoot positions
lie.
When a glyph’s size is less than that expressed by BlueScale, glyph features that fall
within alignment zones have their overshoots suppressed. For glyphs larger than the
BlueScale size, glyph features that fall beyond the flat position of an alignment zone
(above for top zones, below for bottom-zones) by a glyph space distance equal to or
greater than the value of BlueShift will overshoot, while glyph features closer to the flat
position than the BlueShift value will overshoot only if their device space distance is at
least one-half pixel.
If one or more flex operators occurs in any CharStrings using the current PrivateDICT
(that is, any of flex, hflex, hflex1, flex1), then the BlueShift value must be greater than
flex depth. Since the default value of BlueShift is 7, this entry must be set explicitly if flex
depth is greater than than 6. For example, if flex depth is 8, then set BlueShift to 9. If flex
depth is 6 or less, then BlueShift can be omitted.
BlueFuzz
ﾉ

Encoding

0x0c0b (12,11)

Stack

[ <integer> ]

Operands

[ dy ]

Expand table

Default

1

Description

Extends the range of alignment zones.

Occurrence

Optional.

Blendable

no

The optional BlueFuzz entry in the PrivateDICT is an integer value that specifies the
number of glyph space units to extend (in both directions) the effect of an alignment
zone on a horizontal stem. If the top of a horizontal stem is within BlueFuzz units (in
glyph space) outside of a top zone, the interpreter will act as if the stem top were
actually within the zone; the same holds for the bottoms of horizontal stems in bottomzones. The default value of BlueFuzz is 1.
BlueFuzz has been a convenient means for compensating for slightly inaccurate
coordinate data. The effect of a non-zero value for BlueFuzz can usually be better
achieved by adjusting the sizes of the alignment zones. New fonts should not rely on it
and disable the feature by explicitly setting BlueFuzz to 0 in the PrivateDICT.
Because a non-zero value for BlueFuzz extends the range of alignment zones, alignment
zones will be declared at least (2 × BlueFuzz + 1) units apart from each other. Therefore,
a default BlueFuzz value of 1 implies that alignment zones should be at least 3 units
apart from each other.
StdHW

Encoding

0x0a (10)

Stack

[ <number> ]

Operands

[ dx ]

Description

Dominant horizontal stem width.

Occurrence

Optional.

Blendable

yes

ﾉ

Expand table

ﾉ

Expand table

StdVW

Encoding

0x0b (11)

Stack

[ <number> ]

Operands

[ dy ]

Description

Dominant vertical stem width.

Occurrence

Optional.

Blendable

yes

StemSnapH

Encoding

0x0c0c (12,12)

Stack

[ <number>+ ] (numbers are a deltaArray)

Operands

[ dx+ ]

Description

Array of common horizontal stem widths.

Occurrence

Optional.

Blendable

yes

ﾉ

Expand table

ﾉ

Expand table

StemSnapV

Encoding

0x0c0d (12,13)

Stack

[ <number>+ ] (numbers are a deltaArray)

Operands

[ dy+ ]

Description

Array of common vertical stem widths.

Occurrence

Optional.

Blendable

yes

Stem Width Information, controlled by these 4 operators, is a mechanism to tell the
renderer about standard stem widths in a font so that the renderer can ensure
consistency at small sizes. If a particular stem is slightly wider or narrower than standard,
either by design or as a result of a small error in creating the font, then at small sizes
where a single pixel difference would be very noticeable, the renderer can render the
stem as though it had the standard width. However, at large sizes where a single pixel

difference will produce only a subtle visual effect, the stem will be allowed to deviate
from the standard.
When the difference between a standard stem width and a particular stem width is
small, the standard width is used. For example, if at 10 points a standard stem width
corresponds to 1.4 pixels wide and a particular stem is 1.6 pixels wide, both can be
rendered as a 1-pixel wide stem. However, at 100 points the standard stem would be
rendered as 14 pixels wide and the particular stem would be rendered as 16 pixels wide.
The information that the renderer needs appears in the following PrivateDICT entries.
StdHW takes a number expressing the dominant width of horizontal stems
(measured vertically in font design units). The operand (including a blended value
in a variable font) must be non-negative.
StdVW takes a number expressing the dominant width of vertical stems (measured
horizontally in font design units). The operand (including a blended value in a
variable font) must be non-negative. Typically, this will be the width of straight
stems in lower case letters. (For an italic font, give the width of the vertical stem
measured at an angle perpendicular to the stem direction.)
StemSnapH is an array of up to 12 numbers of the most common widths
(including the dominant width given in StdHW) for horizontal stems (measured
vertically). These widths must be sorted in increasing order.
StemSnapV is an array of up to 12 numbers of the most common widths (including
the dominant width given in the StdVW) for vertical stems (measured horizontally).
These widths must be sorted in increasing order. For example, a designer might
include widths for straight and curved stems in uppercase and lowercase letters.
For an italic font, this array should be empty.
Note: The ordering requirement for StemSnapH and StemSnapV applies to the
values encoded as operands. The order is not semantically significant, but some
implementations could expect values to be ordered for searching purposes. In a
variable font, if the operand values are blended, blending could potentially result in
derived values that are not in increasing order for some variation instances. If an
implementation requires stem width values in its memory representation to be
sorted, it could be necessary to re-sort the stems after blended values are obtained.
If these Stem Width Information hints are not present in the PrivateDICT, then each stem
is rendered according to its own definition in the CharString (as modified by any other
CharString hints).
LanguageGroup

ﾉ

Encoding

0x0c11 (12,17)

Stack

[ <integer> ]

Operands

[ group ]

Default

0

Description

Identifies the language group of glyphs.

Occurrence

Optional. Default to zero if omitted.

Blendable

no

Expand table

Certain groups of written languages share broad aesthetic characteristics. Identification
of such language groups can prove useful for accurate glyph rendering.
The value of the entry LanguageGroup is an integer that indicates the language group
of the CharStrings (glyphs) using this PrivateDICT. If the PrivateDICT does not contain
this entry, or if the given value is not recognized, then the value of LanguageGroup
defaults to zero.
Two language groups are defined:
Group 0 consists of languages that use Latin, Greek, Cyrillic, and similar scripts.
Since the value of the LanguageGroup entry defaults to 0, a PrivateDICT
containing glyphs corresponding to one of these languages does not need to
contain this entry.
Group 1 consists of Chinese ideographs and similar character sets, including
Japanese Kanji and Korean Hangul. A PrivateDICT that contains glyphs
corresponding to one of these languages should define LanguageGroup.
ExpansionFactor
ﾉ

Encoding

0x0c12 (12,18)

Stack

[ <number> ]

Operands

[ dSize ]

Default

0.06

Description

Provides control over rendering of counters.

Expand table

Occurrence

Optional.

Blendable

no

The optional ExpansionFactor entry is a real number that gives a limit for changing the
size of a glyph bounding box during the processing that adjusts the sizes of counters in
glyphs of LanguageGroup 1. The default value of ExpansionFactor is 0.06. At small point
sizes or low resolutions, the system may have to accept irregular counters rather than
violate this limit. Bar code fonts or logos that need counter control could benefit by
setting LanguageGroup to 1 and increasing the ExpansionFactor limit to a larger
amount such as 0.5 or more.

Operator ordering restrictions
The OtherBlues operator, if used, must occur after the BlueValues operator.
The FamilyOtherBlues operator, if used, must occur after the FamilyBlues operator.

CharString
Overview
The CharString format provides a method for compact encoding of glyphs, including
path data, hint data and variation data. The CFF2 CharString specification updates
previous definitions of CharString, including that used for the 'CFF ' table, and is
intended for use only within a CFF2 table in an OpenType font file. See Comparison of
'glyf', 'CFF ' and CFF2 tables for a summary of differences between CFF and CFF2
CharStrings.
A CharString is a binary data block, similar to a DICT in that it consists of a sequence of
encoded numbers and operators to be decoded using a stack. (See Decoding DICT and
CharString data using a stack for details.) The maximum length of a CharString is 65535
bytes.
There is one CharString for each glyph in a font. The CharStrings for a font are stored in
a CharStringINDEX table. Some data used by CharStrings is stored in other parts of the
CFF2 table. In particular:
Hinting metadata is stored in one or more PrivateDICT tables. See PrivateDICT for
more information.

Encoded data common to multiple CharStrings can be implemented as
subroutines. Subroutines are stored either in the GlobalSubrINDEX or in a
LocalSubrINDEX within a PrivateDICT. See Subroutines for more information.
Horizontal and vertical glyph metrics are stored in the 'hmtx' and 'vmtx' tables. In a
variable font, glyph metrics can undergo variations using the HVAR and VVAR tables.
Note: CFF2 CharStrings are different from the 'CFF ' table in this regard: in the 'CFF '
table, glyph metrics can be specified within each CharString.

CharStringINDEX
The CharStringINDEX is an INDEX that contains the CharStrings for all CFF2 glyphs in the
font. The location of the CharStringINDEX is specified by the CharStringINDEXOffset key
in the TopDICT table. Each CharString is accessed by glyph ID. The first CharString (glyph
ID 0) must be the .notdef glyph. The number of glyphs defined in the CFF2 table can be
determined from the CharStringINDEX count field. The value of this field must match the
value of the numGlyphs field in the 'maxp' table.
Non-printing glyphs
Non-printing glyphs, such as the space character, require no path, hinting or variation
data. Therefore, no CharString data is stored. In the CharStringINDEX, the offset for such
an empty CharString is identical to the offset for the subsequent CharString.

CharString concepts
Hints
CFF2 hints aid the rasterizer in recognizing and controlling stems and counter areas
within a glyph to provide a more consistent appearance at different sizes. The effects of
hint operators in a CharString are also conditioned by hinting metadata in a PrivateDICT
(see PrivateDICT hinting operators).
Hint operators in a CharString specify horizontal and vertical regions that require special
treatment. Hint stem operators (hstem, vstem, hstemhm and vstemhm) define
horizontal or vertical hints for stems and edges. A hint counter operator (cntrmask)
defines gaps between stems, specified in terms of horizontal or vertical stems on
opposite sides of the counter.
Hints must be specified at the start of a CharString in the following order:

horizontal stems and edges using hstem or hstemhm operators
vertical stems and edges using vstem or vstemhm operators
counters using the cntrmask operator
One or more operators of each type may be used, and each type is optional. If a counter
is specified, however, it requires two stems of the same orientation to be defined.
Overlapping stems
In some glyphs, two or more stems can overlap. This is illustrated in the following figure.

Overlapping horizontal stems
If overlapping stems are defined, it could cause problems for a rasterizer as it decides
how to control points on the pixel grid. For such cases, the hintmask operator is used to
specify which stems are active for subsequent path construction operations. If stems
overlap but these zones are not controlled using hintmask, the results are undefined.
If the hintmask operator is used within a CharString, then stems must be defined using
the hstemhm and vstemhm operators, rather than hstem and vstem.
See Hint operators for more information and examples.
Stem hint encoding
Stems are features with two edges. Stem hints are, accordingly, defined by pairs of
numbers: the bottom edge followed by the top edge for a horizontal stem, and the left
edge followed by the right edge for a vertical stem. When encoding multiple stems, they
must be encoded in ascending order as follows:
Sort the pairs by the position of the first edge in each pair: bottom for horizontal
stems, and left for vertical stems.
Concatenate the pairs into a sequence of numbers.
Represent the numbers using relative values: the first number is relative to 0, and
all subsequence numbers are relative to the previous number.

For example, consider a sans-serif glyph “E” with cap-height of 700 and with three
horizontal stems whose y coordinates are: 0 and 80, 310 and 390, 620 and 700. These
stems can be defined as:
0 80 230 80 230 80 hstem
Notice that the second number in each pair represents a stem width greater than zero.
In a variable font, the values that define a stem may be blended, but additional
considerations apply. See Blended stem and edge hints for more information.
Edge hints
In some situations, a glyph may have an edge that is not part of a stem but that needs
to align with a stem in other glyphs. For example, consider the glyph for a sans-serif “E”,
with three horizontal stems as described above. In the same font, we want to control
features in other glyphs that align vertically with the stems of the “E” but do not have a
suitable horizontal stem. For example, the glyph “L”: it has a lower stem as for “E”, but
has a top edge without a stem that should align with the top edge of the top stem of
“E”. Likewise, “F” has a bottom edge that would benefit by alignment with the bottom
edge of the bottom stem of “E”.
For such cases, an edge hint can be used. An edge hint is defined using the stem
operators but by specifying a special negative width:
a width of -21 defines a left edge or a bottom edge;
a width of -20 defines a right edge or a top edge.
If interpreted as a pair of edges, a negative width would imply that the second edge of
the pair is lower or farther left than the first edge of the pair. When deriving the
coordinates of an edge, the leftmost or lowest implied edges are used for left and
bottom edges, while the rightmost or highest implied edges are used for right and top
edge. Thus, for a left or bottom edge, the initial edge value and the negative width value
are combined to derive the edge hint coordinate, while for a right or top edge, only the
initial edge value is used. So, for example, to define a bottom edge at 100, the encoded
representation would use the values 121 -21; to define a top edge at 700, the encoded
representation would be 700 -20.
Because the width value of an edge hint represents left, bottom, top or right rather than
an actual measurement, edge hints are never considered to overlap other stems.
Edge hints are encoded together with stems, in ascending order. For purposes of
sorting, left and bottom edges are sorted based on the actual edge coordinate, not the

first value used to encode the edge hint (for instance, 100 in the previous bottom edge
example, not 121).
Example
Consider the following figure.

Encoding of edge hints
The glyph in this figure has a bottom edge at 100 and top edge at 500. To specify edge
hints for these two edges, the encoding would be:
121 -21 400 -20 hstem
Example
Consider the case mentioned earlier with sans-serif “E”, “L” and “F”. The bottom stem
and top edge of “L” can be specified as follows:
0 80 620 -20 hstem

Likewise, the bottom edge and top stem of “F” can be specified as follows:
21 -21 620 80 hstem
In a variable font, the first value of an edge may be blended, but the special "width"
operands must not be blended. See Blended stem and edge hints for more information.
Implied vertical stem operators
The vstem and vstemhm operators have the unusual property that, in special cases, they
may be omitted from a CharString to save one byte of data. These cases (which are in
fact relatively common in fonts) require both horizontal and vertical stems to be
defined, and for those definitions to be followed immediately by a cntrmask or
hintmask operator.

Paths
Path data in a CharString describes the glyph outline in terms of one or more contours,
where each contour has a start point followed by one or more line segments and cubic
Bézier curves. The number of contours in a glyph and the number of line and curve
segments within each contour are limited only by the maximum CharString length
(65535) and the maximum number of operands on the stack (513).
Several path operators are defined and are of three types:
moveto operators start a new contour at a specified point;
lineto operators append a line segment to the current contour from the current
point to a specified end point;
curveto operators append a cubic Bézier curve to the current contour from the
current point to a specified end point, with two specified off-curve control points.
The number of items on the stack can trigger multiple sequential path operations of the
same type; for example, a single lineto operator can produce three line segments if the
stack contains operands for three end points. Some operators combine curve and line
specifications in a single operation.
The current point is initially at (0, 0) and is updated after each path operation.
All moveto, lineto and curveto operators use relative coordinates: each point is defined
as a relative coordinate offset from the point before it. This rule also applies to the three
points of a curve operation, where the first specified point is relative to the current
point, the second is relative to the first, and the third is relative to the second. After any
path construction operation, the current point is then set to the last of the given points.

Coordinates for path operations are typically integers. Fixed 16.16 format coordinates
are permitted but require significantly more CharString data.
Closing contours
All contours must be closed with a lineto operation. If the current contour is open when
a moveto operation is encountered, the path will be closed with an implicit lineto
operation to draw a line segment to the position specified by the previous moveto
operation that started the contour. Similarly, if the last explicit operation is a curveto
operation, an implicit lineto operation will be inserted, even if the ending position for
the curve was the starting position of the contour. The implicit lineto operation does not
change the current position.
Note: In a variable font, care is needed when the start position of a contour is
blended (varied using a blend operator) and the contour is explicitly closed with a
final curveto operator. If the final explicit position does not vary in exactly the same
way as the starting position, then a line segment will be inserted into the contour,
connecting the last point to the start point.
Path direction
A contour that is to be filled must be defined in a counterclockwise orientation. A
contour that is to be left unfilled must be defined in a clockwise orientation. If you
imagine walking along a contour in the direction it is defined, then the filled area will be
on your left.
Note: These orientations are opposite to those used for TrueType outlines in the
'glyf' table.
Unlike CharStrings in the 'CFF ' table, overlapping contours are supported in CFF2
CharStrings. CFF2 renderers must use a non-zero winding rule (see below), not an evenodd rule as used for CFF CharStrings. Thus, for example, a counterclockwise contour
completely inside another counterclockwise contour does not introduce any
transparency; both contours are filled. This behavior is necessary to support variable
font data, where the use of overlapping contours is common. Care is required, therefore,
when converting CFF2 CharString data into CFF CharStrings (or any other outline format
that uses the even-odd rule), such as by using an overlap removal operation.
The non-zero winding rule is used to determine which areas of the surface are filled as
follows: For a given point on the surface, draw a ray from that point toward infinity in
any direction. Then follow that ray from the point noting when a glyph contour line is
crossed. Starting with a count of zero, add one each time the ray crosses a contour line

that goes in a clockwise direction, and subtract one each time it crosses a contour line
that goes counterclockwise. If the final count is non-zero, the point is within an area that
is filled.
Flex
The flex mechanism is provided to improve the rendering of shallow curves at small
sizes, causing them to appear as line segments rather than resulting in small humps or
dents in the glyph shape. The flex mechanism can be used for curved glyph features, in
any orientation or depth, that meet the following requirements:
The curved feature can be represented as exactly two curves, drawn by two
rrcurveto operators.
The curves must meet at a common point (the joining point).
The length of the combined curve must exceed its depth.
See the flex, flex1, hflex and hflex1 operator descriptions for more information and
examples.

Subroutines
A subroutine is a portion of CharString data that can be invoked (or “called”) from within
other CharString data. Multiple CharStrings can efficiently call the same subroutine,
thereby achieving significant data size savings.
An example of a subroutine could be data that describes a diacritic or serif shape that is
identical in multiple glyphs. In practice, the identification of portions of CharString data
suitable for becoming subroutines is usually automated. There are no restrictions on
how CharString data may be split into subroutines; subroutines do not need to
represent complete contours, or even a complete set of operands with their operator.
CFF2 compilers use subroutines to minimize file size. Use of subroutines is not
mandatory, however. Faster compilation could be possible by avoiding subroutines, and
in some situations could even result in a smaller file size in subsequent file compression
steps.
There are two types of subroutines:
Global subroutines are stored in the GlobalSubrINDEX and may be called by any
CharString or subroutine.
Local subroutines are stored in a LocalSubrINDEX within a PrivateDICT and may
only be called by CharStrings that have access to that PrivateDICT, or by
subroutines within the same LocalSubrINDEX.

Any CharString may use both types of subroutine.
Nesting of subroutines (one subroutine calling another subroutine) is allowed up to a
maximum of 10 levels. Recursion (one subroutine calling itself, or being called by any
subroutine in its nested subroutine chain) is not allowed.
The GlobalSubrINDEX and LocalSubrINDEX structures use the INDEX format—see INDEX
data.
Every CFF2 table includes a GlobalSubrINDEX, which is at a fixed location immediately
following the TopDICT subtable. (See Organization of the CFF2 table.) If there are no
global subroutines to be stored, then an empty GlobalSubrINDEX is required (that is, the
count of elements is zero).
A LocalSubrINDEX is contained within a PrivateDICT at a location specified by the
LocalSubrINDEXOffset key—see PrivateDICT subroutine operator.
Calling subroutines and subroutine bias
Local subroutines are invoked using the callsubr operator; global subroutines are
invoked using the callgsubr operator. Both operators take a single operand that is a
biased index into the subroutine array of the corresponding INDEX. The operand must
be added to a subroutine bias value to derive the array index. The bias is calculated for
each subroutine INDEX based on nSubrs—the number of subroutines (the INDEX count)
in the given INDEX—as follows:
If nSubrs is in the range [0,1239], then bias = 107.
If nSubrs is in the range [1240,33899], then bias = 1131.
If nSubrs is >= 33900, then bias = 32768.
This technique allows subroutine identifiers to be specified using negative as well as
positive numbers, efficiently utilizing the available number ranges to reduce the size of
data.
Subroutines and the stack
Unlike most operators, the callsubr and callgsubr operators do not clear the stack. For
example, a subroutine could be called to push certain operands onto the stack; then,
after the subroutine returns, a subsequent path drawing operator could use the
operands placed on the stack by the subroutine.
Implementing subroutines with a “return stack”
A CFF2 decoder must keep track of the location within CharString data to which a
subroutine returns after it is completed. The return location is the byte immediately after

the callsubr or callgsubr operator that called the subroutine. Because of potential
nesting, this could be within CharString data in the CharStringINDEX, or within a
segment of CharString data in another subroutine. It is recommended to implement a
“return stack” so that a chain of multiple return locations can be tracked. Care is
required to check whether the return location is beyond the end of the CharString or
subroutine data from which the subroutine was called. If so, the decoder must perform
one or more extra “return” steps (if the subroutine was called from another subroutine)
or terminate decoding (if the subroutine was called from a CharString).

CharString organization
A complete CharString has the following structure:
hs* vs* cm* hm* {mt <path constructing data>}*
That is,
zero or more horizontal stem hints (using hstem or hstemhm operators), followed
by
zero or more vertical stem hints (using vstem or vstemhm operators), followed by
zero or more counter hints (using the cntrmask operator), followed by
zero or more hintmask operations, followed by
path data for zero or more contours.
The data for each contour beings with a moveto operation followed by any number of
line or curve operations. Within the path constructing data, there can be any number of
hintmask operations to control which stems are active.
In a variable font, the blend operator may be used in any of the path constructing
operations, or in any of the hint operations except hintmask or cntrmask. Only one set
of variation regions (specified using a vsindex operator) is used for a given CharString.
(See Variation operators for other restrictions on the blend and vsindex operators.)
Any portion of the CharString data may be packaged as a subroutine.

CharString operators
CharString operator summary
The following table lists all valid CharString operators, together with their byte encoding
(hexadecimal and decimal), their general purpose, whether their operands may be
blended (variable), and whether they clear the stack.

ﾉ

Expand table

Hex

Dec

Name

Purpose

Blendable

Clears stack

0x15

21

rmoveto

paths

yes

yes

0x16

22

hmoveto

paths

yes

yes

0x04

4

vmoveto

paths

yes

yes

0x05

5

rlineto

paths

yes

yes

0x06

6

hlineto

paths

yes

yes

0x07

7

vlineto

paths

yes

yes

0x08

8

rrcurveto

paths

yes

yes

0x1b

27

hhcurveto

paths

yes

yes

0x1a

26

vvcurveto

paths

yes

yes

0x1f

31

hvcurveto

paths

yes

yes

0x1e

30

vhcurveto

paths

yes

yes

0x18

24

rcurveline

paths

yes

yes

0x19

25

rlinecurve

paths

yes

yes

0x0c 0x23

12 35

flex

paths

yes

yes

0x0c 0x22

12 34

hflex

paths

yes

yes

0x0c 0x24

12 36

hflex1

paths

yes

yes

0x0c 0x25

12 37

flex1

paths

yes

yes

0x01

1

hstem

hinting

yes

yes

0x03

3

vstem

hinting

yes

yes

0x12

18

hstemhm

hinting

yes

yes

0x17

23

vstemhm

hinting

yes

yes

0x13

19

hintmask

hinting

no

yes

0x14

20

cntrmask

hinting

no

yes

0x0a

10

callsubr

subroutines

no

no

0x1d

29

callgsubr

subroutines

no

no

Hex

Dec

Name

Purpose

Blendable

Clears stack

0x0f

15

vsindex

variation

no

yes

0x10

16

blend

variation

yes

no

CharString path operators
The operands for all path operators may be integer or real values.

Operators that move the current point and start a new contour
rmoveto
ﾉ

Expand table

Encoding

0x15 (21)

Stack
operands

[ dx1 dy1 ]

Description

Moves the current point to a position at the relative coordinates (dx1, dy1) and
starts a new contour.

Blendable

yes

hmoveto
ﾉ

Expand table

Encoding

0x16 (22)

Stack
operands

[ dx ]

Description

Moves the current point dx units in the horizontal direction and starts a new
contour.

Blendable

yes

vmoveto
ﾉ

Encoding

0x04 (4)

Expand table

Stack
operands

[ dy ]

Description

Moves the current point dy units in the vertical direction and starts a new
contour.

Blendable

yes

Path operators that draw line segments
rlineto
ﾉ

Expand table

Encoding

0x05 (5)

Stack
operands

[ (dx dy)+ ]

Description

Appends a line segment from the current point to a position at the relative
coordinates (dx, dy). Additional rlineto operations are performed for all
subsequent argument pairs. The number of arguments must be even, and the
number of lines is determined from the number of arguments on the stack.

Blendable

yes

hlineto
ﾉ

Encoding

0x06 (6)

Stack

[ d+ ]

Expand table

operands
Description

Appends a horizontal line segment from the current point to a position at the
relative coordinates (d, 0). When multiple arguments are used, additional line
segments are appended in alternating vertical and horizontal orientations. Thus,
the second argument appends a vertical line from the end of the previous line to
the relative coordinates (0, d), the third argument appends a horizontal line to the
relative coordinates (d, 0), and so on. The number of line segments is determined
from the number of arguments on the stack.
A contour that consists of only horizontal and vertical lines can be constructed
using one of the moveto operators and a single hlineto operator, with the number
of line segments limited only by the size of the stack.

Blendable

yes

vlineto
ﾉ

Expand table

Encoding

0x07 (7)

OperStack
operands

[ d+ ]

Description

Appends a vertical line segment from the current point to a position at the
relative coordinates (0, d). As with hlineto, when multiple arguments are used,
the orientation alternates for each additional argument.

Blendable

yes

Path operators that draw curves
rrcurveto
ﾉ

Expand table

Encoding

0x08 (8)

Stack
operands

[ (dxa dya dxb dyb dxc dyc)+ ]

Description

Appends a cubic Bézier curve, defined by the points p0, p1, p2, p3 where p0 is
located at the current point, p1 is the first off-curve point given by the relative
coordinates (dxa, dya), p2 is the second off-curve point given by the relative
coordinates (dxb, dyb) and p3 is the end point given by the relative coordinates
(dxc, dyc). The location of each point is defined relative to the preceding one. For
each subsequent set of six arguments, an additional curve is appended to the
previous curve segment. The number of curve segments is determined from the
number of arguments on the stack and is limited only by the size of the stack.

Blendable

yes

hhcurveto
ﾉ

Encoding

0x1b (27)

Stack

[ <number>+ ]

Stack

[ dya? {dxa dxb dyb dxc}+ ]

operands

Expand table

Description

Appends one or more Bézier curves starting from the current point, as described
by the dxa…dxc set(s) of arguments. If the argument count is a multiple of four, the
curve starts and ends with horizontal tangents. For each curve segment, the first
off-curve point is given by relative coordinates (dxa, 0), the second off-curve point
is given by relative coordinates (dxb, dyb), and the end point is given by relative
coordinates (dxc, 0)
If the argument count is one more than a multiple of four, the first curve does not
begin with a horizontal tangent and dya is given by the first argument; thus the
first off-curve point is at (dxa, dya) relative to the current point. This option is
available only for the first curve segment.

Blendable

yes

vvcurveto
ﾉ

Expand table

Encoding

0x1b (27)

Stack
operands

[ dxa? {dya dxb dyb dyc}+ ]

Description

Appends one or more Bézier curves starting from the current point, as described
by the dya…dyc set(s) of arguments. This operator is the vertical counterpart to
hhcurveto. If the argument count is a multiple of four, the curve starts and ends
vertical. If the argument count is one more than a multiple of four, the first curve
segement does not begin with a vertical tangent and its dxa value is given by the
first argument.

Blendable

yes

hvcurveto
ﾉ

Expand table

Encoding

0x1f (31)

Stack
operands

[ dx1 dx2 dy2 dy3 dx3? ]
[ (dxa dxb dyb dyc dyd dxe dye dxf)+ dyf? ]
[ dx1 dx2 dy2 dy3 (dya dxb dyb dxc dxd dxe dye dyf)* dxf? ]

Description

Appends one or more Bézier curves starting from the current point with start/end
tangents that alternate between horizontal and vertical: in the first curve segment,
the starting tangent is horizontal, and the ending tangent is vertical; if a second
curve segment is defined, it begins vertical and ends horizontal; if a third segment
is defined, it begins horizontal and ends vertical; and so on. If the argument count
is a multiple of four, the curve always begins horizontal and ends either vertical or
horizontal. If the argument count is one more than a multiple of four, then the

tangent of the final segment is overridden, with the optional extra argument
defining a non-zero coordinate.
Blendable

yes

vhcurveto
ﾉ

Expand table

Encoding

0x1e (30)

Stack

[ dy1 dx2 dy2 dx3 dy3? ]

operands

[ (dya dxb dyb dxc dxd dxe dye dyf)+ dxf? ]
[ dy1 dx2 dy2 dx3 (dxa dxb dyb dyc dyd dxe dye dxf)* dyf? ]

Description

Appends one or more Bézier curves starting from the current point with start/end
tangents that alternate between vertical and horizontal. This operator is a vertical
counterpart to hvcurveto: it always starts vertical and (with a multiple of four
arguments) ends either horizontal or vertical. An optional extra argment may be
used to override the orientation of the final tangent.

Blendable

yes

rcurveline
ﾉ

Expand table

Encoding

0x18 (24)

Stack
operands

[ (dxa dya dxb dyb dxc dyc)+ dxd dyd ]

Description

Appends a sequence of Bézier curves followed by a line. This is equivalent to one
rrcurveto for each set of six arguments dxa…dyc, followed by exactly one rlineto
using the dxd, dyd arguments. The number of curve segments is determined from
the count of arguments on the stack.

Blendable

yes

rlinecurve
ﾉ

Encoding

0x19 (25)

Stack
operands

[ (dxa dya)+ dxb dyb dxc dyc dxd dyd ]

Expand table

Description

Appends a sequence of lines followed by a Bézier curve. This is equivalent to one
rlineto for each pair of dxa, dya arguments preceding the six arguments dxb…dyd
needed for one rrcurveto operation. The number of line segments is determined
from the count of arguments on the stack.

Blendable

yes

Flex mechanism operators
Flex operators define two connected Bézier curve segments that will be rendered as a
straight line at small sizes when the flex depth is below a certain threshold value. The flex
depth is the distance from the joining point to a line drawn from the starting point of
the first curve to the ending point of the second curve, as shown in the following figure.

Curves constructed with a flex operator
If the combined curve is not exactly horizontal or vertical, determination of the flex
depth uses a method that depends on whether the curve is more horizontal or more
vertical, as illustrated in the following figure.

Flex depth calculations

A fully qualified list of operands for flex operations would comprise the 12 coordinates
dx1…dy6 plus a flex depth threshold operand fd. Some flex operators omit some of
these operands and can be used in cases where some of the points have the same x or y
coordinate. The preceding figure can be referenced when reading the descriptions for
the operators.
flex
ﾉ

Expand table

Encoding

0x0c 0x23 (12,35)

Stack
operands

[ dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 fd ]

Description

Appends two Bézier curves described by dx1…dy6. The operand fd specifies a flex
depth threshold in 1/100ths of a device pixel. The curves must be rendered as a
straight line when the flex depth is less than fd/100 device pixels, and as curved
lines when the flex depth is greater than or equal to fd/100 device pixels.

Blendable

yes

hflex
ﾉ

Expand table

Encoding

0x0c 0x22 (12,34)

Stack
operands

[ dx1 dx2 dy2 dx3 dx4 dx5 dx6 ]

Description

Appends two Bézier curves described by dx1…dx6. The curves must be rendered
as a straight line when the flex depth is less than 0.5 device pixels (threshold fd =
50 is implicit), and as curves when the flex depth is greater than or equal to 0.5
device pixels.

Blendable

yes

The hflex operator assumes a horizontal orientation and omits several coordinates from
its operands. It can be used when the following are all true:
The starting point, ending point, first control point and last control point all have
the same y coordinate.
The joining point and neighboring control points have the same y coordinate.
The flex depth threshold is 50.
hflex1

ﾉ

Expand table

Encoding

0x0c 0x24 (12,36)

Stack
operands

[ dx1 dy1 dx2 dy2 dx3 dx4 dx5 dy5 dx6 ]

Description

Appends two Bézier curves described by dx1…dx6. The curves must be rendered
as a straight line when the flex depth is less than 0.5 device pixels (threshold fd =
50 is implicit), and as curves when the flex depth is greater than or equal to 0.5
device pixels.

Blendable

yes

The hflex1 operator is similar to hflex in assuming a horizontal orientation but does not
constrain the starting and ending tangents to be horizontal. It can be used when the
following are all true:
The starting and ending points have the same y coordinate.
The joining point and neighboring control points have the same y coordinate.
The flex depth threshold is 50.
flex1
ﾉ

Expand table

Encoding

0x0c 0x25 (12,37)

Stack
operands

[ dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 d6 ]

Description

Appends two Bézier curves described by dx1…d6. The d6 operand will be
interpreted as either a dx or dy value depending on the combined curve—see
details below. The curves must be rendered as a straight line when the flex depth
is less than 0.5 device pixels (threshold fd = 50 is implicit), and as curves when the
flex depth is greater than or equal to 0.5 device pixels.

Blendable

yes

The interpretation of d6 as either dx6 or dy6 depends on the overall horizontal or
vertical orientation of the combined curve. This is determined by computing the vector
from the starting point (x,y) to the last control point specified by (dx5,dy5): sum the x
arguments dx1, dx2…dx5 and the y arguments dy1, dy2…dy5 to obtain the vector (dx,
dy). If abs(dx) > abs(dy), then d6 is interpreted as dx6. Else, d6 is interpreted as dy6.

CharString hint operators

See CharString concepts: Hints for an overview of hints as well as key concepts,
including the encoding of stem and edge hints.
hstem
ﾉ

Expand table

Encoding

0x01 (1)

Stack

[ (<number> <number>)+ ]

Operands

[ (y1 y2)+ ]

Description

Defines a sequence of non-overlapping horizontal stems for the CharString using
pairs of numbers, dy1, dy2, where dy1 is the bottom edge and dy2 is the width.

Blendable

yes

vstem
ﾉ

Expand table

Encoding

0x03 (3)

Stack

[ (<number> <number>)+ ]

Operands

[ (dx1 dx2)+ ]

Description

Defines a sequence of non-overlapping vertical stems for the CharString using
pairs of numbers, dx1, dx2, where dx1 is the left edge and dx2 is the width.

Blendable

yes

Stems defined using one or more hstem or vstem operators must not overlap and
cannot be used in conjunction with the hintmask operator.
hstemhm
ﾉ

Expand table

Encoding

0x012 (18)

Stack

[ (<number> <number>)+ ]

Operands

[ (dy1 dy2)+ ]

Description

Defines a sequence of horizontal stems for the CharString using pairs of numbers,
dy1, dy2, where dy1 is the bottom edge and dy2 is the width. Stems defined using

this operator may overlap.
Blendable

yes

vstemhm
ﾉ

Expand table

Encoding

0x017 (23)

Stack

[ (<number> <number>)+ ]

Operands

[ (dx1 dx2)+ ]

Description

Defines a sequence of vertical stems for the CharString using pairs of numbers, dx1,
dx2, where dx1 is the left edge and dx2 is the width. Stems defined using this
operator may overlap.

Blendable

yes

Stems defined using one or more hstemhm or vstemhm operators may overlap and
should be used in conjunction with the hintmask operator.
hintmask
ﾉ

Encoding

0x013 (19)

Stack

[-]

Operands

See below.

Description

Activates and deactivates stem hints within this CharString.

Blendable

no

Expand table

If any horizontal stems overlap or any vertical stems overlap, the hintmask operator
must be used to establish a non-overlapping subset of hints for a portion of the
CharString data. Rendering for path operators occurring after a hintmask is influenced
by the new set of active hints. The hintmask operator may be used any number of times
within a CharString.
The hintmask operator is exceptional in that it does not pop operands from the stack
but consumes bytes that come after it in the CharString data. The byte sequence is
interpreted as a bit field that flags each stem as active or inactive. The number of bytes
used depends on the total number of horizontal and vertical stem hints, numStems, that

were defined using the hstemhm and vstemhm operators. A whole number of bytes is
consumed; hence, there can be extra bits at the end of the bitfield that are unused. The
number of bytes used is 1 + floor( (numStems - 1) /8 ). The bytes are treated in bigendian order: the high-order bit is a flag for the first stem hint, and so on. A stem hint is
active if the corresponding bit is 1, and inactive if the bit is 0. All unused bits must be 0.
The hintmask operator must not be used unless the CharString also defines stems using
hstemhm or vstemhm.
Example
Suppose a CharString has 17 hints in total. Three bytes are consumed by each use of
hintmask. To activate hints 1, 3 and 9 while deactivating other hints, the bit field
required is: 01010000 01000000 00000000; thus, the three bytes 0x404000 immediately
follow the hintmask operator in the data.
Example
Consider the following figure that shows part of a glyph with horizontal and vertical
stems with the horizontal stems overlapping.

Stems with overlaps

The horizontal stems are from 280 to 380 (hstem1) and from 310 to 350 (hstem2).
Because they overlap, they must be defined using hstemhm, and use of the hintmask
operator will be required to select one or the other as active. The glyph also has a
vertical stem, from 400 to 450 (vstem1). Because hintmask will be used, the vertical stem
must be defined using vstemhm, even though this stem does not overlap another
vertical stem.
Suppose only these three stems are defined. They will be defined in the order hstem1,
hstem2, then vstem1. The hintmask operator will require a bit field of three bits and so
will consume one byte that follows it in the data.
Now suppose the outline is being constructed in a counterclockwise direction starting
with the horizontal line segment ending at (400, 310). The first group of stem hints that
need to be active are those for hstem2 and vstem1. The bit field data required to select
those hints will be 01100000 (padded with five extra bits), hence a byte 0x60. The stem
hint and hint mask encoding will be as follows.
280 100 -70 40 hstemhm 400 50 vstemhm hintmask 0x60
Since both horizontal and vertical stems are defined and the hintmask operator is used,
the vstemhm operator can be invoked implicitly and omitted from the CharString,
shortening this portion of the CharString to the following.
280 100 -70 40 hstemhm 400 50 hintmask 0x60
cntrmask
ﾉ

Expand table

Encoding

0x014 (20)

Stack

[-]

Operands

See below.

Description

Specifies the counter spaces to be controlled, and their relative priority.

Blendable

no

Counter definitions depend on stem definitions (already defined using hstem, vstem,
hstemhm or vstemhm). A counter is defined by specifying a group of stems that delimit
the counter. Two stems are required to define a counter. When cntrmask is used, more
than two stems may be specified in order to define multiple counters.

Multiple cntrmask operators can be used in a CharString when sets of counters are to
be treated with different priority. Counters defined by the first cntrmask have top
priority; subsequent cntrmask operators specify lower priority counters.
As with hintmask, the cntrmask operator does not pop operands from the stack.
Instead, it consumes bytes that come after it in the data that are interpreted as a bit field
of flags indicating which stems from the complete list of stems are used. See the
[hintmask] operator description for details on how these bytes are encoded. The set of
hints selected must not overlap.
Example
Consider the following figure, showing a glyph with multiple stems and counters.

Horizontal and vertical stems that delimit counters
Horizontal stems must be defined before vertical stems, and in each case must be
defined in increasing upward or rightward order. Thus, the complete list of stems would
be:
H1 H2 H3 H4 H5 H6 H7 H8 V1 V2 V3 V4 V5
With 13 stems defined, the cntrmask operator will evaluate a bit field of 13 bits; the data
consumed will be extended to two bytes with three additional bits unused.

A designer could wish to assert that the counters in the right half of the glyph should
maintain their vertical proportions as far as possible, and that the two principal
horizontal counter widths should also maintain their relative proportion. These counters
are represented by selecting the following set of stems:
H1 H3 H4 H6 H8 V1 V2 V3 V5
One could also wish to assert that the counters in the left half of the glyph should
maintain their vertical proportions as far as possible, but not at the cost of affecting
previously defined counters. That second set of counters would be represented by
selecting the following stems:
H2 H5 H7
Stem V4 in this example does not delimit a useful counter space and, so, is not
referenced.
The following cntrmask commands would be used to encode these requirements:
cntrmask 0xB5 0xE8
cntrmask 0x4A 0x00

CharString subroutine operators
callsubr
ﾉ

Expand table

Encoding

0x0a (10)

Stack

[ … <integer> ]

Operands

[ … subr# ]

Description

Calls the subroutine in LocalSubrINDEX with the index determined by subr#. This
operand must be added to the subroutine bias number before being used as the
index. See CharString concepts: Subroutines for details on calculation of the
subroutine bias.

Blendable

no

callgsubr
ﾉ

Expand table

Encoding

0x1d (29)

Stack

[ … <integer> ]

Operands

[ … subr# ]

Description

Calls the subroutine in GlobalSubrINDEX with the index determined by subr#. This
operand must be added to the subroutine bias number before being used as the
index. See CharString concepts: Subroutines for details on calculation of the
subroutine bias.

Blendable

no

The callsubr and callgsubr operators pop the subr# operand from the stack, and
otherwise leave the stack unchanged. The subroutine itself may pop or push operands,
leaving fewer or more operands on the stack when the subroutine returns.

CharString variation operators
vsindex
ﾉ

Expand table

Encoding

0x0f (15)

Stack

[ <integer> ]

Operands

[ ivd ]

Description

Activates a particular list of variation regions from a VariationStore subtable. May
only be used once in a CharString and must precede the first use of the blend
operator.

Blendable

no

The vsindex operator is used to select a set of active variation regions from the defined
set of variation regions. When used in a CharString, it takes precedence over a vsindex
key set in the associated PrivateDICT. See OpenType Font Variations in CFF2 for
complete details about the effect of this operator.
Note: The CharString vsindex operator is encoded as 0x0f, whereas the PrivateDICT
key operator is encoded as 0x16.
blend

ﾉ

Expand table

Encoding

0x010 (16)

Stack

[ … <number>+ <number>+ <integer> ]

Operands

[ … <n default values> <n * k deltas> n ]

Description

Pops n + n * k + 1 operands from the stack, processes them according to the
OpenType variations interpolation algorithm, then pushes n result numbers back
onto the stack.

Blendable

yes

The blend operator may be used in CharStrings to make operands of blendable
CharString operators variable. The number of operands that are popped by the blend
operator is determined by the last operand (n) and the number of active variation
regions (k), with an upper limit determined by the number of operands required by the
next operator in the data. See OpenType Font Variations in CFF2 for complete details
about the implementation of this operator and interpretation of its operands.
Note: The CharString blend operator is encoded as 0x10, whereas in PrivateDICT
data it is encoded as 0x17.
Different ItemVariationData tables can have different numbers of active variation
regions. Because the number of active regions (k) affects the number of operands
popped by the blend operator (n + n * k + 1), the list of regions selected by a vsindex
operator needs to be coordinated with the encoding of blend operands in the
CharString. This has implications for the use of these operators in subroutines. Because
subroutines can be shared by different CharStrings, care is needed to ensure a list of
active regions set by vsindex in a subroutine is compatible with any subsequent blend
operations in any CharStrings that call the subroutine. Similarly, if a blend operator is
used in a subroutine, care is needed to ensure that it is compatible with the count of
active regions in any CharStrings that call that subroutine. Within a PrivateDICT, it will
not be problematic to ensure that use of blend in local subroutines is coordinated with
a vsindex key set in the PrivateDICT. If the vsindex operator is used within a CharString,
care will be needed if the number of activated regions is different from the default set in
the associated PrivateDICT. Extra care will be needed if either operator is used in a
global subroutine.

OpenType Font Variations in CFF2

Overview
The CFF2 table supports font variations as described in the chapter OpenType Font
Variations Overview, and this section assumes familiarity with that chapter. In CFF2
tables, variation data may adjust:
positions of outline points defined in CharStrings,
hinting values defined in CharStrings, and
hinting values defined in PrivateDICTs.
In general, to support variation of glyphs or other font data, font variations require a set
of default values for particular data items, a set of delta adjustment values used to
modify the default values, and a set of regions within the font’s variation space over
which the different delta values apply. In CFF2, interpolation of new values for a
particular variation instance—based on default values, delta values, regions and current
axis settings—is called blending.
Blending is defined only for CharString and PrivateDICT data. In each case, two
operators control variation:
vsindex selects an active list of variation regions.
blend performs a blending operation, updating numbers on the stack using delta
values also provided on the stack.
CFF2 glyph data in a variable font is structured much the same as in a non-variable font,
with the same structures and operators as would be used in the default design.
However, wherever a value occurs in the default design, a blend operator can be added
along with a set of deltas to make that value variable. Different glyphs can use different
sets of variation regions for variation operations; the vsindex operator can be used to
select the appropriate set of regions for a glyph. Other details about the function of
these operators is explained below.
A CFF2 table supporting font variations requires a VariationStore structure. This defines a
global list of all the variation regions used in the font, and also multiple subsets of that
list.

VariationStore
The VariationStore starts with a length field followed by an ItemVariationStore table of
that length.
VariationStore table

ﾉ

Type

Name

Description

uint16

length

length of the ItemVariationStore

uint8

data[length]

ItemVariationStore data

Expand table

The location of the VariationStore in the CFF2 table is given by the VariationStoreOffset
key of the TopDICT. If there is no such key in a CFF2 table, then the VariationStore data
block is omitted, no variations can be defined, and the blend and vsindex operators
must not be used.
The Item Variation Store format is specified in the chapter OpenType Font Variations
Common Table Formats. A brief description of the format as used within the CFF2 table
follows.
An ItemVariationStore contains two important components: a VariationRegionList, and
an array of ItemVariationData structures.
The VariationRegionList is an array of VariationRegion structures. Each specifies a portion
of the design variation space in which particular variation values (deltas) will have effect.
In the CFF2 table, the VariationRegionList defines all of the VariationRegions used in the
CFF2 table, even if a given region is used only in a single CharString or PrivateDict.
An ItemVariationData structure defines a regionIndexes array. Each element in this array
is a 0-based index into the VariationRegionList. This is used to associate variation delta
values with a region of effect: deltas are organized into sets, and the number of deltas in
each set is the length of the associated regionIndexes array. The regionIndexes array
does not need to reference every region in the VariationRegionList but can select a
subset of active regions. Different ItemVariationData structures can define different sets
of active regions.
Note: In the discussion of the blend operator, the length of the active regionIndexes
array is referred to as k.
The ItemVariationStore contains an array of ItemVariationData structures. A CFF2 table
can have only one ItemVariationData, in which case the same set of regions is used by
all glyphs. Multiple ItemVariationData structures may be used, however, to allow
different sets of glyphs to use different sets of regions. When multiple ItemVariationData
structures are present, the vsindex operator can be used in a CharString or in a
PrivateDICT to specify that a different ItemVariationData that the default (index 0) is to
be used.

Note: Use of multiple ItemVariationData structures with different sets of regions can
be useful in some situations to reduce data size. For example, consider a one-axis
font in which most glyphs use only one region, but a special glyph required 20
intermediate regions. If only one ItemVariationData structure were used, it would
need to select all 21 regions. This would require 21 delta operands for every blend
operation when, for nearly all cases, only one delta would otherwise be needed. By
adding a second ItemVariationData structure, glyphs can be divided into two groups
according to the number of regions that need to be selected, and the
corresponding number of deltas for each variable item in the glyph data.
In general, the ItemVariationData structure allows the specification of delta values within
itself, as well as the regionIndexes array. CFF2 does not use this facility. Instead, delta
values in a CFF2 table are stored as operands to a blend operator within CharStrings or
within a PrivateDICT. Only the regionIndexes array of the ItemVariationData structure is
used. Therefore, the itemCount and wordDeltaCount fields in each ItemVariationData
must be set to 0. Since itemCount is 0, there are no Delta Sets to store, so the deltaSets
array is not stored at all.
The CFF2 VariationStore structure does not share data with ItemVariationStore structures
in other parts of the font. For example, if the VariationRegionList used in the CFF2 table
is identical with that in the MVAR table, it needs to be specified explicitly for both.
An example of a VariationStore structure in a CFF2 table can be seen in Example CFF2
table.

Variation operators
The vsindex and blend operators may be used in PrivateDICTs and in CharStrings.
Different encodings are used in PrivateDICTs than in CharStrings, but the operand syntax
and interpretation are the same for both. See PrivateDICT variation operators and
CharString variation operators for details on the encoding and operand syntax for these
operators. The operand interpretation and implementation are described in detail
below.
vsindex
When multiple ItemVariationData structures are defined, then PrivateDICTs and
CharStrings need to be able to select which ItemVariationData structure and
corresponding list of VariationRegions (the regionIndexes array) is used. By default, the
first ItemVariationData structure (index 0) will be used. The vsindex operator can be
used for glyphs that require a different list of regions. The vsindex operator takes a

single operand, ivd, which specifies the index for the ItemVariationData structure to be
used.
If only one ItemVariationData structure is defined, there is no need to use the vsindex
operator.
The vsindex key may be used in a PrivateDICT to select a different list of regions for the
group of glyphs associated with that PrivateDICT. vsindex may also be used in a
CharString to select the list of regions for that glyph. When used in a CharString, it
overrides a setting in the associated PrivateDICT.
The number of active VariationRegions (k) will determine the number of delta values to
be applied to a default value and, hence, the number of operands required by the blend
operator—see details below.
The vsindex operator may be used only once in a CharString and must precede the first
use of the blend operator.
blend
The blend operator may be used in a PrivateDICT or in CharStrings to make operands of
blendable operators variable—this is the mechanism in CFF2 for interpolating default
values with delta values. This interpolation is affected by these factors:
A set of normalized axis settings for a particular variation instance.
An active ItemVariationData structure that provides a list of k VariationRegions
(default, or set using vsindex).
Based on the axis settings and the configuration of each VariationRegion, the Font
Variations system supplies a scalar (a real number in the range [0,1]) for each of the k
VariationRegions, yielding an array of k scalars.
The blend operator pops n + n * k + 1 arguments from the stack. These are organized in
three groups.
n default values (the items to be varied);
n * k delta values, organized into n groups (one for each of the n default values),
with k deltas in each group (one for each region);
n itself.
n will be the first argument popped from the stack, after which the number of additional
arguments to be popped will be known.
To calculate the blended values, the n default values are each treated in turn. The k delta
values for a particular default value are respectively multiplied by the k scalars. These k

products are then all added to the default value, resulting in its final blended value.
Once all n default values have been blended, the results are pushed onto the stack for
use by subsequent operators.
For a detailed description of the interpolation calculation, see Algorithm for
interpolation of instance values.
Example
Consider a value of 120 used as the argument of a hlineto operator. Suppose that the
glyph uses an ItemVariationData with just one active region (k = 1), and suppose that
that hlineto argument has a delta of 52 design units associated with the one active
region. After the single default value (120) we also require n * k delta values, and finally
n itself. Since n = 1 and k = 1, the number of delta values is 1 * 1 = 1. So, the complete
sequence of numbers and operators is as follows:
120 52 1 blend hlineto
For an instance where axis settings result in a scalar of 0.75 for the one active region, we
can calculate the blended value by multiplying the delta value by that scalar (52 * 0.75 =
39), and then adding the product to the default value (39 + 120 = 159). So, for this
instance, we effectively have a hlineto line segment as if a static font had the following
sequence of numbers and operators:
159 hlineto
Example
Consider the previous example, with hlineto and a default operand value of 120, but
after vsindex has been used to select two active regions (k = 2). Now two delta values
are required. Including the default value for the hlineto argument and n, a total of four
operands are required. For instance:
120 52 36 1 blend hlineto
Suppose for a given instance the axis settings result in scalars of 0.75 and 0.50 for the
two regions. The blended value is obtained by multiplying each scalar with its
corresponding delta (52 & 0.75 = 39, 36 * 0.50 = 18), then adding these products to the
default value (39 + 18 + 120 = 177). Thus, for this instance the hlineto line segment is as
if a static font had the following sequence of numbers and operators:
177 hlineto

Blended stem and edge hints
The stem hint operators, hstem, hstemhm, vstem and vstemhm, are blendable,
meaning that the geometric regions they define can vary. As a result, stems that do not
overlap by default could overlap after blending, or vice versa. Generalizing, a pair of
stems could overlap in some regions of the font’s design variation space but not in
other regions.
Whenever stems overlap, the hintmask operator should always be used to activate only
stems that do not overlap. Note that it is not possible to activate different sets of stems
for different regions of the variation space: each use of hintmask will activate the same
set of stems for all variation instances.
Therefore, if any stems defined for a CharString overlap for any variation instance, then
all stems should be defined using hstemhm or vstemhm.
When defining stem hints, either the first or second value in a pair may be blended, but
the blended result for the second value must always remain greater than or equal to
zero.
When defining edge hints, the first value in a pair may be blended, but the special
“width” values used to indicate an edge (-20 and -21) must not be blended.
As described above (see CharString concepts), when multiple stems are defined, the
pairs of values must be sorted in increasing order of the first value for each pair. This
applies to the values encoded as operands of stem hint operators. In a variable font, if
these operand values are blended, blending could potentially result in derived values
such that, for some variation instances, the first values of each pair are not in increasing
order. Such derived instance values are valid. The bit flag operands for the cntrmask and
hintmask operators always reference stems in their encoded order, not in sorted order
for a particular variation instance.
Note: If a CFF2 rasterizer implementation requires stems in its memory
representation to be sorted, it could be necessary to re-sort the stems after blended
values are obtained. However, re-sorting would also require maintaining the
association between each stem and its corresponding cntrmask or hintmask bit
flag.

Advanced uses of blend
The blend operator always works in conjunction with a subsequent operator expecting
precalculated values (such as rlineto or BlueValues), and is ultimately required to leave
operands on the stack ready for that static operator. It is not required to process all of

those operands in a single blend operation, however. Thus, the number n in a blend may
be less than the number of operands expected by the subsequent static operator,
nStatic.
When n < nStatic, only a subset of the operands for the static operator are blended. For
example, the two operands to rlineto would normally be blended in a single blend with
n = 2, but using two separate blend operations, each with n = 1 and each placed
immediately after the relevant operand, is also valid. Also, if only one of the operands
has variation deltas, then a blend with n = 1 immediately after that operand can save
some data.
For example, the rrcurveto operator defines a Bézier curve using six operands. Suppose
only the second and sixth operands (dya and dyc) needed to vary. A single blend
operator could be used, but its effect would need to span five of the default values,
dya…dyc; this would entail specifying n = 5, and requiring 5k delta operands, of which 3k
would be zeros. A more efficient implementation would use two separate blend
operators, one for dya and one for dyc, each having n = 1 and only k deltas.
Also, by having multiple blend operators before a static operator and also pushing
additional values onto the stack, values already blended once can be blended multiple
times. Only in the very last blend operation directly before the static operator are the
blended offsets added to the default operands. This technique can be used to provide
higher order interpolation using a single variation axis, for example to control the
variation of a point along a quadratic, cubic or quartic curve rather than along a straight
line.

Comparison of CFF2 variations with 'gvar' variations
Variation of glyph metrics
The TrueType rasterizer appends four “phantom” points to the array of glyph points,
based on metrics data from the 'hmtx' and 'vmtx' tables. These phantom points
represent glyph metrics, and can be varied using 'gvar' variation data just as if they were
regular points on the glyph outline. The CFF2 rasterizer also uses the 'hmtx' and 'vmtx'
tables, but it does not create phantom points that can be manipulated in the CharString.
Instead, CFF2 depends on the HVAR and VVAR tables for variation of glyph metrics.
Variation regions
In 'gvar', a global array of variation regions is defined in the sharedTuples array. A record
for each glyph defines a custom array of regions, where each region is either selected
from the global array or defined only for that glyph. CFF2, by requiring all regions to be

defined globally, and also by predefining the order of regions when referenced in a
blend operation, requires less data overall for specifying regions.
Inferred deltas
The 'gvar' variations mechanism includes functionality for “inferred deltas”. By moving
only certain points on a glyph outline, deltas can be inferred for other points, saving
data overall. (See Inferred deltas for un-referenced point numbers.) Inferred deltas are
not supported in the CFF2 table.
Translating contours
Although CFF2 lacks functionality for inferred deltas, an entire contour can still be
efficiently translated by variable x and y offsets by applying variation deltas to a single
point on the contour to be moved. In gvar, any point on the contour may be chosen, the
other points moving identically via inferred deltas. In CFF2, since all points of a contour
are defined relative to the contour’s initial rmoveto operation, it is only the operands of
that rmoveto that would need to be blended. The locations of subsequent points on the
contour, having deltas of zero relative to the initial point, can avoid blend operations
entirely. Care is needed to disable unintended variation on subsequent contours in the
CharString, by means of opposing deltas on the operands of the subsequent rmoveto.

CFF2 dependencies on other font tables
An important factor in the design of the CFF2 specification was the avoidance of
duplicating data already specified elsewhere in an OFF font file, which is a short-coming
of fonts that use the 'CFF ' table. Consequently, CFF2 is highly dependent on data in
other OFF tables. OpenType tables that do not refer to specific glyph formats are
intended to function as specified, including:
the 'cmap' table;
the 'hhea' table;
the 'name' table;
the 'post' table;
the 'OS/2' table;
advanced layout tables—GDEF, GPOS and GSUB;
color tables—COLR and CPAL; and
variation tables—'fvar', 'avar', STAT, MVAR, HVAR and VVAR.
Here follow some requirements and considerations for specific tables.

SFNT header

sfntVersion The sfntVersion field, the first four bytes of an OpenType font file, must be
0x4F54544F (“OTTO”) for OpenType fonts with glyphs defined in a CFF2 table.

'maxp' table
version
CFF2 fonts must use version 0.5 (encoded as 0x00005000). (This is only 6 bytes long and
omits values not required for CFF2.)
numGlyphs
This must be identical to the number of CharStrings in the CFF2 table (the number of
items in CharStringsINDEX).

'head' table
The specification should be followed for all fields, with the following notes.
unitsPerEm
This is respected and must correspond with the value of the TopDICT FontMatrix key in
the CFF2 table. FontMatrix uses the reciprocal of unitsPerEm in a specific sequence of
operands. For example, if unitsPerEm is 2000, having reciprocal 1/2000 = 0.0005, then
FontMatrix must be set to 0.0005 0 0 0.0005 0 0. If unitsPerEm is equal to 1000, then the
FontMatrix key may be omitted from the TopDICT.
indexToLocFormat
Set to 0.
glyphDataFormat
Set to 0.

'hmtx' and HVAR tables
Horizontal metrics for each glyph are stored in the 'hmtx' table. Variation of horizontal
metrics is controlled by the HVAR table.

'vmtx' and VVAR tables
Vertical metrics for each glyph are stored in the 'vmtx' table. Variation of vertical metrics
is controlled by the VVAR table.

'fvar' table
An 'fvar' table is required if a CFF2 table uses font variations. In other words, if a
VariationStore structure is defined within the CFF2 table, an 'fvar' table must also be
defined. This table specifies the number of axes, axisCount, as well as their order. For
each axis it specifies the fields axisTag, nameID, defaultValue, minValue, and maxValue,
which are all necessary for any implementation of font variations.
The CFF2 VariationStore data structure and the blend operators refer to variation axes
according to their ordering in the 'fvar' table.

'gvar' table
The 'gvar' table is not used in OpenType fonts with CFF2-encoded glyphs. Variation in
glyph outlines and glyph hinting are controlled directly in CharString data. Variation of
glyph metrics is controlled in the HVAR and VVAR tables.

Example CFF2 table
This section illustrates the CFF2 format with an example CFF2 table.
Binary dump (226 bytes):
0000: 02 00 05 00 07 CF 0C 24 C3 11 9B 18 00 00 00 00
0010: 00 26 00 01 00 00 00 0C 00 01 00 00 00 1C 00 01
0020: 00 02 C0 00 E0 00 00 00 C0 00 C0 00 E0 00 00 00
0030: 00 00 00 02 00 00 00 01 00 00 00 02 01 01 03 05
0040: 20 0A 20 0A 00 00 00 01 01 01 05 F7 06 DA 12 77
0050: 9F F8 6C 9D AE 9A F4 9A 95 9F B3 9F 8B 8B 8B 8B
0060: 85 9A 8B 8B 97 73 8B 8B 8C 80 8B 8B 8B 8D 8B 8B
0070: 8C 8A 8B 8B 97 17 06 FB 8E 95 86 9D 8B 8B 8D 17
0080: 07 77 9F F8 6D 9D AD 9A F3 9A 95 9F B3 9F 08 FB
0090: 8D 95 09 1E A0 37 5F 0C 09 8B 0C 0B C2 6E 9E 8C
00A0: 17 0A DB 57 F7 02 8C 17 0B B3 9A 77 9F 82 8A 8D
00B0: 17 0C 0C DB 95 57 F7 02 85 8B 8D 17 0C 0D F7 06
00C0: 13 00 00 00 01 01 01 1B BD BD EF 8C 10 8B 15 F8
00D0: 88 27 FB 5C 8C 10 06 F8 88 07 FC 88 EF F7 5C 8C
00E0: 10 06

Analysis:
ﾉ

Hex data

Source

Comments

Expand table

Header

CFF2 offsets: 0000 to 0004

02

majorVersion

=2

00

minorVersion

=0

05

headerSize

=5

00 07

topDictSize

=7

TopDICT

CFF2 offsets: 0005 to 000B

[ offset ]
FontDICTINDEXOffset

= 68 FontDICTINDEXOffset
The bytes 0C 24 represent the

CF 0C 24

FontDICTINDEXOffset operator. The operand
byte is hex CF = decimal 207, which is decoded
using the rule for byte values from 32 to 246
(see Encoded number formats): b0 - 139.
This gives the offset of the FontDICTINDEX:
decimal 68 = hex 44.
C3 11

[ offset ]
CharStringINDEXOffset

= 56 CharStringINDEXOffset
The byte 11 represents the
CharStringINDEXOffset operator. The operand
byte is hex C3, which is the encoded
representation of the value 56.
This gives the offset of the CharStringINDEX:
decimal 56 = hex 38.

9B 18

[ offset ]
VariationStoreOffset

= 16 VariationStoreOffset
The byte 18 represents the VariationStoreOffset
operator. The operand byte is hex 9B, which is
the encoded representation of the value 16.
This gives the offset of the VariationStore:
decimal 16 = hex 10.

00 00 00 00

GlobalSubrINDEX

CFF2 offsets: 000C to 000F

count

= empty INDEX; no additional fields
represented.

00 26

VariationStore

CFF2 offsets: 0010 to 0037

length

= 38 — length in bytes of the
ItemVariationStore structure that follows.

ItemVariationStore

CFF2 offsets: 0012 to 0037

00 01

format

=1

00 00 00 0C

variationRegionListOffset

= 12 — offset in bytes from the start of the
ItemVariationStore.

00 01

itemVariationDataCount

= 1 — number of ItemVariationData subtables.

00 00 00 1C

itemVariationDataOffsets[0]

= 28 — offset in bytes from start of the
ItemVariationStore to ItemVariationData
subtable 0.

VariationRegionList

CFF2 offsets: 001E to 002D

00 01

axisCount

=1

00 02

regionCount

=2

variationRegions[0]

CFF2 offsets: 0022 to 0027

regionAxes[0]

CFF2 offsets: 0022 to 0027

C0 00

startCoord

= -1.0 (F2DOT14 value)

E0 00

peakCoord

= -0.5 (F2DOT14 value)

00 00

endCoord

= 0.0 (F2DOT14 value)

variationRegions[1]

CFF2 offsets: 0028 to 002D

regionAxes[0]

CFF2 offsets: 0028 to 002D

C0 00

startCoord

= -1.0 (F2DOT14 value)

C0 00

peakCoord

= -1.0 (F2DOT14 value)

E0 00

endCoord

= -0.5 (F2DOT14 value)

ItemVariationData
subtable 0

CFF2 offsets: 002E to 0037

00 00

itemCount

=0

00 00

shortDeltaCount

=0

00 02

regionIndexCount

=2

00 00 00 01

regionIndexes[]

= {0, 1}

CharStringINDEX

CFF2 offsets: 0038 to 0043

00 00 00 02

count

=2

01

offsetSize

=1

01 03 05

offsets[]

= {1, 3, 5} (number of elements is count + 1)

CharString 0

CFF2 offsets: 0040 to 0041

20 0A

[ subr# ] callsubr

= -107 callsubr
The byte 0A represents the callsubr operator.
The operand byte is 20, which is the encoded
representation of the value -107.

CharString 1

CFF2 offsets: 0042 to 0043

[ subr# ] callsubr

= -107 callsubr
The byte 0A represents the callsubr operator.
The operand byte is 20, which is the encoded
representation of the value -107.

FontDICTINDEX

CFF2 offsets: 0044 to 004E

00 00 00 01

count

=1

01

offsetSize

=1

01 05

offsets[]

= {1, 5} (number of elements is count + 1)

FontDICT 0

CFF2 offsets: 004B to 004E

[ size offset ]
PrivateDICTOffset

= 114 79 PrivateDICTOffset
The byte 12 represents the PrivateDICTOffset
operator. The operand bytes F7 06 are the
encoded representation of the value 114. The
operand byte DA is the encoded representation
of the value 79.
This gives the size and offset of a PrivateDICT:

20 0A

F7 06 DA 12

size is 114 bytes, offset (from start of CFF2
table) is 79 bytes (hex 4F).

77 9F F8 6C 9D
AE 9A F4 9A 95
9F B3 9F 8B 8B
8B 8B 85 9A 8B
8B 97 73 8B 8B
8C 80 8B 8B 8B
8D 8B 8B 8C 8A

PrivateDICT

CFF2 offset: 004F to 00C0

[ num* ] blend BlueValues

= -20 20 472 18 35 15 105 15 10 20 40 20 0 0 0
0 -6 15 0 0 12 -24 0 0 1 -11 0 0 0 2 0 0 1 -1 0 0
12 blend BlueValues
The byte 06 represents the BlueValues operator.
The byte 17 represents the blend operator. The
operand bytes 77… 97 are the encoded
representation of the values -20… 12.

[ num* ] blend OtherBlues

= -250 10 -5 18 0 0 2 blend OtherBlues

8B 8B 97 17 06
FB 8E 95 86 9D
8B 8B 8D 17 07

77 9F F8 6D 9D
AD 9A F3 9A 95

The byte 07 represents the OtherBlues
operator. The byte 17 represents the blend
operator. The operand bytes FB… 8D are the
encoded representation of the values -250… 2.
[ num* ] FamilyBlues

= -20 20 473 18 34 15 104 15 10 20 40 20
FamilyBlues

9F B3 9F 08

FB 8D 95 09

The byte 08 represents the operator
FamilyBlues. The operand bytes 77… 9F are the
encoded representation of the values -20… 20.
[ num* ] FamilyOtherBlues

= -249 10 FamilyOtherBlues
The byte 09 represents the FamilyOtherBlues
operator. The operand bytes FB 8D are the
encoded representation of the value -249. The
operand byte 95 is the encoded representation
of the value 10.

1E A0 37 5F 0C
09

[ num ] BlueScale

= 0.0375 BlueScale
The bytes 0C 09 represent the BlueScale
operator. The operand bytes 1E A0 37 5F are
the encoded representation of the value 0.0375.

8B 0C 0B

[ num ] BlueFuzz

= 0 BlueFuzz
The bytes 0C 0B represents the BlueFuzz
operator. The operand byte 8B is the encoded
representation of the value 0.

C2 6E 9E 8C 17

[ num* ] blend StdHW

0A

DB 57 F7 02 8C
17 0B

= 55 -29 19 1 blend StdHW
The byte 0A represents the StdHW operator.
The byte 17 represents the blend operator. The
operand bytes C2 6E 9E 8C are the encoded
representation of the values 55 -29 19 1.

[ num* ] blend StdVW

= 80 -52 110 1 blend StdVW
The byte 0B represents the StdVW operator.
The byte 17 represents the blend operator. The
operand bytes DB 57 F7 02 8C are the encoded
representation of the values 80 -52 110 1.

B3 9A 77 9F 82

[ num* ] blend StemSnapH

8A 8D 17 0C 0C

DB 95 57 F7 02
85 8B 8D 17 0C
0D

= 40 15 -20 20 -9 -1 2 blend StemSnapH
The bytes 0C 0C represent the StemSnapH
operator. The byte 17 represents the blend
operator. The operand bytes B3 9A 77 9F 82 8A
8D are the encoded representation of the
values 40 15 -20 20 -9 -1 2.

[ num* ] blend StemSnapV

= 80 10 -52 110 -6 0 2 blend StemSnapV
The bytes 0C 0D represent the StemSnapV
operator. The byte 17 represents the blend
operator. The operand bytes DB 95 57 F7 02 85
8B 8D are the encoded representation of the
values 80 10 -52 110 -6 0 2.

F7 06 13

[ num ]
LocalSubrINDEXOffset

= 114 Subrs
The byte 13 represents the
LocalSubrINDEXOffset operator. The operand
bytes F7 06 are the encoded representation of

the value 114.
This gives the offset (from the start of the
PrivateDICT) to the LocalSubrINDEX: 114 bytes
(hex 72).
LocalSubrINDEX

CFF2 offsets: 00C1 to 00E1

00 00 00 01

count

=1

01

offsetSize

=1

01 1B

offsets[]

= {1, 27} (number of elements is count + 1)

subr 0

CFF2 offsets: 00C8 to 00E1

[ num* ] blend num
rmoveto

= 50 50 100 1 blend 0 rmoveto
The byte 15 represents the rmoveto CharString
operator. The byte 10 represents the blend

BD BD EF 8C 10
8B 15

CharString operator. The operand bytes BD BD
EF 8C are the encoded representation of the
values 50 50 100 1. The operand byte 8B is the
encoded representation of the value 0.
F8 88 27 FB 5C
8C 10 06

[ num* ] blend hlineto

= 500 -100 -200 1 blend hlineto
The byte 06 represents the hlineto CharString
operator. The byte 10 represents the blend
CharString operator. The operand bytes F8 88
27 FB 5C 8C are the encoded representation of
the values 500 -100 -200 1.

F8 88 07

[ num ] vlineto

= 500 vlineto
The byte 07 represents the vlineto CharString
operator. The operand bytes F8 88 are the
encoded representation of the value 500.

FC 88 EF F7 5C
8C 10 06

[ num* ] blend hlineto

= -500 100 200 1 blend hlineto The byte 06
represents the hlineto CharString operator. The
byte 10 represents the blend CharString
operator. The operand bytes FC 88 EF F7 5C 8C
are the encoded representation of the values
-500 100 200 1.

cmap — Character to Glyph Index
Mapping Table
Article • 05/29/2024

Table overview
This table defines the mapping of character codes to a default glyph index. Different
subtables may be defined that each contain mappings for different character encoding
schemes. The table header indicates the character encodings for which subtables are
present.
Regardless of the encoding scheme, character codes that do not correspond to any
glyph in the font should be mapped to glyph index 0. The glyph at this location must be
a special glyph representing a missing character, commonly known as .notdef.
Each subtable is in one of seven possible formats and begins with a format field
indicating the format used. The first four formats — formats 0, 2, 4 and 6 — were
originally defined prior to Unicode 2.0. These formats allow for 8-bit single-byte, 8-bit
multi-byte, and 16-bit encodings. With the introduction of supplementary planes in
Unicode 2.0, the Unicode addressable code space extends beyond 16 bits. To
accommodate this, three additional formats were added — formats 8, 10 and 12 — that
allow for 32-bit encoding schemes.
Other enhancements in Unicode led to the addition of other subtable formats. Subtable
format 13 allows for an efficient mapping of many characters to a single glyph; this is
useful for “last-resort” fonts that provide fallback rendering for all possible Unicode
characters with a distinct fallback glyph for different Unicode ranges. Subtable format 14
provides a unified mechanism for supporting Unicode variation sequences.
Of the seven available formats, not all are commonly used today. Formats 4 or 12 are
appropriate for most new fonts, depending on the Unicode character repertoire
supported. Format 14 is used in many applications for support of Unicode variation
sequences. Some platforms also make use for format 13 for a last-resort fallback font.
Other subtable formats are not recommended for use in new fonts. Application
developers, however, should anticipate that any of the formats may be used in fonts.
Note: The 'cmap' table version number remains at 0x0000 for fonts that make use of
the newer subtable formats.

'cmap' Header
The Character to Glyph Index Mapping table is organized as follows.
'cmap' Header:
ﾉ

Expand table

Type

Name

Description

uint16

version

Table version number (0).

uint16

numTables

Number of encoding tables that follow.

EncodingRecord

encodingRecords[numTables]

Encoding records and encodings
The array of encoding records specifies particular encodings and the offset to the
subtable for each encoding.
EncodingRecord:
ﾉ

Expand table

Type

Name

Description

uint16

platformID

Platform ID.

uint16

encodingID

Platform-specific encoding ID.

Offset32

subtableOffset

Byte offset from beginning of table to the subtable for this encoding.

The platform ID and platform-specific encoding ID in the encoding record are used to
specify a particular character encoding. In the case of the Macintosh platform, a
language field within the mapping subtable is also used for this purpose.
The encoding record entries in the 'cmap' header must be sorted first by platform ID,
then by platform-specific encoding ID, and then by the language field in the
corresponding subtable. Each platform ID, platform-specific encoding ID, and subtable
language combination may appear only once in the 'cmap' table.
Apart from a format 14 subtable, all other subtables are exclusive: applications should
select and use one and ignore the others. If a Unicode subtable is used (platform 0, or

platform 3 / encoding 1 or 10), then a format 14 subtable using platform 0/encoding 5
can also be supplemented for mapping Unicode variation sequences.
If a font includes Unicode subtables for both 16-bit encoding (typically, format 4) and
also 32-bit encoding (formats 10 or 12), then the characters supported by the subtable
for 32-bit encoding should be a superset of the characters supported by the subtable
for 16-bit encoding, and the 32-bit encoding should be used by applications.
Fonts should not include 16-bit Unicode subtables using both format 4 and format 6;
format 4 should be used. Similarly, fonts should not include 32-bit Unicode subtables
using both format 10 and format 12; format 12 should be used.
If a font includes encoding records for Unicode subtables of the same format but with
different platform IDs, an application may choose which to select, but should make this
selection consistently each time the font is used.

Platform IDs
The following platform IDs are defined:
ﾉ

Platform ID

Platform name

Platform-specific encoding IDs

0

Unicode

Various

1

Macintosh

Script manager code

2

ISO [deprecated]

ISO encoding [deprecated]

3

Windows

Windows encoding

4

Custom

Custom

Expand table

Platform ID values 240 through 255 are reserved for user-defined platforms and shall
never be assigned to a registered platform.

Unicode platform (platform ID = 0)
The following encoding IDs are defined for use with the Unicode platform:
ﾉ

Encoding ID

Description

Expand table

0

Unicode 1.0 semantics—deprecated

1

Unicode 1.1 semantics—deprecated

2

ISO/IEC 10646 semantics—deprecated

3

Unicode 2.0 and onwards semantics, Unicode BMP only

4

Unicode 2.0 and onwards semantics, Unicode full repertoire

5

Unicode variation sequences—for use with subtable format 14

6

Unicode full repertoire—for use with subtable format 13

Use of encoding IDs 0, 1 or 2 is deprecated.
Encoding ID 3 should be used in conjunction with 'cmap' subtable formats 4 or 6.
Encoding ID 4 should be used in conjunction with subtable formats 10 or 12.
Unicode variation sequences supported by the font should be specified in the 'cmap'
table using a format 14 subtable. A format 14 subtable must only be used under
platform ID 0 and encoding ID 5; and encoding ID 5 should only be used with a format
14 subtable.
Encoding ID 6 should only be used in conjunction with 'cmap' subtable format 13; and
subtable format 13 should only be used under platform ID 0 and encoding ID 6.

Macintosh platform (platform ID = 1)
Older Macintosh versions required fonts to have a 'cmap' subtable for platform ID 1. For
current Apple platforms, use of platform ID 1 is discouraged. See the 'name' table
chapter for details regarding encoding IDs defined for the Macintosh platform.

ISO platform (platform ID = 2)
Use of this platform ID is deprecated.
The following encoding IDs are defined for use with the ISO platform:
ﾉ

Code

ISO encoding

0

7-bit ASCII

1

ISO 10646

Expand table

2

ISO 8859-1

Windows platform (platform ID = 3)
The Windows platform supports several encodings. When creating fonts for Windows,
Unicode 'cmap' subtables should always be used—platform ID 3 with encoding ID 1 or
encoding ID 10. See below for additional details.
The following encoding IDs are supported on the Windows platform:
ﾉ

Platform ID

Encoding ID

Description

3

0

Symbol

3

1

Unicode BMP

3

2

ShiftJIS

3

3

PRC

3

4

Big5

3

5

Wansung

3

6

Johab

3

7

Reserved

3

8

Reserved

3

9

Reserved

3

10

Unicode full repertoire

Expand table

Fonts that support only Unicode BMP characters (U+0000 to U+FFFF) on the Windows
platform must use encoding 1 with a format 4 subtable. This encoding must not be used
to support Unicode supplementary-plane characters.
Fonts that support Unicode supplementary-plane characters (U+10000 to U+10FFFF) on
the Windows platform must use encoding 10 with a format 12 subtable.
The symbol encoding was created to support fonts with arbitrary ornaments or symbols
not supported in Unicode or other standard encodings. A format 4 subtable would be
used, typically with up to 224 graphic characters assigned at code positions beginning
with 0xF020. This corresponds to a sub-range within the Unicode Private-Use Area

(PUA), though this is not a Unicode encoding. In legacy usage, some applications would
represent the symbol characters in text using a single-byte encoding, and then map
0x20 to the OS/2.usFirstCharIndex value in the font. In new fonts, symbols or characters
not in Unicode should be encoded using PUA code points in a Unicode 'cmap' subtable.
See the Recommendations chapter for additional information.

Custom platform (platform ID = 4) and OTF Windows NT
compatibility mapping
Platform ID 4 is a legacy platform that was created to provide compatibility of older
applications with OpenType fonts that had been adapted from older Type 1 fonts. This
platform is not commonly used today, and should not be used in new fonts.
ﾉ

ID

Custom encoding

0-255

OTF Windows NT compatibility mapping

Expand table

This 'cmap' platform provides a compatibility mechanism for non-Unicode applications
that use the font as if it were Windows ANSI encoded. Non-Windows ANSI Type 1 fonts,
such as Cyrillic and Central European fonts that Adobe shipped in the past, had “0”
(Windows ANSI) recorded in the CharSet field of the .PFM file; Adobe Type Manager for
Windows 9x ignored the CharSet altogether. Adobe provides this compatibility 'cmap'
encoding in every OpenType font converted from a Type1 font in which the Encoding is
not StandardEncoding.
When platform ID 4 is used, the encoding ID must be set to the Windows charset value
(in the range 0 to 255, inclusive) present in the .PFM file of the original Type 1 font.
If a platform ID 4, encoding ID 0 – 255 'cmap' encoding is present in an OpenType font
with CFF outlines, then the OTF font driver in Windows NT will: (a) superimpose the
glyphs encoded at character codes 0-255 in the encoding on the corresponding
Windows ANSI (code page 1252) Unicode values in the Unicode encoding it reports to
the system; (b) add Windows ANSI (CharSet 0) to the list of CharSets supported by the
font; and (c) consider the value of the encoding ID to be a Windows CharSet value and
add it to the list of CharSets supported by the font. Note that the 'cmap' subtable needs
to use Format 0 or 6 for its subtable, and the encoding needs to be identical to the CFF’s
encoding.

'cmap' subtable formats

Use of the language field in 'cmap' subtables
All 'cmap' subtable formats include a language field. The language field must be set to
zero for all 'cmap' subtables whose platform IDs are other than Macintosh (platform ID
1). For 'cmap' subtables whose platform IDs are Macintosh, set this field to the
Macintosh language ID of the 'cmap' subtable plus one, or to zero if the 'cmap' subtable
is not language-specific. For example, a Mac OS Turkish 'cmap' subtable must set this
field to 18, since the Macintosh language ID for Turkish is 17. A Mac OS Roman 'cmap'
subtable must set this field to 0, since Mac OS Roman is not a language-specific
encoding.

Format 0: Byte encoding table
Format 0 was the standard mapping subtable used on older Macintosh platforms but is
not required on newer Apple platforms.
'cmap' Subtable Format 0:
ﾉ

Expand table

Type

Name

Description

uint16

format

Format number is set to 0.

uint16

length

This is the length in bytes of the subtable.

uint16

language

For requirements on use of the language field, see “Use of the
language field in 'cmap' subtables” in this document.

uint8

glyphIdArray[256]

An array that maps character codes to glyph index values.

This is a simple 1 to 1 mapping of character codes to glyph indices. The glyph set is
limited to 256. If this format is used to index into a larger glyph set, only the first 256
glyphs will be accessible.

Format 2: High byte mapping through table
This subtable format was created for “double-byte” encodings following national
character code standards used for Japanese, Chinese, and Korean characters. These code
standards use a mixed 8-/16-bit encoding. This format is not commonly used today.
In these mixed 8-/16-bit encodings, certain byte values signal the first byte of a 2-byte
character. (These byte values are also valid as the second byte of a 2-byte character.) In
addition, even for the 2-byte characters, the mapping of character codes to glyph index

values depends heavily on the first byte. Consequently, the table begins with an array
that maps the first byte to a SubHeader record. For 2-byte character codes, the
SubHeader is used to map the second byte’s value into a sub-range of a glyph index
array—a sub-array—, as described below. When processing mixed 8-/16-bit text,
SubHeader 0 is special: it is used for single-byte character codes. When SubHeader 0 is
used, a second byte is not needed; the single byte value is mapped through the
specified sub-array.
'cmap' Subtable Format 2:
ﾉ

Expand table

Type

Name

Description

uint16

format

Format number is set to 2.

uint16

length

This is the length in bytes of the subtable.

uint16

language

For requirements on use of the language field, see “Use of
the language field in 'cmap' subtables” in this document.

uint16

subHeaderKeys[256]

Array that maps high bytes into the subHeaders array: value
is subHeaders index × 8.

SubHeader

subHeaders[ ]

Variable-length array of SubHeader records.

uint16

glyphIdArray[ ]

Variable-length array containing sub-arrays used for
mapping the low byte of 2-byte characters.

The SubHeader record is structured as follows:
SubHeader Record:
ﾉ

Type

Name

Description

uint16

firstCode

First valid low byte for this SubHeader.

uint16

entryCount

Number of valid low bytes for this SubHeader.

int16

idDelta

See text below.

uint16

idRangeOffset

See text below.

Expand table

The firstCode and entryCount values specify a subrange that begins at firstCode and has
a length equal to the value of entryCount. This subrange stays within the 0-255 range of
the byte being mapped. Bytes outside of this subrange are mapped to glyph index 0

(missing glyph). The offset of the byte within this subrange is then used as index into a
corresponding sub-array of glyphIdArray. This sub-array is also of length entryCount.
The value of the idRangeOffset is the number of bytes past the actual location of the
idRangeOffset word where the glyphIdArray element corresponding to firstCode
appears.
Finally, if the value obtained from the sub-array is not 0 (which indicates the missing
glyph), you should add idDelta to it in order to get the glyphIndex. The value idDelta
permits the same sub-array to be used for several different subheaders. The idDelta
arithmetic is modulo 65536. If the result after adding idDelta to the value from the subarray is less than zero, add 65536 to obtain a valid glyph ID.

Format 4: Segment mapping to delta values
This is the standard character-to-glyph-index mapping subtable for fonts that support
only Unicode Basic Multilingual Plane characters (U+0000 to U+FFFF).
Note: To support Unicode supplementary-plane characters, format 12 should be
used.
This format is used when the character codes for the characters represented by a font
fall into several contiguous ranges, possibly with holes in some or all of the ranges (that
is, some of the codes in a range might not have a representation in the font). The
format-dependent data is divided into three parts, which must occur in the following
order:
1. A four-word header gives parameters for an optimized search of the segment list.
2. Four parallel arrays describe the segments (one segment for each contiguous
range of codes).
3. A variable-length array of glyph IDs (unsigned words).
'cmap' Subtable Format 4:
ﾉ

Expand table

Type

Name

Description

uint16

format

Format number is set to 4.

uint16

length

This is the length in bytes of the subtable.

uint16

language

For requirements on use of the language field, see “Use of
the language field in 'cmap' subtables” in this document.

Type

Name

Description

uint16

segCountX2

2 × segCount.

uint16

searchRange

Maximum power of 2 less than or equal to segCount, times 2
((2**floor(log2(segCount))) * 2, where “**” is an
exponentiation operator)

uint16

entrySelector

Log2 of the maximum power of 2 less than or equal to
segCount
(log2(searchRange/2), which is equal to floor(log2(segCount)))

uint16

rangeShift

segCount times 2, minus searchRange
((segCount * 2) - searchRange)

uint16

endCode[segCount]

End characterCode for each segment, last=0xFFFF.

uint16

reservedPad

Set to 0.

uint16

startCode[segCount]

Start character code for each segment.

int16

idDelta[segCount]

Delta for all character codes in segment.

uint16

idRangeOffset[segCount]

Offsets into glyphIdArray or 0

uint16

glyphIdArray[ ]

Glyph index array (arbitrary length)

The number of segments is specified by segCount, which is not given directly in the
header but is readily derived from segCountX2. All of the other header parameters are
derived from it. The searchRange value is twice the largest power of 2 that is less than or
equal to segCount. For example, if segCount=39, we have the following:
ﾉ

segCountX2

78

searchRange

64 (= 2 × (largest power of 2 <=39))

entrySelector

5 (= log232)

rangeShift

14 (= 2 × 39 - 64)

Expand table

To assist in quick binary searches, the searchRange, entrySelector and rangeShift fields
are included as parameters that can be used in configuring search algorithms. In
particular, binary search is optimal when the number of entries is a power of two. The
searchRange field provides the largest number of items that can be searched with that
constraint (maximum power of two). The rangeShift field provides the remaining

number of items that would also need to be searched. The entrySelector field indicates
the maximum number of levels into the binary tree will need to be entered.
In early implementations on devices with limited hardware capabilities, optimizations
provided by the searchRange, entrySelector and rangeShift fields were of high
importance. They have less importance on modern devices but could still be used in
some implementations. However, incorrect values could potentially be used as an attack
vector against some implementations. Since these values can be derived from the
segCountX2 field when the file is parsed, it is strongly recommended that parsing
implementations not rely on the searchRange, entrySelector and rangeShift fields in the
font but derive them independently from segCountX2. Font files, however, should
continue to provide valid values for these fields to maintain compatibility with all
existing implementations.
Each segment is described by a startCode and endCode, along with an idDelta and an
idRangeOffset, which are used for mapping the character codes in the segment. The
segments are sorted in order of increasing endCode values, and the segment values are
specified in four parallel arrays. You search for the first endCode that is greater than or
equal to the character code you want to map. If the corresponding startCode is less than
or equal to the character code, then you use the corresponding idDelta and
idRangeOffset to map the character code to a glyph index (otherwise, the missingGlyph
is returned). For the search to terminate, the final startCode and endCode values must
be 0xFFFF. This segment need not contain any valid mappings. (It can just map the
single character code 0xFFFF to missingGlyph). However, the segment must be present.
If the idRangeOffset value for the segment is not 0, the mapping of character codes
relies on glyphIdArray. The character code offset from startCode is added to the
idRangeOffset value. This sum is used as an offset from the current location within
idRangeOffset itself to index out the correct glyphIdArray value. This obscure indexing
trick works because glyphIdArray immediately follows idRangeOffset in the font file. The
C expression that yields the glyph index is:

glyphId = *(idRangeOffset[i]/2
+ (c - startCode[i])
+ &idRangeOffset[i])

The value c is the character code in question, and i is the segment index in which c
appears. If the value obtained from the indexing operation is not 0 (which indicates
missingGlyph), idDelta[i] is added to it to get the glyph index. The idDelta arithmetic is
modulo 65536.

If the idRangeOffset is 0, the idDelta value is added directly to the character code offset
(i.e. idDelta[i] + c ) to get the corresponding glyph index. Again, the idDelta arithmetic
is modulo 65536. If the result after adding idDelta[i] + c is less than zero, add 65536
to obtain a valid glyph ID.
As an example, the variant part of the table to map characters 10-20, 30-90, and 153480 onto a contiguous range of glyph indices may look like this:
ﾉ

segCountX2:

8

searchRange:

8

entrySelector:

2

rangeShift:

0

endCode:

20 90 480 0xffff

reservedPad:

0

startCode:

10 30 153 0xffff

idDelta:

-9 -18 -80 1

idRangeOffset:

0000

Expand table

This table yields the following mappings:
10 ⇒ 10 - 9 = 1
20 ⇒ 20 - 9 = 11
30 ⇒ 30 - 18 = 12
90 ⇒ 90 - 18 = 72
153 ⇒ 153 - 80 = 73
480 ⇒ 480 - 80 = 400
0xffff ⇒ 0
Note that the delta values could be reworked so as to reorder the segments.

Format 6: Trimmed table mapping
Format 6 was designed to map 16-bit characters to glyph indexes when the character
codes for a font fall into a single contiguous range.
'cmap' Subtable Format 6:

ﾉ

Expand table

Type

Name

Description

uint16

format

Format number is set to 6.

uint16

length

This is the length in bytes of the subtable.

uint16

language

For requirements on use of the language field, see “Use of
the language field in 'cmap' subtables” in this document.

uint16

firstCode

First character code of subrange.

uint16

entryCount

Number of character codes in subrange.

uint16

glyphIdArray[entryCount]

Array of glyph index values for character codes in the range.

The firstCode and entryCount values specify a subrange (beginning at firstCode, length
= entryCount) within the range of possible character codes. Codes outside of this
subrange are mapped to glyph index 0. The offset of the code (from the first code)
within this subrange is used as index to the glyphIdArray, which provides the glyph
index value.

Format 8: mixed 16-bit and 32-bit coverage
Subtable format 8 was designed to support Unicode supplementary-plane characters in
UTF-16 encoding, though it is not commonly used. Format 8 is similar to format 2 in
that it provides for mixed-length character codes. Instead of allowing for 8- and 16-bit
character codes, however, it allows for 16- and 32-bit character codes.
If a font contains Unicode supplementary-plane characters (U+10000 to U+10FFFF),
then it’s likely that it will also include Unicode BMP characters (U+0000 to U+FFFF) as
well. Hence, there is a need to map a mixture of 16-bit and 32-bit character codes. A
simplifying assumption is made: namely, that there are no 32-bit character codes which
share the same first 16 bits as any 16-bit character code. (Since the Unicode code space
extends only to U+10FFFF, a potential conflict exists only for characters U+0000 to
U+0010, which are non-printing control characters.) This means that the determination
as to whether a particular 16-bit value is a standalone character code or the start of a
32-bit character code can be made by looking at the 16-bit value directly, with no
further information required.
'cmap' Subtable Format 8:
ﾉ

Expand table

Type

Name

Description

uint16

format

Subtable format; set to 8.

uint16

reserved

Reserved; set to 0

uint32

length

Byte length of this subtable (including the header)

uint32

language

For requirements on use of the language field, see
“Use of the language field in 'cmap' subtables” in
this document.

uint8

is32[8192]

Tightly packed array of bits (8K bytes total)
indicating whether the particular 16-bit (index)
value is the start of a 32-bit character code

uint32

numGroups

Number of groupings which follow

SequentialMapGroup

groups[numGroups]

Array of SequentialMapGroup records.

Each sequential map group record specifies a character range and the starting glyph ID
mapped from the first character. Glyph IDs for subsequent characters follow in
sequence.
SequentialMapGroup Record:
ﾉ

Expand table

Type

Name

Description

uint32

startCharCode

First character code in this group; note that if this group is for one or
more 16-bit character codes (which is determined from the is32 array),
this 32-bit value will have the high 16-bits set to zero

uint32

endCharCode

Last character code in this group; same condition as listed above for the
startCharCode

uint32

startGlyphID

Glyph index corresponding to the starting character code

A few notes here. The endCharCode is used, rather than a count, because comparisons
for group matching are usually done on an existing character code, and having the
endCharCode be there explicitly saves the necessity of an addition per group. Groups
must be sorted by increasing startCharCode. A group’s endCharCode must be less than
the startCharCode of the following group, if any.
To determine if a particular word (cp) is the first half of 32-bit code points, one can use
an expression such as ( is32[ cp / 8 ] & ( 1 << ( 7 - ( cp % 8 ) ) ) ). If this is non-zero, then
the word is the first half of a 32-bit code point.

0 is not a special value for the high word of a 32-bit code point. A font must not have
both a glyph for the code point 0x0000 and glyphs for code points with a high word of
0x0000.
The presence of the packed array of bits indicating whether a particular 16-bit value is
the start of a 32-bit character code is useful even when the font contains no glyphs for a
particular 16-bit start value. This is because the system software often needs to know
how many bytes ahead the next character begins, even if the current character maps to
the missing glyph. By including this information explicitly in this table, no “secret”
knowledge needs to be encoded into the OS.
Although this format was created to support Unicode supplementary-plane characters,
it is not widely supported or used. Also, no character encoding other than Unicode uses
mixed 16-/32-bit characters. The use of this format is discouraged.

Format 10: Trimmed array
Subtable format 10 was designed to support Unicode supplementary-plane characters,
though it is not commonly used. Format 10 is similar to format 6 in that it defines a
trimmed array for a tight range of character codes. It differs, however, in that it uses 32bit character codes.
'cmap' Subtable Format 10:
ﾉ

Expand table

Type

Name

Description

uint16

format

Subtable format; set to 10.

uint16

reserved

Reserved; set to 0

uint32

length

Byte length of this subtable (including the header)

uint32

language

For requirements on use of the language field, see “Use of the language
field in 'cmap' subtables” in this document.

uint32

startCharCode

First character code covered

uint32

numChars

Number of character codes covered

uint16

glyphIdArray[]

Array of glyph indices for the character codes covered

This format is not widely used and is not supported on Windows platforms. It would be
most suitable for fonts that support only a contiguous range of Unicode supplementaryplane characters, but such fonts are rare.

Format 12: Segmented coverage
This is the standard character-to-glyph-index mapping subtable for fonts supporting
Unicode character repertoires that include supplementary-plane characters (U+10000 to
U+10FFFF).
Fonts that include a format 12 subtable can also include a format 4 subtable for
compatibility with older applications. This is not required, however. See the
Recommendations chapter for additional information.
Format 12 is similar to format 4 in that it defines segments for sparse representation. It
differs, however, in that it uses 32-bit character codes.
'cmap' Subtable Format 12:
ﾉ

Expand table

Type

Name

Description

uint16

format

Subtable format; set to 12.

uint16

reserved

Reserved; set to 0

uint32

length

Byte length of this subtable (including the header)

uint32

language

For requirements on use of the language field, see
“Use of the language field in 'cmap' subtables” in
this document.

uint32

numGroups

Number of groupings which follow

SequentialMapGroup

groups[numGroups]

Array of SequentialMapGroup records.

The sequential map group record is the same format as is used for the format 8
subtable. The qualifications regarding 16-bit character codes does not apply here,
however, since characters codes are uniformly 32-bit.
SequentialMapGroup Record:
ﾉ

Type

Name

Description

uint32

startCharCode

First character code in this group

uint32

endCharCode

Last character code in this group

Expand table

Type

Name

Description

uint32

startGlyphID

Glyph index corresponding to the starting character code

Groups must be sorted by increasing startCharCode. A group’s endCharCode must be
less than the startCharCode of the following group, if any. The endCharCode is used,
rather than a count, because comparisons for group matching are usually done on an
existing character code, and having the endCharCode be there explicitly saves the
necessity of an addition per group.

Format 13: Many-to-one range mappings
This subtable provides for situations in which the same glyph is used for hundreds or
even thousands of consecutive characters spanning across multiple ranges of the code
space. This subtable format may be useful for “last resort” fonts, although these fonts
may use other suitable subtable formats as well. (For “last resort” fonts, see also the
'head' table flags, bit 14.)
Note: Subtable format 13 has the same structure as format 12; it differs only in the
interpretation of the startGlyphID/glyphID fields.
'cmap' Subtable Format 13:
ﾉ

Expand table

Type

Name

Description

uint16

format

Subtable format; set to 13.

uint16

reserved

Reserved; set to 0

uint32

length

Byte length of this subtable (including the header)

uint32

language

For requirements on use of the language field, see
“Use of the language field in 'cmap' subtables” in
this document.

uint32

numGroups

Number of groupings which follow

ConstantMapGroup

groups[numGroups]

Array of ConstantMapGroup records.

The constant map group record has the same structure as the sequential map group
record, with start and end character codes and a mapped glyph ID. However, the same
glyph ID applies to all characters in the specified range rather than sequential glyph IDs.

ConstantMapGroup Record:
ﾉ

Expand table

Type

Name

Description

uint32

startCharCode

First character code in this group

uint32

endCharCode

Last character code in this group

uint32

glyphID

Glyph index to be used for all the characters in the group’s range.

Format 14: Unicode variation sequences
Subtable format 14 specifies the Unicode variation sequences (UVSes) supported by the
font. A variation sequence, according to the Unicode Standard, comprises a base
character followed by a variation selector. For example, <U+82A6, U+E0101>.
This subtable format must only be used under platform ID 0 and encoding ID 5.
The subtable partitions the UVSes supported by the font into two categories: “default”
and “non-default” UVSes. Given a UVS, if the glyph obtained by looking up the base
character of that sequence in the Unicode 'cmap' subtable (i.e., the BMP subtable or
BMP + supplementary-planes subtable) is the glyph to use for that sequence, then the
sequence is a “default” UVS. Otherwise, it is a “non-default” UVS, and the glyph to use
for that sequence is specified in the format 14 subtable itself.
The example at the bottom of the page shows how a font vendor can use format 14 for
a JIS-2004-aware font.
'cmap' Subtable Format 14:
ﾉ

Expand table

Type

Name

Description

uint16

format

Subtable format; set to 14.

uint32

length

Byte length of this subtable (including
this header)

uint32

numVarSelectorRecords

Number of variation Selector Records

VariationSelector

varSelector[numVarSelectorRecords]

Array of VariationSelector records.

Each VariationSelector record specifies a variation selector character, and offsets to
“default” and “non-default” tables used to map variation sequences using that variation
selector.
VariationSelector Record:
ﾉ

Expand table

Type

Name

Description

uint24

varSelector

Variation selector

Offset32

defaultUVSOffset

Offset from the start of the format 14 subtable to Default UVS
table. May be 0.

Offset32

nonDefaultUVSOffset

Offset from the start of the format 14 subtable to Non-Default
UVS table. May be 0.

The VariationSelector records are sorted in increasing order of varSelector. No two
records may have the same varSelector value.
A VariationSelector record and the data its offsets point to specify those UVSes
supported by the font for which the variation selector is the varSelector value of the
record. The base characters of the UVSes are stored in the tables pointed to by the
offsets. The UVSes are partitioned by whether they are default or non-default UVSes.
Glyph IDs to be used for non-default UVSes are specified in the Non-Default UVS table.

Default UVS table
A Default UVS table is simply a range-compressed list of Unicode scalar values,
representing the base characters of the default UVSes which use the varSelector of the
associated VariationSelector record.
DefaultUVS Table:
ﾉ

Expand table

Type

Name

Description

uint32

numUnicodeValueRanges

Number of Unicode character ranges.

UnicodeRange

ranges[numUnicodeValueRanges]

Array of UnicodeRange records.

Each Unicode range record specifies a contiguous range of Unicode values.

UnicodeRange Record:
ﾉ

Type

Name

Description

uint24

startUnicodeValue

First value in this range

uint8

additionalCount

Number of additional values in this range

Expand table

For example, the range U+4E4D – U+4E4F (3 values) will set startUnicodeValue to
0x004E4D and additionalCount to 2. A singleton range will set additionalCount to 0.
The sum (startUnicodeValue + additionalCount) must not exceed 0xFFFFFF.
The Unicode Value Ranges are sorted in increasing order of startUnicodeValue. The
ranges must not overlap; i.e., (startUnicodeValue + additionalCount) must be less than
the startUnicodeValue of the following range (if any).
All code points listed in the ranges array should have corresponding entries in a
Unicode 'cmap' subtable. Applications could encounter fonts in which this is not the
case, however.

Non-Default UVS table
A Non-Default UVS table is a list of pairs of Unicode scalar values and glyph IDs. The
Unicode values represent the base characters of all non-default UVSes which use the
varSelector of the associated VariationSelector record, and the glyph IDs specify the
glyph IDs to use for the UVSes.
NonDefaultUVS Table:
ﾉ

Expand table

Type

Name

Description

uint32

numUVSMappings

Number of UVS Mappings that follow

UVSMapping

uvsMappings[numUVSMappings]

Array of UVSMapping records.

Each UVSMapping record provides a glyph ID mapping for one base Unicode character,
when that base character is used in a variation sequence with the current variation
selector.
UVSMapping Record:

ﾉ

Type

Name

Description

uint24

unicodeValue

Base Unicode value of the UVS

uint16

glyphID

Glyph ID of the UVS

Expand table

The UVS Mappings are sorted in increasing order of unicodeValue. No two mappings in
this table may have the same unicodeValue values.
Typically, code points listed in the uvsMappings array will have corresponding entries in
a Unicode 'cmap' subtable. This is not required, however. For example, it might not be
the case if a font is intended for use with content in which a given Unicode character
only occurs in a variation sequence.

Example
Here is an example of how a format 14 'cmap' subtable may be used in a font that is
aware of JIS-2004 variant glyphs. The CIDs (character IDs) in this example refer to those
in the Adobe Character Collection “Adobe-Japan1” and can be assumed to be identical
to the glyph IDs in the font in our example.
JIS-2004 changed the default glyph variants for some of its code points. For example:
JIS-90: U+82A6 ⇒ CID 1142
JIS-2004: U+82A6 ⇒ CID 7961
Both of these glyph variants are supported through the use of Unicode variation
sequences, as the following examples from Unicode’s UVS registry show:
U+82A6 U+E0100 ⇒ CID 1142
U+82A6 U+E0101 ⇒ CID 7961
If the font wants to support the JIS-2004 variants by default, it will:
encode glyph ID 7961 at U+82A6 in the Unicode 'cmap' subtable;
specify <U+82A6, U+E0101> in the UVS 'cmap' subtable’s Default UVS table
(varSelector will be 0x0E0101 and defaultUVSOffset will point to data containing a
0x0082A6 Unicode value);
specify <U+82A6, U+E0100> ⇒ glyph ID 1142 in the UVS 'cmap' subtable’s NonDefault UVS table (varSelector will be 0x0E0100 and nonDefaultBaseUVSOffset will
point to data containing a unicodeValue 0x0082A6 and glyphID 1142).
If, however, the font wants to support the JIS-90 variants by default, it will:

encode glyph ID 1142 at U+82A6 in the Unicode 'cmap' subtable;
specify <U+82A6, U+E0100> in the UVS 'cmap' subtable’s Default UVS table;
specify <U+82A6, U+E0101> ⇒ glyph ID 7961 in the UVS 'cmap' subtable’s NonDefault UVS table.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

COLR — Color Table
Article • 05/31/2024

Overview
The COLR table adds support for multi-colored glyphs in a manner that integrates with
the rasterizers of existing text engines and that is designed to be easy to support with
current OpenType font files.
The COLR table defines color presentations for glyphs. The color presentation of a glyph
is specified as a graphic composition using other glyphs, such as a layered arrangement
of glyphs, each with a different color. The term “color glyph” is used informally to refer
to such a graphic composition defined in the COLR table; and the term “base glyph” is
used to refer to a glyph for which a color glyph is provided. Processing of the COLR
table is done on glyph sequences after text layout processing is completed and prior to
final presentation of glyphs. Typically, a base glyph is a glyph that may occur in a
sequence that results from the text layout process.
For example, the Unicode character U+1F600 is the grinning face emoji. Suppose in an
emoji font the 'cmap' table maps U+1F600 to glyph ID 718. Assuming no glyph
substitutions, glyph ID 718 would be considered the base glyph. Suppose the COLR
table has data describing a color presentation for this using a layered arrangement of
other glyphs with different colors assigned: that description and its presentation result
would be considered the corresponding color glyph.
Two versions of the COLR table are defined.
Version 0 allows for a simple composition of colored elements: a linear sequence of
glyphs that are stacked vertically as layers in bottom-up z-order. Each layer combines a
glyph outline from the 'glyf', 'CFF ' or CFF2 table (referenced by glyph ID) with a solid
color fill. These capabilities are sufficient to define color glyphs such as those illustrated
in the following figure:

Version 1 supports additional graphic capabilities. In addition to solid colors, gradient
fills can be used, as well as more complex fills using other graphic operations, including
affine transformations and various blending modes. Version 1 capabilities allow for color
glyphs such as those illustrated in the following figure:

Version 1 also extends capabilities in variable fonts. A COLR version 0 table can be used
in variable fonts with glyph outlines being variable, but no other aspect of the color
composition being variable. In version 1, all of the new constructs for which it could be
relevant have been designed to be variable; for example, the placement of color stops in
a gradient, or the alpha values applied to colors. The graphic capabilities supported in
version 0 and in version 1 are described in more detail below.
The COLR table is used in combination with the CPAL table: all color values are specified
as entries in color palettes defined in the CPAL table. If the COLR table is present in a
font but no CPAL table exists, then the COLR table is ignored.
Some applications can simulate italic/oblique or bold appearance if italic or bold
formatting is applied to text that is displayed with a non-italic or non-bold font. If text is
displayed using color glyphs, such simulations could badly distort the appearance of the
color glyphs. Applications should not apply simulations designed for use in non-color
glyph rendering when displaying color glyphs.

Graphic compositions
Introduction: 2D graphic concepts
The graphic compositions in a color glyph definition use a set of 2D graphic concepts
and constructs:
Shapes (or geometries)
Fills (or shadings)
Layering—a z-order—of elements

Composition and blending modes—different ways that the content of a layer is
combined with the content of layers above or below it
Affine transformations
For both version 0 and version 1, shapes are obtained from glyph outlines in the 'glyf',
'CFF ' or CFF2 table, referenced by glyph ID. Colors used in fills are obtained from the
CPAL table.
The simplest color glyphs use just a few of the concepts above: shapes, solid color fills,
and layering. This is the set of capabilities provided by version 0 of the COLR table. In
version 0, a base glyph record specifies the color glyph for a given base glyph as a
sequence of layers. Each layer is specified in a layer record and has a shape (a glyph ID)
and a solid color fill (a CPAL palette entry). The filled shapes in the layer stack are
composed using only alpha blending.
The following figure illustrates the version 0 capabilities: three shapes are in a layered
stack: a blue square in the bottom layer, an opaque green circle in the next layer, and a
red triangle with some transparency in the top layer.

The basic concepts also apply to color glyphs defined using the version 1 formats:
shapes have fills and can be arranged in layers. But the additional formats of version 1
support much richer capabilities. In a version 1 color glyph, graphic constructs and
capabilities are represented primarily in Paint tables, which are linked together in a
directed, acyclic graph. Several different Paint formats are defined, each describing a
particular type of graphic operation:
A PaintColrLayers table provides a layering structure used for creating a color
glyph from layered elements. A PaintColrLayers table can be used at the root of
the graph, providing a base layering structure for the entire color glyph definition.
A PaintColrLayers table can also be nested within the graph, providing a set of
layers to define some graphic sub-component within the color glyph.

The PaintSolid, PaintVarSolid, PaintLinearGradient, PaintVarLinearGradient,
PaintRadialGradient, PaintVarRadialGradient, PaintSweepGradient, and
PaintVarSweepGradient tables provide basic fills, using color entries from the CPAL
table.
The PaintGlyph table provides glyph outlines as the basic shapes.
The PaintTransform and PaintVarTransform tables are used to apply an affine
transformation matrix to a sub-graph of paint tables, and the graphic operations
they represent. Several Paint formats are also provided for specific transformation
types: translate, scale, rotate, or skew, with additional variants of these formats for
variations and other options.
The PaintComposite table supports alternate compositing and blending modes for
two sub-graphs.
The PaintColrGlyph table allows a color glyph definition, referenced by a base
glyph ID, to be re-used as a sub-graph within multiple color glyphs.
Note: Some paint formats come in Paint* and PaintVar* pairs. In these cases, the
latter format supports variations in variable fonts, while the former provides a more
compact representation for the same graphic capability but without variation
capability.
In a simple color glyph description, a PaintGlyph table might be linked to a PaintSolid
table, for example, representing a glyph outline filled using a basic solid color fill. But
the PaintGlyph table could instead be linked to a much more complex sub-graph of
Paint tables, representing a shape that gets filled using the more-complex set of
operations described by the sub-graph of Paint tables.
The graphic capabilities are described in more detail in the following sections. The
formats used for these will be specified later in this chapter—see COLR table formats.

Colors and solid color fills
All colors are specified as a base zero index into CPAL palette entries. A font can define
alternate palettes in its CPAL table; it is up to the application to determine which palette
is used. A palette entry index value of 0xFFFF is a special case indicating that the text
foreground color (defined by the application) should be used, and must not be treated
as an actual index into the CPAL ColorRecord array.
The CPAL color data includes alpha information, as well as RGB values. In the COLR
version 0 formats, a color reference is made in a LayerRecord as a palette entry index

alone. In the formats added for COLR version 1, color references include a palette entry
index and a separate alpha value within the COLR structure for a solid color fill or
gradient color stop (described below). Separation of alpha from palette entries in
version 1 allows use of transparency in a color glyph definition independent of the
choice of palette. The alpha value in the COLR structure is multiplied into the alpha
value given in the CPAL color entry. If the palette entry index is 0xFFFF, the alpha value
in the COLR structure is multiplied into the alpha value of the text foreground color.
In version 1, a solid color fill is specified using a PaintVarSolid or PaintSolid table, with or
without variation support, respectively. See Formats 2 and 3: PaintSolid, PaintVarSolid for
format details.
See Filling shapes for details on how fills are applied to a shape.

Gradients
COLR version 1 supports three types of gradients: linear gradients, radial gradients, and
sweep gradients. For each type, non-variable and variable formats are defined. Each
type of gradient is specified using a color line.

Color lines
A color line is a function that maps real numbers to color values to define a onedimensional gradation of colors, to be used in the definition of linear, radial, or sweep
gradients. A color line is defined as a set of one or more color stops, each of which maps
a particular real number to a specific color.
On its own, a color line has no positioning, orientation or size within a design grid. The
definition of a linear, radial, or sweep gradient will reference a color line and map it onto
the design grid by specifying positions in the design grid that correspond to the real
values 0 and 1 in the color line. The specifications for linear, radial and sweep gradients
also include rules for where to draw interpolated colors of the color line, following from
the placement of 0 and 1.
A color stop is defined by a real number, the stop offset, and a color. Stop offsets are
represented using F2DOT14 values, therefore color stops can only be specified within
the range [-2, 2). In a variable font, however, stop offsets can be variable, and with the
application of deltas can lie outside that range. (See Color references, ColorStop and
ColorLine for format details.) A color line requires at least one color stop to paint any
color values. If the color line does not have any color stops, then transparent black is
used for the entire color line. If only one color stop is specified, that color is used for the
entire color line. At least two color stops are needed to create color gradation.

Color gradation is defined over the interval from the color stop with the minimum
offset, through successive color stops, to the color stop with the maximum offset.
Between numerically-adjacent color stops, color values are linearly interpolated. See
Interpolation of Colors for requirements on how colors are interpolated.
Color stops must be used in their stop offset order, which can be different from the order
in which they are defined in the font. Also, when processing a selected instance of a
variable font, stops must be re-ordered according to offset values after variation deltas
are applied. Therefore, the ordering of colors in the color line definition can change
between one variation instance and another instance.
Color values outside the defined interval are determined by the color line’s extend mode,
described below. In this way, colors are defined for all stop offset values, from negative
infinity to positive infinity.
For example, a gradient color line could be defined with two color stops at 0.2 and 1.5.
Colors for offsets between 0.2 and 1.5 are interpolated. Colors for offsets above 1.5 and
below 0.2 are determined by the color line’s extend mode.
If there are multiple color stops defined for the same stop offset, the first one given in
the font must be used for computing color values on the color line below that stop
offset, and the last one must be used for computing color values at or above that stop
offset. All other color stops for that stop offset must be ignored. In a variable font, if two
color stops have different default offset values but vary to have the same offset value for
a given variation instance, those stops must be applied to the color line in the order in
which they are given in the font, as described above.
The color patterns outside the defined interval are determined by the color line’s extend
mode. Three extend modes are supported:
Pad: outside the defined interval, the color of the closest color stop is used. Using
a sequence of letters as an analogy, given a sequence “ABC”, it is extended to “…
AA ABC CC…”.
Repeat: The color line is repeated over repeated multiples of the defined interval.
For example, if color stops are specified for a defined interval of [0.2, 1.5], then the
pattern is repeated above the defined interval for intervals (1.5, 2.8], (2.8, 4.1], etc.;
and also repeated below the defined interval for intervals [-1.1, 0.2), [-2.4, -1.1), etc.
In each repeated interval, the first color is that of the farthest defined color stop. By
analogy, given a sequence “ABC”, it is extended to “…ABC ABC ABC…”.
Reflect: The color line is repeated over repeated intervals, as for the repeat mode.
However, in each repeated interval, the ordering of color stops is the reverse of the

adjacent interval. By analogy, given a sequence “ABC”, it is extended to “…ABC CBA
ABC CBA ABC…”.
The following figures illustrate the different color line extend modes. The figures show
the color line extended over a limited interval, but the extension is unbounded in either
direction.

Color gradation extended using pad mode

Color gradation extended using repeat mode

Color gradation extended using reflect mode
Note: The extend modes are the same as the spreadMethod

attribute used for

linear and radial gradients in the Scalable Vector Graphics (SVG) 1.1 (Second
Edition)

specification.

If all color stops have the same offset and the extend mode is pad, the color line has two
colors: the first stop is used below that offset, and the last stop is used at and above that
offset. However, if the extend mode is repeat or reflect, the color line is ill-formed and
nothing must be rendered.
When combining a color line with the geometry of a particular gradient definition, one
might want to achieve a certain number of repetitions of the gradient pattern over a
particular geometric range. Assuming that geometric range will correspond to
placement of stop offsets 0 and 1, the following steps can be used:
In order to get a certain number of repetitions of the gradient pattern (without
reflection), divide 1 by the number of desired repetitions, use the result as the
maximum stop offset for specified color stops, and set the extend mode to repeat.
In order to get a certain number of repetitions of the reflected gradient pattern,
divide 1 by two times the number of desired repetitions, use the result as the
maximum stop offset for specified color stops, and set the extend mode to reflect.
Note: Given the above specifications for how color lines are defined, and also
allowing for the application of variation deltas, the definition of a color line can span
an interval greater than, narrower than, or in other ways different from the interval
[0, 1]. However, some application platforms that provide an implementation for
gradients can require a color line to be defined for exactly the interval [0, 1].

Implementations can work around such constraints by normalizing the offsets of the
defined color stops. For example, if constrained to the range [0, 1], map the lowest
stop offset to 0, map the largest offset to 1, and linearly interpolate normalized
offsets for other stops in between. Then, for correct alignment to the geometry of a
gradient definition, interpolate or extrapolate alternate geometric values to align
with the normalized 0 and 1 stop offsets. For radial gradients, special geometry
considerations can also apply; see Radial gradients for more information.
Color lines are specified using color line tables, which contain arrays of color stop
records. Two color line table and two color stop record formats are defined:
ColorLine table and ColorStop record
VarColorLine table and VarColorStop record
The VarColorLine and VarColorStop formats can be used in variable fonts and allow for
stop offsets and color alpha values to be variable. The ColorLine and ColorStop formats
provide a more compact representation when variation is not required. See Color
references, ColorStop and ColorLine for format details.

Linear gradients
A linear gradient provides gradation of colors along a straight line. The gradient is
defined by three points, p₀, p₁ and p₂, plus a color line. The color line is positioned in the
design grid with stop offset 0 aligned to p₀ and stop offset 1.0 aligned to p₁. (The line
passing through p₀ and p₁ will be referred to as line p₀p₁.) Colors at each position on
line p₀p₁ are interpolated using the color line. For each position along line p₀p₁, the
color at that position is projected on either side of the line.
The additional point, p₂, is used to rotate the gradient orientation in the space on either
side of the line p₀p₁. The line passing through points p₀ and p₂ (line p₀p₂) determines
the direction in which colors are projected on either side of the color line. That is, for
each position on line p₀p₁, the line that passes through that position on line p₀p₁ and
that is parallel to line p₀p₂ will have the color for that position on line p₀p₁.
Note: For convenience, point p₂ can be referred to as the rotation point, and the
vector from p₀ to p₂ can be referred to as the rotation vector. However, neither the
magnitude of the vector nor the direction (from p₀ to p₂, versus from p₂ to p₀) has
significance.
If either point p₁ or p₂ is the same as point p₀, the gradient is ill-formed and must not be
rendered.

If line p₀p₂ is parallel to line p₀p₁ (or near-parallel for an implementation-determined
definition), then the gradient is ill-formed and must not be rendered.
Note: An implementation can derive a single vector, from p₀ to a point p₃, by
computing the orthogonal projection of the vector from p₀ to p₁ onto a line
perpendicular to line p₀p₂ and passing through p₀ to obtain point p₃. The linear
gradient defined using p₀, p₁ and p₂ as described above is functionally equivalent to
a linear gradient defined by aligning stop offset 0 to p₀ and aligning stop offset 1.0
to p₃, with each color projecting on either side of that line in a perpendicular
direction. This specification uses three points, p₀, p₁ and p₂, as that provides greater
flexibility in controlling the placement and rotation of the gradient, as well as
variations thereof.
The following figures illustrate linear gradients using the three different color line extend
modes. Each figure illustrates linear gradients with two different rotation vectors. In each
case, three color stops are specified: red at 0.0, yellow at 0.5, and blue at 1.0.

Linear gradients with different rotations using the pad extend mode

Linear gradients with different rotations using the repeat extend mode

Linear gradients with different rotations using the reflect extend mode
Note: When a linear gradient is combined with a transformation (see
Transformations), the appearance will be the same as if the gradient were defined

using the transformed positions of points p₀, p₁ and p₂.
Linear gradients are specified using a PaintVarLinearGradient or PaintLinearGradient
table, with or without variation support, respectively. See Formats 4 and 5:
PaintLinearGradient, PaintVarLinearGradient for format details.
See Filling shapes for details on how fills are applied to a shape.
Note on implementation of linear gradients
Some application platforms can provide an implementation for linear gradients that
requires a color line to be specified for exactly the interval [0, 1]. If an application is
using such a platform implementation but the font has a linear gradient with a color line
specified over a different interval, the application can work around the platform
constraint by normalizing the color line to the interval [0, 1]. This would require deriving
alternate geometric points for the linear gradient definition. For the defined points p₀, p₁
and p₂, alternate points p₀′, p₁′ and p₂′ can be derived as follows: if omin is the minimum
stop offset in the defined color line, omax is the maximum offset, and vector v = p₁ - p₀,
then let
p₀′ = p₀ + ominv
p₁′ = p₀ + omaxv
p₂′ = p₂ + ominv
If an implementation derives a single vector with point p₃, as described above, then
alternate points p₀ and p₃ can be derived as follows: with vector w = p₃ - p₀, let
p₀′ = p₀ + ominw
p₃′ = p₀ + omaxw

Radial gradients
A radial gradient provides gradation of colors along a cylinder defined by two circles.
The gradient is defined by circles with center c₀ and radius r₀, and with center c₁ and
radius r₁, plus a color line. The color line aligns with the two circles by associating stop
offset 0 with the first circle (with center c₀) and aligning stop offset 1.0 with the second
circle (with center c₁).
Note: The term “radial gradient” is used in some contexts for more limited
capabilities. In some contexts, the type of gradient defined here is referred to as a
“two point conical” gradient.

The drawing algorithm for radial gradients follows the HTML WHATWG Canvas
specification for createRadialGradient()

, but adapted with alternate color line extend

modes and more flexibility for color stop offsets. Radial gradients must be rendered with
results that match the results produced by the following steps.
With circle center points c₀ and c₁ defined as c₀ = (x₀, y₀) and c₁ = (x₁, y₁):
1. If c₀ = c₁ and r₀ = r₁ then paint nothing and return.
2. For real values of ω:
Let x(ω) = (x₁-x₀)ω + x₀
Let y(ω) = (y₁-y₀)ω + y₀
Let r(ω) = (r₁-r₀)ω + r₀
Let the color at ω be the color at position ω on the color line.
3. For all values of ω where r(ω) > 0, starting with the value of ω nearest to positive
infinity and ending with the value of ω nearest to negative infinity, draw the
circular line with radius r(ω) centered at position (x(ω), y(ω)), with the color at ω,
but only painting on the parts of the bitmap that have not yet been painted on in
this step of the algorithm for earlier values of ω.
The algorithm provides results in various cases as follows:
When the circles are identical, then nothing is painted.
When both radii are 0 (r₀ = r₁ = 0), then r(ω) is always 0 and nothing is painted.
If the centers of the circles are distinct, the radii of the circles are different, and
neither circle is entirely contained within the radius of the other circle, then the
resulting shape resembles a cone that is open to one side. The surface outside the
cone is not painted. (See figures below.)
If the centers of the circles are distinct but the radii are the same, and neither circle
is contained within the other, then the result will be a strip, similar to the flattened
projection of a circular cylinder. The surface outside the strip is not painted. (See
figures below.)
If the radii of the circles are different but one circle is entirely contained within the
radius of the other circle, the gradient will radiate in all directions from the inner
circle, and the entire surface will be painted. (See figures below.)
The following figures illustrate radial gradients using the three different color line extend
modes. The color line is defined with stops for the interval [0, 1]: red at 0.0, yellow at 0.5,
and blue at 1.0. Note that the circles that define the gradient are not stroked as part of
the gradient itself. Stroked circles have been overlaid in the figure to illustrate the color
line and the region that is painted in relation to the two circles.

Radial gradient using pad extend mode

Radial gradient using repeat extend mode

Radial gradient using reflect extend mode
The following figures illustrate the case in which the circles have distinct centers but the
same radii, and neither circle is contained within the other, giving the appearance of a
strip. The color stops are as in the previous figures.

Radial gradient with same-size circles appearing as a strip, using pad extend mode

Radial gradient with same-size circles appearing as a strip, using repeat extend mode

Radial gradient with same-size circles appearing as a strip, using reflect extend mode
Because the rendering algorithm progresses ω in a particular direction, from positive
infinity to negative infinity, and because pixels are not re-painted as ω progresses, the
appearance will be affected by which circle is considered circle 0 and which is circle 1.
This is illustrated in the following three figures. The gradient in the first figure is the
same as was shown above of a radial gradient using the pad extend mode. In this
gradient, circle 0 is the small circle, on the left. In the second figure, the start and end
circles are reversed: circle 0 is the large circle, on the right. The color line is kept the
same, and so the red end starts at circle 0, now on the right. In the third figure, the order
of stops in the color line is also reversed to put red on the left. The key difference to
notice between the gradients in these figures is the way that colors are painted in the
interior: when the two circles are not overlapping, the arcs of constant color bend in the
same direction as the near side of circle 1.
Note: This difference does not exist if one circle is entirely contained within the
other: in that case, the arcs of constant color are complete circles.

Cone-shaped radial gradient with circle 0 on the left

Cone-shaped radial gradient with start and end circles swapped

Cone-shaped radial gradient with start and end circles swapped and color line reversed
When one circle is contained within the other, the extension of the gradient beyond the
larger circle will fill the entire surface. Colors in the areas inside the inner circle and
outside the outer circle are determined by the extend mode. The following figures
illustrate this for the different extend modes.

Radial gradient with one circle contained within the other, pad extend mode

Radial gradient with one circle contained within the other, repeat extend mode

Radial gradient with one circle contained within the other, reflect extend mode
Note: When a radial gradient is combined with a transformation (see
Transformations), the appearance will be the same as if the geometry of the two
circles were transformed and step 3 of the algorithm were performed by
interpolating the shapes derived from the two transformed circles. For the condition
r(ω) > 0, the pre-transformation values of r(ω) can be used.
Note: A scale transformation can flatten shapes to resemble lines. If a radial gradient
is nested in the child sub-graph of a transformation that flattens the circles so that
they are nearly lines, the centers could still be separated by some distance. In that
case, the radial gradient would appear as a strip, or as a cone filled with a linear
gradient.
If a radial gradient is nested in the sub-graph of a transformation that flattens the circles
so that they form a single line (or nearly a line, for an implementation-determined
definition), with both centers on that line, then the resulting gradient is degenerate and
must not be rendered.
Note: As seen in the figures above, the gradient fills the space when one circle is
contained within the other, but not when neither circle is contained within the other.
In a variable font, if the placement or radii of the circles vary, then a sharp transition

can occur if the variation results in one circle being contained within the other for
some instances but not for other instances. This transition will occur when the inner
circle just touches the outer circle (i.e., they have exactly one point in common). In
this case, the gradient will fill exactly one half of the space. This is illustrated in the
following figure using the pad extend mode.

Radial gradient with inner circle just touching the outer circle, pad extend mode
When the repeat or reflect extend modes are used, having the two circles in very close
proximity results in very high spatial-frequency transitions that can lead to Moiré
patterns or other display artifacts. This is illustrated in the following figure, which shows
the display result, for one particular rendering context, of a radial gradient defined using
nearly-identical circles and the reflect extend mode.

Radial gradient defined using nearly-identical circles, showing interference patterns
The artifacts seen can be affected by a combination of several factors, such as image
scaling, sub-pixel rendering, display technology, and limitations in software
implementation or display capabilities. For this reason, the appearance can be very
different in different situations. Font designers should exercise caution if the circles are
in close proximity (either in a static design or for some variable font instances), and
should not rely on these display artifacts to obtain a particular pattern.
While the Paint table formats use unsigned values to define the circle radii, application
of deltas in variable fonts can result in negative radii values. While a negative radius

does not seem to make sense intuitively, negative radii are not a problem for the
rendering algorithm described above: given the formula r(ω) = (r₁-r₀)ω + r₀, r(ω) will
have positive and negative values for different values of ω when the values of r₀ and r₁
are both positive, but also if either r₀ or r₁, or both, are negative. For example, if r₀ = -1
and r₁ = -2, then r(ω) = ω - 2, and r(ω) ≥ 0 for ω ≥ 2. There is one notable change,
however, in the case of r₀ = r₁ (hence, r(ω) = r₀): if the values are positive, a cylinder is
painted (since r₀ > 0), but if the values are negative, then nothing is painted (since r₀ <
0).
Note: If r₀ is different from r₁, the geometry defined by the two circles can be
understood as a 2D projection of a cone. The cone has a tip where r(ω) = 0, and the
cone is painted on the side of the tip for which r(ω) ≥ 0. In the general case,
ωtip = r₀/(r₀ - r₁)
if r₁ > r₀, r(ω) > 0 for all ω > r₀/(r₀ - r₁)
if r₁ < r₀, r(ω) > 0 for all ω < r₀/(r₀ - r₁)
Radial gradients are specified using a PaintVarRadialGradient or PaintRadialGradient
table, with or without variation support, respectively. See Formats 6 and 7:
PaintRadialGradient, PaintVarRadialGradient for format details.
See Filling shapes for details on how fills are applied to a shape.
Note on implementation of radial gradients
Some application platforms can provide an implementation for radial gradients that
require the circle radii to be non-negative. If an application is using such a platform
implementation but a variable font instance has a radial gradient with a negative circle
radius, the application can work around the platform constraint by deriving an alternate
gradient definition that uses only circles with non-negative radii and that produces the
same visual appearance. This would also require deriving an alternate color line
definition that preserves the same color line extend mode behaviors.
Similarly, if the platform provides an implementation for radial gradients that requires
color stops to be defined for exactly the interval [0, 1] but the font has a radial gradient
with a color line specified over a different interval, the application can work around that
platform constraint by normalizing the color line to the interval [0, 1]. But the
normalized color line would require deriving alternate circle specifications, and a simple
normalization can result in a circle with a negative radius.
Thus, handling of negative circle radii and normalization of the color line need to be
considered together. The following observations will be helpful:

If r₀ and r₁ are positive and r₀ = r₁, a simple normalization of the color line can be
used.
If the color stops that define the color line all have offsets ω such that r(ω) ≥ 0,
then a simple normalization of the color line can be used with alternate circles that
have non-negative radii.
For pad extend mode, if some color stops have offsets ω such that r(ω) < 0, the
same visual result can be obtained by using a truncated color line definition in
which all stops with offsets ω such that r(ω) < 0 are replaced by a single stop for
ωtip with an interpolated color value. (See Interpolation of Colors for requirements
on how colors are interpolated.)
For pad and repeat extend modes, the extended color line has a repeating pattern
with offset wavelength λ, and any color line definition that is a slice of the color
line of length λ will produce the same visual results. Thus, the application can
derive an alternate color line definition in which all stops have offsets ω such that
r(ω) ≥ 0, normalize those stop offsets to [0, 1], then derive alternate circles that
align to the normalized 0 and 1 offsets.

Sweep gradients
A sweep gradient provides a gradation of colors that sweep around a center point. For a
given color on a color line, that color projects as a ray from the center point in a given
direction. This is illustrated in the following figure.
Note: The following figures illustrate sweep gradients clipped to a region. Sweep
gradients are not bounded, however, and fill the entire space.

A sweep gradient
Note: In some contexts, this type of gradient is referred to as a “conic” gradient, or
as an “angular” gradient.

A sweep gradient is defined by a center point, start and end angles, and a color line. The
angles are expressed in counter-clockwise degrees from the direction of the positive xaxis on the design grid.
For sampling and interpolating colors, the color line is aligned to an infinitely spiraling
circular arc around the center point, with arbitrary radius. The position 0° on the arc
means the direction of the positive x-axis, and 360° means one full counter-clockwise
rotation. The color line’s stop offset 0 is aligned with the start angle and stop offset 1 is
aligned with the end angle, independent of which angle is larger.
Outside the defined interval of the color line, the color value of a position on the color
line is filled in depending on its extend mode. See Color Lines for more details. In effect,
this means that the spiraling circular arc can be sampled for colors outside the defined
color line interval.
To draw the sweep gradient, for each position along the circular arc starting from 0° up
to but not including 360°, a ray from the center outward is painted with the color of the
color line where the ray intersects the circular arc at that particular angle. Angle
positions below 0° and equal to or above 360° are not sampled for drawing the rays.
If the color line's extend mode is reflect or repeat and start and end angle are equal,
nothing shall be drawn.
When the sweep gradient's color line uses the repeat or reflect extend mode and the
angular distance between the start and end angles is small, this results in very high
spatial-frequency transitions that can lead to Moiré patterns or other display artifacts.
(See above where this effect is shown for a similar case involving radial gradients).
The following figure illustrates a sweep gradient with the drawing direction progressing
from 0° to 360°. The gradient is specified with a start angle of 110° and end angle of
230°. The color line is specified with a yellow stop at offset 0 (aligned to the start angle)
and a red stop at offset 1 (aligned to the end angle). The pad extend mode is used,
hence the color for angles below 110° is yellow, and the color for angles above 150° is
red.

A sweep gradient with start angle of 110° and an end angle of 230°, using a color line
with color stops 0 and 1 for yellow and red and pad extend mode.
Note: If the start angle is less than or equal to the end angle, the color line
progresses from smaller to larger offsets in the counter-clockwise direction along
the circular arc. If the start angle is larger than the end angle, however, the color line
is inverted and progresses in the clockwise direction, as illustrated in the following
figure.

A sweep gradient, from yellow to red, with start angle of 210° and end angle of 110°,
showing the inversion of the color line when the start angle is larger than the end angle.
Not more than one full rotation is drawn and there is no overlap in drawing for angles
outside the 0° to 360° range. However, start and end angles may be positioned at
angles below 0° or above 360°. Through that, and through how wide the color line
interval is defined, color stops can lie outside the 0° to 360° circle. This has an effect on
the computation of the gradient colors inside the interval of 0° to 360°, but colors are
not sampled from outside this interval. See the following figure for an example: The
color line goes from yellow to red with a start angle of 330° and an end angle of 400°.
The color for angles lower than 330° is yellow due to the pad extend mode, then the
color line transitions from yellow at 330° to red at 400°, but only the color values up
until 360° are sampled for drawing.

A sweep gradient with a start angle of 330° and an end angle of 400°, using a color line
with color stops 0 and 1 for yellow and red and extend mode pad.
Note: Because the sweep gradient is drawn from 0° to 360° a sharp transition can
occur at 0°. This can be mitigated by adjusting the color stops at the 0° and 360°
positions on the arc to have the same color. The location of the transition axis can
also be shifted by nesting the sweep gradient inside a rotation transformation (see
Transformations).
Note: When a sweep gradient is combined with a transformation, the appearance
will be the same as if (i) a circle of some non-zero radius was constructed with
points on the circle computed from the start and end angles; (ii) the center point,
circle and points on the circle were transformed; (iii) the color line was aligned to
the transformed circle; and then (iv) a gradient was derived from the result, with rays
from the transformed center point passing through the transformed color circle.
When aligning the color line to the transformed circle, stop offset 0 would be
aligned to the transformed point derived from the start angle, with stop offset 1
aligned to the transformed point derived from the end angle. Thus, a transform can
result in the color line progressing in the opposite direction compared to the nontransformed gradient.
Sweep gradients are specified using a PaintVarSweepGradient or PaintSweepGradient
table, with or without variation support, respectively. See Formats 8 and 9:

PaintSweepGradient, PaintVarSweepGradient for format details.
See Filling shapes for details on how fills are applied to a shape.

Filling shapes
All basic shapes used in a color glyph are obtained from glyph outlines, referenced
using a glyph ID. In a color glyph description, a PaintGlyph table is used to represent a
basic shape.
Note: Shapes can also be derived using PaintGlyph tables in combination with other
tables, such as PaintTransform (see Transformations) or PaintComposite (see
Compositing and blending).
The PaintGlyph table has a field for the glyph ID, plus an offset to a child paint table that
is used as the fill for the shape. The glyph outline is not rendered; only the fill is
rendered.
Any of the basic fill formats (PaintSolid, PaintVarSolid, PaintLinearGradient,
PaintVarLinearGradient, PaintRadialGradient, PaintVarRadialGradient,
PaintSweepGradient, PaintVarSweepGradient) can be used as the child paint table. This is
illustrated in the following figure: a PaintGlyph table has a glyph ID for an outline in the
shape of a triangle, and it links to a child PaintLinearGradient table. The combination is
used to represent a triangle filled with the linear gradient.

PaintGlyph and PaintLinearGradient tables used to fill a shape with a linear gradient
The child of a PaintGlyph table is not, however, limited to one of the basic fill formats.
Rather, the child can be the root of a sub-graph that describes some graphic
composition that is used as a fill. Another way to describe the relationship between a

PaintGlyph table and its child sub-graph is that the glyph outline specified by the
PaintGlyph table defines a bounds, or clip region, that is applied to the fill composition
defined by the child sub-graph.
To illustrate this, the example in the previous figure is extended so that a PaintGlyph
table links to a second PaintGlyph that links to a PaintLinearGradient: the parent
PaintGlyph will clip the filled shape described by the child sub-graph.

A PaintGlyph table defines a clip region for the composition defined by its child subgraph
A PaintGlyph table on its own does not add content: if there is no child paint table, then
the graph is not well formed. See Color glyphs as a directed acyclic graph for details
regarding well-formedness and validity of the graph.

Layering
Layering of visual elements was introduced above in Introduction: 2D graphic concepts.
Both COLR version 0 and version 1 support the use of multiple layers, though in
different ways.
For version 0, layers are fundamental: they are the sole way in which separate elements
are composed into a color glyph. An array of LayerRecords is created, with each
LayerRecord specifying a glyph ID and a CPAL entry (a shape and solid color fill). Each
color glyph definition is a slice from that array (that is, a contiguous sub-sequence),
specified in a BaseGlyphRecord for a particular base glyph. Within a given slice, the first
record specifies the content of the bottom layer, and each subsequent record specifies
content that overlays the preceding content (increasing z-order). A single array is used
for defining all color glyphs. The LayerRecord slices for two base glyphs may overlap,
though often will not overlap.
The following figure illustrates layers using version 0 formats.

Version 0: Color glyphs are defined by slices of a layer records array
When using version 1 formats, use of multiple layers is supported but is optional. For
example, a simple glyph description need not use any layering, as illustrated in the
following figure:

Complete color glyph definition without use of layers
The version 1 formats define a color glyph as a directed, acyclic graph of paint tables,
and the concept of layering corresponds roughly to the number of distinct leaf nodes in
the graph. (See Color glyphs as a directed acyclic graph.) The basic fill formats
(PaintSolid, PaintVarSolid, PaintLinearGradient, PaintVarLinearGradient,
PaintRadialGradient, PaintVarRadialGradient, PaintSweepGradient,
PaintVarSweepGradient) do not have child paint tables and so can only be leaf nodes in
the graph. Some paint tables, such as the PaintGlyph table, have only a single child, so
can be used within a layer but do not provide any means of adding additional layers.

Increasing the number of layers requires paint tables that have two or more children,
creating a fork in the graph.
The version 1 formats include two paint formats that have two or more children, and so
can increase the number of layers in the graph:
The PaintComposite table allows two sub-graphs to be composed together using
different compositing or blending modes.
The PaintColrLayers table supports defining a sequence of several layers.
Note: The PaintColrGlyph table provides a means of incorporating the graph of one
color glyph as a sub-graph in the definition of another color glyph. In this way,
PaintColrGlyph provides an indirect means of introducing additional layers into a
color glyph definition: forks in the resulting graph do not come from the
PaintColrGlyph table itself, but can come from PaintColrLayers or PaintComposite
tables that are nested in the incorporated sub-graph. See Re-use using
PaintColrGlyph for a description of the PaintColrGlyph table.
While the PaintComposite table only combines two sub-graphs, other PaintComposite
tables can be nested to provide additional layers. The primary purpose of
PaintComposite is to support compositing or blending modes other than simple alpha
blending. The PaintComposite table is covered in more detail in Compositing and
blending. The remainder of this section will focus on the PaintColrLayers table.
The PaintColrLayers table is used to define a bottom-up z-order sequence of layers.
Similar to version 0, it defines a layer set as a slice in an array, but in this case the array is
an array of offsets to paint tables, contained in a LayerList table. Each referenced paint
table is the root of a sub-graph of paint tables that specifies a graphic composition to
be used as a layer. Within a given slice, the first offset provides the content for the
bottom layer, and each subsequent offset provides content that overlays the preceding
content. Definition of a layer set—a slice within the layer list—is given in a
PaintColrLayers table.
The following figure illustrates the organizational relationship between PaintColrLayers
tables, the LayerList, and referenced paint tables that are roots of sub-graphs.

Version 1: PaintColrLayers tables specify slices within the LayerList, providing a layering
of content defined in sub-graphs
Note: Paint table offsets in the LayerList table are only used in conjunction with
PaintColrLayers tables. If a paint table does not need to be referenced via a
PaintColrLayers table, its offset does not need to be included in the LayerList array.
A PaintColrLayers table can be used as the root of a color glyph definition, providing a
base layering structure for the color glyph. In this usage, the PaintColrLayers table is
referenced by a BaseGlyphPaintRecord, which specifies the root of the graph of a color
glyph definition for a given base glyph. This is illustrated in the following figure.

PaintColrLayers table used as the root of a color glyph definition
A PaintColrLayers table can also be nested more deeply within the graph, providing a
layer structure to define some component within a larger color glyph definition. (See Re-

use using PaintColrLayers for more information.) The ability to nest a PaintColrLayers
table within a graph creates the potential to introduce a cycle within the graph, which
would be invalid (see Color glyphs as a directed acyclic graph).

Transformations
A 2 × 3 transformation matrix can be used within a color glyph description to apply an
affine transformation to a sub-graph. Affine transformations supported by a matrix can
be a combination of scale, skew, mirror, rotate, or translate. The transformation is
applied to all nested paints in the child sub-graph.
A transformation matrix is specified using a PaintVarTransform or PaintTransform table,
with or without variation support, respectively. See Formats 12 and 13: PaintTransform,
PaintVarTransform for format details.
The effect of a transformation is illustrated in the following figure: a PaintTransform is
used to specify a rotation, and both the glyph outline and gradient in the sub-graph are
rotated.

A rotation transformation rotates the fill content defined by the child sub-graph
If the sub-graph of a transformation table contains another nested transformation table,
then the second transformation also applies to its child sub-graph. For the sub-subgraph, the two transformations are combined. To illustrate this, the example in the
previous figure is extended by inserting a mirroring transformation between the
PaintGlyph and PaintLinearGradient tables: the glyph outline is rotated as before, but the
gradient is mirrored in its (pre-rotation) y-axis as well as being rotated. Notice that both
visible elements—the shape and the gradient fill—are affected by the rotation, but only
the gradient is affected by the mirroring.

Combined effects of a transformation nested within the child sub-graph of another
transformation
While the PaintTransform and PaintVarTransform tables support several types of
transforms, additional paint formats are defined to support specific transformations:
PaintTranslate and PaintVarTranslate support translation only, without or with
variation support. See Formats 14 and 15: PaintTranslate, PaintVarTranslate for
format details.
PaintScale and PaintVarScale support scaling only, without or with variation
support. These two formats scale relative to the origin, and allow for different scale
factors in X and Y directions. PaintScaleAroundCenter, PaintVarScaleAroundCenter,
PaintScaleUniform, PaintVarScaleUniform, PaintScaleUniformAroundCenter, and
PaintVarScaleUniformAroundCenter support scaling relative to a different center,
scaling uniformly in both X and Y directions, or both. See Formats 16 to 23:
PaintScale and variant scaling formats for format details.
PaintRotate and PaintVarRotate support rotation only, without or with variation
support. These two formats rotate around the origin; the PaintRotateAroundCenter
and PaintVarRotateAroundCenter formats support rotation around a different
center. See Formats 24 to 27: PaintRotate, PaintVarRotate,
PaintRotateAroundCenter, PaintVarRotateAroundCenter for format details.
PaintSkew and PaintVarSkew support skew only, without or with variation support.
These two formats skew using the origin as a center for the skew rotation; the
PaintSkewAroundCenter and PaintVarSkewAroundCenter formats support skews
using a different center. See Formats 28 to 31: PaintSkew, PaintVarSkew,
PaintSkewAroundCenter, PaintVarSkewAroundCenter for format details.
Note: Horizontal mirroring is done by scaling using a scale factor in the x direction
of -1. Vertical mirroring is done by scaling with a -1 scale factor in the y direction.

When only one of these specific types of transformation is required, these formats
provide a more compact representation than the PaintTransform or PaintVarTransform
formats. Another significant difference of the rotation and skew formats is that the
rotations and skews are specified as angles, in counter-clockwise degrees.
Note: Specifying the rotation or skew as an angle can have a significant benefit in
variable fonts if an angle of skew or rotation needs to vary, since it is easier to
implement variation of angles when specified directly rather than as matrix
elements. This is because the matrix elements for a rotation or skew are the sine,
cosine or tangent of the rotation angle, which do not change in linear proportion to
the angle. To achieve a linear variation of rotation using matrix elements would
require approximating the variation using multiple delta sets.
The rotations and skews specified using PaintRotate, PaintSkew and their variants can
also be representated as a matrix using a PaintTransform or PaintVarTransform table. The
behavior for the PaintRotate or PaintSkew formats and their variants must be the same
as if the rotation or skew were represented using an equivalent matrix or sequence of
matrices. See Formats 24 to 27: PaintRotate, PaintVarRotate, PaintRotateAroundCenter,
PaintVarRotateAroundCenter for details regarding the matrix equivalent for a rotation
expressed as an angle; and see Formats 28 to 31: PaintSkew, PaintVarSkew,
PaintSkewAroundCenter, PaintVarSkewAroundCenter for similar details in relation to
skews.

Compositing and blending
When a color glyph has overlapping content in two layers, the pixels in the two layers
must be combined in some way. If the content in the top layer has full opacity, then
normally the pixels from that layer are shown, occluding overlapping pixels from lower
layers. If the top layer has some transparency (some portion has alpha less than 1.0),
then blending of colors for overlapping pixels occurs by default. The default interaction
between layers uses simple alpha compositing, as described in the W3C specification,
Compositing and Blending Level 1

.

A PaintComposite table can be used to get other compositing or blending effects. The
PaintComposite table combines content defined by two sub-graphs: a source sub-graph;
and a destination, or backdrop, sub-graph. First, the paint operations for the backdrop
sub-graph are executed, then the drawing operations for the source sub-graph are
executed and combined with backdrop using a specified compositing or blending
mode. Various composition and blending modes are supported. The available modes
are given in the CompositionModes enumeration (see Format 32: PaintComposite). The

effect and processing rule of each mode are specified in Compositing and Blending
Level 1

.

The available modes fall into two general types: compositing modes, also referred to as
“Porter-Duff” modes; and blending modes. In rough terms, the Porter-Duff modes
determine how much effect pixels from the source and the backdrop each contribute in
the result, while blending modes determine how color values for pixels from the source
and backdrop are combined. These are illustrated with examples in the following figures:
in each case, red and blue rectangles are the source and backdrop content.
The first figure shows the effect of a Porter-Duff mode, XOR, which has the effect that
only non-overlapping pixels contribute to the result.

Two content elements combined using the Porter-Duff XOR mode
The next figure shows the effect of a lighten blending mode, which has the effect that
the R, G, and B color components for each pixel in the result is the greater of the R, G,
and B values from corresponding pixels in the source and backdrop.

Two content elements combined using the *lighten* blending mode
For complete details on each of the Porter-Duff and blending modes, see the
Compositing and Blending Level 1

specification.

The following figure illustrates how the PaintComposite table is used in combination
with content sub-graphs to implement an alternate compositing effect. The source sub-

graph defines a green capital A; the backdrop sub-graph defines a black circle. The
compositing mode used is Source Out, which has the effect that the source content
punches out a hole in the backdrop. (For this mode, the fill color of the source is
irrelevant; a black or yellow “A” would have the same effect.) A red rectangle is included
as a lower layer to show that the backdrop has been punched out by the source, making
that portion of the lower layer visible.

A color glyph using a PaintComposite table to punch out a shape from the fill of a circle
Note: In the previous figure, the “A” is filled with green to illustrate that the color of
the fill has no affect for the Source Out composite mode. Because that is the case,
the black or red PaintSolid could have been re-used instead of adding a separate
PaintSolid table. See Re-use by referencing shared subtables for more information
on re-use of paint tables for such situations.
Scalable Vector Graphics (SVG)

supports alpha channel masking using the <mask>

element. The same effects can be implemented in COLR version 1 using a
PaintComposite table by setting a pattern of alpha values in the source sub-graph and
selecting the Source In composite mode. This is illustrated in the following figure.

An alpha mask implemented using a PaintComposite table and the *Source In* mode

Re-usable components
Overview
Within a color font, many color glyphs might share components in common. For
example, in emoji fonts, many different “smilies” or clock faces share a common
background. This can be seen in the following figure, which shows color glyphs for three
emoji clock faces.

Emoji clock faces for 12 o’clock, 1 o’clock and 2 o’clock
Several components are shared between these color glyphs: the entire face, with a
gradient background and dots at the 3, 6, 9 and 12 positions; the minute hand pointing
to the 12 position; and the circles in the center. Also, note that the four dots have the
same shape and fill, and differ only in their position. In addition, the hour hands have
the same shape and fill, and differ only in their orientation.
There are several ways in which elements of a color glyph description can be re-used:
Reference to shared subtables
Use of a PaintColrLayers table
Use of a PaintColrGlyph table
The PaintColrLayers and PaintColrGlyph table formats create a potential for introducing
cycles within the graph of a color glyph, which would be invalid (see Color glyphs as a
directed acyclic graph).

Re-use by referencing shared subtables
Several of the paint table formats link to a child paint table using a forward offset within
the file:
PaintGlyph

PaintComposite
PaintTransform, PaintVarTransform
PaintTranslate, PaintVarTranslate
PaintScale, PaintVarScale, and the other variant scaling paint formats
PaintRotate, PaintVarRotate, PaintRotateAroundCenter,
PaintVarRotateAroundCenter
PaintSkew, PaintVarSkew, PaintSkewAroundCenter, PaintVarSkewAroundCenter
A child subtable can be shared by several tables of these formats. For example, several
PaintGlyph tables might link to the same PaintSolid table, or to the same node for a subgraph describing a more complex fill. The only limitation is that child paint tables are
referenced using a forward offset from the start of the referencing table, so a re-used
paint table can only occur later in the file than any of the paint tables that use it.
The clock faces shown in the figure above provide an example of how PaintRotate tables
can be combined with re-use of a sub-graph. As noted above, the hour hands have the
same shape and fill, but have a different orientation. The glyph outline could point to
the 12 position, then in color glyph descriptions for other times, PaintRotate tables
could link to the same glyph/fill sub-graph, re-using that component but rotated as
needed.
This is illustrated in the following figures. The first shows a sub-graph defining the hour
hand, with upright orientation, using a PaintGlyph and a PaintSolid table. Example file
offsets for the tables are indicated.

A PaintGlyph and PaintSolid table are used to define the clock hour hand pointing to 12
The next figure shows this sub-graph of paint tables being re-used, in some cases linked
from PaintRotate tables that rotate the hour hand to point to different clock positions as
needed. All of the paint tables that reference this sub-graph occur earlier in the file.

The sub-graph for the hour hand is re-used with PaintRotate tables to point to different
hours

Re-use using PaintColrLayers
As described above (see Layering), a PaintColrLayers table defines a set of paint subgraphs arranged in bottom-up z-order layers, and an example was given of a
PaintColrLayers table used as the root of a color glyph definition. A PaintColrLayers table
can also be nested more deeply within the graph of a color glyph. One purpose for
doing this is to reference a re-usable component defined as a contiguous set of layers in
the LayerList) table.
This is readily explained using the clock faces as an example. As described above, each
clock face shares several elements in common. Some of these form a contiguous set of
layers. Suppose four sub-graphs for shared clock face elements are given in the
LayerList as contiguous layers, as shown in the following figure. (For brevity, the visual
result for each sub-graph is shown, but not the paint details.)

Common clock face elements given as a slice within the LayerList table
A PaintColrLayers table can reference any contiguous slice of layers in the LayerList
table. Thus, the set of layers shown in the previouis figure can be referenced by
PaintColrLayers tables anywhere in the graph of any color glyph. In this way, this set of
layers can be re-used in multiple clock face color glyph definitions.
This is illustrated in the following figure: The color glyph definition for the one o’clock
emoji has a PaintColrLayers table as its root, referencing a slice of three layers in the
LayerList table. The upper two layers are the hour hand, which is specific to this color
glyph; and the cap over the pivot for the minute and hour hands, which is common to
other clock emoji but in a layer that is not contiguous with other common layers. The
bottom layer of these three layers is the composition for all the remaining common
layers. It is represented using a nested PaintColrLayers table that references the slice
within the LayerList for the common clock face elements shown in the previous figure.

A PaintColrLayers table is used to reference a set of layers that define a shared clock
face composition
The color glyphs for other clock face emoji could be structured in exactly the same way,
using a nested PaintColrLayers table to re-use the layer composition of the common
clock face elements.

Re-use using PaintColrGlyph
A third way to re-use components in color glyph definitions is to use a nested
PaintColrGlyph table. This format references a base glyph ID, which is used to access a
corresponding BaseGlyphPaintRecord. That record will provide the offset of a paint table
that is the root of a graph for a color glyph definition. That graph can potentially be
used as an independent color glyph, but it can also define a shared composition that
gets re-used in multiple color glyphs. Each time the shared composition is to be re-used,
it is referenced by its base glyph ID using a PaintColrGlyph table. The graph of the
referenced color glyph is thereby incorporated into the graph of the PaintColrGlyph
table as its child sub-graph.
When a PaintColrGlyph table is used, a BaseGlyphPaintRecord with the specified glyph
ID is expected. If no BaseGlyphPaintRecord with that glyph ID is found, the color glyph is
not well formed. See Color glyphs as a directed acyclic graph for details regarding wellformedness and validity of the graph.
The example from the previous section is modified to illustrate use of a PaintColrGlyph
table. In the following figure, a PaintColrLayers table references a slice within the
LayerList that defines the shared component. Now, however, this PaintColrLayers table is
treated as the root of a color glyph definition for base glyph ID 63163. The color glyph
for the one o’clock emoji is defined with three layers, as before, but now the bottom

layer uses a PaintColrGlyph table that references the color glyph definition for glyph ID
63163.

A PaintColrGlyph table is used to reference the shared clock face composition via a
glyph ID
While the PaintColrGlyph and PaintColrLayers tables are similar in being able to
reference a layer set as a re-usable component, they could be handled differently in
implementations. In particular, an implementation could process and cache the result of
the color glyph description for a given base glyph ID. In that case, subsequent
references to that base glyph ID using a PaintColrGlyph table would not require the
corresponding graph of paint tables to be re-processed. As a result, using a
PaintColrGlyph for re-used graphic components could provide performance benefits.

Glyph metrics and boundedness
Metrics for color glyphs using version 0 formats
For color glyphs using version 0 formats, the advance width of glyphs used for each
layer must be the same as the advance width of the base glyph. If the font has vertical
metrics, the glyphs used for each layer must also have the same advance height and
vertical Y origin as the base glyph.

Metrics and boundedness of color glyphs using version 1 formats
For color glyphs using version 1 formats, the advance width of the base glyph must be
used as the advance width for the color glyph. If the font has vertical metrics, the
advance height and vertical Y origin of the base glyph must be used for the color glyph.

The advance width and height of glyphs referenced by PaintGlyph tables are not
required to be the same as that of the base glyph and are ignored.
A valid color glyph definition must define a bounded region—that is, it must paint
within a region for which a finite bounding box could be defined. A clip box can be
specified to set overall bounds for a color glyph (see below). Otherwise, boundedness is
determined by the graph of paint tables that describe the color glyph content. The
different paint formats have different boundedness characteristics:
PaintGlyph is inherently bounded.
PaintSolid, PaintVarSolid, PaintLinearGradient, PaintVarLinearGradient,
PaintRadialGradient, PaintVarRadialGradient, PaintSweepGradient, and
PaintVarSweepGradient are inherently unbounded.
PaintColrLayers is bounded if and only if all referenced sub-graphs are bounded.
PaintColrGlyph is bounded if and only if the color glyph definition for the
referenced base glyph ID is bounded.
Paint formats for transformations (PaintTransform, PaintVarTransform,
PaintTranslate, PaintScale, etc.) are bounded if and only if the referenced sub-graph
is bounded.
PaintComposite is either bounded or unbounded, according to the composite
mode used and the boundedness of the referenced sub-graphs. See Format 32:
PaintComposite for details.
A ClipBox table may be associated with a color glyph to define an overall bounds for the
color glyph. The clip box may vary in a variable font. If a clip box is provided for a color
glyph, the color glyph is bounded, and no inspection of the Paint graph is required to
determine boundedness. If no clip box is defined for a color glyph, however,
applications must confirm that the color glyph definition is bounded, and must not
render the color glyph if the defining graph is not bounded.
Note: If present, the clip box for a color glyph can be used to allocate a drawing
surface without needing to traverse the graph of the color glyph definition.
Note: If no ClipBox table is present but a bounding box is required by the
implementation, it can be computed for a given color glyph by traversing the graph
of Paint tables that defines that color glyph.
To ensure that rendering implementations do not clip any part of a color glyph, the clip
box needs to be large enough to encompass the entire color glyph composition. In a
variable font, glyph outlines can vary, but transformations in a color glyph description
can also vary, affecting the portions of the design grid to be painted. For example, a

filled rectangle that is wide but not tall for one variation instance can be variably rotated
to be tall but not wide for other instances. The clip box either should be large enough to
encompass the color glyph for all instances, or should itself vary such that each instance
of the clip box encompasses the instance color glyph.

Color glyphs as a directed acyclic graph
When using version 1 formats, a color glyph is defined by a directed, acyclic graph of
linked paint tables. For each BaseGlyphPaintRecord, the paint table referenced by that
record is the root of a graph defining a color glyph composition.
The graph for a given color glyph is made up of all paint tables reachable from the
BaseGlyphPaintRecord. The BaseGlyphPaintRecord and several paint table formats use
direct links; that is, they include a forward offset to a paint subtable. Two paint formats
make indirect links:
A PaintColrLayers table references a slice of offsets within the LayerList. The paint
tables referenced by those offsets are considered to be linked within the graph as
children of the PaintColrLayers table.
A PaintColrGlyph table references a base glyph ID, for which a corresponding
BaseGlyphPaintRecord is expected. That record points to the root of a graph that is
a complete color glyph definition on its own. But when referenced in this way by a
PaintColrGlyph table, that entire graph is considered to be a child sub-graph of the
PaintColrGlyph table, and a continuation of the graph of which the PaintColrGlyph
table is a part.
The graph for a color glyph is a combination of paint tables using any of the paint table
formats. The simplest color glyph definition would consist of a PaintGlyph table linked
to a basic fill table (PaintSolid, PaintVarSolid, PaintLinearGradient,
PaintVarLinearGradient, PaintRadialGradient, PaintVarRadialGradient,
PaintSweepGradient, PaintVarSweepGradient). But the graph can be arbitrarily complex,
with an arbitrary depth of paint nodes (to the limits inherent in the formats).
The graph can define a visual element in a single layer, or many elements in many layers.
The concept of layers, as distinct visual elements stacked in a z-order, is not precisely
defined in relation to the complexity of the graph. Each separate visual element requires
a leaf node, but nodes in the graph, including leaf nodes, can be re-used (see Re-usable
components). Also, each separate visual element requires a fork in the graph, and a
separate root-to-leaf path, but not all paths necessarily result in a distinct visual
element. For example, a gradient mask effect can be created with a gradient with
gradation of alpha values, and then using that as the source of a PaintComposite table

with the Source In compositing mode. In that case, the leaf has a visual affect but does
not result in a distinct visual element. This was illustrated in an earlier figure, repeated
here: the PaintLinearGradient is a leaf node in the graph and creates a masking effect
but does not add a distinct visual element.

Graph with a leaf node that isn’t a distinct visual element
Thus, the generalization that can be made regarding the relationship between the
number of layers and the nature of the graph is that the number of distinct root-to-leaf
paths will be greater than or equal to the number of layers.
The following are necessary for the graph to be well-formed and valid:
All subtable links must satisfy the following criteria:
Forward offsets are within the COLR table bounds.
If a PaintColrLayers table is present, then a LayerList is also present, and the
referenced slice is within the length of the LayerList.
If a PaintColrGlyph table is present, there is a BaseGlyphPaintRecord for the
referenced base glyph ID.
The graph must be acyclic.
Note: These constraints imply that all leaf nodes will be one of PaintSolid,
PaintVarSolid, PaintLinearGradient, PaintVarLinearGradient, PaintRadialGradient,
PaintVarRadialGradient, PaintSweepGradient, or PaintVarSweepGradient.
For the graph to be acyclic, no paint table may have any child or descendent paint table
that is also its parent or ancestor within the graph. In particular, because the
PaintColrLayers and PaintColrGlyph tables use indirect child references rather than
forward offsets, they provide a possibility for introducing cycles. Applications should
track paint tables within a path in the graph, checking whether any paint table was

already encountered within that path. The following pseudo-code algorithm can be
used:
C

// called initially with the root paint and an empty set pathPaints
function paintIsAcyclic(paint, pathPaints)
if paint is in pathPaints
return false // cycle detected
add paint to pathPaints
for each childPaint referenced by paint as a child subtable
call paintIsAcyclic(childPaint, pathPaints)
remove paint from pathPaints

For the graph to be valid, it must also be visually bounded, as described above (see
Metrics and boundedness of color glyphs using version 1 formats).
Note: Implementations can combine testing for cycles and other well-formedness or
validity requirements together with other processing for rendering the color glyph.
If the graph contains a cycle or is otherwise not well-formed or valid, the paint table at
which the error occurs should be ignored, that sub-graph should not be rendered, and
that node in the graph should be considered to be visually bounded. The application
should attempt to render the remainder of the graph, if well-formed and valid.
Future minor version updates of the COLR table could introduce new paint formats. If a
paint table with an unrecognized format is encountered, it and its sub-graph should
similarly be ignored, the node should be considered to be visually bounded, and the
application should attempt to render the remainder of the graph.
If an application is not able to recover from errors while traversing the graph, it may
ignore the color glyph entirely. If the base glyph ID has an outline, that may be rendered
as a non-color glyph instead.

COLR table formats
Overview
Various table and record formats are defined for COLR version 0 and version 1.
Several values contained within the version 1 formats are variable. For items that vary in
a variable font, the variation data is contained in an ItemVariationStore table. To
associate each variable item with the corresponding variation data, a DeltaSetIndexMap

table is used. Within a given table that has variable items, a base/sequence scheme is
used to index into the mapping data. See COLR table and OpenType Font Variations for
details.
Future minor version updates of the COLR table could introduce new formats that
extend the capabilities for color glyph descriptions using version 1 formats.
Unrecognized formats should be ignored. See Color glyphs as a directed acyclic graph
for more information.

COLR header
The COLR table begins with a header. Two versions have been defined.
COLR version 0:
ﾉ

Expand table

Type

Name

Description

uint16

version

Table version number—set to 0.

uint16

numBaseGlyphRecords

Number of BaseGlyph records.

Offset32

baseGlyphRecordsOffset

Offset to baseGlyphRecords array, from beginning of COLR
table.

Offset32

layerRecordsOffset

Offset to layerRecords array, from beginning of COLR table.

uint16

numLayerRecords

Number of Layer records.

Note: For fonts that use COLR version 0, some early Windows implementations of
the COLR table require glyph ID 1 to be the .null glyph.
COLR version 1:
ﾉ

Expand table

Type

Name

Description

uint16

version

Table version number—set to 1.

uint16

numBaseGlyphRecords

Number of BaseGlyph records; may be 0 in a version 1
table.

Offset32

baseGlyphRecordsOffset

Offset to baseGlyphRecords array, from beginning of COLR
table (may be NULL).

Type

Name

Description

Offset32

layerRecordsOffset

Offset to layerRecords array, from beginning of COLR table
(may be NULL).

uint16

numLayerRecords

Number of Layer records; may be 0 in a version 1 table.

Offset32

baseGlyphListOffset

Offset to BaseGlyphList table, from beginning of COLR
table.

Offset32

layerListOffset

Offset to LayerList table, from beginning of COLR table
(may be NULL).

Offset32

clipListOffset

Offset to ClipList table, from beginning of COLR table (may
be NULL).

Offset32

varIndexMapOffset

Offset to DeltaSetIndexMap table, from beginning of COLR
table (may be NULL).

Offset32

itemVariationStoreOffset

Offset to ItemVariationStore, from beginning of COLR table
(may be NULL).

The BaseGlyphList and its subtables are only used in COLR version 1.
The LayerList is only used in conjunction with the BaseGlyphList and, specifically, with
PaintColrLayers tables; it is not required if no color glyphs use a PaintColrLayers table. If
not used, set layerListOffset to NULL.
The ClipList is only used in conjunction with the BaseGlyphList. If not used, set
clipListOffset to NULL.
The ItemVariationStore is used in conjunction with a BaseGlyphList and its subtables, but
only in variable fonts. If it is not used, set itemVariationStoreOffset to NULL.
The DeltaSetIndexMap table is described in the OpenType Variations Common Table
Formats chapter—see Associating Target Items to Variation Data. Within the COLR table,
either format 0 or format 1 of the DeltaSetIndexMap can be used. A DeltaSetIndexMap
is used in conjunction with the ItemVariationStore in a variable font. The
DeltaSetIndexMap is optional: if an ItemVariationStore is present but a
DeltaSetIndexMap is not included (varIndexMapOffset is NULL), then an implicit
mapping is used. See COLR table and OpenType Font Variations for details.

Mixing version 0 and version 1 formats
A font that uses COLR version 1 and that includes a BaseGlyphList can also include
BaseGlyph and Layer records for compatibility with applications that only support COLR

version 0.
Color glyphs that can be implemented in COLR version 0 using BaseGlyph and Layer
records can also be implemented using the version 1 BaseGlyphList and subtables. Thus,
a font that uses the version 1 formats does not need to use the version 0 BaseGlyph and
Layer records. However, a font may use the version 1 structures for some base glyphs
and the version 0 structures for other base glyphs. A font may also include a version 1
color glyph definition for a given base glyph ID that is equivalent to a version 0
definition, though this should never be needed.
A font may define a color glyph for a given base glyph ID using version 0 formats, and
also define a different color glyph for the same base glyph ID using version 1 formats.
Applications that support COLR version 1 should give preference to the version 1 color
glyph.
For applications that support COLR version 1, the application should search for a base
glyph ID first in the BaseGlyphList. Then, if not found, search in the baseGlyphRecords
array, if present.

BaseGlyph and Layer records
BaseGlyph and Layer records are required for COLR version 0, but optional for version 1.
(See Mixing version 0 and version 1 formats.)
A BaseGlyph record is used to map a base glyph to a sequence of layer records that
define the corresponding color glyph. The BaseGlyph record includes a base glyph
index, an index into the layerRecords array, and the number of layers.
BaseGlyph record:
ﾉ

Type

Name

Description

uint16

glyphID

Glyph ID of the base glyph.

uint16

firstLayerIndex

Index (base 0) into the layerRecords array.

uint16

numLayers

Number of color layers associated with this glyph.

Expand table

The glyph ID must be less than the numGlyphs value in the 'maxp' table.
The BaseGlyph records must be sorted in increasing glyphID order. It is assumed that a
binary search can be used to find a matching BaseGlyph record for a specific glyphID.

The color glyph for a given base glyph is defined by the consecutive records in the
layerRecords array for the specified number of layers, starting with the record indicated
by firstLayerIndex. The first record in this sequence is the bottom layer in the z-order,
and each subsequent layer is stacked on top of the previous layer.
The layer record sequences for two different base glyphs may overlap, with some layer
records used in multiple color glyph definitions.
The Layer record specifies the glyph used as the graphic element for a layer and the
solid color fill.
Layer record:
ﾉ

Type

Name

Description

uint16

glyphID

Glyph ID of the glyph used for a given layer.

uint16

paletteIndex

Index (base 0) for a palette entry in the CPAL table.

Expand table

The glyphID in a Layer record must be less than the numGlyphs value in the 'maxp'
table. That is, it must be a valid glyph with outline data in the 'glyf', 'CFF ' or CFF2 table.
See Metrics and boundedness of color glyphs using version 1 formats for requirements
regarding glyph metrics of referenced glyphs.
The paletteIndex value must be less than the numPaletteEntries value in the CPAL table.
A paletteIndex value of 0xFFFF is a special case, indicating that the text foreground color
(as determined by the application) is to be used.

BaseGlyphList, LayerList and ClipList
The BaseGlyphList table is, conceptually, similar to the baseGlyphRecords array in COLR
version 0, providing records that map a base glyph to a color glyph definition. The color
glyph definitions that each refer to are significantly different, however—see Graphic
Compositions.
BaseGlyphList table:
ﾉ

Type

Name

uint32

numBaseGlyphPaintRecords

Expand table
Description

Type

Name

Description

BaseGlyphPaintRecord

baseGlyphPaintRecords[numBaseGlyphPaintRecords]

BaseGlyphPaintRecord:
ﾉ

Expand table

Type

Name

Description

uint16

glyphID

Glyph ID of the base glyph.

Offset32

paintOffset

Offset to a Paint table, from beginning of BaseGlyphList table.

The glyphID value must be less than the numGlyphs value in the 'maxp' table.
The records in the baseGlyphPaintRecords array must be sorted in increasing glyphID
order. It is intended that a binary search can be used to find a matching
BaseGlyphPaintRecord for a specific glyphID.
The paint table referenced by the BaseGlyphPaintRecord is the root of the graph for a
color glyph definition.
Note: Often the paint table that is the root of the graph for the color glyph
definition will be a PaintColrLayers table, though this is not required. See Color
glyphs as a directed acyclic graph for more information regarding the graph of a
color glyph, and Layering for background information regarding the PaintColrLayers
table.
A LayerList table is used in conjunction with PaintColrLayers tables to represent layer
structures. A single LayerList is defined and can be used by multiple PaintColrLayer
tables, each of which references a slice of the layer list.
LayerList table:
ﾉ

Type

Name

uint32

numLayers

Offset32

paintOffsets[numLayers]

Expand table

Description

Offsets to Paint tables, from beginning of LayerList table.

The sequence of offsets to paint tables corresponds to a bottom-up z-order layering of
the graphic compositions defined by the sub-graph of each referenced paint table

graph. For a given slice of the list, the sub-graph of the first paint table defines the
element at the bottom of the z-order, and the sub-graph of each subsequent paint table
defines an element that is layered on top of the previous element. As each element is a
composition defined in a sub-graph, one of these elements may itself be multi-layered.
In that case, the layers of this element are stacked above all previous layers, and layers
of following elements are stacked above the top layer of this element.
Offsets for paint tables not referenced by any PaintColrLayers table should not be
included in the paintOffsets array.
A ClipList table is used to provide precomputed clip boxes for color glyphs. It contains
an array of Clip records, each of which associates a range of base glyph IDs with a
ClipBox table. The ClipBox table provides a precomputed clip box for the associated
color glyphs. Clip boxes are optional: a font may provide clip boxes for some color
glyphs but not others.
ClipList table:

Type

Name

Description

uint8

format

Set to 1.

uint32

numClips

Number of Clip records.

Clip

clips[numClips]

Clip records. Sorted by startGlyphID.

ﾉ

Expand table

ﾉ

Expand table

Clip record:

Type

Name

Description

uint16

startGlyphID

First glyph ID in the range.

uint16

endGlyphID

Last glyph ID in the range.

Offset24

clipBoxOffset

Offset to a ClipBox table, from beginning of ClipList table.

Within a ClipList table, the glyph ID ranges of Clip records must not overlap.
Two Clipbox table formats are defined: format 1 for clip boxes without variation, and
format 2 allowing for clip boxes that can vary in a variable font.
ClipBoxFormat1 table, static clip box:

Type

Name

Description

uint8

format

Set to 1.

FWORD

xMin

Minimum x of clip box.

FWORD

yMin

Minimum y of clip box.

FWORD

xMax

Maximum x of clip box.

FWORD

yMax

Maximum y of clip box.

ﾉ

Expand table

ﾉ

Expand table

ClipBoxFormat2 table, variable clip box:

Type

Name

Description

uint8

format

Set to 2.

FWORD

xMin

Minimum x of clip box. For variation, use varIndexBase + 0.

FWORD

yMin

Minimum y of clip box. For variation, use varIndexBase + 1.

FWORD

xMax

Maximum x of clip box. For variation, use varIndexBase + 2.

FWORD

yMax

Maximum y of clip box. For variation, use varIndexBase + 3.

uint32

varIndexBase

Base index into DeltaSetIndexMap.

Any content drawn outside the clip box must not render.
The clip box is not required to be a tight bounding box around the content. As it may be
used by implementations to allocate resources, however, it should not be unnecessarily
large.
Note: At runtime, when computing a variable ClipBox, compute the min/max
coordinates using floating-point values and then round to integer values such that
the clip box expands. That is, round xMin and yMin towards negative infinity and
round xMax and yMax towards positive infinity.
For variable data, a base/sequence scheme is used to index into variation mapping data.
See COLR table and OpenType Font Variations for details.

Color references, ColorStop and ColorLine

Colors are used in solid color fills for graphic elements, or as stops in a color line used to
define a gradient. Colors are defined by reference to palette entries in the CPAL table.
While CPAL entries include an alpha component, formats for COLR version 1 that
reference palette entries also includes a separate alpha specification to allow different
graphic elements to use the same color but with different alpha values, and to allow for
variation of the alpha in variable fonts.
A paletteIndex value of 0xFFFF is a special case, indicating that the text foreground color
(as determined by the application) is to be used.
The alpha value is always set explicitly. Values for alpha outside the range [0., 1.]
(inclusive) are reserved; values outside this range must be clamped. A value of zero
means no opacity (fully transparent); 1.0 means fully opaque (no transparency). The
alpha indicated in this record is multiplied with the alpha component of the CPAL entry
(converted to float—divide by 255). Note that the resulting alpha value can be
combined with and does not supersede alpha or opacity attributes set in higher-level,
application-defined contexts.
See Colors and solid color fills for more information regarding color references and solid
color fills. Solid color fills are defined using a PaintSolid or PaintVarSolid table, described
below—see Formats 2 and 3: PaintSolid, PaintVarSolid.
Gradients are defined using a color line. A color line is a mapping of real numbers to
color values, defined using color stops. See Color line, above, for an overview and
additional details.
Two color-stop record formats are defined: one that allows for variation of stop offset
position or of alpha, and one that does not.
ColorStop record:

Type

Name

Description

F2DOT14

stopOffset

Position on a color line.

uint16

paletteIndex

Index for a CPAL palette entry.

F2DOT14

alpha

Alpha value.

ﾉ

Expand table

ﾉ

Expand table

VarColorStop record:

Type

Name

Description

F2DOT14

stopOffset

Position on a color line. For variation, use varIndexBase + 0.

uint16

paletteIndex

Index for a CPAL palette entry.

F2DOT14

alpha

Alpha value. For variation, use varIndexBase + 1.

uint32

varIndexBase

Base index into DeltaSetIndexMap.

The VarColorStop format uses a base/sequence scheme to index into mapping data.
Also, applying variation deltas to an F2DOT14 value requires special handling. See COLR
table and OpenType Font Variations for details.
A color line is defined by an array of color stop records plus an extend mode.
Two color-line table formats are defined: one that allows for variation of color stop
offsets positions or of alpha values, and one that does not. Different paint table formats
for gradients use one or the other of the color line formats.
ColorLine table:
ﾉ

Type

Name

Description

uint8

extend

An Extend enum value.

uint16

numStops

Number of ColorStop records.

ColorStop

colorStops[numStops]

Expand table

VarColorLine table:
ﾉ

Expand table

Type

Name

Description

uint8

extend

An Extend enum value.

uint16

numStops

Number of ColorStop records.

VarColorStop

colorStops[numStops]

Allows for variations.

Applications must apply the colorStops entries in increasing stopOffset order. Within a
variable font, the stopOffset values can vary, and the relative orderings of color stop
records along the color line can change as a result of variation. With a variable font, the

colorStops entries must be ordered after the instance values for the stop offsets have
been derived.
A color line defines stops for only certain positions along the line, but the color line
extends infinitely in either direction. The extend field is used to indicate how the color
line is extended. The same behavior is used for extension in both directions. The extend
field uses the following enumeration:
Extend enumeration:
ﾉ

Value

Name

Description

0

EXTEND_PAD

Use nearest color stop.

1

EXTEND_REPEAT

Repeat from farthest color stop.

2

EXTEND_REFLECT

Mirror color line from nearest end.

Expand table

The extend mode behaviors are described in detail above—see Color lines. If a ColorLine
in a font has an unrecognized extend value, applications should use EXTEND_PAD by
default.

Paint tables
Paint tables are used for COLR version 1 color glyph definitions. Thirty-two paint table
formats are defined (formats 1 to 32). Some formats come in non-variable and variable
pairs, but otherwise, each provides different graphic capability for defining the
composition for a color glyph. The graphic capability of each format and the manner in
which they are combined to represent a color glyph has been described above—see
Graphic Compositions.
Each paint table format has a one-byte format field as the first field. When parsing font
data, the format field can be read first to determine the format of the table.

Format 1: PaintColrLayers
Format 1 is used to define a vector of layers. The layers are a slice of layers from the
LayerList table. The first layer is the bottom of the z-order, and subsequent layers are
composited on top using the COMPOSITE_SRC_OVER composition mode (see Format
32: PaintComposite).

For general information on the PaintColrLayers table, see Layering. For information
about its use for shared, re-usable components, see Re-use using PaintColrLayers.
PaintColrLayers table (format 1):
ﾉ

Expand table

Type

Name

Description

uint8

format

Set to 1.

uint8

numLayers

Number of offsets to paint tables to read from LayerList.

uint32

firstLayerIndex

Index (base 0) into the LayerList.

Note: An 8-bit value is used for numLayers to minimize size for common scenarios. If
more than 256 layers are needed, then two or more PaintColrLayers tables can be
combined in a tree using a PaintComposite table or another PaintColrLayers table to
combine them.

Formats 2 and 3: PaintSolid, PaintVarSolid
Formats 2 and 3 are used to specify a solid color fill. Format 3 allows for variation of
alpha in a variable font; format 2 provides a more compact representation when
variation is not required. Format 3 must not be used in non-variable fonts or if the COLR
table does not have an ItemVariationStore subtable.
For general information about specifying color values, see Colors and solid color fills. For
information about applying a fill to a shape, see Filling shapes.
PaintSolid table (format 2):

Type

Name

Description

uint8

format

Set to 2.

uint16

paletteIndex

Index for a CPAL palette entry.

F2DOT14

alpha

Alpha value.

ﾉ

Expand table

ﾉ

Expand table

PaintVarSolid table (format 3):

Type

Name

Description

uint8

format

Set to 3.

uint16

paletteIndex

Index for a CPAL palette entry.

F2DOT14

alpha

Alpha value. For variation, use varIndexBase + 0.

uint32

varIndexBase

Base index into DeltaSetIndexMap.

The PaintVarSolid format uses a base/sequence scheme to index into mapping data.
Also, applying variation deltas to an F2DOT14 value requires special handling. See COLR
table and OpenType Font Variations for details.

Formats 4 and 5: PaintLinearGradient, PaintVarLinearGradient
Formats 4 and 5 are used to specify a linear gradient fill. Format 5 allows for variation of
color stop positions or of alpha in a variable font; format 4 provides a more compact
representation when variation is not required. Format 5 must not be used in nonvariable fonts or if the COLR table does not have an ItemVariationStore subtable.
For general information about linear gradients, see Linear gradients. For information
about applying a fill to a shape, see Filling shapes.
The PaintLinearGradient and PaintVarLinearGradient tables have a ColorLine and
VarColorLine subtable, respectively. For the ColorLine and VarColorLine table formats,
see Color references, ColorStop and ColorLine. For background information on the color
line, see Color lines.
PaintLinearGradient table (format 4):
ﾉ

Expand table

Type

Name

Description

uint8

format

Set to 4.

Offset24

colorLineOffset

Offset to ColorLine table, from beginning of PaintLinearGradient
table.

FWORD

x0

Start point (p₀) x coordinate.

FWORD

y0

Start point (p₀) y coordinate.

FWORD

x1

End point (p₁) x coordinate.

FWORD

y1

End point (p₁) y coordinate.

Type

Name

Description

FWORD

x2

Rotation point (p₂) x coordinate.

FWORD

y2

Rotation point (p₂) y coordinate.

PaintVarLinearGradient table (format 5):
ﾉ

Expand table

Type

Name

Description

uint8

format

Set to 5.

Offset24

colorLineOffset

Offset to VarColorLine table, from beginning of
PaintVarLinearGradient table.

FWORD

x0

Start point (p₀) x coordinate. For variation, use varIndexBase + 0.

FWORD

y0

Start point (p₀) y coordinate. For variation, use varIndexBase + 1.

FWORD

x1

End point (p₁) x coordinate. For variation, use varIndexBase + 2.

FWORD

y1

End point (p₁) y coordinate. For variation, use varIndexBase + 3.

FWORD

x2

Rotation point (p₂) x coordinate. For variation, use varIndexBase + 4.

FWORD

y2

Rotation point (p₂) y coordinate. For variation, use varIndexBase + 5.

uint32

varIndexBase

Base index into DeltaSetIndexMap.

The PaintVarLinearGradient format uses a base/sequence scheme to index into mapping
data. See COLR table and OpenType Font Variations for details.

Formats 6 and 7: PaintRadialGradient, PaintVarRadialGradient
Formats 6 and 7 are used to specify a radial gradient fill. Format 7 allows for variation of
color stop positions or of alpha in a variable font; format 6 provides a more compact
representation when variation is not required. Format 7 must not be used in nonvariable fonts or if the COLR table does not have an ItemVariationStore subtable.
For general information about radial gradients supported in COLR version 1, see Radial
gradients. For information about applying a fill to a shape, see Filling shapes.
The PaintRadialGradient and PaintVarRadialGradient tables have a ColorLine and
VarColorLine subtable, respectively. For the ColorLine and VarColorLine table formats,

see Color references, ColorStop and ColorLine. For background information on the color
line, see Color lines.
PaintRadialGradient table (format 6):
ﾉ

Expand table

Type

Name

Description

uint8

format

Set to 6.

Offset24

colorLineOffset

Offset to ColorLine table, from beginning of PaintRadialGradient
table.

FWORD

x0

Start circle center x coordinate.

FWORD

y0

Start circle center y coordinate.

UFWORD

radius0

Start circle radius.

FWORD

x1

End circle center x coordinate.

FWORD

y1

End circle center y coordinate.

UFWORD

radius1

End circle radius.

PaintVarRadialGradient table (format 7):
ﾉ

Expand table

Type

Name

Description

uint8

format

Set to 7.

Offset24

colorLineOffset

Offset to VarColorLine table, from beginning of
PaintVarRadialGradient table.

FWORD

x0

Start circle center x coordinate. For variation, use varIndexBase + 0.

FWORD

y0

Start circle center y coordinate. For variation, use varIndexBase + 1.

UFWORD

radius0

Start circle radius. For variation, use varIndexBase + 2.

FWORD

x1

End circle center x coordinate. For variation, use varIndexBase + 3.

FWORD

y1

End circle center y coordinate. For variation, use varIndexBase + 4.

UFWORD

radius1

End circle radius. For variation, use varIndexBase + 5.

uint32

varIndexBase

Base index into DeltaSetIndexMap.

The PaintVarRadialGradient format uses a base/sequence scheme to index into mapping
data. See COLR table and OpenType Font Variations for details.

Formats 8 and 9: PaintSweepGradient,
PaintVarSweepGradient
Formats 8 and 9 are used to specify a sweep gradient fill. Format 9 allows for variation
of color stop positions or of alpha in a variable font; format 8 provides a more compact
representation when variation is not required. Format 9 must not be used in nonvariable fonts or if the COLR table does not have an ItemVariationStore subtable.
For general information about sweep gradients, see Sweep gradients. For information
about applying a fill to a shape, see Filling shapes.
The PaintSweepGradient and PaintVarSweepGradient table have a ColorLine and
VarColorLine subtable, respectively. For the ColorLine and VarColorLine table formats,
see Color references, ColorStop and ColorLine. For background information on the color
line, see Color lines.
PaintSweepGradient table (format 8):
ﾉ

Expand table

Type

Name

Description

uint8

format

Set to 8.

Offset24

colorLineOffset

Offset to ColorLine table, from beginning of PaintSweepGradient
table.

FWORD

centerX

Center x coordinate.

FWORD

centerY

Center y coordinate.

F2DOT14

startAngle

Start of the angular range of the gradient: add 1.0 and multiply by
180° to retrieve counter-clockwise degrees.

F2DOT14

endAngle

End of the angular range of the gradient: add 1.0 and multiply by
180° to retrieve counter-clockwise degrees.

PaintVarSweepGradient table (format 9):
ﾉ

Expand table

Type

Name

Description

uint8

format

Set to 9.

Offset24

colorLineOffset

Offset to VarColorLine table, from beginning of
PaintVarSweepGradient table.

FWORD

centerX

Center x coordinate. For variation, use varIndexBase + 0.

FWORD

centerY

Center y coordinate. For variation, use varIndexBase + 1.

F2DOT14

startAngle

Start of the angular range of the gradient: add 1.0 and multiply by
180° to retrieve counter-clockwise degrees. For variation, use
varIndexBase + 2.

F2DOT14

endAngle

End of the angular range of the gradient: add 1.0 and multiply by
180° to retrieve counter-clockwise degrees. For variation, use
varIndexBase + 3.

uint32

varIndexBase

Base index into DeltaSetIndexMap.

The PaintVarSweepGradient format uses a base/sequence scheme to index into mapping
data. Also, applying variation deltas to an F2DOT14 value requires special handling. See
COLR table and OpenType Font Variations for details.
Angles are expressed in counter-clockwise degrees from the direction of the positive xaxis in the design grid.
Note: To allow for a representation of +360°, a bias of 1.0 is used in the
representation of start and end angles of sweep gradients. For example, an
F2DOT14 value of -2.0 (0x8000) represents -180°; an F2DOT14 value of 0.0 (0x0000)
represents +180°; an F2DOT14 value of 0.25 (0x1000) represents +225°; an F2DOT14
value of 1.0 (0x4000) represents +360°. However, a bias is not used for
representation of angles in rotate or skew transforms.

Format 10: PaintGlyph
Format 10 is used to specify a glyph outline to use as a shape to be filled or,
equivalently, a clip region. The outline sets a clip region that constrains the content of a
separate paint subtable and the sub-graph linked from that subtable.
For information about applying a fill to a shape, see Filling shapes.
PaintGlyph table (format 10):
ﾉ

Expand table

Type

Name

Description

uint8

format

Set to 10.

Offset24

paintOffset

Offset to a Paint table, from beginning of PaintGlyph table.

uint16

glyphID

Glyph ID for the source outline.

The glyphID value must be less than the numGlyphs value in the 'maxp' table. That is, it
must be a valid glyph with outline data in the 'glyf', 'CFF ' or CFF2 table. Only that
outline data is used. In particular, if this glyph ID has a description in the COLR table
(glyphID appears in a COLR BaseGlyph record or the BaseGlyphList), that COLR data is
not relevant for purposes of the PaintGlyph table.

Format 11: PaintColrGlyph
Format 11 is used to allow a color glyph definition from the BaseGlyphList to be a reusable component that can be incorporated into multiple color glyph definitions. See
Re-use using PaintColrGlyph for more information.
PaintColrGlyph table (format 11):
ﾉ

Type

Name

Description

uint8

format

Set to 11.

uint16

glyphID

Glyph ID for a BaseGlyphList base glyph.

Expand table

The glyphID value must be a glyphID found in a BaseGlyphPaintRecord within the
BaseGlyphList. The BaseGlyphPaintRecord provides an offset to a paint table; that paint
table and the graph linked from it are incorporated as a child sub-graph of the
PaintColrGlyph table within the current color glyph definition.

Formats 12 and 13: PaintTransform, PaintVarTransform
Formats 12 and 13 are used to apply an affine transformation to a sub-graph. The paint
table that is the root of the sub-graph is linked as a child.
Format 13 allows for variation of the transformation in a variable font; format 12
provides a more compact representation when variation is not required. Format 13 must
not be used in non-variable fonts or if the COLR table does not have an
ItemVariationStore subtable.

For general information regarding transformations in a color glyph definition, see
Transformations.
PaintTransform table (format 12):
ﾉ

Expand table

Type

Name

Description

uint8

format

Set to 12.

Offset24

paintOffset

Offset to a Paint subtable, from beginning of PaintTransform table.

Offset24

transformOffset

Offset to an Affine2x3 table, from beginning of PaintTransform table.

PaintVarTransform table (format 13):
ﾉ

Expand table

Type

Name

Description

uint8

format

Set to 13.

Offset24

paintOffset

Offset to a Paint subtable, from beginning of PaintVarTransform
table.

Offset24

transformOffset

Offset to a VarAffine2x3 table, from beginning of PaintVarTransform
table.

The affine transformation is defined by a 2×3 matrix, specified in an Affine2x3 or
VarAffine2x3 table. The 2×3 matrix supports scale, skew, reflection, rotation, and
translation transformations. The VarAffine2x3 table supports mapping into variation
data, allowing the transform definition to be variable in a variable font.
Affine2x3 table:
ﾉ

Type

Name

Description

Fixed

xx

x-component of transformed x-basis vector.

Fixed

yx

y-component of transformed x-basis vector.

Fixed

xy

x-component of transformed y-basis vector.

Fixed

yy

y-component of transformed y-basis vector.

Expand table

Type

Name

Description

Fixed

dx

Translation in x direction.

Fixed

dy

Translation in y direction.

VarAffine2x3 table:
ﾉ

Expand table

Type

Name

Description

Fixed

xx

x-component of transformed x-basis vector. For variation, use
varIndexBase + 0.

Fixed

yx

y-component of transformed x-basis vector. For variation, use
varIndexBase + 1.

Fixed

xy

x-component of transformed y-basis vector. For variation, use
varIndexBase + 2.

Fixed

yy

y-component of transformed y-basis vector. For variation, use
varIndexBase + 3.

Fixed

dx

Translation in x direction. For variation, use varIndexBase + 4.

Fixed

dy

Translation in y direction. For variation, use varIndexBase + 5.

uint32

varIndexBase

Base index into DeltaSetIndexMap.

The VarAffine2x3 format uses a base/sequence scheme to index into mapping data.
Also, applying variation deltas to a Fixed value requires special handling. See COLR table
and OpenType Font Variations for details.
For a pre-transformation position (x, y), the post-transformation position (x′, y′) is
calculated as follows:
x′ = xx * x + xy * y + dx
y′ = yx * x + yy * y + dy
Note: It is helpful to understand linear transformations by their effect on x- and ybasis vectors î = (1, 0) and ĵ = (0, 1). The transform described by the Affine2x3 or
VarAffine2x3 table maps the basis vectors to î′ = (xx, yx) and ĵ′ = (xy, yy), and
translates the origin to (dx, dy).
When the transformed composition from the referenced paint table (and its sub-graph)
is composed into the destination (represented by the parent of this table), the source

design grid origin is aligned to the destination design grid origin. The transform can
translate the source such that a pre-transform position (0,0) is moved elsewhere. The
post-transform origin, (0,0), is aligned to the destination origin.

Formats 14 and 15: PaintTranslate, PaintVarTranslate
Formats 14 and 15 are used to apply a translation to a sub-graph. The paint table that is
the root of the sub-graph is linked as a child.
Format 15 allows for variation of the translation in a variable font; format 14 provides a
more compact representation when variation is not required. Format 15 must not be
used in non-variable fonts or if the COLR table does not have an ItemVariationStore
subtable.
These tables use reduced precision for compactness. Where higher precision is required
use PaintTransform/PaintVarTransform.
For general information regarding transformations in a color glyph definition, see
Transformations.
PaintTranslate table (format 14):
ﾉ

Expand table

Type

Name

Description

uint8

format

Set to 14.

Offset24

paintOffset

Offset to a Paint subtable, from beginning of PaintTranslate table.

FWORD

dx

Translation in x direction.

FWORD

dy

Translation in y direction.

PaintVarTranslate table (format 15):
ﾉ

Expand table

Type

Name

Description

uint8

format

Set to 15.

Offset24

paintOffset

Offset to a Paint subtable, from beginning of PaintVarTranslate table.

FWORD

dx

Translation in x direction. For variation, use varIndexBase + 0.

Type

Name

Description

FWORD

dy

Translation in y direction. For variation, use varIndexBase + 1.

uint32

varIndexBase

Base index into DeltaSetIndexMap.

The PaintVarTranslate format uses a base/sequence scheme to index into mapping data.
See COLR table and OpenType Font Variations for details.
Note: Pure translation can also be represented using the PaintTransform or
PaintVarTransform table by setting xx = 1, yy = 1, xy and yx = 0, and setting dx and
dy to the translation values. The PaintTranslate or PaintVarTranslate table provides a
more compact representation when only translation is required.
The translation will result in the pre-transform position (0,0) being moved elsewhere.
See Formats 12 and 13: PaintTransform, PaintVarTransform regarding alignment of the
transformed content with the destination.

Formats 16 to 23: PaintScale and variant scaling formats
Formats 16 to 23 are used to scale a sub-graph. The paint table that is the root of the
sub-graph is linked as a child. Several variant formats are provided:
Formats 16 and 17: scale in x or y directions relative to the origin. Format 17 allows
for variation of the x and y scale factors in a variable font; format 16 provides a
more compact representation when variation is not required.
Formats 18 and 19: scale in x or y directions relative to a specified center. Format
19 allows for variation of the x and y scale factors or of the center position; format
18 provides a more compact representation when variation is not required.
Formats 20 and 21: scale uniformly in x and y directions relative to the origin.
Format 21 allows for variation of the scale factor in a variable font; format 20
provides a more compact representation when variation is not required.
Formats 22 and 23: scale uniformly in x and y directions relative to a specified
center. Format 23 allows for variation of the scale factor or of the center position;
format 22 provides a more compact representation when variation is not required.
Formats 17, 19, 21 and 23 must not be used in non-variable fonts or if the COLR table
does not have an ItemVariationStore subtable.
These tables use reduced precision for compactness. Where higher precision is required
use PaintTransform/PaintVarTransform.

For general information regarding transformations in a color glyph definition, see
Transformations.
PaintScale table (format 16):
ﾉ

Expand table

Type

Name

Description

uint8

format

Set to 16.

Offset24

paintOffset

Offset to a Paint subtable, from beginning of PaintScale table.

F2DOT14

scaleX

Scale factor in x direction.

F2DOT14

scaleY

Scale factor in y direction.

PaintVarScale table (format 17):
ﾉ

Expand table

Type

Name

Description

uint8

format

Set to 17.

Offset24

paintOffset

Offset to a Paint subtable, from beginning of PaintVarScale table.

F2DOT14

scaleX

Scale factor in x direction. For variation, use varIndexBase + 0.

F2DOT14

scaleY

Scale factor in y direction. For variation, use varIndexBase + 1.

uint32

varIndexBase

Base index into DeltaSetIndexMap.

PaintScaleAroundCenter table (format 18):
ﾉ

Expand table

Type

Name

Description

uint8

format

Set to 18.

Offset24

paintOffset

Offset to a Paint subtable, from beginning of PaintScaleAroundCenter
table.

F2DOT14

scaleX

Scale factor in x direction.

F2DOT14

scaleY

Scale factor in y direction.

FWORD

centerX

x coordinate for the center of scaling.

Type

Name

Description

FWORD

centerY

y coordinate for the center of scaling.

PaintVarScaleAroundCenter table (format 19):
ﾉ

Expand table

Type

Name

Description

uint8

format

Set to 19.

Offset24

paintOffset

Offset to a Paint subtable, from beginning of
PaintVarScaleAroundCenter table.

F2DOT14

scaleX

Scale factor in x direction. For variation, use varIndexBase + 0.

F2DOT14

scaleY

Scale factor in y direction. For variation, use varIndexBase + 1.

FWORD

centerX

x coordinate for the center of scaling. For variation, use varIndexBase
+ 2.

FWORD

centerY

y coordinate for the center of scaling. For variation, use varIndexBase
+ 3.

uint32

varIndexBase

Base index into DeltaSetIndexMap.

PaintScaleUniform table (format 20):
ﾉ

Expand table

Type

Name

Description

uint8

format

Set to 20.

Offset24

paintOffset

Offset to a Paint subtable, from beginning of PaintScaleUniform table.

F2DOT14

scale

Scale factor in x and y directions.

PaintVarScaleUniform table (format 21):
ﾉ

Expand table

Type

Name

Description

uint8

format

Set to 21.

Offset24

paintOffset

Offset to a Paint subtable, from beginning of PaintVarScaleUniform
table.

Type

Name

Description

F2DOT14

scale

Scale factor in x and y directions. For variation, use varIndexBase + 0.

uint32

varIndexBase

Base index into DeltaSetIndexMap.

PaintScaleUniformAroundCenter table (format 22):

Type

Name

Description

uint8

format

Set to 22.

Offset24

paintOffset

Offset to a Paint subtable, from beginning of
PaintScaleUniformAroundCenter table.

F2DOT14

scale

Scale factor in x and y directions.

FWORD

centerX

x coordinate for the center of scaling.

FWORD

centerY

y coordinate for the center of scaling.

ﾉ

Expand table

ﾉ

Expand table

PaintVarScaleUniformAroundCenter table (format 23):

Type

Name

Description

uint8

format

Set to 23.

Offset24

paintOffset

Offset to a Paint subtable, from beginning of
PaintVarScaleUniformAroundCenter table.

F2DOT14

scale

Scale factor in x and y directions. For variation, use varIndexBase + 0.

FWORD

centerX

x coordinate for the center of scaling. For variation, use varIndexBase
+ 1.

FWORD

centerY

y coordinate for the center of scaling. For variation, use varIndexBase
+ 2.

uint32

varIndexBase

Base index into DeltaSetIndexMap.

The PaintVarScale, PaintVarScaleAroundCenter, PaintVarScaleUniform, and
PaintVarScaleUniformAroundCenter formats use a base/sequence scheme to index into
mapping data. Also, applying variation deltas to an F2DOT14 value requires special
handling. See COLR table and OpenType Font Variations for details.

Note: Pure scaling can also be represented using the PaintTransform or
PaintVarTransform table. For scaling about the origin, this could be done by setting
xx and yy to x and y scale factors, and setting xy, yx, dx and dy = 0. The PaintScale
table and variants provide more compact representation when only scaling is
required.

Formats 24 to 27: PaintRotate, PaintVarRotate,
PaintRotateAroundCenter, PaintVarRotateAroundCenter
Formats 24 to 27 are used to apply a rotation to a sub-graph. The paint table that is the
root of the sub-graph is linked as a child. The amount of rotation is expressed directly as
an angle, using a floating-point value where 1.0 represents an angle of 180°.
Formats 24 and 25 apply rotations using the origin as the center of rotation. Format 25
allows for variation of the rotation in a variable font; format 24 provides a more compact
representation when variation is not required.
Formats 26 and 27 apply rotations around a specified center of rotation. Format 27
allows for variation of the rotation or of the position of the center of rotation in a
variable font; format 26 provides a more compact representation when variation is not
required.
Formats 25 and 27 must not be used in non-variable fonts or if the COLR table does not
have an ItemVariationStore subtable.
These tables use reduced precision for compactness. Where higher precision is required
use PaintTransform/PaintVarTransform.
For general information regarding transformations in a color glyph definition, see
Transformations.
PaintRotate table (format 24):
ﾉ

Expand table

Type

Name

Description

uint8

format

Set to 24.

Offset24

paintOffset

Offset to a Paint subtable, from beginning of PaintRotate table.

F2DOT14

angle

Rotation angle, 180° in counter-clockwise degrees per 1.0 of value.

PaintVarRotate table (format 25):

ﾉ

Expand table

Type

Name

Description

uint8

format

Set to 25.

Offset24

paintOffset

Offset to a Paint subtable, from beginning of PaintVarRotate table.

F2DOT14

angle

Rotation angle, 180° in counter-clockwise degrees per 1.0 of value. For
variation, use varIndexBase + 0.

uint32

varIndexBase

Base index into DeltaSetIndexMap.

PaintRotateAroundCenter table (format 26):
ﾉ

Expand table

Type

Name

Description

uint8

format

Set to 26.

Offset24

paintOffset

Offset to a Paint subtable, from beginning of PaintRotateAroundCenter
table.

F2DOT14

angle

Rotation angle, 180° in counter-clockwise degrees per 1.0 of value.

FWORD

centerX

x coordinate for the center of rotation.

FWORD

centerY

y coordinate for the center of rotation.

PaintVarRotateAroundCenter table (format 27):
ﾉ

Expand table

Type

Name

Description

uint8

format

Set to 27.

Offset24

paintOffset

Offset to a Paint subtable, from beginning of
PaintVarRotateAroundCenter table.

F2DOT14

angle

Rotation angle, 180° in counter-clockwise degrees per 1.0 of value. For
variation, use varIndexBase + 0.

FWORD

centerX

x coordinate for the center of rotation. For variation, use varIndexBase
+ 1.

FWORD

centerY

y coordinate for the center of rotation. For variation, use varIndexBase
+ 2.

Type

Name

Description

uint32

varIndexBase

Base index into DeltaSetIndexMap.

The PaintVarRotate and PaintVarRotateAroundCenter formats use a base/sequence
scheme to index into mapping data. Also, applying variation deltas to an F2DOT14 value
requires special handling. See COLR table and OpenType Font Variations for details.
Note: Pure rotation about a point can also be represented using the PaintTransform
or PaintVarTransform table. For rotation about the origin, this could be done by
setting matrix values as follows for angle θ:
xx = cos(θ)
yx = sin(θ)
xy = -sin(θ)
yy = cos(θ)
dx = dy = 0
The important distinction of the PaintRotate table and its variants is in allowing an angle
to be specified directly in degrees, rather than as changes to basis vectors. In variable
fonts, if a rotation angle needs to vary, it is easier to get smooth variation if an angle is
specified directly than when using trigonometric functions to derive matrix elements.
Note: The rotation angle is represented using an F2DOT14 value, which supports
values in the range [-2, 2). Since each 1.0 unit represents a change of 180°, rotation
angles of [-360, 360) can be represented directly. Variations of the rotation angle are
not limited to that range, however.
Note: If representation of rotation directly as an angle is preferred but higher
precision is required to specify a center of rotation, a chained sequence of
transforms can be used. For example, a PaintTransform can be used to align the
origin to the desired center of rotation, then PaintRotate can be used for the desired
rotation, and a second PaintTransform can be used to reset the origin.
When combining the transform effect of a PaintRotate table (or variants) with other
transforms, the result must be the same as if the rotation were represented using an
equivalent matrix or sequence of matrices.
A rotation can result in the pre-transform position (0, 0) being moved elsewhere. See
Formats 12 and 13: PaintTransform, PaintVarTransform regarding alignment of the
transformed content with the destination.

Formats 28 to 31: PaintSkew, PaintVarSkew,
PaintSkewAroundCenter, PaintVarSkewAroundCenter
Formats 28 to 31 are used to apply a skew to a sub-graph. The paint table that is the
root of the sub-graph is linked as a child. The amounts of skew in the x or y direction are
expressed directly as angles, using floating-point values where 1.0 represents an angle
of 180°.
Formats 28 and 29 apply skews using the origin as the center of rotation for the skew.
Format 29 allows for variation of the rotation in a variable font; format 28 provides a
more compact representation when variation is not required.
Formats 30 and 31 apply skews around a specified center of rotation. Format 31 allows
for variation of the rotation or of the position of the center of rotation in a variable font;
format 30 provides a more compact representation when variation is not required.
Formats 29 and 31 must not be used in non-variable fonts or if the COLR table does not
have an ItemVariationStore subtable.
These tables use reduced precision for compactness. Where higher precision is required
use PaintTransform/PaintVarTransform.
For general information regarding transformations in a color glyph definition, see
Transformations.
PaintSkew table (format 28):
ﾉ

Expand table

Type

Name

Description

uint8

format

Set to 28.

Offset24

paintOffset

Offset to a Paint subtable, from beginning of PaintSkew table.

F2DOT14

xSkewAngle

Angle of skew in the direction of the x-axis, 180° in counter-clockwise
degrees per 1.0 of value.

F2DOT14

ySkewAngle

Angle of skew in the direction of the y-axis, 180° in counter-clockwise
degrees per 1.0 of value.

PaintVarSkew table (format 29):
ﾉ

Expand table

Type

Name

Description

uint8

format

Set to 29.

Offset24

paintOffset

Offset to a Paint subtable, from beginning of PaintVarSkew table.

F2DOT14

xSkewAngle

Angle of skew in the direction of the x-axis, 180° in counter-clockwise
degrees per 1.0 of value. For variation, use varIndexBase + 0.

F2DOT14

ySkewAngle

Angle of skew in the direction of the y-axis, 180° in counter-clockwise
degrees per 1.0 of value. For variation, use varIndexBase + 1.

uint32

varIndexBase

Base index into DeltaSetIndexMap.

PaintSkewAroundCenter table (format 30):
ﾉ

Expand table

Type

Name

Description

uint8

format

Set to 30.

Offset24

paintOffset

Offset to a Paint subtable, from beginning of PaintSkewAroundCenter
table.

F2DOT14

xSkewAngle

Angle of skew in the direction of the x-axis, 180° in counter-clockwise
degrees per 1.0 of value.

F2DOT14

ySkewAngle

Angle of skew in the direction of the y-axis, 180° in counter-clockwise
degrees per 1.0 of value.

FWORD

centerX

x coordinate for the center of rotation.

FWORD

centerY

y coordinate for the center of rotation.

PaintVarSkewAroundCenter table (format 31):
ﾉ

Expand table

Type

Name

Description

uint8

format

Set to 31.

Offset24

paintOffset

Offset to a Paint subtable, from beginning of
PaintVarSkewAroundCenter table.

F2DOT14

xSkewAngle

Angle of skew in the direction of the x-axis, 180° in counter-clockwise
degrees per 1.0 of value. For variation, use varIndexBase + 0.

Type

Name

Description

F2DOT14

ySkewAngle

Angle of skew in the direction of the y-axis, 180° in counter-clockwise
degrees per 1.0 of value. For variation, use varIndexBase + 1.

FWORD

centerX

x coordinate for the center of rotation. For variation, use varIndexBase
+ 2.

FWORD

centerY

y coordinate for the center of rotation. For variation, use varIndexBase
+ 3.

uint32

varIndexBase

Base index into DeltaSetIndexMap.

The PaintVarSkew and PaintVarSkewAroundCenter formats use a base/sequence scheme
to index into mapping data. Also, applying variation deltas to an F2DOT14 value requires
special handling. See COLR table and OpenType Font Variations for details.
Note: Pure skews about a point can also be represented using the PaintTransform or
PaintVarTransform table. For skews about the origin, this could be done by setting
matrix values as follows for x skew angle φ and y skew angle ψ:
xx = yy = 1
yx = tan(ψ)
xy = -tan(φ)
dx = dy = 0
The important distinction of the PaintSkew table and its variants is in being able to
specify skew as an angle, rather than as changes to basis vectors. In variable fonts, if a
skew angle needs to vary, it is easier to get smooth variation if an angle is specified
directly than when using trigonometric functions to derive matrix elements.
Note: The skew angles are represented using F2DOT14 values, which support values
in the range [-2, 2). Since each 1.0 unit represents a change of 180°, skew angles of
[-360, 360) can be represented directly. Variations of the skew angle are not limited
to that range, however.
Note: If representation of skew directly as an angle is preferred but higher precision
is required to specify a center of rotation, a chained sequence of transforms can be
used. For example, a PaintTransform can be used to align the origin to the desired
center of rotation, then PaintSkew can be used for the desired skew rotation, and a
second PaintTransform can be used to reset the origin.

When combining the transform effect of a PaintSkew table (or variants) with other
transforms, the result must be the same as if the skew were represented using an
equivalent matrix or sequence of matrices.
A skew can result in the pre-transform position (0, 0) being moved elsewhere. See
Formats 12 and 13: PaintTransform, PaintVarTransform regarding alignment of the
transformed content with the destination.

Format 32: PaintComposite
Format 32 is used to combine two layered compositions, referred to as source and
backdrop, using different compositing or blending modes. The available compositing
and blending modes are defined in an enumeration. For general information and
examples, see Compositing and blending.
Note: The backdrop is also referred to as the “destination”.
PaintComposite table (format 32):
ﾉ

Expand table

Type

Name

Description

uint8

format

Set to 32.

Offset24

sourcePaintOffset

Offset to a source Paint table, from beginning of
PaintComposite table.

uint8

compositeMode

A CompositeMode enumeration value.

Offset24

backdropPaintOffset

Offset to a backdrop Paint table, from beginning of
PaintComposite table.

The compositeMode value must be one of the values defined in the CompositeMode
enumeration, which are taken from the W3C Compositing and Blending Level 1
specification. Details on each mode, including specifications of the required calculations
using pixel color and alpha values, are provided in that specification. If an unrecognized
value is encountered, COMPOSITE_CLEAR must be used.
CompositeMode enumeration:
ﾉ

Expand table

Value

Name

Description

Porter-Duff modes
0

COMPOSITE_CLEAR

Clear

1

COMPOSITE_SRC

Source (“Copy” in Composition & Blending Level 1)

2

COMPOSITE_DEST

Destination

3

COMPOSITE_SRC_OVER

Source Over

4

COMPOSITE_DEST_OVER

Destination Over

5

COMPOSITE_SRC_IN

Source In

6

COMPOSITE_DEST_IN

Destination In

7

COMPOSITE_SRC_OUT

Source Out

8

COMPOSITE_DEST_OUT

Destination Out

9

COMPOSITE_SRC_ATOP

Source Atop

10

COMPOSITE_DEST_ATOP

Destination Atop

11

COMPOSITE_XOR

XOR

12

COMPOSITE_PLUS

Plus (“Lighter” in Composition & Blending Level 1)

Separable color blend modes:
13

COMPOSITE_SCREEN

screen

14

COMPOSITE_OVERLAY

overlay

15

COMPOSITE_DARKEN

darken

16

COMPOSITE_LIGHTEN

lighten

17

COMPOSITE_COLOR_DODGE

color-dodge

18

COMPOSITE_COLOR_BURN

color-burn

19

COMPOSITE_HARD_LIGHT

hard-light

20

COMPOSITE_SOFT_LIGHT

soft-light

21

COMPOSITE_DIFFERENCE

difference

22

COMPOSITE_EXCLUSION

exclusion

23

COMPOSITE_MULTIPLY

multiply

Value

Name

Description

Non-separable color blend modes:
24

COMPOSITE_HSL_HUE

hue

25

COMPOSITE_HSL_SATURATION

saturation

26

COMPOSITE_HSL_COLOR

color

27

COMPOSITE_HSL_LUMINOSITY

luminosity

The graphic compositions are defined by the source and backdrop paint tables and their
respective sub-graphs. Conceptually, they are rendered into bitmaps, and the source is
composited or blended into the backdrop using the specified composite mode.
While color values obtained from the CPAL table are represented in sRGB using the nonlinear transfer function defined in the sRGB specification, the compositing and blending
calculations are done after applying the inverse transfer function to derive linear-light
RGB values. For more information regarding the non-linear and linear-light
representations for sRGB, see Interpolation of Colors in the CPAL table chapter.
As mentioned above (see Metrics and boundedness of color glyphs using version 1
formats), a color glyph definition must be bounded. A sub-graph that has
PaintComposite as its root is either bounded or unbounded, depending on the mode
used and the boundedness of the source and backdrop sub-graphs. For each mode,
boundedness is determined by the boundedness of the source and backdrop as follows:
Always bounded:
COMPOSITE_CLEAR
Bounded if and only if the source is bounded:
COMPOSITE_SRC
COMPOSITE_SRC_OUT
Bounded if and only if the backdrop is bounded:
COMPOSITE_DEST
COMPOSITE_DEST_OUT
Bounded if and only if either the source or backdrop is bounded:
COMPOSITE_SRC_IN
COMPOSITE_DEST_IN
Bounded if and only if both the source and backdrop are bounded:
All other modes

COLR version 1 rendering algorithm

The various graphic concepts represented by COLR version 1 formats were individually
described in the Graphic Compositions section, and the various formats were described
in the COLR table formats section. Together, these provide most of the necessary details
regarding how a color glyph is rendered. The following provides a comprehensive
description of the rendering process, considering the graph as a whole.
The following algorithm can be used to render color glyphs defined using version 1
formats. Applications are not required to implement rendering using this algorithm, but
must produce equivalent results.
Note: Checks for well-formedness and validity, as described in the Color glyphs as a
directed acyclic graph section, are not repeated here. Actual implementations can
integrate such checks with rendering processing.
1. Start with an initial drawing surface. As mentioned above (see Metrics and
boundedness of color glyphs using version 1 formats), if a clip box is provided, it
can be used to determine the size. Otherwise, the graph can be traversed to
compute a required size.
2. Traverse the graph of a color glyph definition, starting with the root paint table
referenced by a BaseGlyphPaintRecord, using the following pseudo-code function.

// render a paint table and its sub-graph
function renderPaint(paint)
if format 1: // PaintColrLayers
for each referenced child paint table, in bottom-up z-order:
// for ordering, see Layering; Format 1: PaintColrLayers
call renderPaint() passing the child paint table
compose the returned graphic onto the surface using simple
alpha blending
if format 2 or 3: // PaintSolid, PaintVarSolid
paint the specified color onto the surface
if format 4, 5, 6, 7, 8 or 9:
// PaintLinearGradient, PaintVarLinearGradient
// PaintRadialGradient, PaintVarRadialGradient
// PaintSweepGradient, PaintVarSweepGradient
paint the gradient onto the surface following the gradient
algorithm
if format 10: // PaintGlyph
apply the outline of the referenced glyph to the clip region
// take the intersection of clip regions—see Filling shapes

call renderPaint() passing the child paint table
restore the previous clip region
if format 11: // PaintColrGlyph
call renderPaint() passing the paint table referenced by the base
glyph ID
if format 12 to 31:
// PaintTransform, PaintVarTransform
// PaintTranslate, PaintVarTranslate
// PaintScale*, PaintVarScale*
// PaintRotate*, PaintVarRotate*
// PaintSkew*, PaintVarSkew*
apply the specified transform
// compose the transform with the current transform state—see
// Transformations
call renderPaint() passing the child paint table
restore the previous transform state
if format 32: // PaintComposite
// render backdrop sub-graph
call renderPaint() passing the backdrop child paint table and save
the result
// render source sub-graph
call renderPaint() passing the source child paint table and save
the result
// compose source and backdrop
compose the source and backdrop using the specified composite mode
// compose final result
compose the result of the above composition onto the surface using
simple alpha blending

COLR table and OpenType Font Variations
The COLR table can be used in variable fonts. For color glyphs defined using version 0
formats, the glyph outlines can be variable, but no other aspect of the color glyph is
variable. For color glyphs defined using version 1 formats, items that can be variable
include the glyph outlines plus other aspects of the color glyph definition:
Alpha values
Color stop offsets in gradient color lines
Placement of gradients onto the design grid
The arguments of transformations (matrix elements, angles, etc.)

Variation data is provided in an ItemVariationStore table contained within the COLR
table.
In a variable font, each value within the COLR version 1 formats that is variable needs to
be associated with corresponding variation data (delta sets) in the item variation store.
This is done using a DeltaSetIndexMap table (see Associating target items to variation
data). The delta-set index mapping table contains an array of entries that provide
indices mapping into sets of delta data in the item variation store. Each variable item in
the COLR table is given an index (base 0) into the mapping data. For example, if a
variable item in the COLR table is given an index value of 5, the sixth entry in the
mapping data is used to index into the item variation store.
The indices for variable items in the COLR table are indicated using a base/sequence
scheme. Each table or record that contains variable items will use a contiguous
sequence of entries in the mapping array, and will include a varIndexBase field that
indicates the first entry in the mapping array to be used. The variable fields within that
table or record use entries in the mapping array, starting with the varIndexBase entry, in
the order the fields occur in the table or record.
For example, the VarAffine2x3 table has six variable fields followed by the varIndexBase
field. For the first variable field (xx), varIndexBase + 0 is used as the index into the
mapping array; for the second variable field (yx), varIndexBase + 1 is used as the index
into the mapping array; and so on.
If the index for a variable item is greater than or equal to the number of entries in the
mapping array, the last mapping array entry must be used.
The sequence of indices derived from a varIndexBase value do not wrap on overflow and
must not exceed 0xFFFFFFFF. A varIndexBase value of 0xFFFFFFFF is assigned a special
meaning indicating that the variable fields in the given table or record do not have
variation data.
Similarly, a delta-set index mapping entry with values 0xFFFF/0xFFFF can be used to
indicate that an item has no variation data. (See the Variation Data section of the
OpenType Font Variations Common Table Formats chapter.)
If the COLR table does not contain an ItemVariationStore subtable, the varIndexBase
field of variation tables or records must be ignored by applications and should be set to
zero.
If the COLR table contains an item variation store but does not contain a mapping table
(varIndexMapOffset in the COLR header is NULL), then an implicit identity mapping is
used: the sequence of values beginning with varIndexBase are treated directly as deltaset indices with 16-bit sub-fields for outer (high word) and inner (low word) index values.

(See the Variation Data section of the OpenType Font Variations Common Table Formats
chapter for more information regarding delta set indices.)
For variable fonts that use COLR version 1 formats, special considerations apply to the
effect of variation on the bounding box. See Metrics and boundedness of color glyphs
using version 1 formats for details. Also, special considerations apply for color lines and
for radial gradients. See Color lines and Radial gradients for details.
Some COLR version 1 formats allow for variation deltas to be applied to F2DOT14 or
Fixed values. While the F2DOT14 and Fixed types have fractional components, variation
deltas are integer values. Applying deltas to F2DOT14 or Fixed values requires special
handling in which these values are treated like integers. See the Item Variation Store
Header and Item Variation Data Subtables section of the OpenType Font Variations
Common Table Formats chapter for details.
For general information on OpenType font variations, see OpenType Font Variations
Overview.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

CPAL — Color Palette Table
Article • 05/29/2024

The palette table is a set of one or more palettes, each containing a predefined number
of color records. It may also contain 'name' table IDs describing the palettes and their
entries.
Palettes are defined by a set of color records. Each color record specifies a color in the
sRGB color space using 8-bit BGRA (blue, green, red, alpha) representation. The sRGB
color space is specified in IEC 61966-2-1:1999 Multimedia systems and equipment Colour measurement and management - Part 2-1: Colour management - Default RGB
colour space - sRGB . Details on the specification for the sRGB color space, including
the color primaries and “gamma” transfer function, are also provided in CSS Color
Module Level 4, section 10.2

.

All palettes have the same number of color records, specified by numColorRecords. All
color records for all palettes are arranged in a single array, and the color records for any
given palette are a contiguous sequence of color records within that array. The first
color record of each palette is provided in the colorRecordIndices array.
Multiple colorRecordIndices may refer to the same color record, in which case multiple
palettes would use the same color records; hence the number of functionally distinct
palettes may be fewer than the numPalettes entry. Also, the sequence of color records
for different palettes may overlap, with certain color records shared between multiple
palettes. Thus, the total number of color records in the CPAL table may be less than the
number of palette entries multiplied by the number of palettes.
The first palette, palette index 0, is the default palette. A minimum of one palette must
be provided in the CPAL table if the table is present. Palettes must have a minimum of
one color record. An empty CPAL table, with no palettes and no color records is not
permitted.
Colors within a palette are referenced by base-zero index. The number of colors in each
palette is given by numPaletteEntries. The number of color records in the color records
array (numColorRecords) must be greater than or equal to max(colorRecordIndices) +
numPaletteEntries.

Palette table header
The CPAL table begins with a header that starts with a version number. Currently, only
versions 0 and 1 are defined.

CPAL version 0
The CPAL header version 0 is organized as follows:
CPAL version 0
ﾉ

Expand table

Type

Name

Description

uint16

version

Table version number (=0).

uint16

numPaletteEntries

Number of palette entries in each palette.

uint16

numPalettes

Number of palettes in the table.

uint16

numColorRecords

Total number of color records, combined for all
palettes.

Offset32

colorRecordsArrayOffset

Offset from the beginning of CPAL table to the first
ColorRecord.

uint16

colorRecordIndices[numPalettes]

Index of each palette’s first color record in the
combined color record array.

CPAL version 1
The CPAL header version 1 adds three additional fields to the end of the table header
and is organized as follows:
CPAL version1
ﾉ

Expand table

Type

Name

Description

uint16

version

Table version number (=1).

uint16

numPaletteEntries

Number of palette entries in each palette.

uint16

numPalettes

Number of palettes in the table.

uint16

numColorRecords

Total number of color records, combined for all
palettes.

Offset32

colorRecordsArrayOffset

Offset from the beginning of CPAL table to the first
ColorRecord.

uint16

colorRecordIndices[numPalettes]

Index of each palette’s first color record in the
combined color record array.

Offset32

paletteTypesArrayOffset

Offset from the beginning of CPAL table to the
Palette Types Array. Set to 0 if no array is provided.

Offset32

paletteLabelsArrayOffset

Offset from the beginning of CPAL table to the
Palette Labels Array. Set to 0 if no array is provided.

Offset32

paletteEntryLabelsArrayOffset

Offset from the beginning of CPAL table to the
Palette Entry Labels Array. Set to 0 if no array is
provided.

Palette entries and color records
Colors defined in the CPAL table are referenced by a palette index plus a palette-entry
index. Indices are base zero. For a given palette index and palette-entry index, an entry
within the color records array is derived: colorRecordIndex =
colorRecordIndices[paletteIndex] + paletteEntryIndex.
The color records array is comprised of color records:
ﾉ

Expand table

Type

Name

Description

ColorRecord

colorRecords[numColorRecords]

Color records for all palettes.

Each color record has BGRA values. The color space for these values is sRGB.
ColorRecord
ﾉ

Type

Name

Description

uint8

blue

Blue value (B0).

uint8

green

Green value (B1).

uint8

red

Red value (B2).

uint8

alpha

Alpha value (B3).

Expand table

The colors in the color record should not be pre-multiplied, and the alpha value should
be explicitly set for each palette entry.

An alpha value of zero means no opacity (fully transparent); 255 means opaque (no
transparency). The alpha value in the color record may be combined with and does not
supersede alpha or opacity attributes set in higher-level contexts.
When placing and registering overlapping elements, there is the possibility of
“seaming”, where the edge rendering of one element interferes with another element.
This could be more or less visible depending on the contrast of the colors used.

Palette types array
The palette types array is an array of integer values specifying flags for each palette.
ﾉ

Expand table

Type

Name

Description

uint32

paletteTypes[numPalettes]

Array of 32-bit flag fields that describe properties of each
palette. See below for details.

The following flags are defined:
ﾉ

Expand table

Mask

Name

Description

0x0001

USABLE_WITH_LIGHT_BACKGROUND

Bit 0: palette is appropriate to use when
displaying the font on a light background such
as white.

0x0002

USABLE_WITH_DARK_BACKGROUND

Bit 1: palette is appropriate to use when
displaying the font on a dark background such
as black.

0xFFFC

Reserved

Reserved for future use — set to 0.

The USABLE_WITH_LIGHT_BACKGROUND and USABLE_WITH_DARK_BACKGROUND flags
are not mutually exclusive: they may both be set.

Palette labels array
The palette labels array is an array of integer values specifying 'name' table IDs that
provide user interface strings associated with each palette. Typically, these will be IDs in
the font-specific name ID range.

ﾉ

Expand table

Type

Name

Description

uint16

paletteLabels[numPalettes]

Array of 'name' table IDs. Use 0xFFFF for a particular palette
if no string is provided.

Palette entry label array
The palette entry label array is an array of integer values specifying 'name' table IDs that
provide user interface strings associated with each palette entry. (For example, “Outline”,
“Fill”.) This set of palette entry labels applies to all palettes in the font. Typically, the IDs
will be in the font-specific name ID range.
ﾉ

Expand table

Type

Name

Description

uint16

paletteEntryLabels[numPaletteEntries]

Array of 'name' table IDs. Use 0xFFFF for a
particular entry if no string is provided.

Relationship to COLR and SVG tables
Both the COLR and SVG tables can use CPAL to define their palettes.

COLR and CPAL
In fonts that have a COLR table, the CPAL table is required, and contains all the fontspecified colors used by multicolored glyphs.
As noted in the COLR table description, the palette entry index of 0xFFFF if specified in
the COLR table represents the foreground color used in the system. This special value
does not change across multiple palettes. The maximum palette entry index is 65535 - 1,
as the 65536th position is used in the COLR table to indicate the foreground font color.

SVG and CPAL
In fonts that have an SVG table, the CPAL table can be used to contain the values of any
color variables used by SVG glyph descriptions in the SVG table. SVG glyph descriptions
can also include color specifications directly, however. Thus, the CPAL table is optional
for fonts with an SVG table.

Foreground color is expressed by the “currentColor” keyword in the SVG glyph
descriptions.
When used with an SVG table, the default palette’s colors must be set to the same
values as the default values for the color variables in the SVG glyph descriptions; this is
for text engines that support the SVG table but not color palettes. The SVG glyph
descriptions can express their own explicit or “hard-coded” colors as well. These are not
related to color variables and thus do not vary by palette selection. See the SVG table
specification for more details.

Interpolation of colors
The SVG table and version 1 of the COLR table both support color gradient fills. The
gradients are defined using color stops to specify color values at specific positions along
a color line, with color values for other positions on the color line derived by
interpolation.
When interpolating color values, linear interpolation between color stop positions is
used. For example, suppose adjacent color stops are specified for positions 0.5 and 0.9
on a color line, and a color value is being calculated for position 0.8. The color value of
the first color stop will contribute 75% of the value ((0.8 - 0.5) / (0.9 - 0.5)), and the color
value of the second color stop will contribute 25% of the value. Interpolated values at
each position of the color line are computed in this way for each of the R, G and B color
components.
When interpolating color values, specific aspects of the representation of colors as well
as handling of alpha need to be considered.
Representations of sRGB color values are expressed as levels of red, green and blue
color “primaries” with specific, absolute chromaticity values, which are defined in the
sRGB specification. Color-primary levels can potentially be expressed using a linear-light
scale that correlates directly to light energy. (On a linear-light scale, for example, a
doubling of a color value would correspond to a doubling of display luminance.) For
sRGB, however, standard practice is to represent levels using a scale defined by a nonlinear transfer function, sometimes referred to as “gamma”. This transfer function is also
defined in the sRGB specification. (See CSS Color Module Level 4, section 10.2

for

details.) In the CPAL table, sRGB color values are always specified in terms of the nonlinear, sRGB transfer function.
Note: An advantage of representing colors using a non-linear scale is that it allows
more effective use of limited bit depth when color-primary levels are represented as
integers: smaller differences in light energy can be represented for lower levels than

for higher levels. This is beneficial since the human visual system is more sensitive to
differences at low luminance levels than to differences at high luminance levels.
When interpolating colors, different results will be obtained if the interpolation is
computed using the non-linear scale for color levels than if using the linear-light scale.
For interoperable results, whether the non-linear or linear-light scale is to be used needs
to be specified.
For gradient color values in the SVG table, the required interpolation behavior is defined
in the Scalable Vector Graphics 1.1 (Second Edition)
interpolation’ property

specification: the ‘color-

can be used in an SVG document to declare whether

interpolation is done using the non-linear sRGB scale (the default), or using a linear-light
scale by applying the inverse sRGB transfer function.
For gradient color values in the COLR table, interpolation must be computed using
linear-light values (i.e., after applying the inverse sRGB transfer function).
After an interpolated color value is computed, whether or not the non-linear sRGB
transfer function needs to be re-applied is determined by the requirements of the
implementation context.
For both the COLR and SVG tables, interpolation must be done with alpha premultiplied into each linearized R, G and B component. For alpha specified in a CPAL
ColorRecord, the value is converted to a floating value in the range [0, 1.0] by dividing
by 255, then multiplied into each R, G and B component. In the COLR table, color
references in formats used for version 1 include a separate alpha value; that alpha value
(with variation, in a variable font) is multiplied into the R, G and B components as well.
Interpolated values are then calculated by linear interpolation using these premultiplied, linear-light R, G and B values.
Note: Alpha components use a linear scale and can be directly interpolated apart
from the R, G and B components without any linearization step.
Once interpolation of the pre-multiplied red, green and blue values and of the alpha
value is complete, the red, green and blue results are then un-pre-multiplied by dividing
each interpolated value by the corresponding interpolated alpha.
While color values are specified as 8-bit integers, the interpolation computations will
require greater precision in each of the linearization, pre-multiply, and interpolation
steps. Also, when rendered results are to be presented on an imaging device with
known characteristics, visual banding artifacts in a gradient can be minimized by taking
full advantage of the color bit depth supported by the device. For instance, if a display

supports 10- or 12-bit quantization per color channel, then ideally the ramp of color
values in a gradient would use that level of quantization. Other factors from the
presentation context may, however, also affect the available capabilities. Therefore, no
minimum level of precision is specified as a requirement.

cvar — CVT Variations Table
Article • 05/29/2024

The control value table (CVT) variations table is used in variable fonts to provide
variation data for CVT values. For a general overview of OpenType Font Variations, see
the chapter, OpenType Font Variations Overview.
Fonts that use the Truetype outline format for glyphs and that have hinting instructions
will typically also have a CVT (the 'cvt ' table). The CVT table provides an indexed list of
control values that can be referenced by instructions. Example values are the height of a
serif, x-height, or the width of uppercase stems. When glyph outline points are adjusted
by instructions to improve rasterization at a particular PPEM size, the control values may
be used by the instructions to provide design-distance values for those adjustments —
typically, values that need to be kept constant across all glyphs in the font for a given
PPEM size.
Within a variable font, the numeric value of particular control values may need to be
adjusted for different variation instances, to match the changes to outlines for different
instances. The CVT variations table provides variation data for that purpose. By using
interpolation to derive adjusted CVT values for a particular instance, instructions can
obtain instance-appropriate values, and the same instructions can be used for all
variations.
The CVT variations table must be used in combination with TrueType outlines and a 'cvt '
table, and also in combination with a font variations ('fvar') table and other required or
optional tables used in variable fonts.

Table Format
The 'cvar' table uses a variant of the tuple variation store format, described in the
chapter, OpenType Font Variations Common Table Formats. The 'gvar' table uses a veryslightly different variant of this format for each glyph.
In terms of overall structure, the 'cvar' table begins with a header, which is followed by
serialized variation data.

Figure: High-level organization of the 'cvar' table
The variation data includes logical groupings of data that apply to different regions of
the variation space — tuple-variation data tables. These logical groupings are stored in
two parts: a header, and serialized data. The 'cvar' header includes an array of tuplevariation data headers, each of which is associated with a particular portion of the
serialized data.
The serialized data includes adjustment delta values and also packed “point number”
data that identify the CVT entries to which the deltas apply. The serialized data for a
given region can include point number data that applies to that specific tuple-variation
data, but there can also be a shared set of point number data, stored at the start of the
serialized data, that can be used in relation to multiple tuple-variation data tables.
The format of the 'cvar' header is as follows.
'cvar' table header:
ﾉ

Expand table

Type

Name

Description

uint16

majorVersion

Major version number of
the CVT variations table —
set to 1.

uint16

minorVersion

Minor version number of
the CVT variations table —
set to 0.

uint16

tupleVariationCount

A packed field. The high 4
bits are flags, and the low
12 bits are the number of
tuple-variation data tables.
The count can be any
number between 1 and
4095.

Offset16

dataOffset

Offset from the start of the
'cvar' table to the serialized
data.

TupleVariationHeader

tupleVariationHeaders[tupleVariationCount]

Array of tuple variation
headers.

Complete details regarding the tupleVariationCount field, the flags used in the
tupleVariationCount, the TupleVariationHeader format and the format of the serialized
data are provided in the chapter, OpenType Font Variations Common Table Formats.
Details regarding how the data are processed to derive interpolated CVT values for
particular instances are provided in that chapter and in the chapter, OpenType Font
Variations Overview.
As noted above, the format of the 'cvar' table is closely related to formats used in the
'gvar' table. The following are key differences to note:
The TupleVariationHeader structure includes a particular field, tupleIndex. This is a
packed field that includes flag bits, one of which indicates whether the structure
includes an embedded peak tuple record. In the 'gvar' table, this is optional, and
the flag does not always need to be set. In the 'cvar' table, however, the embedded
peak tuple record is mandatory, and this flag must always be set.
The serialized data includes packed “point” numbers. In the context of the 'gvar'
table, these are indices for the outline points of a particular glyph. In the 'cvar'
table, these are indices for CVT values within the 'cvt ' table.
In the 'gvar' table, there are two logical deltas for each enumerated outline point:
one for the X coordinate, and one for the Y coordinate. Hence, the total number of
logical deltas is twice the count of point numbers. In the 'cvar' table, there is
exactly one logical delta for each point number.
Note that the CVT values are all FWORDs, and that the total number of CVT values is
determined by the length of the 'cvt ' table. Hence, CVT index values range from 0 to
floor(cvtLength / sizeof(FWORD)) - 1.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

cvt — Control Value Table
Article • 12/09/2021

This table contains a list of values that can be referenced by instructions. They can be
used, among other things, to control characteristics for different glyphs. The length of
the table must be an integral number of FWORD units.
ﾉ

Expand table

Type

Description

FWORD[ n
]

List of n values referenceable by instructions. n is the number of FWORD items that
fit in the size of the table.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

DSIG — Digital Signature Table
Article • 05/31/2024

Overview
The DSIG table contains the digital signature of the OpenType™ font. Signature formats
are widely documented and rely on a key pair architecture. Software developers, or
publishers posting material on the Internet, create signatures using a private key.
Operating systems or applications authenticate the signature using a public key.
The W3C and major software and operating system developers have specified security
standards that describe signature formats, specify secure collections of web objects, and
recommend authentication architecture. OpenType fonts with signatures will support
these standards.
OpenType fonts offer many security features:
Operating systems and browsing applications can identify the source and integrity
of font files before using them,
Font developers can specify embedding restrictions in OpenType fonts, and these
restrictions cannot be altered in a font signed by the developer.
The enforcement of signatures is an administrative policy that may be supported by the
host environment in which fonts are used. Systems may restrict use of unsigned fonts, or
may allow policy to be controlled by a system administrator.
Anyone can obtain identity certificates and encryption keys from a certifying agency,
such as Verisign or GTE’s Cybertrust, free or at a very low cost.

Table structure
The DSIG table is organized as follows. The first portion of the table is the header.
DsigHeader
ﾉ

Expand table

Type

Name

Description

uint32

version

Version number of the DSIG table
(0x00000001)

uint16

numSignatures

Number of signatures in the table

uint16

flags

Permission flags:
bit 0: cannot be resigned
bits 1-7: Reserved (Set to 0)

SignatureRecord

signatureRecords[numSignatures]

Array of signature records

The version of the DSIG table is expressed as a uint32, beginning at 0. The version of the
DSIG table currently used is version 1 (0x00000001).
Permission bit 0 allows a party signing the font to prevent any other parties from also
signing the font (counter-signatures). If this bit is set to zero (0) the font may have a
signature applied over the existing digital signature(s). A party who wants to ensure that
their signature is the last signature can set this bit.
The DSIG header has an array of signature records that specify the format and offset of
signature blocks.
SignatureRecord
ﾉ

Expand table

Type

Name

Description

uint32

format

Format of the signature

uint32

length

Length of signature in bytes

Offset32

signatureBlockOffset

Offset to the signature block from the beginning of the table

Signatures are contained in one or more signature blocks. Signature blocks may have
various formats; currently one format is defined. The format identifier specifies both the
format of the signature block, as well as the hashing algorithm used to create and
authenticate the signature.
Signature Block Format 1
ﾉ

Type

Name

Description

uint16

reserved1

Reserved for future use; set to zero.

uint16

reserved2

Reserved for future use; set to zero.

Expand table

uint32

signatureLength

Length (in bytes) of the PKCS#7 packet in the signature
field.

uint8

signature[signatureLength]

PKCS#7 packet

For more information about PKCS#7 signatures, see RFC 2315, PKCS #7: Cryptographic
Message Syntax, Version 1.5 (https://www.rfc-editor.org/info/rfc2315

).

For more information about counter-signatures, see RFC 2985, PKCS #9: Selected Object
Classes and Attribute Types, Version 2.0 (https://www.rfc-editor.org/info/rfc2985

).

Format 1: For whole fonts, with either TrueType outlines and/or CFF or CFF2 data
PKCS#7 or PKCS#9. The signed content digest is created as follows:
1. If there is an existing DSIG table in the font:
a. Remove the DSIG table from font.
b. Remove the DSIG table entry from the table directory.
c. Adjust table offsets as necessary.
d. Recalculate the checksumAdjustment in the 'head' table.
2. Select the flags value and append it to a copy of the revised font data.
3. Hash the revised font data using a secure one-way hash (such as MD5) to create
the content digest.
4. Create the PKCS#7 signature block using the content digest.
5. Create a new DSIG table containing the signature block.
6. Add the DSIG table to the font, adjusting table offsets as necessary.
7. Add a DSIG table entry to the table directory.
8. Recalculate the checksumAdjustment in the 'head' table.
Validation of a signature in a font file is done by repeating steps 1 – 4 in an in-memory
copy of the font file, using the flags value from the font file in step 2. Note that
changing the checksumAdjustment in the last step does not break the signature
because validation is done on an in-memory copy with these changes.
Prior to signing a font file, ensure that all the following attributes are true:
The magic number in the 'head' table is correct.
Given the numTables value in the table directory, the other values in the table
directory are consistent.
The table records in the table directory are ordered alphabetically by the table
tags, and there are no duplicate tags.
The offset of each table is a multiple of 4. (That is, tables are long word aligned.)
The first actual table in the file comes immediately after the directory of tables.

If the tables are sorted by offset, then for all tables i (where index 0 means the
table with the smallest offset), Offset[i] + Length[i] <= Offset[i+1] and Offset[i] +
Length[i] >= Offset[i+1] - 3. In other words, the tables do not overlap, and there
are at most 3 bytes of padding between tables.
The pad bytes between tables are all zeros.
The offset of the last table in the file plus its length is not greater than the size of
the file.
The checksums of all tables are correct.
The 'head' table’s checksumAdjustment field is correct.

Signatures for font collection files
The DSIG table for a font collection file (.ttc or .otc) must be the last table in the file. The
offset to the table is put in the TTCHeader (version 2). Signatures of font collection files
must be Format 1 signatures.
The signature of a font collection file applies to the entire file, not to the individual fonts
contained within the file. Signing the font collection file ensures that other contents are
not added to the file.
Individual fonts included in a font collection file should not be individually signed as the
process of making the font collection file could invalidate the signature on individual
fonts.
When DSIG table is created for a font collection file, the steps given above are used,
with these revisions:
In step 1: if there is an existing DSIG table referenced in a version 2.0 TTC header,
the DSIG table is removed, and the DSIG fields in the TTC header are set to NULL.
No recalculation of a checksumAdjustment is required.
In steps 6 and 7: the DSIG table is added to the file, not to any individual font
within the collection. A version 2.0 TTC header is required, with the DSIG fields in
the TTC header set to reference the DSIG table.
Step 8 is not applicable.
See the TTC Header section of the OpenType Font File chapter for related information.

６ Collaborate with us on
GitHub

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:

The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

 Open a documentation issue
 Provide product feedback

EBDT — Embedded Bitmap Data Table
Article • 05/31/2024

The EBDT table is used to embed monochrome or grayscale bitmap glyph data. It is
used together with the EBLC table, which provides embedded bitmap locators, and the
EBSC table, which provides embedded bitmap scaling information.
OpenType embedded bitmaps are also called “sbits” (for “scaler bitmaps”). A set of
bitmaps for a face at a given size is called a strike.
The EBLC table identifies the sizes and glyph ranges of the sbits, and has offsets to glyph
bitmap data within the EBDT table. The EBDT table then stores the glyph bitmap data,
using a number of different possible formats. Glyph metrics information may be stored
in either the EBLC or EBDT table, depending upon the formats used in each table. The
EBSC table identifies sizes that will be handled by scaling up or scaling down other sbit
sizes.

Table structure
The EBDT table begins with a header containing simply the table version number.
EBDT Header
ﾉ

Type

Name

Description

uint16

majorVersion

Major version of the EBDT table, = 2.

uint16

minorVersion

Minor version of the EBDT table, = 0.

Expand table

Note: The first version of the EBDT table is 2.0.
The rest of the EBDT table is a collection of bitmap data. The bitmap data can be in a
number of possible formats, indicated by information in the EBLC table. Some of the
formats contain metric information plus image data, and other formats contain only the
image data. Long word alignment is not required for these sub tables; byte alignment is
sufficient.
There are also two different formats for glyph metrics: big glyph metrics and small glyph
metrics. A BigGlyphMetrics record defines metrics information for both horizontal and
vertical layouts. This is important in fonts (such as Kanji) where both types of layout may

be used. The SmallGlyphMetrics record defines metrics information for one layout
direction only. Which direction applies, horizontal or vertical, is determined by the flags
field in the BitmapSize records within the EBLC table.
BigGlyphMetrics record
ﾉ

Expand table

Type

Name

Description

uint8

height

Number of rows in the bitmap.

uint8

width

Number of columns in the bitmap.

int8

horiBearingX

Distance in pixels from the horizontal origin to the left edge of the bitmap.

int8

horiBearingY

Distance in pixels from the horizontal origin to the top edge of the bitmap.

uint8

horiAdvance

Horizontal advance width in pixels.

int8

vertBearingX

Distance in pixels from the vertical origin to the left edge of the bitmap.

int8

vertBearingY

Distance in pixels from the vertical origin to the top edge of the bitmap.

uint8

vertAdvance

Vertical advance width in pixels.

SmallGlyphMetrics record
ﾉ

Expand table

Type

Name

Description

uint8

height

Number of rows in the bitmap.

uint8

width

Number of columns in the bitmap.

int8

bearingX

Distance in pixels from the horizontal origin to the left edge of the bitmap (for
horizontal text); or distance in pixels from the vertical origin to the top edge of
the bitmap (for vertical text).

int8

bearingY

Distance in pixels from the horizontal origin to the top edge of the bitmap (for
horizontal text); or distance in pixels from the vertical origin to the left edge of
the bitmap (for vertical text).

uint8

advance

Horizontal or vertical advance width in pixels.

Some of the bitmap data formats allow a composite bitmap to be defined, using one or
more bitmaps as components. The composite formats allow for any number of

components, and allow the components to be positioned anywhere in the composite
glyph. The components are referenced using an EbdtComponent record.
EbdtComponent record
ﾉ

Type

Name

Description

uint16

glyphID

Component glyph ID

int8

xOffset

Position of component left

int8

yOffset

Position of component top

Expand table

The EbdtComponent record contains the glyph ID of the component, which can be used
to look up the location of component glyph data in the EBLC table. The record also
contains xOffset and yOffset values that specify where to position the top-left corner of
the component within the composite. Nested composites (a composite of composites)
are allowed, and the number of nesting levels is determined by implementation stack
space.

Glyph bitmap data formats
The nine different formats currently defined for glyph bitmap data are listed and
described below. Different formats are better for different purposes.
In all formats, if the bitDepth is greater than 1, all of a pixel’s bits are stored
consecutively in memory, and all of a row’s pixels are stored consecutively.
Each format can contain black/white or grayscale bitmaps depending on the setting of
the bitDepth field in the EBLC table. For performance reasons, a byte-aligned format for
embedded bitmaps with bitDepth of 8 is recommended.

Format 1: small metrics, byte-aligned data
GlyphBitmapFormat1 table
ﾉ

Expand table

Type

Name

Description

SmallGlyphMetrics

smallMetrics

Metrics information for the glyph

uint8

imageData[variable]

Byte-aligned bitmap data

Glyph bitmap format 1 consists of a small metrics records (either horizontal or vertical
depending on the flags field of the BitmapSize record within the EBLC table) followed by
byte aligned bitmap data. The bitmap data begins with the most significant bit of the
first byte corresponding to the top-left pixel of the bounding box, proceeding through
succeeding bits moving left to right. The data for each row is padded to a byte
boundary, so the next row begins with the most significant bit of a new byte. 1 bits
correspond to black, and 0 bits to white.

Format 2: small metrics, bit-aligned data
GlyphBitmapFormat2 table
ﾉ

Expand table

Type

Name

Description

SmallGlyphMetrics

smallMetrics

Metrics information for the glyph

uint8

imageData[variable]

Bit-aligned bitmap data

Glyph bitmap format 2 is the same as format 1 except that the bitmap data is bit
aligned. This means that the data for a new row will begin with the bit immediately
following the last bit of the previous row. The start of each glyph must be byte aligned,
so the last row of a glyph may require padding. This format takes a little more time to
parse, but saves file space compared to format 1.

Format 3: (obsolete)
This format is not supported in OpenType.

Format 4: (not supported) metrics in EBLC, compressed
data
Glyph bitmap format 4 is a compressed format used by Apple in some of their East
Asian fonts. This format is not supported in OpenType.

Format 5: metrics in EBLC, bit-aligned image data only
GlyphBitmapFormat5 table

ﾉ

Type

Name

Description

uint8

imageData[variable]

Bit-aligned bitmap data

Expand table

Glyph bitmap format 5 is similar to format 2 except that no metrics information is
included, just the bit aligned data. This format is for use with EBLC indexSubTable format
2 or format 5, which will contain the metrics information for all glyphs. It works well for
Kanji fonts.
In Windows, the rasterizer recalculates sbit metrics for Format 5 bitmap data, allowing
correct ABC widths to be reported, even if the bitmaps have white space on either side
of the bitmap image. This allows fonts to store monospaced bitmap glyphs in the
efficient Format 5 without breaking calls to the GetABCWidths API.

Format 6: big metrics, byte-aligned data
GlyphBitmapFormat6 table
ﾉ

Expand table

Type

Name

Description

BigGlyphMetrics

bigMetrics

Metrics information for the glyph

uint8

imageData[variable]

Byte-aligned bitmap data

Glyph bitmap format 6 is the same as format 1 except that is uses big glyph metrics
instead of small.

Format 7: big metrics, bit-aligned data
GlyphBitmapFormat7 table
ﾉ

Expand table

Type

Name

Description

BigGlyphMetrics

bigMetrics

Metrics information for the glyph

uint8

imageData[variable]

Bit-aligned bitmap data

Glyph bitmap format 7 is the same as format 2 except that is uses big glyph metrics
instead of small.

Format 8: small metrics, component data
Format 8 allows definition of composite bitmaps using one or more component
bitmaps. See the Table structure section above for a description of the EbdtComponent
record.
GlyphBitmapFormat8 table
ﾉ

Expand table

Type

Name

Description

SmallGlyphMetrics

smallMetrics

Metrics information for the glyph

uint8

pad

Pad to 16-bit boundary

uint16

numComponents

Number of components

EbdtComponent

components[numComponents]

Array of EbdtComponent records

Format 9: big metrics, component data
Format 9 allows definition of composite bitmaps using one or more component
bitmaps. See the Table structure section above for a description of the EbdtComponent
record.
GlyphBitmapFormat9 table
ﾉ

Expand table

Type

Name

Description

BigGlyphMetrics

bigMetrics

Metrics information for the glyph

uint16

numComponents

Number of components

EbdtComponent

components[numComponents]

Array of EbdtComponent records

EBLC — Embedded Bitmap Location
Table
Article • 05/31/2024

The EBLC provides embedded bitmap locators. It is used together with the EBDT table,
which provides embedded, monochrome or grayscale bitmap glyph data, and the EBSC
table, which provided embedded bitmap scaling information.
OpenType embedded bitmaps are called “sbits” (for “scaler bitmaps”). A set of bitmaps
for a face at a given size is called a strike.
The EBLC table identifies the sizes and glyph ranges of the sbits, and has offsets to glyph
bitmap data within the EBDT table. The EBDT table then stores the glyph bitmap data,
using a number of different possible formats. Glyph metrics information may be stored
in either the EBLC or EBDT table, depending upon the formats used in each table. The
EBSC table identifies sizes that will be handled by scaling up or scaling down other sbit
sizes.

Table structure
The EBLC table begins with a header containing the table version and number of strikes.
An OpenType font may have one or more strikes embedded in the EBDT table.
EBLC Header
ﾉ

Expand table

Type

Name

Description

uint16

majorVersion

Major version of the EBLC table, = 2.

uint16

minorVersion

Minor version of the EBLC table, = 0.

uint32

numSizes

Number of BitmapSize records.

BitmapSize

bitmapSizes[numSizes]

BitmapSize records array.

Note: The first version of the EBLC table is 2.0.
Each strike is defined by one BitmapSize record.
BitmapSize record

ﾉ

Expand table

Type

Name

Description

Offset32

indexSubtableListOffset

Offset to IndexSubtableList, from beginning of
EBLC.

uint32

indexSubtableListSize

Total size in bytes of the IndexSubtableList including
its array of IndexSubtables.

uint32

numberOfIndexSubtables

Number of IndexSubtables in the IndexSubtableList.

uint32

colorRef

Not used; set to 0.

SbitLineMetrics

hori

Line metrics for text rendered horizontally.

SbitLineMetrics

vert

Line metrics for text rendered vertically.

uint16

startGlyphIndex

Lowest glyph index for this size.

uint16

endGlyphIndex

Highest glyph index for this size.

uint8

ppemX

Horizontal pixels per em.

uint8

ppemY

Vertical pixels per em.

uint8

bitDepth

bit depth: 1, 2, 4, or 8.

int8

flags

Vertical or horizontal (see Bitmap Flags, below).

The indexSubtableListOffset is the offset from the beginning of the EBLC table to an
IndexSubtableList. The indexSubtableListSize is the total size in bytes of the
IndexSubtableList data, including the array of IndexSubtables. Each strike has an
IndexSubtableList to support various formats and discontiguous ranges of bitmaps. Each
IndexSubtable provides the locations of the bitmap data for one or more glyphs within
the EBDT table, and may optionally provide glyph metrics to use for that set of glyphs.
The horizontal and vertical line metrics contain the ascender, descender, linegap, and
advance information for the strike. The line metrics format is as follows:
SbitLineMetrics record
ﾉ

Type

Name

int8

ascender

int8

descender

Expand table

uint8

widthMax

int8

caretSlopeNumerator

int8

caretSlopeDenominator

int8

caretOffset

int8

minOriginSB

int8

minAdvanceSB

int8

maxBeforeBL

int8

minAfterBL

int8

pad1

int8

pad2

The caret slope determines the angle at which the caret is drawn, and the offset is the
number of pixels (+ or -) to move the caret. This is a signed integer since we are dealing
with integer metrics. The minOriginSB, minAdvanceSB , maxBeforeBL, and minAfterBL
are described in the diagrams below. The main need for these numbers is for scalers
that may need to pre-allocate memory and/or need more metric information to position
glyphs. All of the line metrics are one byte in length. The line metrics are not used
directly by the rasterizer, but are available to applications that want to parse the EBLC
table.
The startGlyphIndex and endGlyphIndex describe the minimum and maximum glyph IDs
in the strike, but a strike does not necessarily contain bitmaps for all glyph IDs in this
range. The IndexSubtables determine which glyphs are actually present in the EBDT
table.
The ppemX and ppemY fields describe the size of the strike in pixels per Em. The ppem
measurement is equivalent to point size on a 72 dots per inch device. Typically, ppemX
will be equal to ppemY for devices with “square” pixels. To accommodate devices with
rectangular pixels, and to allow for bitmaps with other aspect ratios, ppemX and ppemY
may differ.
Bit depth
The bitDepth field of the BitmapSize record is used to specify the number of levels of
gray used in the embedded bitmaps. The following bit depths are supported:
ﾉ

Expand table

Value

Description

1

black/white

2

4 levels of gray

4

16 levels of gray

8

256 levels of gray

Bitmap flags
The flags field of the BitmapSize record uses the following flags to indicate the direction
of small glyph metrics: horizontal or vertical. The remaining bits are reserved.
Bitmap flags enumeration
ﾉ

Mask

Name

Description

0x01

HORIZONTAL_METRICS

Horizontal

0x02

VERTICAL_METRICS

Vertical

0xFC

Reserved

For future use — set to 0.

Expand table

The colorRef and bitDepth fields are reserved for future enhancements. For
monochrome bitmaps they should have the values colorRef=0 and bitDepth=1.
Associated with the image data for every glyph in a strike is a set of glyph metrics. These
glyph metrics describe bounding box height and width, as well as side bearing and
advance width information. The following figures illustrate different metric values used
for horizontal or vertical layout.

Metrics in horizontal text

Metrics in vertical text
Glyph metrics can be found in one of two places. For ranges of glyphs (not necessarily
the whole strike) whose metrics may be different for each glyph, the glyph metrics are
stored along with the glyph image data in the EBDT table. Details of how this is done are
described in the EBDT table chapter. For ranges of glyphs whose metrics are identical for
every glyph, significant space can be saved by storing a single copy of the glyph metrics
in the IndexSubTable in the EBLC.
There are also two different formats for glyph metrics: big glyph metrics and small glyph
metrics. Big glyph metrics define metrics information for both horizontal and vertical
layouts. This is important in fonts (such as Kanji) where both types of layout may be
used. Small glyph metrics define metrics information for one layout direction only.
Which direction applies, horizontal or vertical, is determined by the flags field in the
BitmapSize record.
BigGlyphMetrics record
ﾉ

Expand table

Type

Name

Description

uint8

height

Number of rows in the bitmap.

uint8

width

Number of columns in the bitmap.

int8

horiBearingX

Distance in pixels from the horizontal origin to the left edge of the bitmap.

int8

horiBearingY

Distance in pixels from the horizontal origin to the top edge of the bitmap.

uint8

horiAdvance

Horizontal advance width in pixels.

int8

vertBearingX

Distance in pixels from the vertical origin to the left edge of the bitmap.

int8

vertBearingY

Distance in pixels from the vertical origin to the top edge of the bitmap.

uint8

vertAdvance

Vertical advance width in pixels.

SmallGlyphMetrics record
ﾉ

Expand table

Type

Name

Description

uint8

height

Number of rows in the bitmap.

uint8

width

Number of columns in the bitmap.

int8

bearingX

Distance in pixels from the horizontal origin to the left edge of the bitmap (for
horizontal text); or distance in pixels from the vertical origin to the top edge of
the bitmap (for vertical text).

int8

bearingY

Distance in pixels from the horizontal origin to the top edge of the bitmap (for
horizontal text); or distance in pixels from the vertical origin to the left edge of
the bitmap (for vertical text).

uint8

advance

Horizontal or vertical advance width in pixels.

The following figure illustrates the meaning of the glyph metrics.

IndexSubtableList
The BitmapSize record for each strike contains the offset to an IndexSubtableList. This
contains records that specify a glyph ID range and an offset to an IndexSubTable for that
range. This allows a strike to contain multiple glyph ID ranges and to be represented in
multiple index formats if desirable.
IndexSubtableList table

ﾉ

Expand table

Type

Name

Description

IndexSubtableRecord

indexSubtableRecords[numberOfIndexSubtables
]

Array of
IndexSubtableRecords.

The number of IndexSubtableRecord elements is specified by the
numberOfIndexSubtables field in the BitmapSize record.
IndexSubtableRecord
ﾉ

Type

Name

Description

uint16

firstGlyphIndex

First glyph ID of this range.

uint16

lastGlyphIndex

Last glyph ID of this range (inclusive).

Offset32

indexSubtableOffset

Offset to an IndexSubtable from the start of the
IndexSubtableList.

Expand table

Records must be sorted by firstGlyphIndex, and records should not have overlapping
glyph ID ranges.
After determining the strike, the rasterizer searches this array for the range containing
the given glyph ID. When the range is found, the indexSubtableOffset provides the
location of the IndexSubtable. This can be added to the indexSubtableListOffset from
the BitmapSize record to obtain the offset of the IndexSubtable within the EBLC table.
The IndexSubtableList for the first strike is located after the bitmapSizes records array.
The IndexSubtables for that strike follow the IndexSubtableList header. Another
IndexSubtableList (if more than one strike) and its IndexSubtables are next. The EBLC
continues with an IndexSubtableList and associate IndexSubtables for each strike.

IndexSubtable formats
There are different formats for IndexSubtables. All formats begin with an
IndexSubHeader which identifies the IndexSubtable format, the format of the EBDT
image data, and the offset from the beginning of the EBDT table to the beginning of the
image data for the specified glyph range.
IndexSubHeader record

ﾉ

Type

Name

Description

uint16

indexFormat

Format of the IndexSubtable.

uint16

imageFormat

Format of EBDT image data.

Offset32

imageDataOffset

Offset to image data in EBDT table.

Expand table

There are five different formats used for the IndexSubtable, depending upon the size
and type of bitmap data used for a given glyph ID range. The choice of format that is
used should be made with the aim of minimizing the size of the font file. Ranges of
glyphs with variable metrics — that is, where glyphs may differ from each other in
bounding box height, width, side bearings or advance — require the use of formats 1, 3
or 4, which require glyph metrics information to be included along with the bitmap data
in the EBDT table. Ranges of glyphs with constant metrics can save space by using
format 2 or 5, which keep a single copy of the metrics information in the IndexSubtable
rather than a copy per glyph in the EBDT table. In some monospaced fonts it makes
sense to store extra white space around some of the glyphs to keep all metrics identical,
thus permitting the use of format 2 or 5.
Structures for each IndexSubtable format are listed below.
IndexSubtableFormat1 table
ﾉ

Expand table

Type

Name

Description

IndexSubHeader

header

Header info.

Offset32

sbitOffsets[numOffsets]

Offsets to bitmap data for each glyph in the range.

Format 1 can be used when glyphs have variable metrics. Offsets for the bitmap data are
4-byte aligned. The number of offsets required is determined from the lastGlyphIndex
and firstGlyphIndex fields in the IndexSubtableRecord. One extra entry is required to
provide the size of data for the last glyph. Thus, numOffsets = lastGlyphIndex –
firstGlyphIndex + 2.
IndexSubtableFormat2 table
ﾉ

Type

Name

Description

Expand table

IndexSubHeader

header

Header info.

uint32

imageSize

All the glyphs are of the same size.

BigGlyphMetrics

bigMetrics

All glyphs have the same metrics; glyph data may be compressed,
byte-aligned, or bit-aligned.

Format 2 can be used when glyphs have identical metrics. The bitmap data for all glyphs
will be the same size, so an array of offsets is not required.
IndexSubtableFormat3 table
ﾉ

Expand table

Type

Name

Description

IndexSubHeader

header

Header info.

Offset16

sbitOffsets[numOffsets]

Offsets to bitmap data for each glyph in the range.

Format 3 can be used when glyphs have variable metrics. Offsets for the bitmap data are
2-byte aligned. The number of offsets required is determined from the lastGlyphIndex
and firstGlyphIndex fields in the IndexSubtableRecord. One extra entry is required to
provide the size of data for the last glyph. Thus, numOffsets = lastGlyphIndex –
firstGlyphIndex + 2.
IndexSubtableFormat4 table
ﾉ

Expand table

Type

Name

Description

IndexSubHeader

header

Header info.

uint32

numGlyphs

Array length.

GlyphIdOffsetPair

glyphArray[numGlyphs + 1]

One per glyph.

Format 4 can be used when glyphs have variable metrics and when the glyph IDs are
sparse, not in a contiguous range. Format 4 uses an array of GlyphIdOffsetPair records.
One extra record is stored to represent the size of the image data for the last glyph.
GlyphIdOffsetPair record
ﾉ

Expand table

Type

Name

Description

uint16

glyphID

Glyph ID of glyph present.

Offset16

sbitOffset

Location in EBDT.

IndexSubtableFormat5 table
ﾉ

Expand table

Type

Name

Description

IndexSubHeader

header

Header info.

uint32

imageSize

All glyphs have the same data size.

BigGlyphMetrics

bigMetrics

All glyphs have the same metrics.

uint32

numGlyphs

Array length.

uint16

glyphIdArray[numGlyphs]

One per glyph, sorted by glyph ID.

Format 5 can be used when glyphs have identical metrics, but the glyph IDs are sparse,
not in a contiguous range.
The size of the EBDT image data can be calculated from the IndexSubtable information.
For the constant-metrics formats (2 and 5) the image data size is constant, and is given
in the imageSize field. For the variable metrics formats (1, 3, and 4) image data must be
stored contiguously and in glyph ID order, so the image data size may be calculated by
subtracting the offset for the current glyph from the offset of the next glyph. Because of
this, it is necessary to store one extra element in the sbitOffsets array pointing just past
the end of the range’s image data. This will allow the correct calculation of the image
data size for the last glyph in the range.
Contiguous, or nearly contiguous, ranges of glyph IDs are handled best by formats 1, 2,
and 3 which store an offset for every glyph ID in the range. Very sparse ranges of glyph
IDs should use format 4 or 5 which explicitly call out the glyph IDs represented in the
range. A small number of missing glyphs can be efficiently represented in formats 1 or 3
by having the offset for the missing glyph be followed by the same offset for the next
glyph, thus indicating a data size of zero.
The only difference between formats 1 and 3 is the size of the sbitOffsets array
elements: format 1 uses uint32s while format 3 uses uint16s. Therefore format 1 can
cover a greater range (> 64k bytes) while format 3 saves more space in the EBLC table.
Since the sbitOffsets elements are added to the imageDataOffset base address in the

IndexSubHeader, a very large set of glyph bitmap data could be addressed by splitting it
into multiple ranges, each less than 64k bytes in size, allowing the use of the more
efficient format 3.
The EBLC table specification requires 32-bit alignment for all subtables. This occurs
naturally for IndexSubTable formats 1, 2, and 4, but might not for formats 3 and 5, since
they include arrays of type uint16. When there is an odd number of elements in these
arrays it is necessary to add an extra padding element to maintain proper alignment.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

EBSC — Embedded Bitmap Scaling
Table
Article • 05/31/2024

The EBSC table provides a mechanism for describing embedded bitmaps which are
created by scaling other embedded bitmaps. While this is the sort of thing that outline
font technologies were invented to avoid, there are cases (small sizes of Kanji, for
example) where scaling a bitmap produces more legible glyphs than scan-converting an
outline. For this reason, the EBSC table allows a font to define a bitmap strike as a scaled
version of another strike.
The EBSC table is used together with the EBDT table, which provides embedded
monochrome or grayscale bitmap data, and the EBLC table, which provides embedded
bitmap locators.

Formats
The EBSC table has the following format:
EBSC table
ﾉ

Type

Name

Description

uint16

majorVersion

Major version of the EBSC table, = 2.

uint16

minorVersion

Minor version of the EBSC table, = 0.

uint32

numSizes

BitmapScale

strikes[numSizes]

Expand table

Array of BitmapScale records, one for each strike.

Note: The first version of the EBSC table is 2.0.
The numSizes field indicates the number of BitmapScale records in the array. Each strike
is defined by one BitmapScale record.
BitmapScale record
ﾉ

Expand table

Type

Name

Description

SbitLineMetrics

hori

line metrics

SbitLineMetrics

vert

line metrics

uint8

ppemX

target horizontal pixels per Em

uint8

ppemY

target vertical pixels per Em

uint8

substitutePpemX

use bitmaps of this size

uint8

substitutePpemY

use bitmaps of this size

The line metrics have the same format and meaning as those in the BitmapSize record in
the EBLC table, and refer to font wide metrics after scaling. The ppemX and ppemY
values describe the size of the font after scaling. The substitutePpemX and
substitutePpemY values describe the size of a strike that exists as an sbit in the EBLC and
EBDT, and that will be scaled up or down to generate the new strike.
Scaling in the x direction is independent of scaling in the y direction, and their scaling
values may differ. A square aspect-ratio strike could be scaled to a non-square aspect
ratio. Glyph metrics are scaled by the same factor as the pixels per Em (in the
appropriate direction), and are rounded to the nearest integer pixel.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

fpgm — Font Program
Article • 05/31/2024

This table is similar to the Control Value (CV) Program, except that it is only run once,
when the font is first used. It is used only for FDEFs and IDEFs. Thus, the CV Program
need not contain function definitions. However, the CV Program may redefine existing
FDEFs or IDEFs.
This table is optional.
ﾉ

Expand table

Type

Description

uint8[ n ]

Instructions. n is the number of uint8 items that fit in the size of the table.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

fvar — Font Variations Table
Article • 12/08/2022

OpenType Font Variations allow a font designer to incorporate multiple faces within a
font family into a single font resource. Variable fonts can provide great flexibility for
content authors and designers while also allowing the font data to be represented in an
efficient format.
A variable font allows for continuous variation along some given design axis, such as
weight:

Figure: Continuous variation along a design axis
Conceptually, variable fonts define one or more axes over which design characteristics
can vary. Weight is one possible axis of variation, but many different kinds of variation
are possible. Variable fonts are not limited to a single axis of variation, but can combine
two or more different axes of variation. For example, the following illustrates a
combination of weight and width variation:

Figure: Continuous variation along multiple design axes
The set of axes supported by a font define a variation space for that font, supporting a
potentially-vast number of design-variation instances at positions across that space.
The font variations table ('fvar') provides the global definition of variations supported
within the font. It specifies the axes of variation that are used and the ranges of variation
for each axis. It also allows the font designer to specify certain coordinate positions
within the font’s variation space as named instances. Named instances have designerprovided names, effectively equivalent to sub-family names, that applications can use as
a short list of “pre-chosen” design variants they can offer to users.
For a general introduction to OpenType Font Variations, see OpenType Font Variations
Overview.
All variable fonts must include a font variations table, as well as other required or
optional tables used in variable fonts.
Note that some of the information in the font variations table also needs to be reflected
in the style attributes (STAT) table, which is also required in all variable fonts. In
particular, each axis and each named instance specified in the font variations table must
have matching axis records and axis value tables in the style attributes table.

Table Formats
The font variations table consists of a table header, followed by an array of variation axis
records, followed by an array of named-instance records:

Figure: High-level organization of the font variations table

'fvar' Header
The format of the font variations table header is as follows.
Font variations header:
ﾉ

Expand table

Type

Name

Description

uint16

majorVersion

Major version number of the font variations table — set to 1.

uint16

minorVersion

Minor version number of the font variations table — set to 0.

Offset16

axesArrayOffset

Offset in bytes from the beginning of the table to the start of the
VariationAxisRecord array.

uint16

(reserved)

This field is permanently reserved. Set to 2.

uint16

axisCount

The number of variation axes in the font (the number of records in
the axes array).

uint16

axisSize

The size in bytes of each VariationAxisRecord — set to 20 (0x0014)
for this version.

uint16

instanceCount

The number of named instances defined in the font (the number of

records in the instances array).
uint16

instanceSize

The size in bytes of each InstanceRecord — set to either axisCount *
sizeof(Fixed) + 4, or axisCount * sizeof(Fixed) + 6.

The header is followed by axes and instances arrays. The location of the axes array is
specified in the axesArrayOffset field; the instances array directly follows the axes array.
ﾉ

Expand table

Type

Name

Description

VariationAxisRecord

axes[axisCount]

The variation axis array.

InstanceRecord

instances[instanceCount]

The named instance array.

Note: The axisSize and instanceSize fields indicate the size of the
VariationAxisRecord and InstanceRecord structures. In this version of the 'fvar' table,
the InstanceRecord structure has an optional field, and so two different size
formulations are possible. Future minor-version updates of the 'fvar' table may
define compatible extensions to either format. Implementations must use the
axisSize and instanceSize fields to determine the start of each record.
The set of axes that make up the font’s variation space are defined by an array of
variation axis records. The number of records, and the number of axes, is determined by
the axisCount field. A functional variable font must have an axisCount value that is
greater than zero. If axisCount is zero, then the font is not functional as a variable font,
and must be treated as a non-variable font; any variation-specific tables or data is
ignored.

VariationAxisRecord
The format of the variation axis record is as follows:
VariationAxisRecord
ﾉ

Type

Name

Description

Tag

axisTag

Tag identifying the design variation for the axis.

Fixed

minValue

The minimum coordinate value for the axis.

Expand table

Fixed

defaultValue

The default coordinate value for the axis.

Fixed

maxValue

The maximum coordinate value for the axis.

uint16

flags

Axis qualifiers — see details below.

uint16

axisNameID

The name ID for entries in the 'name' table that provide a display name
for this axis.

Each axis has a tag that identifies the design variation for the axis. For example, the tag
'wght' designates a weight variation. Tags are registered for commonly-used design
axes, but foundry-defined tags may also be used. Registered tags define valid ranges of
coordinate values for the axis across all fonts. The variation axis record defines minimum
and maximum values supported by the font, which may be more limited that the valid
ranges defined for a registered tag.
Note: Axis values given in the variation axis record use user scale coordinates that
are specific to each axis tag. The user scale for each registered tag is described with
the definition of each tag. In most other font tables that contain variation-related
data, axis coordinate values are expressed using normalized coordinate scales. For
more information regarding user scales and normalized scales, and a specification of
the normalization process, see the Coordinate Scales and Normalization section in
the OpenType Font Variations Overview chapter.
To be valid, axis tags must conform to general requirements for the Tag type (see Data
Types) as well as certain additional requirements. Also, the valid patterns for registered
tags and for foundry-defined tags are mutually exclusive. This is required to ensure
there is never a future conflict between foundry-defined tags in existing fonts and
newly-registered tags.
For more details on axis tags, their validity requirements, and definitions for registered
design-variation axes, see OpenType Design-Variation Axis Tag Registry.
The default value interacts with the glyph and glyph variations tables in a particular way:
the variation instance that has the default coordinate value for each axis will use glyph
outlines as defined in the glyph table, without any variations from the glyph variations
table applied. This instance is referred to as the default instance.
Flags can be assigned to indicate certain uses or behaviors for a given axis, independent
of the specific axis tag and its definition. If no flags are set, then no assumptions are to
be made beyond the definition for a registered axis. The following flags are defined.
ﾉ

Expand table

Mask

Name

Description

0x0001

HIDDEN_AXIS

The axis should not be exposed directly in user interfaces.

0xFFFE

Reserved

Reserved for future use — set to 0.

The HIDDEN_AXIS flag is provided to indicate a recommendation by the font developer
that the axis not be exposed directly to end users in application user interfaces. Reasons
for setting this flag might include that the axis is intended only for programmatic
interaction, or is intended for font-internal use by the font developer. If this flag is set,
the axis should not be exposed to users in application user interfaces except in
specialized scenarios, such as a font inspection utility. The flag should not affect
handling of named instances, which should always be exposed in text-formatting user
interfaces. If this flag is not set, then applications may expose the given axis in a default
user interface or, based on the nature of the axis, may choose to expose it in an
advanced-user interface.
The axisNameID field provides a name ID that can be used to obtain strings from the
'name' table that can be used to refer to the axis in application user interfaces. The
name ID must be greater than 255 and less than 32768. For registered axis tags, a
conventional US English axis name is provided; it is recommended that that name, or
localized derivative names, be used in application user interfaces to provide greater
consistency in user experience between different fonts.

InstanceRecord
The instance record format includes a UserTuple record that specifies a position within
the font’s variation space. The UserTuple record has an array of user scale coordinates:
UserTuple record:
ﾉ

Expand table

Type

Name

Description

Fixed

coordinates[axisCount]

Coordinate array specifying a position within the font’s variation
space.

Note: The UserTuple record and Tuple record both describe a position in the
variation space but are distinct: UserTuple uses Fixed values to represent user scale
coordinates, while the Tuple record uses F2DOT14 values to represent normalized
coordinates.

The format of the instance record is as follows.
InstanceRecord:
ﾉ

Expand table

Type

Name

Description

uint16

subfamilyNameID

The name ID for entries in the 'name' table that provide
subfamily names for this instance.

uint16

flags

Reserved for future use — set to 0.

UserTuple

coordinates

The coordinate array for this instance.

uint16

postScriptNameID

Optional. The name ID for entries in the 'name' table that
provide PostScript names for this instance.

The postScriptNameID field is optional. All of the instance records in a given font must
be the same size, with all either including or omitting the postScriptNameID field.
The subfamilyNameID field provides a name ID that can be used to obtain strings from
the 'name' table that can be treated as equivalent to name ID 17 (typographic
subfamily) strings for the given instance. Values of 2 or 17 can be used; otherwise, values
must be greater than 255 and less than 32768. The values 2 or 17 should only be used if
the named instance corresponds to the font’s default instance.
The postScriptNameID field provides a name ID that can be used to obtain strings from
the 'name' table that can be treated as equivalent to name ID 6 (PostScript name)
strings for the given instance. Values of 6 and 0xFFFF can be used; otherwise, values
must be greater than 255 and less than 32768. If the value is 0xFFFF, then the value is
ignored, and no PostScript name equivalent is provided for the instance. The value 6
should only be used if the named instance corresponds to the font’s default instance.
All of the instance records in a font should have distinct coordinates and distinct
subfamilyNameID and postScriptName ID values. If two or more records share the same
coordinates, the same nameID values or the same postScriptNameID values, then all but
the first can be ignored.
The default instance of a font is that instance for which the coordinate value of each axis
is the defaultValue specified in the corresponding variation axis record. An instance
record is not required for the default instance, though an instance record can be
provided. When enumerating named instances, the default instance should be
enumerated even if there is no corresponding instance record. If an instance record is
included for the default instance (that is, an instance record has coordinates set to

default values), then the nameID value should be set to 2 or 17 or to a name ID with the
same value as name ID 2 or 17. Also, if a postScriptNameID is included in instance
records, the value should be set to 6 or to a name ID with the same value as name ID 6.
Note: Since an instance record for the default instance is not required, a variable
font that has no instance records defined in the 'fvar' table (instanceCount is zero)
still has one named instance.

Variation Instance Selection
When formatting text using a variable font, applications must select a particular
variation instance; that is, specific, in-range values must be specified for each of the axes
defined in the font variation table. An instance may be selected by reference to a named
instanced defined in an instance record, or by using a set of arbitrary axis values for the
various axes. If a value is not specified for any particular axis, the default value for that
axis defined in the font is used. If an application specifies a value for an axis that is less
than the minValue defined in the font, then minValue must be used. Similarly, if an
application specifies a value greater than the maxValue defined in the font, then
maxValue must be used.

Example
This example is for a hypothetical font with family name “SelawikV” that has two axes of
variation, for weight and width. This table summarizes the description of the axes for the
font:
ﾉ

Expand table

Axis tag

Minimum value

Default value

Maximum value

Axis name ID

'wght'

300

400

700

256

'wdth'

62.5

100

150

257

This font also has the following named instances:

Instance

Subfamily

subfamily name

name ID

Regular

258

PostScript name

SelawikV-Regular

ﾉ

Expand table

PostScript

'wght'

'wdth'

name ID

value

value

262

400

100

Bold

259

SelawikV-Bold

263

700

100

Condensed

260

SelawikVCondensed

264

400

75

Condensed Bold

261

SelawikVCondensedBold

265

700

75

The 'fvar' table is constructed as follows:
ﾉ

Hex data

Field

Expand table

Comment

Header
0001

majorVersion

0000

minorVersion

0010

axesArrayOffset

16 bytes — combined size of fields before the axes
array.

0002

countSizePairs

2 count/size pairs: axis, instance

0002

axisCount

2 axes ('wght', 'wdth')

0014

axisSize

Size of each variation axis record is 20 bytes.

0004

instanceCount

4 named instances

000E

instanceSize

Size of instance records is 14 bytes.

First variation axis record
77676874

axisTag

Axis tag 'wght'.

012C0000

minValue

Minimum 'wght' value is 300 (Fixed format).

01900000

defaultValue

Default 'wght' value is 400.

02BC0000

maxValue

Maximum 'wght' value is 700.

0000

flags

0100

axisNameID

Display name “Weight” uses name ID 256.

Second variation axis
record
77647468

axisTag

Axis tag 'wdth'.

003E8000

minValue

Minimum 'wdth' value is 62.5 (Fixed format).

00640000

defaultValue

Default 'wdth' value is 100.

00960000

maxValue

Maximum 'wdth' value is 150.

0000

flags

0101

axisNameID

Display name “Width” uses name ID 257.

First instance record
0102

subfamilyNameID

Instance subfamily name “Regular” uses name ID 258.

0000

flags

01900000

coordinates[0]

'wght' coordinate is 400.

00640000

coordinates[1]

'wdth' coordinate is 100.

0106

postScriptNameID

Instance PostScript name “SelawikV-Regular” uses name
ID 262.

Second instance record
0103

subfamilyNameID

Instance subfamily name “Bold” uses name ID 259.

0000

flags

02BC0000

coordinates[0]

'wght' coordinate is 700.

00640000

coordinates[1]

'wdth' coordinate is 100.

0107

postScriptNameID

Instance PostScript name “SelawikV-Bold” uses name ID
263.

Third instance record
0104

subfamilyNameID

Instance subfamily name “Condensed” uses name ID
260.

0000

flags

01900000

coordinates[0]

'wght' coordinate is 400.

004B0000

coordinates[1]

'wdth' coordinate is 75.

0108

postScriptNameID

Instance PostScript name “SelawikV-Condensed” uses
name ID 264.

Fourth instance record
0105

subfamilyNameID

Instance subfamily name “Condensed Bold” uses name

ID 261.
0000

flags

02BC0000

coordinates[0]

'wght' coordinate is 700.

004B0000

coordinates[1]

'wdth' coordinate is 75.

0109

postScriptNameID

Instance PostScript name “SelawikV-CondensedBold”
uses name ID 265.

The total size of the table is 112 bytes.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

gasp — Grid-fitting and Scanconversion Procedure Table
Article • 05/31/2024

This table contains information which describes the preferred rasterization techniques
for the typeface when it is rendered on grayscale-capable devices. This table also has
some use for monochrome devices, which may use the table to turn off hinting at very
large or small sizes, to improve performance.
At very small sizes, the best appearance on grayscale devices can usually be achieved by
rendering the glyphs in grayscale without using hints. At intermediate sizes, hinting and
monochrome rendering will usually produce the best appearance. At large sizes, the
combination of hinting and grayscale rendering will typically produce the best
appearance.
If the 'gasp' table is not present in a typeface, the rasterizer may apply default rules to
decide how to render the glyphs on grayscale devices.
Two versions of the 'gasp' table have been defined: both versions use the same formats,
except that two new flags were defined in version 1, as documented below. All new
fonts and applications should use version 1.

'gasp' Table Formats
The 'gasp' table consists of a header followed by groupings of 'gasp' records.
'gasp' Header
ﾉ

Expand table

Type

Name

Description

uint16

version

Version number (0 or 1—set to 1 in new fonts)

uint16

numRanges

Number of records to follow

GaspRange

gaspRanges[numRanges]

Sorted by ppem

The array of GaspRange records provides recommended behaviors for various ppem
sizes.
GaspRange Record

ﾉ

Type

Name

Description

uint16

rangeMaxPPEM

Upper limit of range, in PPEM

uint16

rangeGaspBehavior

Flags describing desired rasterizer behavior.

Expand table

There are four RangeGaspBehavior flags defined.
RangeGaspBehavior flags
ﾉ

Expand table

Mask

Name

Description

0x0001

GASP_GRIDFIT

Use gridfitting

0x0002

GASP_DOGRAY

Use grayscale rendering

0x0004

GASP_SYMMETRIC_GRIDFIT

Use gridfitting with ClearType symmetric smoothing
Only supported in version 1

0x0008

GASP_SYMMETRIC_SMOOTHING

Use smoothing along multiple axes with ClearType®
Only supported in version 1

0xFFF0

Reserved

Reserved flags — set to 0

The set of bit flags may be extended in the future. The first two bit flags operate
independently of the following two bit flags. If font smoothing is enabled, then the first
two bit flags are used. If ClearType is enabled, then the following two bit flags are used.
The seven currently defined values of rangeGaspBehavior would have the following
uses:
ﾉ

Expand table

Flag

Value

Meaning

GASP_DOGRAY

0x0002

small sizes, typically ppem < 9

GASP_GRIDFIT

0x0001

medium sizes, typically 9 <= ppem <=
16

GASP_DOGRAY | GASP_GRIDFIT

0x0003

large sizes, typically ppem > 16

GASP_SYMMETRIC_GRIDFIT

0x0004

typically always enabled

GASP_SYMMETRIC_SMOOTHING

0x0008

larger screen sizes, typically ppem > 15,
most commonly used with the gridfit

Flag

Value

Meaning
flag.

GASP_SYMMETRIC_SMOOTHING |

0x000C

larger screen sizes, typically ppem > 15

0x0000

optional for very large sizes, typically

GASP_SYMMETRIC_GRIDFIT
(no flags)

ppem > 2048

The records in the gaspRange[] array must be sorted in order of increasing
rangeMaxPPEM value. The last record should use 0xFFFF as a sentinel value for
rangeMaxPPEM and should describe the behavior desired at all sizes larger than the
previous record’s upper limit. If the only entry in 'gasp' is the 0xFFFF sentinel value, the
behavior described will be used for all sizes.

'gasp' Table and OpenType Font Variations
In a variable font, the threshold sizes at which rasterizer behaviors are changed may
need to be adjusted for different variation instances. Variation data for adjusting the
rangeMaxPPEM value of up to ten GaspRange records can be provided in the metrics
variations (MVAR) table, referenced using value tags 'gsp0' to 'gsp9'. Note that the
rasterizer behavior for a given GaspRange record cannot be changed for different
variation instances; only the rangeMaxPPEM value can be adjusted.
The last GaspRange record in a 'gasp' table is assumed to have a rangeMaxPPEM value
of 0xFFFF (effectively infinity). The rangeMaxPPEM value of the last record is never
adjusted for different instances; the number of value records in the MVAR table that are
associated with 'gasp' entries must never be more than numRanges minus one.
For general information on OpenType Font Variations, see the chapter, OpenType Font
Variations Overview.

Sample 'gasp' table
ﾉ

Field

Value

version

0x0001

numRanges

0x0004

Font smoothing
meaning

Expand table

ClearType with symmetric smoothing
meaning

Field

Value

Font smoothing
meaning

ClearType with symmetric smoothing
meaning

rangeMaxPPEM

0x0008

ppem <= 8

ppem <= 8

rangeGaspBehavior

0x000A

grayscale only

symmetric ClearType only

rangeMaxPPEM

0x0010

9 <= ppem <= 16

9 <= ppem <= 16

rangeGaspBehavior

0x0005

gridfit only

symmetric gridfit only

rangeMaxPPEM

0x0013

17 <= ppem <= 19

17 <= ppem <= 19

rangeGaspBehavior

0x0007

gridfit and grayscale

symmetric gridfit

rangeMaxPPEM

0xFFFF

20 <= ppem

20 <= ppem

rangeGaspBehavior

0x000F

gridfit and grayscale

symmetric gridfit and symmetric
smoothing

gaspRanges[0]

gaspRanges[1]

gaspRanges[2]

gaspRanges[3]

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

GDEF — Glyph Definition Table
Article • 05/31/2024

Overview
The Glyph Definition (GDEF) table provides various glyph properties used in OpenType
Layout processing. It contains six types of information in six independent subtables:
The glyph class definition table classifies the different types of glyphs in the font.
The attachment list table identifies all attachment points on the glyphs, which
streamlines data access and bitmap caching.
The ligature caret list table contains positioning data for ligature carets, which the
text-processing client uses on screen to select and highlight the individual
components of a ligature glyph.
The mark attachment class definition table classifies mark glyphs, to help group
together marks that are positioned similarly.
The mark glyph sets table allows the enumeration of an arbitrary number of glyph
sets that can be used as an extension of the mark attachment class definition to
allow lookups to filter mark glyphs by arbitrary sets of marks.
The item variation store table is used in variable fonts to contain variation data
used for adjustment of values in the GDEF, GPOS or JSTF tables.
The GSUB, GPOS or JSTF tables may reference certain GDEF table information used for
processing of lookup tables. See, for example, the LookupFlag bit enumeration in
OpenType Layout Common Table Formats. In variable fonts, the GDEF, GPOS and JSTF
tables may all reference variation data within the item variation store table contained
within the GDEF table. See below for further discussion of variable fonts and the item
variation store table.
A client may use any one or more of the six GDEF tables during text processing. This
overview explains how each of the six tables are organized and used (see Figure 7a). The
rest of this chapter describes the individual GDEF tables and the formats that they
reference.

Figure 7a. High-level organization of GDEF table
Glyph class definition table
The glyph class definition table (GlyphClassDef) identifies four types of glyphs in a font:
base glyphs, ligature glyphs, combining mark glyphs, and glyph components (see Figure
7b). GSUB and GPOS lookups define and use these glyph classes to differentiate the
types of glyphs in a string. For example, GPOS uses the glyph classes to distinguish
between a simple base glyph and the mark glyph that follows it.

Figure 7b. A base glyph, ligature glyph, mark glyph, and glyph components
In addition, a client uses class definitions to apply GSUB and GPOS LookupFlag data
correctly. For example, a LookupFlag may specify ignoring ligatures and marks during a
glyph operation. If the font does not include a GlyphClassDef table, the client will need
to define and maintain this information when processing the GSUB and GPOS tables.
Attachment point list table
The attachment point list table (AttachList) identifies all the attachment points defined in
the GPOS table and their associated glyphs so a client can quickly access coordinates for
each glyph’s attachment points. As a result, the client can cache coordinates for
attachment points along with glyph bitmaps and avoid recalculating the attachment
points each time it displays a glyph. Without this table, processing speed would be
slower because the client would have to decode the GPOS lookups that define
attachment points and compile the points in a list.
Ligature caret list table
The ligature caret list table (LigCaretList) specifies coordinates for positioning carets
within ligatures in a font. The client uses this data to select and highlight ligature

components in displayed text (see Figure 7c).

Figure 7c. Proper ligature caret postioning
Each ligature may have more than one caret position, with each position defined as an X
or Y value on the baseline according to the writing direction of the script or language
system. The font developer can use any of three formats to represent a caret coordinate
value. One format represents values in design units only, another fine-tunes a value
based on a designated contour point, and the third uses a Device table (in non-variable
fonts only) to adjust values at specific font sizes.
In a variable font, the caret positions may need to be adjusted for different variation
instances. This is done using data in an item variation store table. See below for more
regarding variable fonts and the item variation store table.
Without a ligature caret list table, the client would have to define caret positions without
knowing the positions of the ligature components. The resulting highlighting or hittesting might be ambiguous. For example, suppose a client places a caret at the
midpoint position along the width of a hypothetical “wi” ligature. Because the “w” is
wider than the “i,” that position would not clearly indicate which component is selected.
Instead, for accurate selection, the caret should be moved to the right so that either the
“w” or “i” could be clearly highlighted.
Mark attachment class definition table
A mark attachment class definition table is used to assign mark glyphs into different
classes. These classes can be used in lookup tables within the GSUB or GPOS table to
control how mark glyphs within a glyph sequence are treated by lookups. For more
information on the use of mark attachment classes, see the description of lookup flags
in the “Lookup Table” section of the chapter, OpenType Layout Common Table Formats.
Mark glyph sets table
A mark glyph sets table (MarkGlyphSets) is used to define sets of mark glyphs that can
be used in lookup tables within the GSUB or GPOS table to control how mark glyphs
within a glyph sequence are treated by lookups. For more information on the use of
mark glyph sets, see the description of lookup flags in the “Lookup Table” section of the
chapter, OpenType Layout Common Table Formats.
Item variation store
An item variation store table (ItemVariationStore) is used in variable fonts. For general
information on OpenType Font Variations, see the chapter, OpenType Font Variations

Overview. When different variation instances are selected, the shape and metrics of
glyphs can change. When the shapes of ligature glyphs change in this way,
corresponding changes could also be required for caret X or Y positions.
Variation data for caret positions is stored in the ItemVariationStore table. This same
table, within the GDEF table, can also hold variation data used for X or Y values in the
GPOS or JSTF tables. The item variation store and constituent formats are described in
the chapter, OpenType Font Variations Common Table Formats.
The variation data within an item variation store is comprised of a number of adjustment
deltas that get applied to the default values of target items for variation instances within
particular regions of the font’s variation space. The item variation store format uses
delta-set indices to reference variation delta data for particular target, font-data items to
which they are applied. Data external to the item variation store identifies the delta-set
index to be used for each given target item. Within the GDEF, GPOS or JSTF tables, these
indices are specified within VariationIndex tables, with one VariationIndex table
referenced for each item that requires variation adjustment.
The VariationIndex table is a variant of a Device table, with a distinct format value. As a
result, variable fonts cannot use device tables. A VariationIndex table will be ignored in
applications that do not support Font Variations, or if the font is not a variable font.

GDEF table structures
GDEF Header
The GDEF table begins with a header that starts with a version number. Three versions
are defined. Version 1.0 contains offsets to glyph class definition, attachment point list,
ligature caret list and mark attachment class definition tables. Version 1.2 also includes
an offset to a mark glyph sets table. Version 1.3 also includes an offset to an item
variation store table.
Example 1 at the end of this chapter shows a GDEF Header table.
GDEF Header, version 1.0
ﾉ

Type

Name

Description

uint16

majorVersion

Major version of the GDEF table, = 1.

uint16

minorVersion

Minor version of the GDEF table, = 0.

Expand table

Offset16

glyphClassDefOffset

Offset to class definition table for glyph type, from
beginning of GDEF header (may be NULL).

Offset16

attachListOffset

Offset to attachment point list table, from beginning of
GDEF header (may be NULL).

Offset16

ligCaretListOffset

Offset to ligature caret list table, from beginning of GDEF
header (may be NULL).

Offset16

markAttachClassDefOffset

Offset to class definition table for mark attachment type,
from beginning of GDEF header (may be NULL).

GDEF Header, version 1.2
ﾉ

Expand table

Type

Name

Description

uint16

majorVersion

Major version of the GDEF table, = 1.

uint16

minorVersion

Minor version of the GDEF table, = 2.

Offset16

glyphClassDefOffset

Offset to class definition table for glyph type, from
beginning of GDEF header (may be NULL).

Offset16

attachListOffset

Offset to attachment point list table, from beginning of
GDEF header (may be NULL).

Offset16

ligCaretListOffset

Offset to ligature caret list table, from beginning of GDEF
header (may be NULL).

Offset16

markAttachClassDefOffset

Offset to class definition table for mark attachment type,
from beginning of GDEF header (may be NULL).

Offset16

markGlyphSetsDefOffset

Offset to the table of mark glyph set definitions, from
beginning of GDEF header (may be NULL).

GDEF Header, version 1.3
ﾉ

Expand table

Type

Name

Description

uint16

majorVersion

Major version of the GDEF table, = 1.

uint16

minorVersion

Minor version of the GDEF table, = 3.

Offset16

glyphClassDefOffset

Offset to class definition table for glyph type, from
beginning of GDEF header (may be NULL).

Offset16

attachListOffset

Offset to attachment point list table, from beginning of
GDEF header (may be NULL).

Offset16

ligCaretListOffset

Offset to ligature caret list table, from beginning of GDEF
header (may be NULL).

Offset16

markAttachClassDefOffset

Offset to class definition table for mark attachment type,
from beginning of GDEF header (may be NULL).

Offset16

markGlyphSetsDefOffset

Offset to the table of mark glyph set definitions, from
beginning of GDEF header (may be NULL).

Offset32

itemVarStoreOffset

Offset to the item variation store table, from beginning of
GDEF header (may be NULL).

Glyph class definition table
The GSUB and GPOS tables use the glyph class definition table (GlyphClassDef) to
identify which glyph classes to adjust with lookups. This table uses the class definition
table format (defined in the OpenType Layout Common Table Formats chapter), but with
classes assigned to indicate specific glyph types, as follows:
GlyphClassDef enumeration
ﾉ

Class

Description

1

Base glyph (single character, spacing glyph)

2

Ligature glyph (multiple character, spacing glyph)

3

Mark glyph (non-spacing combining glyph)

4

Component glyph (part of single character, spacing glyph)

Expand table

The font developer does not have to classify every glyph in the font, but any glyph not
assigned a class value falls into Class zero (0). For instance, class values might be useful
for the Arabic glyphs in a font, but not for the Latin glyphs. Then the GlyphClassDef
table will list only Arabic glyphs, and-by default-the Latin glyphs will be assigned to
Class 0. Component glyphs can be put together to generate ligatures. A ligature can be
generated by creating a glyph in the font that references the component glyphs, or
outputting the component glyphs in the desired sequence. Component glyphs are not
used in defining any GSUB or GPOS formats.

Example 2 at the end of this chapter defines a GlyphClassDef table with a sample glyph
for each of the assigned classes.

Attachment point list table
The attachment point list table (AttachList) may be used to cache attachment point
coordinates along with glyph bitmaps.
The table consists of an offset to a Coverage table listing all glyphs that define
attachment points in the GPOS table, a count of the glyphs with attachment points, and
an array of offsets to AttachPoint tables. The array lists the AttachPoint tables, one for
each glyph in the Coverage table, in the same order as the Coverage Index.
AttachList table
ﾉ

Expand table

Type

Name

Description

Offset16

coverageOffset

Offset to Coverage table, from beginning of
AttachList table.

uint16

glyphCount

Number of glyphs with attachment points.

Offset16

attachPointOffsets[glyphCount]

Array of offsets to AttachPoint tables, from
beginning of AttachList table, in Coverage Index
order.

An AttachPoint table consists of a count of the attachment points on a single glyph and
an array of contour indices of those points, listed in increasing numerical order.
Example 3 at the end of the chapter demonstrates an AttachList table that defines
attachment points for two glyphs.
AttachPoint table
ﾉ

Expand table

Type

Name

Description

uint16

pointCount

Number of attachment points on this glyph.

uint16

pointIndices[pointCount]

Array of contour point indices, in increasing numerical order.

Ligature caret list table

The ligature caret list table (LigCaretList) defines caret positions for ligature glyphs in a
font. The table consists of an offset to a Coverage table that lists all the ligature glyphs,
a count of the defined ligatures, and an array of offsets to LigGlyph tables. The array lists
the LigGlyph tables, one for each ligature in the Coverage table, in the same order as the
Coverage Index.
Example 4 at the end of this chapter shows a LigCaretList table.
LigCaretList table
ﾉ

Expand table

Type

Name

Description

Offset16

coverageOffset

Offset to Coverage table, from beginning of
LigCaretList table.

uint16

ligGlyphCount

Number of ligature glyphs.

Offset16

ligGlyphOffsets[ligGlyphCount]

Array of offsets to LigGlyph tables, from beginning of
LigCaretList table, in Coverage index order.

A ligature glyph table (LigGlyph) contains the caret coordinates for a single ligature
glyph. The number of coordinate values, each defined in a separate table, equals the
number of components in the ligature minus one.
The LigGlyph table consists of a count of the number of caret value tables defined for
the ligature and an array of offsets to caret value tables.
Example 4 at the end of the chapter shows a LigGlyph table.
LigGlyph table
ﾉ

Expand table

Type

Name

Description

uint16

caretCount

Number of caret value tables for this ligature
(components - 1).

Offset16

caretValueOffsets[caretCount]

Array of offsets to caret value tables, from beginning
of LigGlyph table, in increasing coordinate order.

Three caret value table formats are defined. One format uses design units to define the
caret position. The other two formats use a contour point or (in non-variable fonts) a
Device table to fine-tune a caret’s position at specific font sizes and device resolutions.

In a variable font, the third format uses a VariationIndex table (a variant of a Device
table) to reference variation data for adjustment of the caret position for the current
variation instance, as needed. Caret coordinates are either X or Y values, depending
upon the text direction.
The first format (CaretValueFormat1) consists of a format identifier followed by a single
coordinate for the caret position, given in design units. This format has the benefits of
small size and simplicity, but the coordinate value cannot be hinted for fine adjustments
at different device resolutions.
Example 4 at the end of this chapter shows a CaretValueFormat1 table.
CaretValueFormat1 table: Design units only
ﾉ

Type

Name

Description

uint16

format

Format identifier — format = 1.

int16

coordinate

X or Y value, in design units.

Expand table

The second format (CaretValueFormat2) specifies the caret coordinate in terms of a
contour point index on a specific glyph. During font hinting, the contour point on the
glyph outline could move. The point’s final position after hinting provides the final value
for rendering a given font size.
The table contains a format identifier and a contour point index.
Example 5 at the end of this chapter demonstrates a CaretValueFormat2 table.
CaretValueFormat2 table: Contour point
ﾉ

Type

Name

Description

uint16

format

Format identifier — format = 2.

uint16

caretValuePointIndex

Contour point index on glyph.

Expand table

The third format (CaretValueFormat3) also specifies the value in design units but, in nonvariable fonts, it uses a Device table rather than a contour point to adjust the value. This
format offers the advantage of fine-tuning the coordinate value for any device
resolution. (For more information about Device tables, see OpenType Layout Common
Table Formats.)

In variable fonts, CaretValueFormat3 is required to reference variation data to adjust
caret positions for different variation instances, if needed. In this case,
CaretValueFormat3 specifies an offset to a VariationIndex table, which is a variant of the
Device table used for variations. If no VariationIndex table is used for a particular caret
position value, then that value is used for all variation instances.
Note: While separate VariationIndex table references are required for each value that
requires variation, two or more values that require the same variation-data values
can have offsets that point to the same VariationIndex table, and two or more
VariationIndex tables can reference the same variation data entries.
The format consists of a format identifier, an X or Y value, and an offset to a Device or
VariationIndex table.
Example 6 at the end of this chapter shows a CaretValueFormat3 table.
CaretValueFormat3 table: Design units plus Device or VariationIndex table
ﾉ

Expand table

Type

Name

Description

uint16

format

Format identifier — format = 3.

int16

coordinate

X or Y value, in design units.

Offset16

deviceOffset

Offset to Device table (non-variable font) / VariationIndex table
(variable font) for X or Y value-from beginning of CaretValue table.

Mark attachment class definition table
A mark attachment class definition table is a class definition table (defined in the
OpenType Layout Common Table Formats chapter) used to assign marks into different
classes that can be used to control the effect of GSUB or GPOS lookups.
Example 7 in this document shows a mark attachment class definition table.

Mark glyph sets table
Mark glyph sets are used in GSUB and GPOS lookups to filter which marks in a glyph
sequence are considered or ignored. Mark glyph sets are defined in a MarkGlyphSets
table, which contains offsets to individual sets each represented by a standard Coverage
table.

MarkGlyphSets table
ﾉ

Expand table

Type

Name

Description

uint16

format

Format identifier — format = 1.

uint16

markGlyphSetCount

Number of mark glyph sets defined.

Offset32

coverageOffsets[markGlyphSetCount]

Array of offsets to mark glyph set coverage
tables, from the start of the MarkGlyphSets
table.

Mark glyph sets are used for the same purpose as mark attachment classes, which is as
filters for GSUB and GPOS lookups. Mark glyph sets differ from mark attachment classes,
however, in that mark glyph sets may intersect as needed by the font developer. As for
mark attachment classes, only one mark glyph set can be referenced in any given
lookup.
Note: The array of offsets for the Coverage tables uses Offset32, not Offset16.

Item variation store table
The format and processing of the ItemVariationStore table and its constituent formats is
described in the chapter, OpenType Font Variations Common Table Formats.
Specification of the interpolation algorithm used to derive values for particular variation
instances is given in the chapter, OpenType Font Variations Overview.
The item variation store contains adjustment-delta values arranged in one or more sets
of deltas that are referenced using delta-set indices. For values that require variation
adjustment, a delta-set index is used to reference the particular variation data needed
for that target value. Within the GDEF table, delta-set indices can be provided in
VariationIndex tables within caret value format 3 tables. For details on use of
VariationIndex tables within the GDEF table, see discussion earlier in this chapter.
As needed, an item variation store within the GDEF table is used to store variation data
not only for GDEF caret positions but also for values in the GPOS or JSTF tables that
vary. Delta values used for the different layout tables may be interleaved and organized
together within the one item variation store in any manner.

GDEF table examples

The rest of this chapter describes examples of all the GDEF table formats. All the
examples reflect unique parameters described below, but the samples provide a useful
reference for building tables specific to other situations.
The examples have three columns showing hex data, source, and comments.

Example 1: GDEF Header
Example 1 shows a GDEF Header definition with offsets to each of the main tables in
GDEF.
ﾉ

Hex Data

Expand table

Source

Comments

GDEFHeader
TheGDEFHeader

GDEFHeader table definition

00010000

0x00010000

major/minor version

000C

GlyphClassDefTable

offset to GlyphClassDef table

0026

AttachListTable

offset to AttachList table

0040

LigCaretListTable

offset to LigCaretList table

005A

MarkAttachClassDefTable

offset to Mark Attachment Class Definition Table

Example 2: GlyphClassDef table
The GlyphClassDef table in Example 2 specifies glyphs for each of the glyph classes
defined in the GlyphClassDef enumeration.
ﾉ

Hex Data

Expand table

Source

Comments

ClassDefFormat2
GlyphClassDefTable

ClassDef table definition

0002

2

classFormat

0004

4

classRangeCount

classRangeRecords[0]
0024

iGlyphID

startGlyphID

0024

iGlyphID

endGlyphID

0001

1

class: base glyphs

classRangeRecords[1]
009F

ffiLigGlyphID

startGlyphID

009F

ffiLigGlyphID

endGlyphID

0002

2

class: ligature glyphs

classRangeRecords[2]
0058

umlautAccentGlyphID

startGlyphID

0058

umlautAccentGlyphID

endGlyphID

0003

3

class: mark glyphs

classRangeRecords[3]
018F

CurvedTailComponentGlyphID

startGlyphID

018F

CurvedTailComponentGlyphID

endGlyphID

0004

4

class: component glyphs

Example 3: AttachList table
In Example 3, the AttachList table enumerates the attachment points defined for two
glyphs. A Coverage table identifies the glyphs: “a” and “e.” For each covered glyph, an
AttachPoint table specifies the attachment point count and point indices: one point for
the “a” glyph and two for the “e” glyph.
ﾉ

Hex Data

Source

Comments

AttachList

AttachList table definition

AttachListTable
0012

GlyphCoverage

offset to Coverage table

0002

2

glyphCount

0008

aAttachPoint

attachPointOffsets[0]

000C

eAttachPoint

attachPointOffsets[1]

Expand table

AttachPoint

AttachPoint table definition

aAttachPoint
0001

1

pointCount

0012

18

pointIndices[0]

AttachPoint
eAttachPoint

AttachPoint table definition

0002

2

pointCount

000E

14

pointIndices[0]

0017

23

pointIndices[1]

CoverageFormat1

Coverage table definition

GlyphCoverage
0001

1

coverageFormat

0002

2

glyphCount

001C

aGlyphID

glyphArray[0]

0020

eGlyphID

glyphArray[1]

Example 4: LigCaretList, LigGlyph and CaretValueFormat1
tables
Example 4 defines a list of ligature carets. A Coverage table lists all the ligature glyphs
that define caret positions. In this example, two ligatures are covered, “ffi” and “fi.” For
each covered glyph, a LigGlyph table specifies the number of carets for the ligature and
their coordinate values. The “fi” ligature defines one caret, positioned between the “f”
and “i” components; the “ffi” ligature defines two, one positioned between the two “f”
components and the other positioned between the “f” and “i.” The caret value tables
shown here use format 1, in which values are specified in design units only.
ﾉ

Hex Data

Source

Comments

LigCaretList

LigCaretList table definition

LigCaretListTable
0008

LigCoverage

offset to Coverage table

0002

2

ligGlyphCount

Expand table

0010

fiLigGlyph

ligGlyphOffsets[0]

0014

ffiLigGlyph

ligGlyphOffsets[1]

CoverageFormat1
LigCoverage

Coverage table definition

0001

1

coverageFormat

0002

2

glyphCount

009F

ffiLigGlyphID

glyphArray[0]

00A5

fiLigGlyphID

glyphArray[1]

LigGlyph

LigGlyph table definition

fiLigGlyph
0001

1

caretCount, equals the number of components - 1

000E

CaretFI

caretValueOffsets[0]

LigGlyph

LigGlyph table definition

ffiLigGlyph
0002

2

caretCount, equals the number of components - 1

0006

CaretFFI1

caretValueOffsets[0]

000E

CaretFFI2

caretValueOffsets[1]

CaretValueFormat1

CaretValue table definition

CaretFI
0001

1

format: design units only

025B

603

coordinate (X or Y value)

CaretValueFormat1

CaretValue table definition

CaretFFI1
0001

1

format: design units only

025B

603

coordinate (X or Y value)

CaretValueFormat1

CaretValue table definition

CaretFFI2
0001

1

format: design units only

04B6

1206

coordinate (X or Y value)

Example 5: CaretValueFormat2 table
Example 5 shows a CaretValueFormat2 table that specifies a ligature caret coordinate in
terms of a contour point index on a specific glyph. The final position of the caret
depends on the location of the contour point on the glyph after hinting.
ﾉ

Hex Data

Source

Comments

CaretValueFormat2
Caret1

CaretValue table definition

0002

2

format: contour point

000D

13

caretValuePointIndex

Expand table

Example 6: CaretValueFormat3 table
In Example 6, the CaretValueFormat3 table defines a caret position in design units, but
includes a Device table to adjust the X or Y coordinate for the point size and resolution
of the output font. Here, the Device table specifies pixel adjustments for font sizes from
12 ppem to 17 ppem.
ﾉ

Hex Data

Source

Comments

CaretValueFormat3

CaretValue table definition

Expand table

Caret3
0003

3

format: design units plus Device table

04B6

1206

coordinate (X or Y value, design units)

0006

CaretDevice

offset to Device table

DeviceTableFormat2
CaretDevice

Device Table definition

000C

12

startSize

0011

17

endSize

0002

2

deltaFormat

1

increase 12ppm by 1 pixel

1111

2200

1

increase 13ppm by 1 pixel

1

increase 14ppm by 1 pixel

1

increase 15ppm by 1 pixel

2

increase 16ppm by 2 pixels

2

increase 17ppm by 2 pixels

Example 7: Mark attachment class definition table
In Example 7, a class definition table specifies an attachment class for the each of the
glyph ranges predefined in the GlyphClassDef table as marks.
ﾉ

Hex Data

Expand table

Source

Comments

ClassDefFormat2
theMarkAttachClassDefTable

ClassDef table definition

0002

2

classFormat: glyph ranges

0004

4

classRangeCount

classRangeRecords[0]
0268

graveAccentGlyphID

startGlyphID

026A

circumflexAccentGlyphID

endGlyphID

0001

1

class: top marks
ClassRangeRecord[1]

classRangeRecords[1]
0270

diaeresisAccentGlyphID

startGlyphID

0272

acuteAccentGlyphID

endGlyphID

0001

1

class: top marks

classRangeRecords[2]
028C

diaeresisBelowGlyphID

startGlyphID

028F

cedillaGlyphID

endGlyphID

0002

2

class: bottom marks

ClassRangeRecord[3]
classRangeRecords[3]
0295

circumflexBelowGlyphID

startGlyphID

0295

circumflexBelowGlyphID

endGlyphID

0002

2

class: bottom marks

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

glyf — Glyph Data
Article • 05/31/2024

This table contains information that describes the glyphs in the font in the TrueType
outline format. Information regarding the rasterizer (scaler) refers to the TrueType
rasterizer. For details regarding scaling, grid-fitting and rasterization of TrueType
outlines, see the TrueType Fundamentals chapter.

Table organization
The 'glyf' table is comprised of a list of glyph data blocks, each of which provides the
description for a single glyph. Glyphs are referenced by identifiers (glyph IDs), which are
sequential integers beginning at zero. The total number of glyphs is specified by the
numGlyphs field in the 'maxp' table. The 'glyf' table does not include any overall table
header or records providing offsets to glyph data blocks. Rather, the 'loca' table
provides an array of offsets, indexed by glyph IDs, which provide the location of each
glyph data block within the 'glyf' table. Note that the 'glyf' table must always be used in
conjunction with the 'loca' and 'maxp' tables. The size of each glyph data block is
inferred from the difference between two consecutive offsets in the 'loca' table (with
one extra offset provided to give the size of the last glyph data block). As a result of the
'loca' format, glyph data blocks within the 'glyf' table must be in glyph ID order.
Each glyph description uses one of two formats:
Simple glyph descriptions specify a glyph outline directly using Bezier control
points.
Composite glyph descriptions specify a glyph outline indirectly by referencing one
or more glyph IDs to use as components.
In both cases, the glyph description begins with a glyph header that is common to both
types of glyph description.

Glyph headers
Each glyph description begins with a header:
Glyph Header
ﾉ

Expand table

Type

Name

Description

int16

numberOfContours

If the number of contours is greater than or equal to zero, this is a
simple glyph. If negative, this is a composite glyph — the value -1
should be used for composite glyphs.

int16

xMin

Minimum x for coordinate data.

int16

yMin

Minimum y for coordinate data.

int16

xMax

Maximum x for coordinate data.

int16

yMax

Maximum y for coordinate data.

The bounding rectangle from each glyph is defined as the rectangle with a lower left
corner of (xMin, yMin) and an upper right corner of (xMax, yMax). These values are
obtained directly from the point coordinate data for the glyph, comparing all on-curve
and off-curve points. Phantom points computed by the rasterizer are not relevant. Note
that the bounding box defined by control points is guaranteed to contain the outline,
but might not be tight to the outline.
The scaler will perform better if the glyph coordinates have been created such that the
xMin is equal to the lsb. For example, if the lsb is 123, then xMin for the glyph should be
123. If the lsb is -12 then the xMin should be -12. If the lsb is 0 then xMin is 0. If all
glyphs are done like this, set bit 1 of flags field in the 'head' table.
Note: The glyph descriptions do not include side bearing information. Left side
bearings are provided in the 'hmtx' table, and right side bearings are inferred from
the advance width (also provided in the 'hmtx' table) and the bounding box
coordinates provided in the 'glyf' table. For vertical layout, top side bearings are
provided in the 'vmtx' table, and bottom side bearings are inferred. The rasterizer
will generate a representation of side bearings in the form of “phantom” points,
which are added as four additional points at the end of the glyph description, and
which can be referenced and manipulated by glyph instructions. See the chapter
Instructing TrueType Glyphs for more background on phantom points.
In a variable font, the minimum and maximum x or y values of control points can vary,
and a tight bounding rectangle containing the outline or all points for an instance could
be smaller or larger than for the default instance (that is, for the glyph description in this
table). The xMin, yMin, xMax and yMax values might or might not encompass the
derived outline for an instance. Also, the 'gvar' table does not provide deltas for these
values. If an application requires a bounding rectangle for a non-default instance of a
glyph, the derived point data (with deltas applied) should be processed to determine a
bounding rectangle.

Simple glyph description
This is the information used to describe a glyph if numberOfContours is greater than or
equal to zero—that is, if a glyph is not a composite.
If a glyph has zero contours, no additional glyph data beyond the header is required. A
glyph with zero contours may have additional data, however; in particular, it may have
instructions that operate on phantom points.
Point numbers are base-zero indices numbered sequentially across all of the contours
for a glyph. The first point of the first contour has point number zero; the first point
number of each additional contour is one greater than the last point number of the
preceding contour. Phantom point numbers follow after the last point number of the
last contour.
Simple Glyph table
ﾉ

Expand table

Type

Name

Description

uint16

endPtsOfContours[numberOfContours]

Array of point indices for the last point of
each contour, in increasing numeric order.

uint16

instructionLength

Total number of bytes for instructions. If
instructionLength is zero, no instructions are
present for this glyph, and this field is
followed directly by the flags field.

uint8

instructions[instructionLength]

Array of instruction byte code for the glyph.

uint8

flags[variable]

Array of flag elements. See below for details
regarding the number of flag array elements.

uint8
or

xCoordinates[variable]

int16

uint8
or
int16

Contour point x-coordinates. See below for
details regarding the number of coordinate
array elements. Coordinate for the first point
is relative to (0,0); others are relative to
previous point.

yCoordinates[variable]

Contour point y-coordinates. See below for
details regarding the number of coordinate
array elements. Coordinate for the first point
is relative to (0,0); others are relative to
previous point.

Note: In the 'glyf' table, the position of a point is not stored in absolute terms but as
a vector relative to the previous point. The delta-x and delta-y vectors represent
these (often small) changes in position. Coordinate values are in font design units,
as defined by the unitsPerEm field in the 'head' table. Note that smaller unitsPerEm
values will make it more likely that delta-x and delta-y values can fit in a smaller
representation (8-bit rather than 16-bit), though with a trade-off in the level or
precision that can be used for describing an outline.
Each element in the flags array is a single byte, each of which has multiple flag bits with
distinct meanings, as shown below.
In logical terms, there is one flag byte element, one x-coordinate, and one y-coordinate
for each point. The number of points is determined by the last entry in the
endPtsOfContours array. Note, however, that the flag byte elements and the coordinate
arrays use packed representations. In particular, if a logical sequence of flag elements or
sequence of x- or y-coordinates is repeated, then the actual flag byte element or
coordinate value can be given in a single entry, with special flags used to indicate that
this value is repeated for subsequent logical entries. The actual stored size of the flags
or coordinate arrays must be determined by parsing the flags array entries. See the flag
descriptions below for details.
Simple Glyph flags
ﾉ

Expand table

Mask

Name

Description

0x01

ON_CURVE_POINT

Bit 0: If set, the point is on the curve;
otherwise, it is off the curve.

0x02

X_SHORT_VECTOR

Bit 1: If set, the corresponding x-coordinate
is 1 byte long, and the sign is determined
by the
X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR
flag. If not set, its interpretation depends on
the
X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR
flag: If that other flag is set, the xcoordinate is the same as the previous xcoordinate, and no element is added to the
xCoordinates array. If both flags are not set,
the corresponding element in the
xCoordinates array is two bytes and
interpreted as a signed integer. See the
description of the

Mask

Name

Description
X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR
flag for additional information.

0x04

Y_SHORT_VECTOR

Bit 2: If set, the corresponding y-coordinate
is 1 byte long, and the sign is determined
by the
Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR
flag. If not set, its interpretation depends on
the
Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR
flag: If that other flag is set, the ycoordinate is the same as the previous ycoordinate, and no element is added to the
yCoordinates array. If both flags are not set,
the corresponding element in the
yCoordinates array is two bytes and
interpreted as a signed integer. See the
description of the
Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR
flag for additional information.

0x08

REPEAT_FLAG

Bit 3: If set, the next byte (read as unsigned)
specifies the number of additional times
this flag byte is to be repeated in the logical
flags array — that is, the number of
additional logical flag entries inserted after
this entry. (In the expanded logical array,
this bit is ignored.) In this way, the number
of flags listed can be smaller than the
number of points in the glyph description.

0x10

X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR

Bit 4: This flag has two meanings,
depending on how the X_SHORT_VECTOR
flag is set. If X_SHORT_VECTOR is set, this
bit describes the sign of the value, with 1
equaling positive and 0 negative. If
X_SHORT_VECTOR is not set and this bit is
set, then the current x-coordinate is the
same as the previous x-coordinate. If
X_SHORT_VECTOR is not set and this bit is
also not set, the current x-coordinate is a
signed 16-bit delta vector.

0x20

Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR

Bit 5: This flag has two meanings,
depending on how the Y_SHORT_VECTOR
flag is set. If Y_SHORT_VECTOR is set, this
bit describes the sign of the value, with 1
equaling positive and 0 negative. If

Mask

Name

Description
Y_SHORT_VECTOR is not set and this bit is
set, then the current y-coordinate is the
same as the previous y-coordinate. If
Y_SHORT_VECTOR is not set and this bit is
also not set, the current y-coordinate is a
signed 16-bit delta vector.

0x40

OVERLAP_SIMPLE

Bit 6: If set, contours in the glyph
description could overlap. Use of this flag is
not required — that is, contours may
overlap without having this flag set. When
used, it must be set on the first flag byte for
the glyph. See additional details below.

0x80

Reserved

Bit 7 is reserved: set to zero.

The OVERLAP_SIMPLE flag is not required and ignored by some rasterizer
implementations. However, it may be (and is) used by some rasterizers to activate
additional logic required when contours overlap to obtain correct rasterization. This flag
can be used in fonts to provide broad interoperability across rasterizer implementations.
Variable fonts often make use of overlapping contours. This has implications for tools
that generate static-font data for a specific instance of a variable font, if broad
interoperability of the derived font is desired: if a glyph has overlapping contours in the
given instance, then the tool should either set the OVERLAP_SIMPLE flag in the derived
glyph data, or else should merge contours to remove overlap of separate contours.
Note: The OVERLAP_COMPOUND flag, described below, has a similar purpose in
relation to composite glyphs. The same considerations described for the
OVERLAP_SIMPLE flag also apply to the OVERLAP_COMPOUND flag.

Composite glyph description
If numberOfContours is negative, a composite glyph description is used.
Note: A numberOfContours value of -1 is recommended to indicate a composite
glyph.
A composite, or compound, glyph describes an outline indirectly by referencing other
glyphs that get incorporated into the composite glyph as components. This is useful
when the same contours are needed for multiple glyphs as it provides consistency for

contours that are repeated across multiple glyphs and can also provide significant size
reduction.
To add clarity in explaining composite glyphs, the terms parent and child will be used, a
composite glyph description being the parent, and the other glyphs referenced as
components being the children.
Composite glyphs may be nested within other composite glyphs—that is, a composite
glyph parent may include other composite glyphs as child components. Thus, a
composite glyph description is a directed graph. This graph must be acyclic, with every
path through the graph leading to a simple glyph as a leaf node. The
maxComponentDepth field in the 'maxp' table is set to indicate the maximum nesting
depth across all composite glyphs in a font. There is no minimum nesting depth that
must be supported. For fonts to be compatible with the widest range of
implementations, nesting of composites should be avoided.
Note: Some PostScript devices (and possibly other implementations) do not
correctly render glyphs that have nested composite descriptions. A composite glyph
description that has nested composites can be flattened to reference only simple
glyphs as child components. This can lose some benefits of de-duplication of
information, but can still retain significant size-saving benefits as well as providing
broader compatibility.
The data for a composite glyph description is comprised of a sequence of data blocks
for each child component glyph. A flag within the data for each component is used to
indicate if there are additional components in the sequence. The sequence is processed
in the order given, with the contours from each child glyph incorporated into the parent.
As the contours from a child are incorporated, its control points are renumbered to
follow sequentially after all points previously incorporated into the parent.
Each glyph has an outline positioned within the font design grid based on the x and y
coordinates of its control points. When incorporated as a child into a composite glyph,
the parent can control placement of the child outline within the parent’s design grid.
This can be done in two different ways: by specifying a vector offset added to (x, y)
coordinates of the child’s control points, or by specifying one control point from the
child’s outline that is aligned with a specified control point in the parent. The second
mechanism assumes some outlines have already been incorporated into the parent, so
cannot be used for the first component glyph.
The parent can also specify a scale or other affine transform to be applied to a child
glyph as it is incorporated into the parent. The transform can affect an offset vector
used to position the child glyph; see below for additional details.

Each component glyph can include instructions that apply to its outline. A parent
composite glyph description can include instructions that apply to the composite as a
whole, after instructions for each child have been performed. Instructions for the parent
composite apply to the accumulated contour data from components with points
renumbered, as described above.
Before each child is incorporated into the parent, it is processed, with phantom points
defined and hinting instructions performed. Thus, if placement of the child is done by
alignment of points, the child’s phantom points can be used for this alignment, and
instructions in child glyphs that affected their points will already have been performed.
The data block for each child component starts with two uint16 values: a flags field, and
a glyph ID. These are followed by two argument fields, though the size and
interpretation of the arguments varies according to the flags that are set. Optional fields
describing a transformation can follow the arguments, depending on the flags.
Component Glyph record
ﾉ

Expand table

Type

Name

Description

uint16

flags

component flag

uint16

glyphIndex

glyph index of component

uint8, int8, uint16

argument1

x-offset for component or point number; type depends on

or int16
uint8, int8, uint16
or int16
[transform data]

bits 0 and 1 in component flags
argument2

y-offset for component or point number; type depends on
bits 0 and 1 in component flags
optional transform data—see below

The C pseudo-code fragment below shows how the sequence of component glyph
records is stored and parsed; definitions for the flag bits follow this fragment:

do {
uint16 flags;
uint16 glyphIndex;
if ( flags & ARG_1_AND_2_ARE_WORDS) {
(int16 or FWORD) argument1;
(int16 or FWORD) argument2;
} else {
uint16 arg1and2; /* (arg1 << 8) | arg2 */
}

if ( flags & WE_HAVE_A_SCALE ) {
F2DOT14 scale;
/* Format 2.14 */
} else if ( flags & WE_HAVE_AN_X_AND_Y_SCALE ) {
F2DOT14 xscale;
/* Format 2.14 */
F2DOT14 yscale;
/* Format 2.14 */
} else if ( flags & WE_HAVE_A_TWO_BY_TWO ) {
F2DOT14 xscale;
/* Format 2.14 */
F2DOT14 scale01;
/* Format 2.14 */
F2DOT14 scale10;
/* Format 2.14 */
F2DOT14 yscale;
/* Format 2.14 */
}
} while ( flags & MORE_COMPONENTS )
if (flags & WE_HAVE_INSTRUCTIONS){
uint16 numInstr
uint8 instr[numInstr]
}

The following component glyph flags are defined:
Component Glyph flags
ﾉ

Expand table

Mask

Name

Description

0x0001

ARG_1_AND_2_ARE_WORDS

Bit 0: If this is set, the arguments are 16-bit (uint16
or int16); otherwise, they are bytes (uint8 or int8).

0x0002

ARGS_ARE_XY_VALUES

Bit 1: If this is set, the arguments are signed xy
values; otherwise, they are unsigned point
numbers.

0x0004

ROUND_XY_TO_GRID

Bit 2: If set and ARGS_ARE_XY_VALUES is also set,
the xy values are rounded to the nearest grid line.
Ignored if ARGS_ARE_XY_VALUES is not set.

0x0008

WE_HAVE_A_SCALE

Bit 3: This indicates that there is a simple scale for
the component. Otherwise, scale = 1.0.

0x0020

MORE_COMPONENTS

Bit 5: Indicates at least one more glyph after this
one.

0x0040

WE_HAVE_AN_X_AND_Y_SCALE

Bit 6: The x direction will use a different scale from
the y direction.

0x0080

WE_HAVE_A_TWO_BY_TWO

Bit 7: There is a 2 by 2 transformation that will be
used to scale the component.

0x0100

WE_HAVE_INSTRUCTIONS

Bit 8: Following the last component are instructions
for the composite glyph.

Mask

Name

Description

0x0200

USE_MY_METRICS

Bit 9: If set, this forces the aw and lsb (and rsb) for
the composite to be equal to those from this
component glyph. This works for hinted and
unhinted glyphs.

0x0400

OVERLAP_COMPOUND

Bit 10: If set, the components of the compound
glyph overlap. Use of this flag is not required —
that is, component glyphs may overlap without
having this flag set. When used, it must be set on
the flag word for the first component. Some
rasterizer implementations may require fonts to
use this flag to obtain correct behavior — see
additional remarks, above, for the similar
OVERLAP_SIMPLE flag used in simple-glyph
descriptions.

0x0800

SCALED_COMPONENT_OFFSET

Bit 11: The composite is designed to have the
component offset scaled. Ignored if
ARGS_ARE_XY_VALUES is not set.

0x1000

UNSCALED_COMPONENT_OFFSET

Bit 12: The composite is designed not to have the
component offset scaled. Ignored if
ARGS_ARE_XY_VALUES is not set.

0xE010

Reserved

Bits 4, 13, 14 and 15 are reserved: set to 0.

The argument1 and argument2 fields of the component glyph record are used to
determine the placement of the child component glyph within the parent composite
glyph. They are interpreted either as an offset vector or as points from the parent and
the child, according to whether the ARGS_ARE_XY_VALUES flag is set. This flag must
always be set for the first component of a composite glyph.
If ARGS_ARE_XY_VALUES is set, then argument1 and argument2 are interpreted as units
in the design coordinate system and an offset vector (x, y) = (argument1, argument2) is
added to the coordinates of each control point of the component glyph. In a variable
font, the offset vector can be modified by deltas in the 'gvar' table; see Point numbers
and processing for composite glyphs in the 'gvar' chapter for details. If a scale or
transform matrix is provided, the offset vector might or might not be subject to the
transformation; see the discussion below of the SCALED_COMPONENT_OFFSET and
UNSCALED_COMPONENT_OFFSET flags for details.
If ARGS_ARE_XY_VALUES is set and the ROUND_XY_TO_GRID flag is also set, the offset
vector (after any transformation and variation deltas are applied) is grid-fitted, with the x
and y values rounded to the nearest pixel grid line.

If ARGS_ARE_XY_VALUES is not set, then argument1 is a point number in the parent
glyph (from contours incoporated and re-numbered from previous component glyphs);
and argument2 is a point number (prior to re-numbering) from the child component
glyph. Phantom points from the parent or the child may be referenced. The child
component glyph is positioned within the parent glyph by aligning the two points. If a
scale or transform matrix is provided, the transformation is applied to the child’s point
before the points are aligned.
In a variable font, when a component is positioned by alignment of points, deltas are
applied to component glyphs before this alignment is done. Any deltas specified for the
parent composite glyph to be applied to components positioned by point alignment are
ignored. See Point numbers and processing for composite glyphs in the 'gvar' chapter
for details.
The WE_HAVE_A_SCALE, WE_HAVE_AN_X_AND_Y_SCALE and WE_HAVE_A_TWO_BY_TWO
flags are mutually exclusive: no more than one of these may be set. If
WE_HAVE_A_SCALE is set, one additional F2DOT14 value is appended to the component
glyph data; if WE_HAVE_AN_X_AND_Y_SCALE is set, two F2DOT14 values are appended;
if WE_HAVE_A_TWO_BY_TWO, four F2DOT14 values are appended. The appended values
define an affine transformation, as described below. The child component glyph is
transformed as it is incorporated into the parent composite glyph, prior to grid-fitting of
the parent. The transform can affect an offset vector used to position the child; see
discussion below of the SCALED_COMPONENT_OFFSET and
UNSCALED_COMPONENT_OFFSET flags for details.
For defining the affine transformation, the general case is handled by the
WE_HAVE_A_TWO_BY_TWO flag. Four values are appended in the component glyph
description: in order, xscale, scale01, scale10, and yscale. These form a two-by-two matrix
used to transform x and y coordinates of points in the component glyph. For a pretransformation position (x, y), the post-transformation position (x′, y′) is calculated as
follows:
x′ = xscale * x + scale10 * y
y′ = scale01 * x + yscale * y
Note: It can be helpful to understand a matrix transformation by the effect on x and
y basis vectors î = (1, 0) and ĵ = (0, 1). The transform described by the four values
maps the basis vectors to î′ = (xscale, scale01) and ĵ′ = (scale10, yscale).
When the WE_HAVE_AN_X_AND_Y_SCALE flag is used, the appended xscale and yscale
values are used as above, but the transformation is constrained by scale01 and scale10
both being set to zero. When the WE_HAVE_A_SCALE flag is used, the transformation is

even further constrained by xscale and yscale both being set to the single appended
value, scale.
The WE_HAVE_INSTRUCTIONS flag is used to indicate that the parent composite glyph
has instructions, in addition to instructions for any of the child component glyphs. If the
flag is set on any component glyph, then a uint16 value is read immediately after the
last component glyph to get the byte length for instructions.
The purpose of USE_MY_METRICS is to force the lsb and rsb to take on values obtained
from the component glyph. For example, an i-circumflex (U+00EF) is often composed of
the circumflex and a dotless-i. In order to force the composite to have the same metrics
as the dotless-i, set USE_MY_METRICS for the dotless-i component of the composite.
Without this bit, the rsb and lsb would be calculated from the 'hmtx' entry for the
composite (or would need to be explicitly set with TrueType instructions).
Note that the behavior of the USE_MY_METRICS operation is undefined for rotated
component glyphs.
The SCALED_COMPONENT_OFFSET and UNSCALED_COMPONENT_OFFSET flags are
used to determine how x and y offset values are to be interpreted when the component
glyph is scaled. If the SCALED_COMPONENT_OFFSET flag is set, then the x and y offset
values are deemed to be in the component glyph’s coordinate system, and the scale
transformation is applied to both values. If the UNSCALED_COMPONENT_OFFSET flag is
set, then the x and y offset values are deemed to be in the current glyph’s coordinate
system, and the scale transformation is not applied to either value. If neither flag is set,
then the rasterizer may apply a default behavior. On Microsoft and Apple platforms, the
default behavior is the same as when the UNSCALED_COMPONENT_OFFSET flag is set;
this behavior is recommended for all rasterizer implementations. If a font has both flags
set, this is invalid; the rasterizer should use its default behavior for this case.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

GPOS — Glyph Positioning Table
Article • 05/29/2024

Overview
The Glyph Positioning table (GPOS) provides precise control over glyph placement for
sophisticated text layout and rendering in each script and language system that a font
supports.
Complex glyph positioning becomes an issue in many writing systems, such as
Vietnamese, that use diacritical and other marks to modify the sound or meaning of
characters. These writing systems require controlled placement of all marks in relation to
one another for legibility and linguistic accuracy.

Figure 4a. Vietnamese words with marks.
Other writing systems require sophisticated glyph positioning for correct typographic
composition. For instance, Urdu glyphs are calligraphic and connect to one another
along a descending, diagonal text line that proceeds from right to left. To properly
render Urdu, a text-processing client must modify both the horizontal (X) and vertical (Y)
positions of each glyph (see Figure 4b).

Figure 4b. Urdu layout requires glyph positioning control, as well as contextual
substitution
With the GPOS table, a font developer can define a complete set of positioning
adjustment features. GPOS data, organized by script and language system, is easy for a
text-processing client to use to position glyphs.
Basic glyph positioning
Basic text layout implementations that do not make use of the GPOS table rely on two
values to determine a glyph’s position: placement, and advance. If glyphs are positioned
with respect to a virtual “pen point” that moves along a line of text, placement describes
the glyph’s position with respect to the current pen point, and advance describes where
to move the pen point to position the next glyph (see Figure 4c). For horizontal text,
placement corresponds to the left side bearing, and advance corresponds to the
advance width.

Figure 4c. Basic glyph positioning
Apart from the GPOS tables, other font tables specify placement and advance only in
the X direction for horizontal layout and only in the Y direction for vertical layout. For
simple layout of some writing systems, these two values could provide for adequate
glyph positioning. For more sophisticated layout, however, the values need to cover a
richer range. Placement and advance may need adjustment vertically, as well as
horizontally.
The only positioning adjustment defined in other font tables is pair kerning, supported
by the legacy 'kern' table, which modifies the horizontal spacing between two glyphs. A
typical kerning table lists pairs of glyphs and specifies how much space a textprocessing client should add or remove between the glyphs to properly display each
pair. It does not provide specific information about how to adjust the glyphs in each pair
and cannot adjust contexts of more than two glyphs.
Advanced glyph positioning
The GPOS table provides excellent control and flexibility for positioning a single glyph
and for positioning multiple glyphs in relation to one another. By using both X and Y
values that the GPOS table defines for placement and advance and by using glyph
attachment points, a client can more precisely adjust the position of a glyph.
In addition, the GPOS table can reference a Device table to define subtle, devicedependent adjustments to any placement or advance value at any font size and device
resolution. For example, a Device table can specify adjustments at 51 pixels per em
(ppem) that do not occur at 50 ppem.
X and Y values specified for placement operations are always within the typical Cartesian
coordinate system (origin at the baseline of the left side), regardless of the writing
direction. Additionally, all values specified are done so in font unit measurements. This is
especially convenient for font designers, since glyphs are drawn in the same coordinate
system. However, it’s important to note that the meaning of “advance width” changes,
depending on the writing direction.

For example, in left-to-right scripts, if the first glyph has an advance width of 100, then
the second glyph begins at 100,0. In right-to-left scripts, if the first glyph has an advance
width of 100, then the second glyph begins at -100,0. For a top-to-bottom feature, to
increase the advance height of a glyph by 100, the YAdvance = 100. For any feature,
regardless of writing direction, to lower the dieresis over an “o” by 10 units, set the
YPlacement = -10.
Other GPOS features can define attachment points to combine glyphs and position
them with respect to one another. A glyph might have multiple attachment points. The
point used will depend on the glyph to be attached. For instance, a base glyph could
have attachment points for different diacritical marks.

Figure 4d. Base glyph with multiple attachment points.
To reduce the size of the font file, a base glyph may use the same attachment point for
all mark glyphs assigned to a particular class. For example, a base glyph could have two
attachment points, one above and one below the glyph. Then all marks that attach
above glyphs would be attached at the high point, and all marks that attach below
glyphs would be attached at the low point. Attachment points are useful in scripts such
as Arabic that combine numerous glyphs with vowel marks.
Attachment points also are useful for connecting cursive-style glyphs. Glyphs in cursive
fonts can be designed to attach or overlap when rendered. Alternatively, the font
developer can use the GPOS table to create a cursive attachment feature and define
explicit exit and entry attachment points for each glyph (see Figure 4e).

Figure 4e. Entry and exit points marked on contextual Urdu glyph variants
The GPOS table supports eight types of actions for positioning and attaching glyphs:
A single adjustment positions one glyph, such as a superscript or subscript.
A pair adjustment positions two glyphs with respect to one another. Kerning is an
example of pair adjustment.
A cursive attachment describes cursive scripts and other glyphs that are connected
with attachment points when rendered.
A mark-to-base attachment positions combining marks with respect to base
glyphs, as when positioning vowels, diacritical marks, or tone marks in Arabic,
Hebrew, and Vietnamese.
A mark-to-ligature attachment positions combining marks with respect to ligature
glyphs. Because ligatures may have multiple points for attaching marks, the font
developer needs to associate each mark with one of the ligature glyph’s
components.
A mark-to-mark attachment positions one mark relative to another, as when
positioning tone marks with respect to vowel diacritical marks in Vietnamese.
Contextual positioning describes how to position one or more glyphs in context,
within an identifiable sequence of specific glyphs, glyph classes, or varied sets of
glyphs. One or more positioning operations may be performed on “input” context
sequences. Figure 4f illustrates a context for positioning adjustments.
Chained contexts positioning describes how to position one or more glyphs in a
chained context, within an identifiable sequence of specific glyphs, glyph classes,
or varied sets of glyphs. One or more positioning operations may be performed on
“input” context sequences.

Figure 4f. Contextual positioning lowered the accent over a vowel glyph that followed
an overhanging uppercase glyph
The GPOS data formats used to implement the different types of positioning and
attaching actions include a ninth type, positioning extension. This provides a format
extension mechanism, allowing reference to subtables using 32-bit offsets rather than
16-bit offsets. It does not provide an additional type of positioning action, however.

GPOS table and OpenType Font Variations

OpenType Font Variations allow a single font to support many design variations along
one or more axes of design variation. For example, a font with weight and width
variations might support weights from thin to black, and widths from ultra-condensed
to ultra-expanded. For general information on OpenType Font Variations, see the
chapter, OpenType Font Variations Overview.
When different variation instances are selected, the design of individual glyphs changes.
The same contours and points are used, but the position in the design grid of each
point can change, as can the default horizontal or vertical advance and side bearings. As
a result, corresponding changes may also be required for positioning and advance
adjustments in the GPOS table.
Positioning actions in the GPOS table can be expressed directly using explicit X or Y
font-unit values. In a variable font, these X and Y values apply to the default instance
and may need to be adjusted for the current variation instance. This is done using
variation data with processes similar to those used for glyph outlines and other font
data, as described in the OpenType Font Variations Overview chapter.
For certain GPOS actions, positions can be expressed indirectly by reference to specific
glyph outline points. In a variable font, use of glyph points to specify a positioning
action would require invoking the rasterizer to process the glyph-outline variation data
in order to obtain the adjusted position of the point before the glyph positioning
operation can be completed. This could have a significant, negative impact on
performance of text-layout processing. For this reason, in a variable font, positions that
require adjustment for different variation instances should always be expressed directly
as X and Y values.
Variation data for adjustment of GPOS X or Y values is stored within an
ItemVariationStore table located within the GDEF table. The same item variation store is
also used for adjustment of values in the GDEF and JSTF tables. The item variation store
and constituent formats are described in the chapter, OpenType Font Variations
Common Table Formats.
The variation data within an item variation store is comprised of a number of adjustment
deltas that get applied to the default values of target items for variation instances within
particular regions of the font’s variation space. The item variation store format uses
delta-set indices to reference variation delta data for particular target, font-data items to
which they are applied. Data external to the item variation store identifies the delta-set
index to be used for each given target item. Within the GPOS table, these indices are
specified within VariationIndex tables, with one VariationIndex table referenced for each
item that requires variation adjustment.

Note that the VariationIndex table is a variant of a Device table, with a distinct format
value. (For full details on the Device and VariationIndex table formats, see the chapter,
OpenType Layout Common Table Formats.) As a result, variable fonts cannot use device
tables. A VariationIndex table will be ignored in applications that do not support Font
Variations, or if the font is not a variable font.

GPOS table organization
The GPOS table begins with a header that defines offsets to a ScriptList, a FeatureList, a
LookupList, and an optional FeatureVariations table (see Figure 4g):
The ScriptList identifies all the scripts and language systems in the font that use
glyph positioning.
The FeatureList defines all the glyph positioning features required to render these
scripts and language systems.
The LookupList contains all the lookup data needed to implement each glyph
positioning feature.
The FeatureVariations table can be used to substitute an alternate set of lookup
tables to use for any given feature under specified conditions. This is currently
used only in variable fonts.
For a detailed discussion of ScriptLists, FeatureLists, LookupLists, and FeatureVariation
tables, see the chapter, OpenType Layout Common Table Formats .

Figure 4g. High-level organization of GPOS table
The GPOS table is organized so text processing clients can easily locate the features and
lookups that apply to a particular script or language system. To access GPOS
information, clients should use the following procedure:
1. Locate the current script in the GPOS ScriptList table.
2. If the language system is known, search the script for the correct LangSys table;
otherwise, use the script’s default LangSys table.
3. The LangSys table provides index numbers into the GPOS FeatureList table to
access a required feature and a number of additional features.
4. Inspect the featureTag of each feature, and select the feature tables to apply to an
input glyph string.

5. If a Feature Variation table is present, evaluate conditions in the Feature Variation
table to determine if any of the initially-selected feature tables should be
substituted by an alternate feature table.
6. Each feature table provides an array of index numbers into the GPOS LookupList
table. Assemble all lookups from the set of chosen feature tables, and apply the
lookups in the order given in the LookupList table.
For a detailed description of the Feature Variation table and how it is processed, see the
chapter, OpenType Layout Common Table Formats.
Lookup data is defined in Lookup tables, which are defined in the OpenType Layout
Common Table Formats chapter. A Lookup table contains one or more subtables that
define the specific conditions, type, and results of a positioning action used to
implement a feature. Specific Lookup subtable types are used for glyph positioning
actions, and are defined in this chapter. All subtables within a Lookup table must be of
the same lookup type, as listed in the following table for the GposLookupType
enumeration:
GposLookupType enumeration
ﾉ

Expand table

Value

Type

Description

1

Single adjustment

Adjust position of a single glyph

2

Pair adjustment

Adjust position of a pair of glyphs

3

Cursive attachment

Attach cursive glyphs

4

Mark-to-base attachment

Attach a combining mark to a base glyph

5

Mark-to-ligature attachment

Attach a combining mark to a ligature

6

Mark-to-mark attachment

Attach a combining mark to another mark

7

Contextual positioning

Position one or more glyphs in context

8

Chained contexts positioning

Position one or more glyphs in chained context

9

Positioning extension

Extension mechanism for other positionings

Each lookup type has one or more subtable formats. The “best” format depends on the
type of positioning operation and the resulting storage efficiency. When glyph
information is best presented in more than one format, a single lookup may define more
than one subtable, as long as all the subtables are of the same lookup type. For

example, within a given lookup, a glyph index array format could best represent one set
of target glyphs, whereas a glyph index range format could be better for another set.
Certain structures are used across multiple GPOS lookup subtable types and formats. All
lookup subtables use the Coverage table, which is defined in the OpenType Layout
Common Table Formats chapter. Single and pair adjustments (lookup types 1 and 2) use
a ValueRecord structure and associated ValueFormat enumeration; attachment subtables
(lookup types 3, 4, 5 and 6) use Anchor and MarkArray tables. These shared formats are
defined later in this chapter.
A series of positioning operations on the same glyph or string requires multiple lookups,
one for each separate action. Each lookup has a different array index in the LookupList
table and is applied in the LookupList order. The positioning adjustment of each lookup
is applied to the result of previous lookups. When the adjustments are expressed as
absolute placement or advance adjustments in the X or Y direction, these adjustments
are accumulated as each lookup is processed. For adjustments expressed using
attachment points, however, attachment point positioning can override the effect of
preceding lookups.
During text processing, a client applies a lookup to each glyph in the string before
moving to the next lookup. A lookup is finished for a glyph after the client locates the
target glyph or glyph context and performs a positioning action, if specified. To move to
the “next” glyph, the client will skip all the glyphs that participated in the lookup
operation: glyphs that were positioned as well as any other glyphs that formed an input
sequence context for the operation. Only glyphs in the input sequence are skipped; in
the case of chained contexts positioning, the glyphs in the lookahead sequence are not
skipped.
There is just one exception: the “next” glyph in a sequence may be one of those that
formed a context for the operation just performed. Specifically, in the case of pair
positioning operations (i.e., kerning), if the ValueRecord for the second glyph is null, that
glyph is treated as the “next” glyph in the sequence.
The next section of this chapter describes the GPOS header and the subtables defined
for each GposLookupType. Examples at the end of this chapter illustrate the GPOS
header and seven of the nine lookup types, as well as the ValueRecord and Anchor and
MarkArray tables.

GPOS table structures
GPOS Header

The GPOS table begins with a header that contains a version number for the table. Two
versions are defined. Version 1.0 contains offsets to three tables: ScriptList, FeatureList,
and LookupList. Version 1.1 also includes an offset to a FeatureVariations table. For
descriptions of these tables, see the chapter, OpenType Layout Common Table Formats .
Example 1 at the end of this chapter shows a GPOS Header version 1.0 table definition.
GPOS Header, version 1.0
ﾉ

Expand table

Type

Name

Description

uint16

majorVersion

Major version of the GPOS table, = 1.

uint16

minorVersion

Minor version of the GPOS table, = 0.

Offset16

scriptListOffset

Offset to ScriptList table, from beginning of GPOS table.

Offset16

featureListOffset

Offset to FeatureList table, from beginning of GPOS table.

Offset16

lookupListOffset

Offset to LookupList table, from beginning of GPOS table.

GPOS Header, version 1.1
ﾉ

Expand table

Type

Name

Description

uint16

majorVersion

Major version of the GPOS table, = 1.

uint16

minorVersion

Minor version of the GPOS table, = 1.

Offset16

scriptListOffset

Offset to ScriptList table, from beginning of GPOS table.

Offset16

featureListOffset

Offset to FeatureList table, from beginning of GPOS table.

Offset16

lookupListOffset

Offset to LookupList table, from beginning of GPOS table.

Offset32

featureVariationsOffset

Offset to FeatureVariations table, from beginning of GPOS
table (may be NULL).

Lookup type 1 subtable: single adjustment positioning
A single adjustment positioning subtable (SinglePos) is used to adjust the placement or
advance of a single glyph, such as a subscript or superscript. In addition, a SinglePos
subtable is commonly used to implement lookup data for contextual positioning.

A SinglePos subtable will have one of two formats: one that applies the same
adjustment to a series of glyphs (format 1), and one that applies a different adjustment
for each unique glyph (format 2).
Single adjustment positioning format 1: single positioning value
A SinglePosFormat1 subtable applies the same positioning value or values to each glyph
listed in its Coverage table. For instance, when a font uses old-style numerals, this
format could be applied to uniformly lower the position of all math operator glyphs.
The format 1 subtable consists of a format identifier, an offset to a Coverage table that
defines the glyphs to be adjusted by the positioning values, a ValueRecord, and a
ValueFormat identifier that describes the amount and kinds of data in the ValueRecord.
The ValueRecord specifies one or more positioning values to be applied to all covered
glyphs. For example, if all glyphs in the Coverage table require both horizontal and
vertical adjustments, the ValueRecord will specify values for both xPlacement and
yPlacement.
Example 2 at the end of this chapter shows a SinglePosFormat1 subtable used to adjust
the placement of subscript glyphs.
SinglePosFormat1 subtable
ﾉ

Expand table

Type

Name

Description

uint16

format

Format identifier — format = 1.

Offset16

coverageOffset

Offset to Coverage table, from beginning of SinglePos subtable.

uint16

valueFormat

Defines the types of data in the ValueRecord.

ValueRecord

valueRecord

Defines positioning value(s) — applied to all glyphs in the
Coverage table.

Single adjustment positioning format 2: array of positioning values
A SinglePosFormat2 subtable provides an array of ValueRecords that contains one
positioning value for each glyph in the Coverage table. This format is more flexible than
format 1, but it requires more space in the font file.
For example, assume that the Cyrillic script will be used in left-justified text. For all
glyphs, format 2 could define position adjustments for left side bearings to align the left
edges of the paragraphs. To achieve this, the Coverage table would list every glyph in

the script, and the SinglePosFormat2 subtable would define a ValueRecord for each
covered glyph. Correspondingly, each ValueRecord would specify an xPlacement
adjustment value for the left side bearing.
Note: A single ValueFormat applies to all ValueRecords defined in a SinglePos
subtable. In this example, if xPlacement is the only value that a ValueRecord needs
to optically align the glyphs, then the X_PLACEMENT flag will be the only flag set in
the valueFormat field of the subtable.
As in format 1, the format 2 subtable consists of a format identifier, an offset to a
Coverage table that defines the glyphs to be adjusted by the positioning values, and the
ValueFormat flags field that describes the amount and kinds of data in the ValueRecords.
In addition, the format 2 subtable includes:
A count of the ValueRecords. One ValueRecord is defined for each glyph in the
Coverage table.
An array of ValueRecords that specify positioning values. Because the array follows
the Coverage Index order, the first ValueRecord applies to the first glyph listed in
the Coverage table, and so on.
Example 3 at the end of this chapter shows how to adjust the spacing of three dash
glyphs with a SinglePosFormat2 subtable.
SinglePosFormat2 subtable
ﾉ

Expand table

Type

Name

Description

uint16

format

Format identifier — format = 2.

Offset16

coverageOffset

Offset to Coverage table, from beginning of SinglePos
subtable.

uint16

valueFormat

Defines the types of data in the ValueRecords.

uint16

valueCount

Number of ValueRecords — must equal glyphCount in
the Coverage table.

ValueRecord

valueRecords[valueCount]

Array of ValueRecords — positioning values applied to
glyphs.

Lookup type 2 subtable: pair adjustment positioning

A pair adjustment positioning subtable (PairPos) is used to adjust the placement or
advances of two glyphs in relation to one another — for instance, to specify kerning
data for pairs of glyphs. Compared to a typical kerning table, however, a PairPos
subtable offers more flexibility and precise control over glyph positioning. The PairPos
subtable can adjust each glyph in a pair independently in both the X and Y directions,
and it can explicitly describe the particular type of adjustment applied to each glyph.
PairPos subtables can be either of two formats: one that identifies glyphs individually by
index (format 1), and one that identifies glyphs by class (format 2).
Pair adjustment positioning format 1: adjustments for glyph pairs
Format 1 uses glyph indices to access positioning data for one or more specific pairs of
glyphs. All pairs are specified in the order determined by the layout direction of the text.
Note: For text written from right to left, the right-most glyph will be the first glyph in
a pair; conversely, for text written from left to right, the left-most glyph will be first.
A PairPosFormat1 subtable contains a format identifier and two ValueFormat fields:
valueFormat1 applies to the ValueRecords for the first glyph in each pair. The
single ValueFormat field applies to ValueRecords for all first glyphs. If valueFormat1
is set to zero (0), the corresponding glyph has no ValueRecord and, therefore,
should not be repositioned.
valueFormat2 applies to the ValueRecords for the second glyph in each pair. The
single ValueFormat field applies to ValueRecords for all second glyphs. If
valueFormat2 is set to 0, then the second glyph of the pair is the “next” glyph for
which a lookup should be performed.
A PairPos subtable also defines an offset to a Coverage table that lists the indices of the
first glyphs in each pair. More than one pair can have the same first glyph, but the
Coverage table will list that glyph only once.
The subtable also contains an array of offsets to PairSet tables (pairSetOffsets) and a
count of the defined tables. The pairSetOffsets array contains one offset for each glyph
listed in the Coverage table and uses the same order as the Coverage Index.
PairPosFormat1 subtable
ﾉ

Type

Name

Description

uint16

format

Format identifier — format = 1.

Expand table

Offset16

coverageOffset

Offset to Coverage table, from beginning of PairPos
subtable.

uint16

valueFormat1

Defines the types of data in valueRecord1 — for the
first glyph in the pair (may be zero).

uint16

valueFormat2

Defines the types of data in valueRecord2 — for the
second glyph in the pair (may be zero).

uint16

pairSetCount

Number of PairSet tables.

Offset16

pairSetOffsets[pairSetCount]

Array of offsets to PairSet tables. Offsets are from
beginning of PairPos subtable, ordered by Coverage
Index.

A PairSet table enumerates all the glyph pairs that begin with a covered glyph. An array
of PairValue records contains one record for each pair and lists the records sorted by the
glyph ID of the second glyph in each pair. The pairValueCount field specifies the number
of PairValue records in the set.
PairSet table
ﾉ

Expand table

Type

Name

Description

uint16

pairValueCount

Number of PairValue records.

PairValue

pairValueRecords[pairValueCount]

Array of PairValue records, ordered by glyph ID of
the second glyph.

A PairValue record specifies the second glyph in a pair and defines a ValueRecord for
each glyph (valueRecord1 and valueRecord2). If valueFormat1 in the PairPos subtable is
set to zero (0), valueRecord1 will be empty; similarly, if valueFormat2 is 0, valueRecord2
will be empty.
Example 4 at the end of this chapter shows a PairPosFormat1 subtable that defines two
cases of pair kerning.
PairValue record
ﾉ

Expand table

Type

Name

Description

uint16

secondGlyph

Glyph ID of second glyph in the pair (first glyph is listed in the
Coverage table).

ValueRecord

valueRecord1

Positioning data for the first glyph in the pair.

ValueRecord

valueRecord2

Positioning data for the second glyph in the pair.

Pair adjustment positioning format 2: class pair adjustment
Format 2 defines a pair as a set of two glyph classes and modifies the positions of all the
glyphs in a class. For example, this format is useful in Japanese scripts that apply specific
kerning operations to all glyph pairs that contain punctuation glyphs. One class would
be defined as all glyphs that may be coupled with punctuation marks, and the other
classes would be groups of similar punctuation glyphs.
In a PairPosFormat2 subtable, glyph classes are defined using a Class Definition table,
defined in the OpenType Layout Common Table Formats chapter.
The PairPosFormat2 subtable begins with a format identifier and an offset to a Coverage
table, measured from the beginning of the PairPos subtable. The Coverage table lists the
indices of the first glyphs that may appear in each glyph pair. More than one pair may
begin with the same glyph, but the Coverage table lists the glyph index only once.
A PairPosFormat2 subtable also includes two ValueFormat fields:
valueFormat1 applies to the ValueRecords for the first glyph in each pair. The
single ValueFormat field applies to ValueRecords for all first glyphs. If valueFormat1
is set to zero (0), then the ValueRecords for the first glyph will be empty and,
therefore, the first glyph is not repositioned.
valueFormat2 applies to the ValueRecords for the second glyph in each pair. The
single ValueFormat field applies to ValueRecords for all second glyphs. If
valueFormat2 is set to 0, then the ValueRecords for the second glyph of the pair
will be empty, the second glyph is not repositioned, and it becomes the “next”
glyph for which a lookup is performed.
PairPosFormat2 requires that each glyph in all pairs be assigned to a class, which is
identified by an integer called a class value. Pairs are then represented in a twodimensional array as sequences of two class values. Multiple pairs can be represented in
one format 2 subtable.
A PairPosFormat2 subtable contains offsets to two class definition tables: one that
assigns class values to all the first glyphs in all pairs (classDef1), and one that assigns
class values to all the second glyphs in all pairs (classDef2). If both glyphs in a pair use
the same class definition, the offset value can be the same for classDef1 as for classDef2,
but they are not required to be the same. The subtable also specifies the number of
glyph classes defined in classDef1 and in classDef2, including class 0.

For each class identified in the classDef1 table, a Class1 record enumerates all pairs that
contain a particular class as a first component. The class1Records array stores all Class1
records according to class value.
Note: Class1 records are not tagged with a class value identifier. Instead, the index
value of a Class1 record in the array defines the class value represented by the
record. For example, the first Class1 record enumerates pairs that begin with a class
0 glyph, the second Class1 record enumerates pairs that begin with a class 1 glyph,
and so on.
PairPosFormat2 subtable
ﾉ

Expand table

Type

Name

Description

uint16

format

Format identifier — format = 2.

Offset16

coverageOffset

Offset to Coverage table, from beginning of PairPos
subtable.

uint16

valueFormat1

ValueRecord definition — for the first glyph of the pair
(may be zero).

uint16

valueFormat2

ValueRecord definition — for the second glyph of the
pair (may be zero).

Offset16

classDef1Offset

Offset to ClassDef table, from beginning of PairPos
subtable — for the first glyph of the pair.

Offset16

classDef2Offset

Offset to ClassDef table, from beginning of PairPos
subtable — for the second glyph of the pair.

uint16

class1Count

Number of classes in classDef1 table — includes class 0.

uint16

class2Count

Number of classes in classDef2 table — includes class 0.

Class1

class1Records[class1Count]

Array of Class1 records, ordered by classes in classDef1.

Each Class1 record contains an array of Class2 records, which also are ordered by class
value. One Class2 record must be declared for each class in the classDef2 table,
including class 0.
Class1 record
ﾉ

Expand table

Type

Name

Description

Class2

class2Records[class2Count]

Array of Class2 records, ordered by classes in classDef2.

A Class2 record consists of two ValueRecords, one for the first glyph in a class pair
(valueRecord1) and one for the second glyph (valueRecord2). Note that both fields of a
Class2 record are optional: If the PairPos subtable has a value of zero (0) for
valueFormat1 or valueFormat2, then the corresponding record (valueRecord1 or
valueRecord2) will be empty — that is, not present. For example, if valueFormat1 is zero,
then the Class2 record will begin with and consist solely of valueRecord2. The textprocessing client must be aware of the variable nature of the Class2 record and use the
valueFormat1 and valueFormat2 fields to determine the size and content of the Class2
record.
Example 5 at the end of this chapter demonstrates pair kerning with glyph classes in a
PairPosFormat2 subtable.
Class2 record
ﾉ

Expand table

Type

Name

Description

ValueRecord

valueRecord1

Positioning for first glyph — empty if valueFormat1 = 0.

ValueRecord

valueRecord2

Positioning for second glyph — empty if valueFormat2 = 0.

Lookup type 3 subtable: cursive attachment positioning
Some cursive fonts are designed so that adjacent glyphs join when rendered with their
default positioning. However, if positioning adjustments are needed to join the glyphs, a
cursive attachment positioning (CursivePos) subtable can describe how to connect the
glyphs by aligning two anchor points: the designated exit point of a glyph, and the
designated entry point of the following glyph.
Anchor alignment can result in horizontal or vertical positioning adjustments, or both.
Note that the positioning effects in the text-layout direction (horizontal, for horizontal
layout) work differently than for the cross-stream direction (vertical, in horizontal layout):
For adjustments in the line-layout direction, the layout engine adjusts the advance
of the first glyph (in logical order). This effectively moves the second glyph relative
to the first so that the anchors are aligned in that direction.

For the cross-stream direction, placement of one glyph is adjusted to make the
anchors align. Which glyph is adjusted is determined by the RIGHT_TO_LEFT flag in
the parent lookup table: if the RIGHT_TO_LEFT flag is clear, the second glyph is
adjusted to align anchors with the first glyph; if the RIGHT_TO_LEFT flag is set, the
first glyph is adjusted to align anchors with the second glyph.
Note that, if the RIGHT_TO_LEFT lookup flag is set, then the last glyph in the connected
sequence keeps its initial position in the cross-stream direction relative to the baseline,
and the cross-stream positions of the preceding, connected glyphs are adjusted.
The subtable has one format: CursivePosFormat1.
Cursive attachment positioning format 1
The CursivePosFormat1 subtable begins with a format identifier and an offset to a
Coverage table, which lists all the glyphs that define cursive attachment data. In
addition, the subtable contains an array of EntryExit records: one for each glyph listed in
the Coverage table, sorted in Coverage index order.
CursivePosFormat1 subtable
ﾉ

Expand table

Type

Name

Description

uint16

format

Format identifier — format = 1.

Offset16

coverageOffset

Offset to Coverage table, from beginning of
CursivePos subtable.

uint16

entryExitCount

Number of EntryExit records.

EntryExit

entryExitRecords[entryExitCount]

Array of EntryExit records, in Coverage index order.

Each EntryExit record consists of two offsets: one to an Anchor table that identifies the
entry point on the glyph, and an offset to an Anchor table that identifies the exit point
on the glyph. See later in this chapter for a description of the Anchor table.
To position glyphs using the CursivePosFormat1 subtable, a text-processing client aligns
the exit anchor point of a glyph with the entry anchor point of the following glyph. If no
corresponding anchor point exists, the offset for either the entry or exit Anchor table
may be NULL, in which case no positioning adjustment is applied.
At the end of this chapter, Example 6 describes cursive glyph attachment in the Urdu
language.

EntryExit record
ﾉ

Expand table

Type

Name

Description

Offset16

entryAnchorOffset

Offset to entryAnchor table, from beginning of CursivePos
subtable (may be NULL).

Offset16

exitAnchorOffset

Offset to exitAnchor table, from beginning of CursivePos subtable
(may be NULL).

Lookup type 4 subtable: mark-to-base attachment
positioning
The mark-to-base attachment (MarkBasePos) subtable is used to position combining
mark glyphs with respect to base glyphs. For example, the Arabic, Hebrew, and Thai
scripts combine vowels, diacritical marks, and tone marks with base glyphs.
In the MarkBasePos subtable, every mark glyph has an anchor point and is also assigned
to a mark class. Each base glyph then defines an anchor point for each class of marks it
uses. When a mark is combined with a given base, the mark placement is adjusted so
that the mark anchor is aligned with the base anchor for the applicable mark class.
Placement of the base glyph and advances of both glyphs are not affected.
For example, assume two mark classes: all marks positioned above base glyphs (class 0),
and all marks positioned below base glyphs (class 1). In this case, each base glyph that
uses these marks would define two anchor points, one for attaching the mark glyphs
listed in class 0, and one for attaching the mark glyphs listed in class 1.
To identify the base glyph that combines with a mark, the text-processing client must
look backward in the glyph string from the mark to the preceding base glyph. To
combine the mark and base glyph, the client aligns their attachment points, positioning
the mark with respect to the final pen point (advance) position of the base glyph.
A mark class is identified by a specific integer. Within the MarkBasePos subtable, the
anchor definition of each mark, and the assignment of each mark to a mark class, is
provided using a MarkArray table in combination with a mark Coverage table. First, a
mark Coverage table specifies all of the mark glyphs covered by the subtable. Then, for
every mark in the Coverage table, the MarkArray table has a corresponding MarkRecord
that defines the anchor and class assignment for the mark. The MarkArray table and
MarkRecord are defined later in this chapter.

The MarkToBase Attachment subtable has one format: MarkBasePosFormat1.
Mark-to-base attachment positioning format 1
The MarkBasePosFormat1 subtable begins with a format identifier and offsets to two
Coverage tables: one that lists all the mark glyphs referenced in the subtable, and one
that lists all the base glyphs referenced in the subtable.
The MarkBasePosFormat1 subtable also contains an offset to a MarkArray table. For
each mark glyph in the mark Coverage table, a MarkRecord in the MarkArray table
specifies its class and an offset to the Anchor table that describes the mark’s attachment
point. The classCount field specifies the total number of distinct mark classes defined in
all the MarkRecords.
The MarkBasePosFormat1 subtable also contains an offset to a BaseArray table, which
defines for each base glyph an array of anchors, one for each mark class.
MarkBasePosFormat1 subtable
ﾉ

Expand table

Type

Name

Description

uint16

format

Format identifier — format = 1.

Offset16

markCoverageOffset

Offset to markCoverage table, from beginning of MarkBasePos
subtable.

Offset16

baseCoverageOffset

Offset to baseCoverage table, from beginning of MarkBasePos
subtable.

uint16

markClassCount

Number of classes defined for marks.

Offset16

markArrayOffset

Offset to MarkArray table, from beginning of MarkBasePos
subtable.

Offset16

baseArrayOffset

Offset to BaseArray table, from beginning of MarkBasePos
subtable.

The BaseArray table consists of an array of BaseRecords. The array stores the
BaseRecords in the same order as the baseCoverage index. Each base glyph in the
baseCoverage table has a BaseRecord.
BaseArray table
ﾉ

Expand table

Type

Name

Description

uint16

baseCount

Number of BaseRecords.

BaseRecord

baseRecords[baseCount]

Array of BaseRecords, in order of baseCoverage Index.

A BaseRecord declares one Anchor table for each mark class (including class 0) identified
in the MarkRecords of the MarkArray table. Each Anchor table specifies one attachment
point used to attach all the marks in a particular class to the base glyph. A BaseRecord
contains an array of offsets to Anchor tables. The zero-based array of offsets defines the
entire set of attachment points each base glyph uses to attach marks. The offsets to
Anchor tables are ordered by mark class.
Note: Anchor tables are not tagged with class value identifiers. Instead, the index
value of an Anchor table in the array defines the class value represented by the
Anchor table.
Example 7 at the end of this chapter defines mark positioning above and below base
glyphs with a MarkBasePosFormat1 subtable.
BaseRecord
ﾉ

Expand table

Type

Name

Description

Offset16

baseAnchorOffsets[markClassCount]

Array of offsets (one per mark class) to Anchor
tables. Offsets are from beginning of BaseArray
table, ordered by class (offsets may be NULL).

Lookup type 5 subtable: mark-to-ligature attachment
positioning
The mark-to-ligature attachment (MarkLigPos) subtable is used to position combining
mark glyphs with respect to ligature base glyphs. With mark-to-base attachment,
described previously, each base glyph has an attachment point defined for each class of
marks. Mark-to-ligature attachment is similar, except that each ligature glyph is defined
to have multiple components (in a virtual sense — not actual glyphs), and each
component has a separate set of attachment points defined for the different mark
classes.
As a result, a ligature glyph may have multiple base attachment points for one class of
marks. For a given mark assigned to a particular class, the appropriate base attachment

point is determined by which ligature component the mark is associated with. This is
dependent on the original character string and subsequent character- or glyphsequence processing, not the font data alone. While a text-layout client is performing
any character-based preprocessing or any glyph-substitution operations using the GSUB
table, the text-layout client must keep track of associations of marks to particular
ligature-glyph components.
The MarkLigPos subtable can be used to define multiple mark-to-ligature attachments.
In the subtable, every mark glyph has an anchor point and is associated with a class of
marks. As with MarkToBase attachment, mark anchors and class assignments are defined
using a MarkArray table in combination with a mark Coverage table. Every ligature glyph
specifies a two-dimensional array of data: for each component in a ligature, an array of
anchor points is defined, one for each class of marks.
For example, assume two mark classes: all marks positioned above base glyphs (class 0),
and all marks positioned below base glyphs (class 1). In this case, each component of a
base ligature glyph may define two anchor points, one for attaching the mark glyphs
listed in class 0, and one for attaching the mark glyphs listed in class 1. Alternatively, if
the language system does not allow marks on the second component, the first ligature
component may define two anchor points, one for each class of marks, and the second
ligature component may define no anchor points.
To position a combining mark using a MarkLigPos subtable, the text-processing client
must work backward from the mark to the preceding ligature glyph. To correctly access
the subtables, the client must keep track of the component associated with the mark.
Aligning the attachment points combines the mark and ligature.
As with mark-to-base attachment, when a mark is combined with a given ligature base,
the mark placement is adjusted so that the mark anchor is aligned with the applicable
base anchor. Placement of the base glyph and advances of both glyphs are not affected.
The MarkToLigature attachment subtable has one format: MarkLigPosFormat1.
Mark-to-ligature attachment positioning format 1
The MarkLigPosFormat1 subtable begins with a format identifier and two offsets to
Coverage tables that list all the mark glyphs and ligature glyphs referenced in the
subtable.
The MarkLigPosFormat1 subtable also contains an offset to a MarkArray table. For each
mark glyph in the mark Coverage table, a MarkRecord in the MarkArray table specifies
its class and an offset to the Anchor table that describes the mark’s attachment point.
The markClassCount field specifies the total number of distinct mark classes defined in
all the MarkRecords.

The MarkLigPosFormat1 subtable also contains an offset to a LigatureArray table, which
defines for each ligature glyph the two-dimensional array of anchor data: one anchor
per ligature component per mark class.
MarkLigPosFormat1 subtable
ﾉ

Expand table

Type

Name

Description

uint16

format

Format identifier — format = 1.

Offset16

markCoverageOffset

Offset to markCoverage table, from beginning of MarkLigPos
subtable.

Offset16

ligatureCoverageOffset

Offset to ligatureCoverage table, from beginning of
MarkLigPos subtable.

uint16

markClassCount

Number of defined mark classes.

Offset16

markArrayOffset

Offset to MarkArray table, from beginning of MarkLigPos
subtable.

Offset16

ligatureArrayOffset

Offset to LigatureArray table, from beginning of MarkLigPos
subtable.

The LigatureArray table contains an array of offsets to LigatureAttach tables. The
ligatureAttachOffsets array lists the offsets to LigatureAttach tables, one for each
ligature glyph listed in the ligatureCoverage table, in the same order as the
ligatureCoverage index.
LigatureArray table
ﾉ

Expand table

Type

Name

Description

uint16

ligatureCount

Number of LigatureAttach table offsets.

Offset16

ligatureAttachOffsets[ligatureCount]

Array of offsets to LigatureAttach tables. Offsets
are from beginning of LigatureArray table,
ordered by ligatureCoverage index.

Each LigatureAttach table consists of an array of ComponentRecords, which describe the
component glyphs in a ligature. The array stores the ComponentRecords in the same
order as the components in the ligature. The order of the records also corresponds to
the writing direction — that is, the logical direction — of the text. For text written left to

right, the first component is on the left; for text written right to left, the first component
is on the right.
LigatureAttach table
ﾉ

Expand table

Type

Name

Description

uint16

componentCount

Number of ComponentRecords in
this ligature.

ComponentRecord

componentRecords[componentCount]

Array of Component records,
ordered in writing direction.

A ComponentRecord, one for each component in the ligature, contains an array of
offsets to the Anchor tables that define all the attachment points used to attach marks
to the component. For each mark class (including class 0) identified in the MarkArray
records, an Anchor table specifies the point used to attach all the marks in a particular
class to the ligature base glyph, relative to the component.
In a ComponentRecord, the zero-based ligatureAnchorOffsets array lists offsets to
Anchor tables by mark class. If a component does not define an attachment point for a
particular class of marks, then the offset to the corresponding Anchor table will be
NULL.
Example 8 at the end of this chapter shows a MarkLigPosFormat1 subtable used to
attach mark accents to a ligature glyph in the Arabic script.
ComponentRecord
ﾉ

Expand table

Type

Name

Description

Offset16

ligatureAnchorOffsets[markClassCount]

Array of offsets (one per class) to Anchor
tables. Offsets are from beginning of
LigatureAttach table, ordered by class
(offsets may be NULL).

Lookup type 6 subtable: mark-to-mark attachment
positioning
The mark-to-mark attachment (MarkMarkPos) subtable is identical in form to the markto-base attachment subtable, although its function is different. Mark-to-mark

attachment defines the position of one mark relative to another mark as when, for
example, positioning tone marks with respect to vowel diacritical marks in Vietnamese.
The attaching mark is mark1, and the base mark being attached to is mark2. In the
MarkMarkPos subtable, every mark1 glyph has an anchor attachment point and is
assigned to a class of marks. As for mark glyphs in a mark-to-base attachment, the
anchor point and class assignment of mark1 glyphs is defined using a MarkArray table
in combination with a mark1 Coverage table. Each mark2 glyph defines an anchor point
for each class of mark1 marks.
For example, assume two mark1 classes: all marks positioned to the left of mark2 glyphs
(class 0), and all marks positioned to the right of mark2 glyphs (class 1). Each mark2
glyph that uses these marks defines two anchor points: one for attaching the mark1
glyphs listed in class 0, and one for attaching the mark1 glyphs listed in class 1.
The mark2 glyph that combines with a mark1 glyph is the glyph preceding the mark1
glyph in glyph string order (skipping glyphs according to LookupFlags). The subtable
applies precisely when that mark2 glyph is covered by the mark2 Coverage. To combine
the mark glyphs, the placement of the mark1 glyph is adjusted such that the relevant
attachment points coincide. Advance widths are not affected. The input context for
mark-to-base, mark-to-ligature and mark-to-mark positioning tables is the mark that is
being positioned. If a sequence contains several marks, a lookup may act on it several
times, to position them.
The mark-to-mark attachment subtable has one format: MarkMarkPosFormat1.
Mark-to-mark attachment positioning format 1
The MarkMarkPosFormat1 subtable begins with a format identifier and two offsets to
Coverage tables: one that lists all the mark1 glyphs referenced in the subtable
(mark1Coverage), and one that lists all the mark2 glyphs referenced in the subtable
(mark2Coverage).
The subtable also has an offset to a MarkArray table for the mark1 glyphs. For each
mark glyph in the mark1Coverage table, a MarkRecord in the MarkArray table specifies
its class and an offset to the Anchor table that describes the mark’s attachment point.
The markClassCount field specifies the total number of distinct mark classes defined in
all the MarkRecords.
The MarkMarkPosFormat1 subtable also has an offset to a Mark2Array table, which
defines for each mark2 glyph an array of anchors, one for each mark1 mark class.
MarkMarkPosFormat1 subtable

ﾉ

Expand table

Type

Name

Description

uint16

format

Format identifier — format = 1.

Offset16

mark1CoverageOffset

Offset to Combining Mark Coverage table, from beginning of
MarkMarkPos subtable.

Offset16

mark2CoverageOffset

Offset to Base Mark Coverage table, from beginning of
MarkMarkPos subtable.

uint16

markClassCount

Number of Combining Mark classes defined.

Offset16

mark1ArrayOffset

Offset to MarkArray table for mark1, from beginning of
MarkMarkPos subtable.

Offset16

mark2ArrayOffset

Offset to Mark2Array table for mark2, from beginning of
MarkMarkPos subtable.

The Mark2Array table contains one Mark2 record for each mark2 glyph listed in the
mark2Coverage table. It stores the records in the same order as the mark2Coverage
index.
Mark2Array table
ﾉ

Expand table

Type

Name

Description

uint16

mark2Count

Number of Mark2 records.

Mark2

mark2Records[mark2Count]

Array of Mark2 records, in Coverage order.

Each Mark2 record contains an array of offsets to Anchor tables (mark2AnchorOffsets).
The zero-based array of offsets, measured from the beginning of the Mark2Array table,
defines the entire set of mark2 attachment points used to attach mark1 glyphs to a
specific mark2 glyph. The Anchor tables referenced in the mark2AnchorOffsets array are
ordered by mark1 class value.
A Mark2 record declares one Anchor table for each mark class (including class 0)
identified in the MarkRecords of the MarkArray. Each Anchor table specifies one mark2
attachment point used to attach all the mark1 glyphs in a particular class to the mark2
glyph.
Example 9 at the end of the chapter shows a MarkMarkPosFormat1 subtable for
attaching one mark to another in the Arabic script.

Mark2 record
ﾉ

Expand table

Type

Name

Description

Offset16

mark2AnchorOffsets[markClassCount]

Array of offsets (one per class) to Anchor
tables. Offsets are from beginning of
Mark2Array table, in class order (offsets may
be NULL).

Lookup type 7 subtable: contextual positioning
A contextual positioning subtable describes glyph positioning in context so a textprocessing client can adjust the position of one or more glyphs within a certain pattern
of glyphs.
Contextual positioning subtables can use any of three formats that are common to the
GSUB and GPOS tables. These define input sequence patterns to be matched against the
text glyph sequence, and then actions to be applied to glyphs within the input
sequence. The actions are specified as “nested” lookups, and each is applied to a
particular sequence position within the input sequence.
Each sequence position + nested lookup combination is specified in a
SequenceLookupRecord. Examples 10, 11, 12, and 13 at the end of this chapter illustrate
the use of sequence lookup records within the GPOS table.
While the subtable formats are common between the GSUB and GPOS tables, the
lookups referenced by sequence lookup records within the GPOS table are referenced
by index into the GPOS LookupList table. In this way, actions specified by a GPOS
contextual lookup can only be positioning adjustments.
Contextual positioning format 1: simple glyph contexts
Format 1 defines the context for a glyph positioning operation as a particular sequence
of glyphs. For example, a context could be <To>, <xyzabc>, <!?*#@>, or any other
glyph sequence.
For example, suppose that accent mark glyphs above lowercase x-height vowel glyphs
need to be lowered when an overhanging capital letter glyph precedes the vowel. When
the client locates this context in the text, the subtable identifies the position of the
accent mark and a lookup index. A lookup specifies a positioning action that lowers the
accent mark over the vowel so that it does not collide with the overhanging capital.

Format 1 contextual positioning is implemented using a SequenceContextFormat1 table.
See Sequence Context Format 1: simple glyph contexts in the OpenType Layout
Common Table Formats chapter for complete details.
Example 10 at the end of this chapter demonstrates glyph kerning in context with a
SequenceContextFormat1 subtable.
Contextual positioning format 2: class-based glyph contexts
Format 2 defines contexts for glyph positioning as input sequence patterns, with
patterns expressed in terms of glyph classes. The glyph classes are defined using a Class
Definition table. Several sequence patterns may be specified, with each pattern
specifying a class of glyphs for each input sequence position.
To clarify the notion of class-based context rules, suppose that certain sequences of
three glyphs need special kerning. The glyph sequences consist of an uppercase glyph
that overhangs on the right side, a punctuation mark glyph, and then a quote glyph. In
this case, the set of uppercase glyphs would constitute one glyph class (class 1), the set
of punctuation mark glyphs would constitute a second glyph class (class 2), and the set
of quote mark glyphs would constitute a third glyph class (class 3). The input context
might be specified as a pattern of one glyph from class 1, followed by one glyph from
class 2, followed by one glyph from class 3.
Format 2 contextual positioning is implemented using a SequenceContextFormat2 table.
See Sequence Context Format 2: class-based glyph contexts in the OpenType Layout
Common Table Formats chapter for complete details.
Example 11 at the end of this chapter demonstrates a SequenceContextFormat2
subtable that uses glyph classes to modify accent positions in glyph strings.
Contextual positioning format 3: coverage-based glyph contexts
Format 3 defines a context for glyph positioning as an input sequence pattern expressed
in terms of Coverage tables. A different Coverage table is defined for each sequence
position.
Format 3 is like format 2 in that patterns are defined using sets of glyphs. However, with
the glyph classes used in format 2, each glyph is in exactly one class. With format 3, any
glyph can occur in multiple Coverage tables.
Unlike Formats 1 and 2, however, this format can define only one context.
For example, consider an input context that contains an uppercase glyph (position 0),
followed by any narrow uppercase glyph (position 1), and then another uppercase glyph
(position 2). This context requires three Coverage tables, one for each position:

For position 0, the first position, the Coverage table lists the set of all uppercase
glyphs.
For position 1, the second position, the Coverage table lists the set of all narrow
uppercase glyphs, which is a subset of the glyphs listed in the Coverage table for
position 0.
For position 2, the Coverage table lists the set of all uppercase glyphs again.
Note: Both position 0 and position 2 can use the same Coverage table.
Format 3 contextual positioning is implemented using a SequenceContextFormat3 table.
See Sequence Context Format 3: coverage-based glyph contexts in the OpenType
Layout Common Table Formats chapter for complete details.
Example 12 at the end of this chapter illustrates the use of a SequenceContextFormat3
subtable to change the positions of sign glyphs in math equations.

Lookup type 8 subtable: chained contexts positioning
A chained contexts positioning subtable describes glyph positioning in context with an
ability to look back and/or look ahead in the sequence of glyphs. The design of the
chained contexts positioning subtable is parallel to that of the contextual positioning
subtable, including the availability of three formats. Each format can describe one or
more chained backtrack, input, and lookahead sequence combinations, and one or more
positioning adjustments for glyphs in each input sequence.
Positioning adjustments may be specified only for the input sequence context, not for
backtrack and lookahead sequences.
Note that backtrack sequences are specified in reverse logical order. See the Chained
Sequence Context Format 1 section in the OpenType Layout Common Table Formats
chapter for details regarding chained backtrack, input, and lookahead sequences.
Chained contexts positioning format 1: simple glyph contexts
Format 1 defines the context for a glyph substitution as a particular sequence of glyphs.
For example, a context could be <xyz>, <holiday>, <!?*#@>, or any other glyph
sequence. Specific glyph sequences are used for input, backtrack or lookahead contexts.
Format 1 chained context substitutions are implemented using a
ChainedSequenceContextFormat1 table. See Chained Sequence Context Format 1:
simple glyph contexts in the OpenType Layout Common Table Formats chapter for
complete details.

Chained contexts positioning format 2: class-based glyph contexts
Format 2 defines contexts for glyph positioning as patterns expressed in terms of glyph
classes. The glyph classes are defined using a Class Definition table. Several sequence
patterns may be specified, with each pattern specifying a class of glyphs for each
sequence position.
To chain contexts, three separate Class Definition tables are used for the backtrack
sequence, input sequence, and lookahead sequence.
Format 2 contextual substitutions are implemented using a
ChainedSequenceContextFormat2 table. See Chained Sequence Context Format 2: classbased glyph contexts in the OpenType Layout Common Table Formats chapter for
complete details.
Chained contexts positioning format 3: coverage-based glyph contexts
Format 3 defines contexts for glyph positioning as patterns expressed in terms of
Coverage tables. A different Coverage table is defined for each position in a sequence.
To chain contexts, three separate sets of Coverage tables are used for the backtrack
sequence, input sequence, and lookahead sequence.
Format 3 is like format 2 in that patterns are defined using sets of glyphs. However, with
the glyph classes used in format 2, each glyph is in exactly one class. With format 3, any
glyph can occur in multiple Coverage tables.
Format 3 contextual substitutions are implemented using a
ChainedSequenceContextFormat3 table. See Chained Sequence Context Format 3:
coverage-based glyph contexts in the OpenType Layout Common Table Formats chapter
for complete details.

Lookup type 9 subtable: positioning subtable extension
This lookup type provides a way to access lookup subtables within the GPOS table using
32-bit offsets. This is needed if the total size of the subtables exceeds the 16-bit limits of
the various other offsets in the GPOS table. In this specification, the subtable stored at
the 32-bit offset location is termed the “extension” subtable.
This subtable type uses one format: PosExtensionFormat1.
Positioning extension format 1
PosExtensionFormat1 subtable

ﾉ

Expand table

Type

Name

Description

uint16

format

Format identifier — format = 1.

uint16

extensionLookupType

Lookup type of subtable referenced by extensionOffset (i.e.
the extension subtable).

Offset32

extensionOffset

Offset to the extension subtable, of lookup type
extensionLookupType, relative to the start of the
PosExtensionFormat1 subtable.

The extensionLookupType field must be set to any lookup type other than 9. If a lookup
table uses extension subtables, then all of the extension subtables must have the same
extensionLookupType. All offsets to extension subtables are set in the usual way—that
is, relative to the start of the PosExtensionFormat1 subtable.
When a layout engine encounters a GPOS type 9 Lookup table, it shall:
Proceed as though the Lookup table’s lookupType field were set to the
extensionLookupType of the subtables.
Proceed as though each extension subtable referenced by extensionOffset
replaced the type 9 subtable that referenced it.

Shared formats: value record, anchor table, mark array
table
Several lookup subtables described earlier in this chapter refer to one or more of the
same formats for positioning data: ValueRecord, Anchor table, and MarkArray table.
These shared formats are described here.

Value record
GPOS subtables use the ValueRecord format to describe all the variables and values
used to adjust the position of a glyph or set of glyphs. A ValueRecord may define any
combination of X and Y values (in design units) to add to (positive values) or subtract
from (negative values) the placement and advance values provided in the font. In nonvariable fonts, a ValueRecord may also contain an offset to a Device table for each of the
specified values. In a variable font, it may also contain an offset to a VariationIndex table
for each of the specified values.
Note that all fields of a ValueRecord are optional: to save space, only the fields that are
required need be included in a given instance. Because the GPOS table uses

ValueRecords for many purposes, the sizes and contents of ValueRecords may vary from
subtable to subtable. A ValueRecord is always accompanied by a ValueFormat flags field
that specifies which of the ValueRecord fields is present. If a ValueRecord specifies more
than one value, the values must be listed in the order shown in the ValueRecord
definition. If the associated ValueFormat flags indicate that a field is not present, then
the next present field follows immediately after the last preceding, present field. The
text-processing client must be aware of the flexible and variable nature of ValueRecords
in the GPOS table.
Example 14 at the end of the chapter uses ValueFormat and a ValueRecord to specify
positioning values in GPOS.
ValueRecord
ﾉ

Expand table

Type

Name

Description

int16

xPlacement

Horizontal adjustment for placement, in design units.

int16

yPlacement

Vertical adjustment for placement, in design units.

int16

xAdvance

Horizontal adjustment for advance, in design units — only used
for horizontal layout.

int16

yAdvance

Vertical adjustment for advance, in design units — only used for
vertical layout.

Offset16

xPlaDeviceOffset

Offset to Device table (non-variable font) / VariationIndex table
(variable font) for horizontal placement, from beginning of the
immediate parent table (SinglePos or PairPosFormat2 lookup
subtable, PairSet table within a PairPosFormat1 lookup subtable)
— may be NULL.

Offset16

yPlaDeviceOffset

Offset to Device table (non-variable font) / VariationIndex table
(variable font) for vertical placement, from beginning of the
immediate parent table (SinglePos or PairPosFormat2 lookup
subtable, PairSet table within a PairPosFormat1 lookup subtable)
— may be NULL.

Offset16

xAdvDeviceOffset

Offset to Device table (non-variable font) / VariationIndex table
(variable font) for horizontal advance, from beginning of the
immediate parent table (SinglePos or PairPosFormat2 lookup
subtable, PairSet table within a PairPosFormat1 lookup subtable)
— may be NULL.

Offset16

yAdvDeviceOffset

Offset to Device table (non-variable font) / VariationIndex table
(variable font) for vertical advance, from beginning of the
immediate parent table (SinglePos or PairPosFormat2 lookup

subtable, PairSet table within a PairPosFormat1 lookup subtable)
— may be NULL.

Note: Device tables are used only in non-variable fonts, while VariationIndex tables
are used only in variable fonts.
In variable fonts, VariationIndex tables are needed to reference variation data for any
placement or advance value that requires adjustment for different variation instances.
Note: While a separate reference to a VariationIndex table is required for each value
that requires variation, two or more values that require the same variation data can
have offsets that point to the same VariationIndex table, and two or more
VariationIndex tables can reference the same variation data entries.
Note: If no VariationIndex table is used for a particular placement or advance value,
then that value is used for all variation instances.
A ValueFormat flags field defines the types of positioning adjustment data that
ValueRecords specify. SinglePos subtables will have ValueRecords for a single glyph
position in a glyph sequence; PairPos subtables will have separate ValueRecords for two
glyph positions. In a given subtable, the same ValueFormat applies to every ValueRecord
for a given glyph position.
The ValueFormat determines whether the ValueRecords:
Apply to placement, advance, or both.
Apply to the horizontal position (X coordinate), the vertical position (Y coordinate),
or both.
Could refer to one or more Device tables (in non-variable fonts) or VariationIndex
tables (in variable fonts) for any of the specified values.
Each defined bit in the ValueFormat flags corresponds to a field in the ValueRecord and
increases the size of the ValueRecord by 2 bytes. A ValueFormat of 0x0000 corresponds
to an empty ValueRecord, which indicates no positioning changes.
To identify the fields in each ValueRecord, the ValueFormat flags shown below are used.
To specify multiple fields with a ValueFormat, the bit settings of the relevant fields are
added with a logical OR operation.
For example, to adjust the left-side bearing of a glyph, the ValueFormat will be 0x0001,
and the ValueRecord will define the xPlacement value. To adjust the advance width of a
different glyph, the ValueFormat will be 0x0004, and the ValueRecord will describe the

xAdvance value. To adjust both the xPlacement and xAdvance of a set of glyphs, the
ValueFormat will be 0x0005, and the ValueRecord will specify both values in the order
they are listed in the ValueRecord definition.
ValueFormat flags
ﾉ

Expand table

Mask

Name

Description

0x0001

X_PLACEMENT

Includes horizontal adjustment for placement.

0x0002

Y_PLACEMENT

Includes vertical adjustment for placement.

0x0004

X_ADVANCE

Includes horizontal adjustment for advance.

0x0008

Y_ADVANCE

Includes vertical adjustment for advance.

0x0010

X_PLACEMENT_DEVICE

Includes Device table (non-variable font) / VariationIndex table
(variable font) for horizontal placement.

0x0020

Y_PLACEMENT_DEVICE

Includes Device table (non-variable font) / VariationIndex table
(variable font) for vertical placement.

0x0040

X_ADVANCE_DEVICE

Includes Device table (non-variable font) / VariationIndex table
(variable font) for horizontal advance.

0x0080

Y_ADVANCE_DEVICE

Includes Device table (non-variable font) / VariationIndex table
(variable font) for vertical advance.

0xFF00

Reserved

For future use (set to zero).

Anchor table
A GPOS table uses anchor points to position one glyph with respect to another: two
glyphs each define an anchor point, and the text-processing client attaches the glyphs
by aligning their corresponding anchor points.
To describe an anchor point, an Anchor table can use one of three formats. The first
format uses X and Y coordinates, in design units, to specify a location for the anchor
point in relation to the location of the outline for a given glyph. The other two formats
refine the location of the anchor point using contour points (Format 2) or Device tables
(Format 3). In a variable font, the third format uses a VariationIndex table (a variant of a
Device table) to reference variation data for adjustment of the anchor position for the
current variation instance, as needed.
Anchor format 1: design units

AnchorFormat1 consists of a format identifier and a pair of design-unit coordinates that
specify the location of the anchor point. This format has the benefits of small size and
simplicity, but the anchor point cannot be hinted to adjust its position for different
device resolutions.
Example 15 at the end of this chapter uses AnchorFormat1.
AnchorFormat1 table
ﾉ

Type

Name

Description

uint16

format

Format identifier — format = 1.

int16

xCoordinate

Horizontal value, in design units.

int16

yCoordinate

Vertical value, in design units.

Expand table

Anchor format 2: design units plus contour point
Like AnchorFormat1, AnchorFormat2 specifies a format identifier and a pair of design
unit coordinates for the anchor point.
For fine-tuning the location of the anchor point, AnchorFormat2 also provides an index
to a glyph contour point that is on the outline of a glyph. Hinting can be used to move
the contour anchor point. In the rendered text, the anchor point will provide the final
positioning data for a given ppem size.
Example 16 at the end of this chapter uses AnchorFormat2.
AnchorFormat2 table
ﾉ

Type

Name

Description

uint16

format

Format identifier — format = 2.

int16

xCoordinate

Horizontal value, in design units.

int16

yCoordinate

Vertical value, in design units.

uint16

anchorPoint

Index to glyph contour point.

Anchor format 3: design units plus Device or VariationIndex tables

Expand table

Like AnchorFormat1, AnchorFormat3 specifies a format identifier and provides
coordinates that locate an anchor point. And, like AnchorFormat2, it permits fine
adjustments in variable fonts to the coordinate values. However, AnchorFormat3 uses
Device tables, rather than a contour point, for this adjustment.
With a Device table, a client can adjust the position of the anchor point for any font size
and device resolution. AnchorFormat3 can specify offsets to separate Device tables for
the X and Y coordinates. If only one coordinate requires adjustment, the offset to the
Device table for the other coordinate may be set to NULL.
In variable fonts, AnchorFormat3 is required to reference variation data to adjust anchor
points for different variation instances, if needed. In this case, AnchorFormat3 specifies
an offset to a VariationIndex table, which is a variant of the Device table used for
variations. If no VariationIndex table is used for a particular anchor point X or Y
coordinate, then that value is used for all variation instances. While separate
VariationIndex table references are required for each value that requires variation, two or
more values that require the same variation-data values can have offsets that point to
the same VariationIndex table, and two or more VariationIndex tables can reference the
same variation data entries.
Example 17 at the end of the chapter shows an AnchorFormat3 table.
AnchorFormat3 table
ﾉ

Expand table

Type

Name

Description

uint16

format

Format identifier — format = 3.

int16

xCoordinate

Horizontal value, in design units.

int16

yCoordinate

Vertical value, in design units.

Offset16

xDeviceOffset

Offset to Device table (non-variable font) / VariationIndex table
(variable font) for X coordinate, from beginning of Anchor table (may
be NULL).

Offset16

yDeviceOffset

Offset to Device table (non-variable font) / VariationIndex table
(variable font) for Y coordinate, from beginning of Anchor table (may
be NULL).

Mark array table

The MarkArray table defines the class and the anchor point for a mark glyph. Three
GPOS subtable types — mark-to-base attachment, mark-to-ligature attachment, and
mark-to-mark attachment — use the MarkArray table to specify data for attaching
marks.
The MarkArray table contains an array of MarkRecords. Each MarkRecord defines the
class of the mark and an offset to the Anchor table that contains data for the mark.
A class value can be zero (0), but the MarkRecord must explicitly assign that class value.
(This differs from the Class Definition table, in which all glyphs not assigned class values
automatically belong to class 0.) The GPOS subtables that refer to MarkArray tables use
the class assignments for indexing zero-based arrays that contain data for each mark
class.
In Example 18 at the end of the chapter, a MarkArray table and two MarkRecords define
two mark classes.
MarkArray table
ﾉ

Expand table

Type

Name

Description

uint16

markCount

Number of MarkRecords.

MarkRecord

markRecords[markCount]

Array of MarkRecords, ordered by corresponding
glyphs in the associated mark Coverage table.

MarkRecord
ﾉ

Expand table

Type

Name

Description

uint16

markClass

Class defined for the associated mark.

Offset16

markAnchorOffset

Offset to Anchor table, from beginning of MarkArray table.

GPOS structure examples
The rest of this chapter describes examples of all the GPOS subtable formats, including
each of the three formats available for contextual positioning. All the examples reflect
unique parameters described below, but the samples provide a useful reference for
building subtables specific to other situations.

All the examples have three columns showing hex data, source, and comments.

Example 1: GPOS Header
Example 1 shows a typical GPOS Header table definition with offsets to a ScriptList,
FeatureList, and LookupList.
Example 1
ﾉ

Hex Data

Source

Comments

GPOSHeader
TheGPOSHeader

GPOSHeader table definition

00010000

0x00010000

major / minor version

000A

TheScriptList

offset to ScriptList table

001E

TheFeatureList

offset to FeatureList table

002C

TheLookupList

offset to LookupList table

Expand table

Example 2: SinglePosFormat1 subtable
Example 2 uses the SinglePosFormat1 subtable to lower the Y placement of subscript
glyphs in a font. The LowerSubscriptsSubTable defines one Coverage table, called
LowerSubscriptsCoverage, which lists one range of glyph indices for the
numeral/numeric subscript glyphs. The subtable’s ValueFormat setting indicates that the
ValueRecord specifies only the yPlacement value, lowering each subscript glyph by 80
design units.
Example 2
ﾉ

Hex Data

Expand table

Source

Comments

SinglePosFormat1
LowerSubscriptsSubTable

SinglePos subtable definition

0001

1

format

0008

LowerSubscriptsCoverage

offset to Coverage table

0002

0x0002

valueFormat: Y_PLACEMENT

ValueRecord
FFB0

-80

move Y position down

CoverageFormat2

Coverage table definition

LowerSubscriptsCoverage
0002

2

format: ranges

0001

1

rangeCount

rangeRecords[0]
01B3

ZeroSubscriptGlyphID

Start, first glyph ID

01BC

NineSubscriptGlyphID

End, last glyph ID

0000

0

startCoverageIndex

Example 3: SinglePosFormat2 subtable
This example uses a SinglePosFormat2 subtable to adjust the spacing of three dash
glyphs by different amounts. The em dash spacing changes by 10 units, the en dash
spacing changes by 25 units, and spacing of the standard dash changes by 50 units.
The DashSpacingSubTable contains one Coverage table with three dash glyph indices,
plus an array of ValueRecords, one for each covered glyph. The ValueRecords use the
same ValueFormat to modify the xPlacement and xAdvance values of each glyph. The
ValueFormat bit setting of 0x0005 is produced by adding the xPlacement and xAdvance
bit settings.
Example 3
ﾉ

Hex Data

Expand table

Source

Comments

SinglePosFormat2
DashSpacingSubTable

SinglePos subtable definition

0002

2

format

0014

DashSpacingCoverage

offset to Coverage table

0005

0x0005

ValueFormat: X_PLACEMENT || X_ADVANCE

0003

3

valueCount

valueRecords[0]

for dash glyph

0032

50

xPlacement

0032

50

xAdvance

valueRecords[1]

for en dash glyph

0019

25

xPlacement

0019

25

xAdvance

valueRecords[2]

for em dash glyph

000A

10

xPlacement

000A

10

xAdvance

CoverageFormat1
DashSpacingCoverage

Coverage table definition

0001

1

format: lists

0003

3

glyphCount

004F

DashGlyphID

glyphArray[0]

0125

EnDashGlyphID

glyphArray[1]

0129

EmDashGlyphID

glyphArray[2]

Example 4: PairPosFormat1 subtable
Example 4 uses a PairPosFormat1 subtable to kern two glyph pairs - “Po” and “To” - by
adjusting the xAdvance of the first glyph and the xPlacement of the second glyph. Two
ValueFormats are defined, one for each glyph. The subtable contains a Coverage table
that lists the index of the first glyph in each pair. It also contains an offset to a PairSet
table for each covered glyph.
A PairSet table defines an array of PairValue records to specify all the glyph pairs that
contain a covered glyph as their first component. In this example, the PairSet table has
one PairValue record that identifies the second glyph in the “Po” pair and two
ValueRecords, one for the first glyph and one for the second. The PairSet table also has
one PairValue record that lists the second glyph in the “To” pair and two ValueRecords,
one for each glyph.
Example 4

ﾉ

Hex Data

Source

Comments

PairPosFormat1

PairPos subtable definition

PairKerningSubTable
0001

1

format

001E

PairKerningCoverage

offset to Coverage table

0004

0x0004

valueFormat1: X_ADVANCE only

0001

0x0001

ValueFormat2: X_PLACEMENT only

0002

2

pairSetCount

000E

PairSetTable

pairSetOffsets[0]

0016

PairSetTable

pairSetOffsets[1]

PairSetTable
PairSetTable

PairSet table definition

1

pairValueCount

0001

pairValueRecords[0]
0059

FFE2

FFEC

LowercaseOGlyphID

secondGlyph

valueRecord1

ValueRecord for first glyph

-30

xAdvance

valueRecord2

ValueRecord for second glyph

-20

xPlacement

PairSetTable

PairSet table definition

PairSetTable
0001

1

pairValueCount

pairValueRecords[0]
0059

FFD8

LowercaseOGlyphID

secondGlyph

valueRecord1

ValueRecord for first glyph

-40

xAdvance

valueRecord2

ValueRecord for second glyph

Expand table

FFE7

-25

xPlacement

CoverageFormat1
PairKerningCoverage

Coverage table definition

0001

1

format: lists

0002

2

glyphCount

002D

UppercasePGlyphID

glyphArray[0]

0031

UppercaseTGlyphID

glyphArray[1]

Example 5: PairPosFormat2 subtable
The PairPosFormat2 subtable in this example defines pairs composed of two glyph
classes. Two ClassDef tables are defined, one for each glyph class. The first glyph in each
pair is in a class of lowercase glyphs with diagonal shapes (v, w, y), defined class 1 in the
LowercaseClassDef table. The second glyph in each pair is in a class of punctuation
glyphs (comma and period), defined in class 1 in the PunctuationClassDef table. The
Coverage table only lists the indices of the glyphs in the LowercaseClassDef table since
they occupy the first position in the pairs.
The subtable defines two Class1 records for the classes defined in LowecaseClassDef,
including Class0. Each record, in turn, defines a Class2 record for each class defined in
PunctuationClassDef, including class 0. The Class2 records specify the positioning
adjustments for the glyphs.
The pairs are kerned by reducing the xAdvance of the first glyph by 50 design units.
Because no positioning change applies to the second glyph, its ValueFormat2 field is set
to 0, to indicate that Value2 is empty for each pair.
Since no pairs begin with class 0 or class 2 glyphs, all the ValueRecords referenced in
class1Records[0] contain values of 0 or are empty. However, class1Records[1] does
define an xAdvance value in its class2Records[1] for kerning all pairs that contain a class
1 glyph followed by a class 2 glyph.
Example 5
ﾉ

Hex
Data

Source

Comments

Expand table

PairPosFormat2

PairPos subtable definition

PunctKerningSubTable
0002

2

format

0018

PunctKerningCoverage

offset to Coverage table

0004

0x0004

valueFormat1: X_ADVANCE only

0000

0

ValueFormat2: no ValueRecord for second glyph

0022

LowercaseClassDef

offset to ClassDef1 table, for first class in pair

0032

PunctuationClassDef

offset to ClassDef2 table, for second class in pair

0002

2

Class1Count

0002

2

Class2Count

class1Records[0]

First Class1 record, for contexts beginning with class 0

class2Records[0]

First Class2 record for class1Records[0]; valueFormat2 is zero,
so no valueRecord2.

valueRecord1
0000

0

xAdvance: no change for first glyph

class2Records[1]

no valueRecord2

valueRecord1
0000

0

xAdvance: no change for first glyph

class1Records[1]

for contexts beginning with class 1

class2Records[0]

no contexts with class 0 as second glyph; no valueRecord2

valueRecord1
0000

0

xAdvance: no change for first glyph

class2Records[1]

contexts with class 1 as second glyph; no valueRecord2

valueRecord1
FFCE

0001

-50

xAdvance: move punctuation glyph left

CoverageFormat1
PunctKerningCoverage

Coverage table definition

1

format: lists

0003

3

glyphCount

0046

LowercaseVGlyphID

glyphArray[0]

0047

LowercaseWGlyphID

glyphArray[1]

0049

LowercaseYGlyphID

glyphArray[2]

ClassDefFormat2
LowercaseClassDef

ClassDef table definition

0002

2

format: ranges

0002

2

classRangeCount

classRangeRecords[0]
0046

LowercaseVGlyphID

startGlyphID

0047

LowercaseWGlyphID

endGlyphID

0001

1

class

classRangeRecords[1]
0049

LowercaseYGlyphID

startGlyphID

0049

LowercaseYGlyphID

endGlyphID

0001

1

class

ClassDefFormat2
PunctuationClassDef

ClassDef table definition

0002

2

format: ranges

0001

1

classRangeCount

classRangeRecords[0]
006A

PeriodPunctGlyphID

startGlyphID

006B

CommaPunctGlyphID

endGlyphID

0001

1

class

Example 6: CursivePosFormat1 subtable
In Example 6, the Urdu language system uses a CursivePosFormat1 subtable to attach
glyphs along a diagonal baseline that descends from right to left. Two glyphs are
defined with attachment data and listed in the Coverage table-the Kaf and Ha glyphs.

For each glyph, the subtable contains an EntryExit record that defines offsets to two
Anchor tables, an entry attachment point, and an exit attachment point. Each Anchor
table defines X and Y coordinate values. To render Urdu down and diagonally, the entry
point’s Y coordinate is above the baseline and the exit point’s Y coordinate is located
below the baseline.
Example 6
ﾉ

Hex Data

Expand table

Source

Comments

CursivePosFormat1
DiagonalWritingSubTable

CursivePos subtable definition

0001

1

format

000E

DiagonalWritingCoverage

offset to Coverage table

0002

2

entryExitCount

entryExitRecords[0]

EntryExit record for Kaf glyph

0016

KafEntryAnchor

offset to EntryAnchor table

001C

KafExitAnchor

offset to ExitAnchor table

entryExitRecords[1]

EntryExit record for Ha glyph

0022

HaEntryAnchor

offset to EntryAnchor table

0028

HaExitAnchor

offset to ExitAnchor table

CoverageFormat1
DiagonalWritingCoverage

Coverage table definition

0001

1

format: lists

0002

2

glyphCount

0203

KafGlyphID

glyphArray[0]

027E

HaGlyphID

glyphArray[1]

AnchorFormat1
KafEntryAnchor

Anchor table definition

0001

1

format: design units only

05DC

1500

xCoordinate

002C

44

yCoordinate

AnchorFormat1
KafExitAnchor

Anchor table definition

0001

1

format: design units only

0000

0

xCoordinate

FFEC

-20

yCoordinate

AnchorFormat1
HaEntryAnchor

Anchor table definition

0001

1

format: design units only

05DC

1500

xCoordinate

002C

44

yCoordinate

AnchorFormat1
HaExitAnchor

Anchor table definition

0001

1

format: design units only

0000

0

xCoordinate

FFEC

-20

yCoordinate

Example 7: MarkBasePosFormat1 subtable
The MarkBasePosFormat1 subtable in Example 7 defines one Arabic base glyph, Tah, and
two Arabic mark glyphs: a fathatan mark above the base glyph, and a kasra mark below
the base glyph. The BaseGlyphsCoverage table lists the base glyph, and the
MarkGlyphsCoverage table lists the mark glyphs.
Each mark is also listed in the MarkArray, along with its attachment point data and a
mark Class value. The MarkArray defines two mark classes: class 0 consists of marks
located above base glyphs, and class 1 consists of marks located below base glyphs.
The BaseArray defines attachment data for base glyphs. In this array, one BaseRecord is
defined for the Tah glyph with offsets to two BaseAnchor tables, one for each class of
marks. AboveBaseAnchor defines an attachment point for marks placed above the Tah
base glyph, and BelowBaseAnchor defines an attachment point for marks placed below
it.
Example 7

ﾉ

Hex Data

Expand table

Source

Comments

MarkBasePosFormat1
MarkBaseAttachSubTable

MarkBasePos subtable definition

0001

1

format

000C

MarkGlyphsCoverage

offset to markCoverage table

0014

BaseGlyphsCoverage

offset to baseCoverage table

0002

2

markClassCount

001A

MarkGlyphsArray

offset to MarkArray table

0030

BaseGlyphsArray

offset to BaseArray table

CoverageFormat1
MarkGlyphsCoverage

Coverage table definition

0001

1

format: lists

0002

2

glyphCount

0333

fathatanMarkGlyphID

glyphArray[0]

033F

kasraMarkGlyphID

glyphArray[1]

CoverageFormat1
BaseGlyphsCoverage

Coverage table definition

0001

1

format: lists

0001

1

glyphCount

0190

tahBaseGlyphID

glyphArray[0]

MarkArray
MarkGlyphsArray

MarkArray table definition

2

markCount

markRecords[0]

MarkRecords in Coverage index order

0000

0

markClass, for marks over base

000A

fathatanMarkAnchor

markAnchorOffset

0002

markRecords[1]
0001

1

markClass, for marks under

0010

kasraMarkAnchor

markAnchorOffset

AnchorFormat1
fathatanMarkAnchor

Anchor table definition

0001

1

format: design units only

015A

346

xCoordinate

FF9E

-98

yCoordinate

AnchorFormat1
kasraMarkAnchor

Anchor table definition

0001

1

format: design units only

0105

261

xCoordinate

0058

88

yCoordinate

BaseArray
BaseGlyphsArray

BaseArray table definition

1

baseCount

0001

baseRecords[0]
0006

AboveBaseAnchor

baseAnchorOffsets[0]

000C

BelowBaseAnchor

baseAnchorOffsets[1]

AnchorFormat1
AboveBaseAnchor

Anchor table definition

0001

1

format: design units only

033E

830

xCoordinate

0640

1600

yCoordinate

AnchorFormat1
BelowBaseAnchor

Anchor table definition

0001

1

format: design units only

033E

830

xCoordinate

FFAD

-83

yCoordinate

Example 8: MarkLigPosFormat1 subtable

Example 8 uses the MarkLigPosFormat1 subtable to attach marks to a ligature glyph in
the Arabic script. The hypothetical ligature is composed of three glyph components: a
Lam (initial form), a meem (medial form), and a jeem (medial form). Accent marks are
defined for the first two components: the sukun accent is positioned above lam, and the
kasratan accent is placed below meem.
The LigGlyphsCoverage table lists the ligature glyph and the MarkGlyphsCoverage table
lists the two accent marks. Each mark is also listed in the MarkArray, along with its
attachment point data and a mark Class value. The MarkArray defines two mark classes:
class 0 consists of marks located above base glyphs, and class 1 consists of marks
located below base glyphs.
The LigGlyphsArray has an offset to one LigatureAttach table for the covered ligature
glyph. This table, called LamWithMeemWithJeemLigAttach, defines a count and array of
the component glyphs in the ligature. Each ComponentRecord defines offsets to two
Anchor tables, one for each mark class.
In the example, the first glyph component, lam, specifies a high attachment point for
positioning accents above, but does not specify a low attachment point for placing
accents below. The second glyph component, meem, defines a low attachment point for
placing accents below, but not above. The third component, jeem, has no attachment
points since the example defines no accents for it.
Example 8
ﾉ

Hex
Data

Source

Comments

MarkLigPosFormat1
MarkLigAttachSubTable

MarkLigPos subtable definition

0001

1

format

000C

MarkGlyphsCoverage

offset to markCoverage table

0014

LigGlyphsCoverage

offset to ligatureCoverage table

0002

2

markClassCount

001A

MarkGlyphsArray

offset to MarkArray table

0030

LigGlyphsArray

offset to LigatureArray table

CoverageFormat1
MarkGlyphsCoverage

Coverage table definition

Expand table

0001

1

format: lists

0002

2

glyphCount

033C

sukunMarkGlyphID

glyphArray[0]

033F

kasratanMarkGlyphID

glyphArray[1]

CoverageFormat1
LigGlyphsCoverage

Coverage table definition

0001

1

format: lists

0001

1

glyphCount

0234

LamWithMeemWithJeem
LigatureGlyphID

glyphArray[0]

MarkArray
MarkGlyphsArray

MarkArray table definition

2

markCount

markRecords[0]

MarkRecords in Coverage index order

0000

0

markClass, for marks above components

000A

sukunMarkAnchor

markAnchorOffset

0002

markRecords[1]
0001

1

markClass, for marks below components

0010

kasratanMarkAnchor

markAnchorOffset

AnchorFormat1
sukunMarkAnchor

Anchor table definition

0001

1

format: design units only

015A

346

xCoordinate

FF9E

-98

yCoordinate

AnchorFormat1
kasratanMarkAnchor

Anchor table definition

0001

1

format: design units only

0105

261

xCoordinate

01E8

488

yCoordinate

LigatureArray
LigGlyphsArray

LigatureArray table definition

0001

1

ligatureCount

0004

LamWithMeemWithJeemLigAttach

ligatureAttachOffsets[0]

LigatureAttach
LamWithMeemWithJeemLigAttach

LigatureAttach table definition

3

componentCount

componentRecords[0]

Right-to-left text; ComponentRecords in writingdirection (logical) order: right-most glyph first

000E

AboveLamAnchor

ligatureAnchorOffsets[0] — offsets ordered by
mark class

0000

NULL

ligatureAnchorOffsets[1] — no attachment points
for class 1 marks

0003

componentRecords[1]
0000

NULL

ligatureAnchorOffsets[0] — no attachment points
for class 0 marks

0014

BelowMeemAnchor

ligatureAnchorOffsets — for class 1 marks (below)

componentRecords[2]
0000

NULL

ligatureAnchorOffsets — no attachment points for
class 0 marks

0000

NULL

ligatureAnchorOffsets[1] — no attachment points
for class 1 marks

AnchorFormat1
AboveLamAnchor

Anchor table definition

0001

1

format: design units only

0271

625

xCoordinate

0708

1800

yCoordinate

AnchorFormat1
BelowMeemAnchor

Anchor table definition

0001

1

format: design units only

0178

376

xCoordinate

FE90

-368

yCoordinate

Example 9: MarkMarkPosFormat1 subtable
The MarkMarkPosFormat1 subtable in Example 9 defines two Arabic marks glyphs. The
hamza mark, the base mark (Mark2), is identified in the Mark2GlyphsCoverage table. The
damma mark, the attaching mark (Mark1), is defined in the Mark1GlyphsCoverage table.
Each Mark1 glyph is also listed in the Mark1Array, along with its attachment point data
and a mark Class value. The Mark1GlyphsArray defines one mark class, class 0, that
consists of marks located above Mark2 base glyphs. The Mark1GlyphsArray contains an
offset to a dammaMarkAnchor table to specify the coordinate of the damma mark’s
attachment point.
The Mark2GlyphsArray table defines a count and an array of Mark2 records, one for
each covered Mark2 base glyph. Each record contains an offset to a Mark2Anchor table
for each Mark1 class. One Anchor table, AboveMark2Anchor, specifies a coordinate
value for attaching the damma mark above the hamza base mark.
Example 9
ﾉ

Hex Data

Source

Comments

MarkMarkPosFormat1
MarkMarkAttachSubTable

MarkBasePos subtable definition

0001

1

format

000C

Mark1GlyphsCoverage

offset to mark1Coverage table

0012

Mark2GlyphsCoverage

offset to mark2Coverage table

0001

1

markClassCount

0018

Mark1GlyphsArray

offset to mark1Array table

0024

Mark2GlyphsArray

offset to mark2Array table

CoverageFormat1
Mark1GlyphsCoverage

Coverage table definition

0001

1

format: lists

0001

1

glyphCount

0296

dammaMarkGlyphID

glyphArray[0]

CoverageFormat1

Coverage table definition

Expand table

Mark2GlyphsCoverage
0001

1

format: lists

0001

1

glyphCount

0289

hamzaMarkGlyphID

glyphArray[1]

MarkArray
Mark1GlyphsArray

MarkArray table definition

1

markCount

markRecords[0]

MarkRecords in Coverage index order

0000

0

markClass — for marks above base mark

0006

dammaMarkAnchor

markAnchorOffset

AnchorFormat1
dammaMarkAnchor

Anchor table definition

0001

1

format: design units only

00BD

189

xCoordinate

FF99

-103

yCoordinate

Mark2Array
Mark2GlyphsArray

Mark2Array table definition

1

mark2Count

0001

0001

mark2Records[0]
0004

AboveMark2Anchor

mark2AnchorOffsets[0]

AnchorFormat1
AboveMark2Anchor

Anchor table definition

0001

1

format: design units only

00DD

221

xCoordinate

012D

301

yCoordinate

Example 10: Contextual positioning format 1
Example 10 illustrates contextual positioning format 1 using a SequenceContextFormat1
subtable to adjust the spacing between three Arabic glyphs in a word. The context is the
glyph sequence (from right to left): heh (initial form), thal (final form), and heh (isolated

form). In the rendered word, the first two glyphs are connected, but the last glyph (the
isolated form of heh), is separate. This subtable reduces the amount of space between
the last glyph and the rest of the word.
The subtable contains a WordCoverage table that lists the first glyph in the word, heh
(initial), and one SequenceRuleSet table, called WordPosRuleSet, that defines all contexts
beginning with this covered glyph.
The WordPosRuleSet contains one SequenceRule table that describes a word context of
three glyphs and identifies the second and third glyphs (the first glyph is identified by
the WordPosRuleSet). When a text-processing client locates this context in text, it
applies a Single Adjustment Positioning lookup (not shown in the example) at position 2
to reduce the spacing between the glyphs.
Example 10
ﾉ

Hex Data

Expand table

Source

Comments

SequenceContextFormat1
MoveHehInSubtable

SequenceContextFormat1 subtable definition

0001

1

format

0008

WordCoverage

offset to Coverage table

0001

1

seqRuleSetCount

000E

WordPosRuleSet

seqRuleSetOffsets[0]

CoverageFormat1
WordCoverage

Coverage table offset

0001

1

format: lists

0001

1

glyphCount

02A6

hehInitialGlyphID

glyphArray[0]

SequenceRuleSet
WordPosRuleSet

SequenceRuleSet table definition

0001

1

seqRuleCount

0004

WordPosRule

seqRuleOffsets[0]

SequenceRule
WordPosRule

SequenceRule table definition

0003

3

glyphCount

0001

1

seqLookupCount

02DD

thalFinalGlyphID

inputSequence[0]

02C6

hehIsolatedGlyphID

inputSequence[1]
seqLookupRecords[0]

0002

2

sequenceIndex

0001

1

lookupListIndex

Example 11: Contextual positioning format 2
Example 11 illustrates contextual positioning format 2 using a SequenceContextFormat2
subtable with glyph classes to modify accent positions in contexts that have preceding
overhanging, uppercase glyphs.
In the example, MoveAccentsSubtable contains a Class Definition table that defines five
glyph classes: class 1 consists of uppercase glyphs that overhang and create a wide
open space on their right side; class 2 consists of uppercase glyphs that overhang and
create a narrow space on their right side; class 3 contains lowercase x-height vowels;
and class 4 contains accent glyphs placed over the lowercase vowels. The rest of the
glyphs in the font fall into class 0.
The MoveAccentsSubtable defines two similar context strings. The first consists of a
class 1 uppercase glyph followed by a class 3 lowercase vowel glyph with a class 4
accent glyph over the vowel. When this context is found in the text, the client lowers the
accent glyph over the vowel so that it does not collide with the overhanging glyph
shape. The second context consists of a class 2 uppercase glyph, followed by a class 3
lowercase vowel glyph with a class 4 accent glyph over the vowel. When this context is
found in the text, the client increases the advance width of the uppercase glyph to
expand the space between it and the accented vowel.
MoveAccentsSubtable defines a table, MoveAccentsCoverage, that identifies the first
glyphs in the two contexts. It also has offsets to five ClassSequenceRuleSet tables, one
for each class defined in the ClassDef table. Since no contexts begin with class 0, class 3,
or class 4 glyphs, the offsets to the ClassSequenceRuleSet tables for these classes are
NULL. ClassSequenceRuleSet[1] defines all contexts beginning with class 1 glyphs; it is
called UCWideOverhangPosClass1Set. ClassSequenceRuleSet[2] defines all contexts
beginning with class 2 glyphs, and it is called UCNarrowOverhangPosClass1Set.

Each ClassSequenceRuleSet defines one ClassSequenceRule. The
UCWideOverhangPosClass1Set uses the UCWideOverhangPosClassRule to specify the
first context. The first class in this context string is identified by the index into the array
of offsets to the ClassSequenceRuleSet tables; in this case, it is class 1. The
ClassSequenceRule table lists the second and third classes in the context as class 3 and
class 4. A Single Adjustment Positioning Lookup (not shown) lowers the accent glyph in
position 3 in the context string.
The UCNarrowOverhangPosClass1Set defines the UCNarrowOverhangPosClassRule for
the second context. This ClassSequenceRule is identical to the
UCWideOverhangPosClassRule, except that the first class in the context string is a class 2
lowercase glyph. A Single Adjustment Positioning Lookup (not shown) increases the
advance width of the overhanging uppercase glyph in position 0 in the context string.
Example 11
ﾉ

Hex

Expand table

Source

Comments

SequenceContextFormat2

SequenceContextFormat2 subtable definition

Data

MoveAccentsSubtable
0002

2

format

0012

MoveAccentsCoverage

Offset to Coverage table

0020

MoveAccentsClassDef

Offset to ClassDef

0005

5

classSeqRuleSetCount

0000

NULL

classSeqRuleSetOffsets[0] — no contexts begin with
class 0 glyphs

0060

UCWideOverhangPosClass1Set

classSeqRuleSetOffsets[1] — contexts beginning with
class 1 glyphs

0070

UCNarrowOverhangPosClass2Set

classSeqRuleSetOffsets[2] — contexts beginning with
class 2 glyphs

0000

NULL

classSeqRuleSetOffsets[3] — no contexts begin with
class 3 glyphs

0000

NULL

classSeqRuleSetOffsets[4] — no contexts begin with
class 4 glyphs

CoverageFormat1

Coverage table definition

MoveAccentsCoverage
0001

1

format: lists

0005

5

glyphCount

0029

UppercaseFGlyphID

glyphArray[0]

0033

UppercasePGlyphID

glyphArray[1]

0037

UppercaseTGlyphID

glyphArray[2]

0039

UppercaseVGlyphID

glyphArray[3]

003A

UppercaseWGlyphID

glyphArray[4]

ClassDefFormat2
MoveAccentsClassDef

ClassDef table definition defines five classes: 0 (all
else), 1 (T, V, W: UCUnderhang), 2 (F, P: UCOverhang),
3 (a, e, I, o, u: LCVowels), 4 (tilde, umlaut)

0002

2

format: ranges

000A

10

classRangeCount

classRangeRecords[0]
0029

UppercaseFGlyphID

startGlyphID

0029

UppercaseFGlyphID

endGlyphID

0002

2

class

classRangeRecords[1]
0033

UppercasePGlyphID

startGlyphID

0033

UppercasePGlyphID

endGlyphID

0002

2

class

classRangeRecords[2]
0037

UppercaseTGlyphID

startGlyphID

0037

UppercaseTGlyphID

endGlyphID

0001

1

class

classRangeRecords[3]
0039

UppercaseVGlyphID

startGlyphID

003A

UppercaseWGlyphID

endGlyphID

0001

1

class

classRangeRecords[4]
0042

LowercaseAGlyphID

startGlyphID

0042

LowercaseAGlyphID

endGlyphID

0003

3

class

classRangeRecords[5]
0046

LowercaseEGlyphID

startGlyphID

0046

LowercaseEGlyphID

endGlyphID

0003

3

class

classRangeRecords[6]
004A

LowercaseIGlyphID

startGlyphID

004A

LowercaseIGlyphID

endGlyphID

0003

3

class

classRangeRecords[7]
0051

LowercaseOGlyphID

startGlyphID

0051

LowercaseOGlyphID

endGlyphID

0003

3

class

classRangeRecords[8]
0056

LowercaseUGlyphID

startGlyphID

0056

LowercaseUGlyphID

endGlyphID

0003

3

class

classRangeRecords[9]
00F5

TildeAccentGlyphID

startGlyphID

00F6

UmlautAccentGlyphID

endGlyphID

0004

4

class

ClassSequenceRuleSet

ClassSequenceRuleSet table definition

UCWideOverhangPosClass1Set
0001

1

classSeqRuleCount

0004

UCWideOverhangPosClassRule

classSeqRuleOffsets[0]

ClassSequenceRule
UCWideOverhangPosClassRule

ClassSequenceRule table definition

0003

3

glyphCount

0001

1

seqLookupCount

0003

3

inputClassSequence[0] — lowercase vowel

0004

4

inputClassSequence[1] — accent

seqLookupRecords[0]
0002

2

sequenceIndex

0001

1

lookupListIndex — lower the accent

ClassSequenceRuleSet
UCNarrowOverhangPosClass2Set

ClassSequenceRuleSet table definition

0001

1

classSeqRuleCount

0004

UCNarrowOverhangPosClassRule

classSeqRuleOffsets[0]

ClassSequenceRule
UCNarrowOverhangPosClassRule

ClassSequenceRule table definition

0003

3

glyphCount

0001

1

seqLookupCount

0003

3

inputClassSequence[0] — lowercase vowel

0004

4

inputClassSequence[1] — accent

seqLookupRecords[0]
0000

0

sequenceIndex

0002

2

lookupListIndex — increase overhang advance width

Example 12: Contextual positioning format 3
Example 12 illustrates contextual positioning format 3 using a SequenceContextFormat3
subtable to lower the position of math signs in math equations consisting of a lowercase
descender or x-height glyph, a math sign glyph, and any lowercase glyph. Format 3 is
better to use for this context than the class-based Format 2 because the sets of covered
glyphs for positions 0 and 2 overlap.

The LowerMathSignsSubtable contains offsets to three Coverage tables
(XhtDescLCCoverage, MathSignCoverage, and LCCoverage), one for each position in the
context glyph string. When the client finds the context in the text stream, it applies the
SequenceLookupRecord data at position 1 and repositions the math sign.
Example 12
ﾉ

Hex Data

Expand table

Source

Comments

SequenceContextFormat3
LowerMathSignsSubtable

SequenceContextFormat3 subtable definition

0003

3

format

0003

3

glyphCount

0001

1

seqLookupCount

0010

XhtDescLCCoverage

coverageOffsets[0]

003C

MathSignCoverage

coverageOffsets[1]

0044

LCCoverage

coverageOffsets[2]

seqLookupRecords[0]
0001

1

sequenceIndex

0001

1

lookupListIndex

CoverageFormat1
XhtDescLCCoverage

Coverage table definition

0001

1

format: lists

0014

20

glyphCount

0033

LCaGlyphID

glyphArray[0]

0035

LCcGlyphID

glyphArray[1]

0037

LCeGlyphID

glyphArray[2]

0039

LCgGlyphID

glyphArray[3]

003B

LCiGlyphID

glyphArray[4]

003C

LCjGlyphID

glyphArray[5]

003F

LCmGlyphID

glyphArray[6]

0040

LCnGlyphID

glyphArray[7]

0041

LCoGlyphID

glyphArray[8]

0042

LCpGlyphID

glyphArray[9]

0043

LCqGlyphID

glyphArray[10]

0044

LCrGlyphID

glyphArray[11]

0045

LCsGlyphID

glyphArray[12]

0046

LCtGlyphID

glyphArray[13]

0047

LCuGlyphID

glyphArray[14]

0048

LCvGlyphID

glyphArray[15]

0049

LCwGlyphID

glyphArray[16]

004A

LCxGlyphID

glyphArray[17]

004B

LCyGlyphID

glyphArray[18]

004C

LCzGlyphID

glyphArray[19]

CoverageFormat1
MathSignCoverage

Coverage table definition

0001

1

format: lists

0002

2

glyphCount

011E

EqualsSignGlyphID

glyphArray[0]

012D

PlusSignGlyphID

glyphArray[1]

CoverageFormat2

Coverage table definition

LCCoverage
0002

2

format: ranges

0001

1

rangeCount

rangeRecords[0]
0033

LCaGlyphID

startGlyphID

004C

LCzGlyphID

endGlyphID

0000

0

startCoverageIndex

Example 13: SequenceLookup record
The SequenceLookup record in Example 13 identifies a lookup to apply at the second
glyph position in a context glyph string.
Example 13
ﾉ

Hex
Data

Expand table

Source

Comments

SequenceLookupRecord
seqLookupRecords[0]

SequenceLookupRecord definition

0001

1

sequenceIndex — for second glyph position

0001

1

lookupListIndex — apply this lookup to second glyph
position

Example 14: ValueFormat and ValueRecord
Example 14 demonstrates how to specify positioning values in the GPOS table. Here, a
SinglePosFormat1 subtable defines the ValueFormat and ValueRecord. The ValueFormat
bit setting of 0x0099 says that the corresponding ValueRecord contains values for a
glyph’s xPlacement and yAdvance. Device tables specify pixel adjustments for these
values at font sizes from 11 ppem to 15 ppem.
Example 14
ﾉ

Hex
Data

Source

Comments

SinglePosFormat1
OnesSubtable

SinglePos subtable definition

0001

1

format

000E

Cov

Offset to Coverage table

0099

0x0099

valueFormat: X_PLACEMENT + Y_ADVANCE +
X_PLACEMENT_DEVICE, Y_ADVANCE_DEVICE

valueRecord

Expand table

0050

80

xPlacement

00D2

210

yAdvance

0018

XPlaDeviceTable

xPlaDeviceOffset

0020

YAdvDeviceTable

yAdvDeviceOffset

CoverageFormat2
Cov

Coverage table definition

0002

2

format: ranges

0001

1

rangeCount

rangeRecords[0]
00C8

200

startGlyphID

00D1

209

endGlyphID

0000

0

startCoverageIndex

DeviceTableFormat1
XPlaDeviceTable

Device Table definition

000B

11

startSize

000F

15

endSize — five delta values (sizes 11 to 15)

0001

1

deltaFormat: LOCAL_2_BIT_DELTAS

1

deltaValue[0]: increase 11ppem by 1 pixel

1

deltaValue[1]: increase 12ppem by 1 pixel

1

deltaValue[2]: increase 13ppem by 1 pixel

1

deltaValue[3]: increase 14ppem by 1 pixel

1

deltaValue[4]: increase 15ppem by 1 pixel

DeviceTableFormat1
YAdvDeviceTable

Device Table definition

000B

11

startSize

000F

15

endSize — five delta values (sizes 11 to 15)

0001

1

deltaFormat: LOCAL_2_BIT_DELTAS

1

deltaValue[0]: increase 11ppem by 1 pixel

5540

5540

1

deltaValue[1]: increase 12ppem by 1 pixel

1

deltaValue[2]: increase 13ppem by 1 pixel

1

deltaValue[3]: increase 14ppem by 1 pixel

1

deltaValue[4]: increase 15ppem by 1 pixel

Example 15: AnchorFormat1 table
Example 15 illustrates an Anchor table for the damma mark glyph in the Arabic script.
Format1 is used to specify X and Y coordinate values in design units.
Example 15
ﾉ

Hex Data

Source

Comments

AnchorFormat1
dammaMarkAnchor

Anchor table definition

0001

1

format: design units only

00BD

189

xCoordinate

FF99

-103

yCoordinate

Expand table

Example 16: AnchorFormat2 table
Example 16 shows an AnchorFormat2 table for an attachment point placed above a base
glyph. With this format, the coordinate value for the Anchor depends on the final
position of a specific contour point on the base glyph after hinting. The coordinates are
specified in design units.
Example 16
ﾉ

Hex Data

0002

Source

Comments

AnchorFormat2
AboveBaseAnchor

Anchor table definition

2

format: design units plus contour point

Expand table

0142

322

xCoordinate

0384

900

yCoordinate

000D

13

anchorPoint — glyph contour point index

Example 17: AnchorFormat3 table
Example 17 shows an AnchorFormat3 table that specifies an attachment point above a
base glyph. Device tables modify the X and Y coordinates of the Anchor for the point
size and resolution of the output font. Here, the Device tables define pixel adjustments
for font sizes from 12 ppem to 17 ppem.
Example 17
ﾉ

Hex Data

Expand table

Source

Comments

AnchorFormat3
AboveBaseAnchor

Anchor table definition

0003

3

format: design units plus device table

0117

279

xCoordinate

0515

1301

yCoordinate

000A

XDevice

xDeviceOffset (may be NULL)

0014

YDevice

yDeviceOffset (may be NULL)

DeviceTableFormat2
XDevice

Device Table definition

000C

12

startSize

0011

17

endSize — six delta values (sizes 12 to 17)

0002

2

deltaFormat: LOCAL_4_BIT_DELTAS

1

deltaValue[0]: increase 12ppem by 1 pixel

1

deltaValue[1]: increase 13ppem by 1 pixel

1

deltaValue[2]: increase 14ppem by 1 pixel

1

deltaValue[3]: increase 15ppem by 1 pixel

1111

2

deltaValue[4]: increase 16ppem by 1 pixel

2

deltaValue[5]: increase 17ppem by 1 pixel

DeviceTableFormat2
YDevice

Device Table definition

000C

12

startSize

0011

17

endSize — six delta values (sizes 12 to 17)

0002

2

deltaFormat: LOCAL_4_BIT_DELTAS

1

deltaValue[0]: increase 12ppem by 1 pixel

1

deltaValue[1]: increase 13ppem by 1 pixel

1

deltaValue[2]: increase 14ppem by 1 pixel

1

deltaValue[3]: increase 15ppem by 1 pixel

2

deltaValue[4]: increase 16ppem by 1 pixel

2

deltaValue[5]: increase 17ppem by 1 pixel

2200

1111

2200

Example 18: MarkArray table and MarkRecord
Example 18 shows a MarkArray table with class and attachment point data for two
accent marks, a grave and a cedilla. Two MarkRecords are defined, one for each covered
mark glyph. The first MarkRecord assigns a mark class value of 0 to accents placed
above base glyphs, such as the grave, and has an offset to a graveMarkAnchor table.
The second MarkRecord assigns a mark class value of 1 for all accents positioned below
base glyphs, such as the cedilla, and has an offset to a cedillaMarkAnchor table.
Example 18
ﾉ

Hex Data

0002

0000

Expand table

Source

Comments

MarkArray
MarkGlyphsArray

MarkArray table definition

2

markCount

markRecords[0]

for first mark in markCoverage table: grave

0

markClass — for marks placed above base glyphs

000A

graveMarkAnchor

markAnchorOffset

markRecords[1]

for second mark in markCoverage table: cedilla

0001

1

markClass — for marks placed below base glyphs

0010

cedillaMarkAnchor

markAnchorOffset

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

GSUB — Glyph Substitution Table
Article • 05/29/2024

Overview
The Glyph Substitution (GSUB) table provides data for substitution of glyphs for
appropriate rendering of scripts, such as cursively-connecting forms in Arabic script, or
for advanced typographic effects, such as ligatures.
Many language systems require substitution of alternate glyph forms. For example, in
the Arabic script, the glyph shape that depicts a particular character varies according to
its position in a word or text string (see Figure 1). In other language systems, glyph
substitutes are aesthetic options for the user, such as the use of ligature glyphs in the
English language (see Figure 2).

Figure 1. Isolated, initial, medial, and final forms of the Arabic character HAH

Figure 2. Two Latin glyphs and their associated ligature
OpenType fonts use character encoding standards, such as the Unicode Standard, that
assumes a distinction between characters and glyphs: text is encoded as sequences of
characters, and the 'cmap' table provides a mapping from that character to a single
default glyph. Multiple characters are not directly mapped to a single glyph, as needed
for ligatures; and a single character is not mapped directly to multiple glyphs, as may be
needed for some complex-script scenarios. The GSUB table provides a way to describe
such substitutions, enabling applications to apply such substitutions during text layout
and rendering to achieve desired results.
To access substitute glyphs, GSUB maps from the glyph index or indices defined in a
'cmap' subtable to the glyph index or indices of the substitute glyphs. For example, if a
font has three alternative forms of an ampersand glyph, the 'cmap' table associates the
ampersand’s character code with only one of these glyphs. In GSUB, the indices of the
other ampersand glyphs are then referenced from this one default index.
The text-processing client uses the GSUB data to manage glyph substitution actions.
GSUB identifies the glyphs that are input to and output from each glyph substitution
action, specifies how and where the client uses glyph substitutes, and regulates the

order of glyph substitution operations. Any number of substitutions can be defined for
each script or language system represented in a font.
The GSUB table supports seven types of glyph substitutions that are widely used in
international typography:
A single substitution replaces a single glyph with another single glyph. This is used,
for example, to render positional glyph variants in Arabic and vertical text in East
Asia (see Figure 3).

Figure 3. Alternative forms of parentheses used when positioning Kanji vertically
A multiple substitution replaces a single glyph with more than one glyph. This is
used to specify actions such as ligature decomposition (see Figure 4).

Figure 4. Decomposing a Latin ligature glyph into its individual glyph components
An alternate substitution identifies functionally equivalent but different looking
forms of a glyph. These glyphs are often referred to as aesthetic alternatives. For
example, a font might have five different glyphs for the ampersand symbol, but
one would have a default glyph index in the 'cmap' table. The client could use the
default glyph or substitute any of the four alternatives (see Figure 5).

Figure 5. Alternative ampersand glyphs in a font
A ligature substitution replaces several glyph indices with a single glyph index, as
when an Arabic ligature glyph replaces a string of separate glyphs (see Figure 6).
When a string of glyphs can be replaced with a single ligature glyph, the first glyph
is substituted with the ligature. The remaining glyphs in the string are deleted, this
does not include those glyphs that are skipped as a result of lookup flags.

Figure 6. Three Arabic glyphs and their associated ligature glyph
Contextual substitution is an extension of the above lookup types, describing glyph
substitutions in context — that is, a substitution of one or more glyphs within a
certain pattern of glyphs. Each substitution describes one or more input glyph

sequences and one or more substitutions to be performed on that sequence.
Contextual substitutions can be applied to specific glyph sequences, glyph classes,
or sets of glyphs.
Chained contexts substitution extends the capabilities of contextual substitution. As
with contextual substitution, actions can be performed on one or more glyphs
within a pattern of glyphs—the input sequence. But the actions can be constrained
by chained glyph sequence contexts: a backtrack sequence that precedes the input
sequence, and a lookahead sequence that follows the input sequence. Three
formats allow the backtrack, input and lookahead sequence patterns to be
described using specific glyphs, glyph classes, or glyph sets.
Reverse Chaining contextual single substitution allows one glyph to be substituted
with another by chaining input glyph to a backtrack and/or lookahead sequence.
The difference between this and other lookup types is that processing of input
glyph sequence goes from end to start.
The GSUB data formats used to implement the different types of substitution include an
eighth type, substitution extension. This provides a format extension mechanism,
allowing reference to subtables using 32-bit offsets rather than 16-bit offsets. It does
not provide an additional type of substitution action, however.

GSUB table and OpenType Font Variations
OpenType Font Variations allow a single font to support many design variations along
one or more axes of design variation. For example, a font with weight and width
variations might support weights from thin to black, and widths from ultra-condensed
to ultra-expanded. For general information on OpenType Font Variations, see the
chapter, OpenType Font Variations Overview.
In a variable font, it may be desirable to have different glyph-substitution actions used
for different regions within the font’s variation space. For example, for narrow or heavy
instances in which counters become small, it may be desirable to make certain glyph
substitutions to use alternate glyphs with certain strokes removed or outlines simplified
to allow for larger counters. Such effects can be achieved using a FeatureVariations table
within the GSUB table. The FeatureVariations table is described in the chapter, OpenType
Layout Common Table Formats. See also the Required Variation Alternates ('rvrn')
feature in the OpenType Layout tag registry.

GSUB table organization

The GSUB table begins with a header that defines offsets to a ScriptList, a FeatureList, a
LookupList, and an optional FeatureVariations table (see Figure 7):
The ScriptList identifies all the scripts and language systems in the font that use
glyph substitutes.
The FeatureList defines all the glyph substitution features required to render these
scripts and language systems.
The LookupList contains all the lookup data needed to implement each glyph
substitution feature.
The FeatureVariations table can be used to substitute alternate sets of lookup
tables to use for any given feature under specified conditions. This is currently
used only in variable fonts.
For a detailed discussion of ScriptLists, FeatureLists, LookupLists, and FeatureVariation
tables, see the chapter, OpenType Layout Common Table Formats.

Figure 7. High-level organization of GSUB table

This organization helps text-processing clients to easily locate the features and lookups
that apply to a particular script or language system. To access GSUB information, clients
should use the following procedure:
1. Locate the current script in the GSUB ScriptList table.
2. If the language system is known, search the script for the correct LangSys table;
otherwise, use the script’s default LangSys table.
3. The LangSys table provides index numbers into the GSUB FeatureList table to
access a required feature and a number of additional features.
4. Inspect the featureTag of each feature, and select the feature tables to apply to an
input glyph string.
5. If a Feature Variations table is present, evaluate conditions in the Feature Variation
table to determine if any of the initially-selected feature tables should be
substituted by an alternate feature table.
6. Each feature table provides an array of index numbers into the GSUB LookupList
table. Assemble all lookups from the set of chosen features, and apply the lookups
in the order given in the LookupList table.
For a detailed description of the Feature Variations table and how it is processed, see
the FeatureVariations table section in the OpenType Layout Common Table Formats
chapter.
Lookup data is defined in Lookup tables, which are defined in the OpenType Layout
Common Table Formats chapter. A Lookup table contains one or more Lookup
subtables that define the specific conditions, type, and results of a substitution action
used to implement a feature. Specific Lookup subtable types are used for glyph
substitution actions, and are defined in this chapter. All subtables within a Lookup table
must be of the same lookup type, as listed in the following table for the
GsubLookupType enumeration:
GsubLookupType enumeration
ﾉ

Expand table

Value

Type

Description

1

Single

Replace one glyph with one glyph

2

Multiple

Replace one glyph with more than one glyph

3

Alternate

Replace one glyph with one of many glyphs

4

Ligature

Replace multiple glyphs with one glyph

5

Contextual substitution

Replace one or more glyphs in context

6

Chained contexts

Replace one or more glyphs in chained context

substitution
7

Substitution extension

Extension mechanism for other substitution types

8

Reverse chaining context
single

Applied in reverse order, replace single glyph in chained
contexts

Each lookup type has one or more subtable formats. The “best” format depends on the
type of substitution and the resulting storage efficiency. When glyph information is best
presented in more than one format, a single lookup may define more than one subtable,
as long as all the subtables are for the same lookup type. For example, within a given
lookup, a glyph index array format could best represent one set of target glyphs,
whereas a glyph index range format could be better for another set.
A series of substitution operations on the same glyph or string requires multiple
lookups, one for each separate action. Each lookup has a different array index in the
LookupList table and is applied in the LookupList order. The substitution action of each
lookup is applied to the results of previous lookups. Some substitution lookups could
“feed” later lookups by producing a glyph sequence that matches the input sequence
pattern of a later lookup that would not have matched the original glyph sequence. The
opposite is also possible: one substitution lookup produces a glyph sequence that does
not match the pattern of a later lookup that would have matched the original glyph
sequence. Thus, the ordering of lookups in the LookupList can be very significant.
During text processing, a client applies a lookup to each glyph in the string before
moving to the next lookup. A lookup is finished for a glyph after the client locates the
target glyph or glyph context and performs a substitution, if specified. To move to the
“next” glyph, the client will skip all the glyphs that participated in the lookup operation:
glyphs that were substituted as well as any other glyphs that formed an input sequence
context for the operation. Only glyphs in the input sequence are skipped; in the case of
chained contexts substitution, the glyphs in the lookahead sequence are not skipped.
The next section of this chapter describes the GSUB header and the subtables defined
for each GsubLookupType. Examples at the end of this chapter illustrate the GSUB
header and six of the eight LookupTypes, including the three formats available for
contextual substitutions (LookupType 5).

GSUB table structures
GSUB Header

The GSUB table begins with a header that contains a version number for the table and
offsets to three tables: ScriptList, FeatureList, and LookupList. For descriptions of each of
these tables, see the chapter, OpenType Layout Common Table Formats. Example 1 at
the end of this chapter shows a GSUB Header version 1.0 table definition.
GSUB Header, version 1.0
ﾉ

Expand table

Type

Name

Description

uint16

majorVersion

Major version of the GSUB table, = 1.

uint16

minorVersion

Minor version of the GSUB table, = 0.

Offset16

scriptListOffset

Offset to ScriptList table, from beginning of GSUB table.

Offset16

featureListOffset

Offset to FeatureList table, from beginning of GSUB table.

Offset16

lookupListOffset

Offset to LookupList table, from beginning of GSUB table.

GSUB Header, version 1.1
ﾉ

Expand table

Type

Name

Description

uint16

majorVersion

Major version of the GSUB table, = 1.

uint16

minorVersion

Minor version of the GSUB table, = 1.

Offset16

scriptListOffset

Offset to ScriptList table, from beginning of GSUB table.

Offset16

featureListOffset

Offset to FeatureList table, from beginning of GSUB table.

Offset16

lookupListOffset

Offset to LookupList table, from beginning of GSUB table.

Offset32

featureVariationsOffset

Offset to FeatureVariations table, from beginning of the
GSUB table (may be NULL).

Lookup type 1 subtable: single substitution
Single substitution (SingleSubst) subtables tell a client to replace a single glyph with
another glyph. The subtables can be either of two formats. Both formats require two
distinct sets of glyph indices: one that defines input glyphs (specified in the Coverage
table), and one that defines the output glyphs. Format 1 requires less space than format
2, but it is less flexible.

Single substitution format 1
Format 1 calculates the indices of the output glyphs, which are not explicitly defined in
the subtable. To calculate an output glyph index, format 1 adds a constant delta value to
the input glyph index. The input and output glyphs do not need to be in continuous
glyph ID ranges, but the delta between input glyph IDs and output glyph IDs need to be
constant. This format does not use the Coverage index that is returned from the
Coverage table.
The SingleSubstFormat1 subtable begins with a format identifier of 1. An offset
references a Coverage table that specifies the indices of the input glyphs. The
deltaGlyphID is a constant value added to each input glyph index to calculate the index
of the corresponding output glyph. Addition of deltaGlyphID is modulo 65536. If the
result after adding deltaGlyphID to the input glyph index is less than zero, add 65536 to
obtain a valid glyph ID.
Example 2 at the end of this chapter uses format 1 to replace standard numerals with
lining numerals.
SingleSubstFormat1 subtable
ﾉ

Expand table

Type

Name

Description

uint16

format

Format identifier: format = 1.

Offset16

coverageOffset

Offset to Coverage table, from beginning of substitution subtable.

int16

deltaGlyphID

Add to original glyph ID to get substitute glyph ID.

Single substitution format 2
Format 2 is more flexible than format 1 but requires more space. It provides an array of
output glyph indices (substituteGlyphIDs) explicitly matched to the input glyph indices
specified in the Coverage table.
The SingleSubstFormat2 subtable specifies a format identifier, an offset to a Coverage
table that defines the input glyph indices, and an array of output glyph indices
(substituteGlyphIDs).
The substituteGlyphIDs array must contain the same number of glyph indices as the
Coverage table, and the glyphs must be ordered to match the order of corresponding
input glyphs in the Coverage table. To locate the corresponding output glyph index in

the substituteGlyphIDs array, this format uses the Coverage index returned from the
Coverage table.
Example 3 at the end of this chapter uses format 2 to substitute vertically oriented
glyphs for horizontally oriented glyphs.
SingleSubstFormat2 subtable
ﾉ

Expand table

Type

Name

Description

uint16

format

Format identifier: format = 2.

Offset16

coverageOffset

Offset to Coverage table, from beginning of
substitution subtable.

uint16

glyphCount

Number of glyph IDs in the substituteGlyphIDs
array.

uint16

substituteGlyphIDs[glyphCount]

Array of substitute glyph IDs — ordered by
Coverage index.

Lookup type 2 subtable: multiple substitution
A multiple substitution (MultipleSubst) subtable replaces a single glyph with a sequence
of glyphs, as when multiple glyphs replace a single ligature. The subtable has a single
format.
Multiple substitution format 1
The MultipleSubstFormat1 subtable specifies a format identifier, an offset to a Coverage
table that defines the input glyph indices, and an array of offsets to Sequence tables
that define the output glyph indices. The Sequence table offsets are ordered by the
Coverage index of the input glyphs.
For each input glyph listed in the Coverage table, a Sequence table defines the output
glyphs. Each Sequence table contains a count of the glyphs in the output glyph
sequence and an array of output glyph indices.
Note: The order of the output glyph indices depends on the writing direction of the
text. For text written left to right, the left-most glyph will be first glyph in the
sequence. Conversely, for text written right to left, the right-most glyph will be first.

The use of multiple substitution for deletion of an input glyph is prohibited. The
glyphCount value must always be greater than 0.
Example 4 at the end of this chapter shows how to replace a single ligature with three
glyphs.
MultipleSubstFormat1 subtable
ﾉ

Expand table

Type

Name

Description

uint16

format

Format identifier: format = 1.

Offset16

coverageOffset

Offset to Coverage table, from beginning of
substitution subtable.

uint16

sequenceCount

Number of Sequence table offsets in the
sequenceOffsets array.

Offset16

sequenceOffsets[sequenceCount]

Array of offsets to Sequence tables. Offsets are
from beginning of substitution subtable, ordered
by Coverage index.

Sequence table
ﾉ

Expand table

Type

Name

Description

uint16

glyphCount

Number of glyph IDs in the substituteGlyphIDs array.
This must always be greater than 0.

uint16

substituteGlyphIDs[glyphCount]

String of glyph IDs to substitute.

Lookup type 3 subtable: alternate substitution
An alternate substitution (AlternateSubst) subtable identifies any number of aesthetic
alternatives from which a user can choose a glyph variant to replace the input glyph. For
example, if a font contains four variants of the ampersand symbol, the 'cmap' table will
specify the index of one of the four glyphs as the default glyph index, and an
AlternateSubst subtable will list the indices of the other three glyphs as alternatives. A
text-processing client would then have the option of replacing the default glyph with
any of the three alternatives.
The subtable has one format.

Alternate substitution format 1
The AlternateSubstFormat1 subtable contains a format identifier, an offset to a
Coverage table containing the indices of glyphs with alternative forms, and an array of
offsets to AlternateSet tables.
For each glyph in the Coverage table, an AlternateSet subtable contains a count of the
alternative glyphs and an array of their glyph indices. Because all the glyphs are
functionally equivalent, they can be in any order in the array.
Example 5 at the end of this chapter shows how to replace the default ampersand glyph
with alternative glyphs.
AlternateSubstFormat1 subtable
ﾉ

Expand table

Type

Name

Description

uint16

format

Format identifier: format = 1.

Offset16

coverageOffset

Offset to Coverage table, from beginning of
substitution subtable.

uint16

alternateSetCount

Number of AlternateSet tables

Offset16

alternateSetOffsets[alternateSetCount]

Array of offsets to AlternateSet tables. Offsets
are from beginning of substitution subtable,
ordered by Coverage index.

AlternateSet table
ﾉ

Expand table

Type

Name

Description

uint16

glyphCount

Number of glyph IDs in the alternateGlyphIDs array.

uint16

alternateGlyphIDs[glyphCount]

Array of alternate glyph IDs, in arbitrary order.

Lookup type 4 subtable: ligature substitution
A ligature substitution (LigatureSubst) subtable identifies ligature substitutions where a
single glyph replaces multiple glyphs. One LigatureSubst subtable can specify any
number of ligature substitutions. The subtable has one format.

Ligature substitution format 1
The LigatureSubstFormat1 subtable contains a format identifier, a Coverage table offset,
and an array of offsets to LigatureSet tables. The Coverage table specifies only the index
of the first glyph component of each ligature set.
Example 6 at the end of this chapter shows how to replace a string of glyphs with a
single ligature.
LigatureSubstFormat1 subtable
ﾉ

Expand table

Type

Name

Description

uint16

format

Format identifier: format = 1.

Offset16

coverageOffset

Offset to Coverage table, from beginning of
substitution subtable.

uint16

ligatureSetCount

Number of LigatureSet tables.

Offset16

ligatureSetOffsets[ligatureSetCount]

Array of offsets to LigatureSet tables. Offsets are
from beginning of substitution subtable,
ordered by Coverage index.

A LigatureSet table, one for each covered glyph, specifies all the ligature sequences that
begin with the covered glyph. For example, if the Coverage table lists the glyph index
for a lowercase “f,” then a LigatureSet table will define ligature that begin with “f”, such
as the “ffl”, “fl”, “ffi”, “fi” and “ff” ligatures. If the Coverage table also lists the glyph index
for a lowercase “e”, then a different LigatureSet table will define ligatures that begin with
“e”, such as the “etc” ligature.
A LigatureSet table consists of a count of the ligatures that begin with the covered glyph
and an array of offsets to Ligature tables, which define the glyphs in each ligature. The
order in the Ligature offset array defines the preference for using the ligatures. For
example, if the “ffl” ligature is preferable to the “ff” ligature, then the Ligature array
would list the offset to the “ffl” Ligature table before the offset to the “ff” Ligature table.
LigatureSet table
ﾉ

Type

Name

Description

uint16

ligatureCount

Number of Ligature tables.

Expand table

Offset16

ligatureOffsets[LigatureCount]

Array of offsets to Ligature tables. Offsets are from
beginning of LigatureSet table, ordered by preference.

For each ligature in the set, a Ligature table specifies the glyph ID of the output ligature
glyph; a count of the total number of component glyphs in the ligature, including the
first component; and an array of glyph IDs for the components. The array starts with the
second component glyph in the ligature (input glyph sequence index = 1,
componentGlyphIDs array index = 0) because the first component glyph is specified in
the Coverage table.
Note: The componentGlyphIDs array lists glyph IDs according to the writing
direction — that is, the logical order — of the text. For text written right to left, the
right-most glyph will be first. Conversely, for text written left to right, the left-most
glyph will be first.
Ligature table
ﾉ

Expand table

Type

Name

Description

uint16

ligatureGlyph

Glyph ID of ligature to substitute.

uint16

componentCount

Number of components in the ligature.

uint16

componentGlyphIDs[componentCount 1]

Array of component glyph IDs — start with
the second component, ordered in writing
direction.

Lookup type 5 subtable: contextual substitution
A contextual substitution subtable describes glyph substitutions in context that replace
one or more glyphs within a certain pattern of glyphs.
Contextual substitution subtables can use any of three formats that are common to the
GSUB and GPOS tables. These define input sequence patterns to be matched against the
text glyph sequence, and then actions to be applied to glyphs within the input
sequence. The actions are specified as “nested” lookups, and each is applied to a
particular sequence position within the input sequence.
Each sequence position + nested lookup combination is specified in a
SequenceLookupRecord. Examples 7, 8, and 9 at the end of this chapter illustrate use of
sequence lookup records within the GSUB table.

While the subtable formats are common between the GSUB and GPOS tables, the
lookups referenced by sequence lookup records within the GSUB table are referenced
by index into the GSUB LookupList table. In this way, actions specified by a GSUB
contextual lookup can only be substitutions.
An input sequence pattern is matched against the current glyph sequence before any
substitution actions are performed. The substitutions may change the current glyph
sequence, but that has no effect on the initial matching operation. For a given lookup
subtable, there may be multiple sequence lookup records, and these are processed in
the specified order. Each substitution action on the glyph sequence applies to the
results from the preceding sequence lookup records. Note in particular that the
sequence position index in each sequence lookup record is relative to the glyph
sequence as modified by the actions of preceding SequenceLookupRecords.
For example, consider a contextual lookup specifying an input glyph sequence of four
glyphs. Suppose that no substitution is performed on the first glyph, but that the middle
two glyphs will be replaced with a ligature, and a single glyph will replace the fourth
glyph. Suppose also that the actions are listed in that order.
The first glyph is at sequence position 0. No SequenceLookupRecord is specified
for sequence index 0.
The first SequenceLookupRecord specifies sequence position 1 and gives a
LookupList index referencing a ligature substitution lookup. The first glyph
specified in the nested lookup will be the glyph at sequence position 1; the second
glyph specified in the nested lookup will be the glyph at sequence position 2. After
the nested substitution has been performed, there will be three glyphs in the
sequence context, not four.
The last SequenceLookupRecord is defined in terms of the modified sequence
context, specifying sequence position 2, not position 3. The nested singlesubstitution lookup will specify the glyph at position 2 as its input glyph.
Contextual substitution format 1: simple glyph contexts
Format 1 defines the context for a glyph substitution as a particular sequence of glyphs.
For example, a context could be <xyz>, <holiday>, <!?*#@>, or any other glyph
sequence.
For example, suppose the glyph string <abc> is to be replaced with its reverse glyph
string <cba>. The input context would be defined as the glyph sequence, <abc>. Two
single-substitution actions can be specified: the “a” at sequence position 0 is substituted
by “c”, and the “c” at sequence position 2 is substituted by “a”.

Format 1 contextual substitutions are implemented using a SequenceContextFormat1
table. See Sequence context format 1: simple glyph contexts in the OpenType Layout
Common Table Formats chapter for complete details.
Example 7 at the end of the chapter uses a SequenceContextFormat1 table to replace a
sequence of three glyphs with a sequence preferred for the French language system.
Contextual substitution format 2: class-based glyph contexts
Format 2 defines contexts for glyph substitutions as input sequence patterns, with
patterns expressed in terms of glyph classes. The glyph classes are defined using a Class
Definition table. Several sequence patterns may be specified, with each pattern
specifying a class of glyphs for each input sequence position.
For example, suppose that a swash capital glyph should replace each uppercase letter
glyph that is preceded by a space glyph and followed by a lowercase letter glyph (a
glyph sequence of space - uppercase - lowercase). The set of uppercase glyphs would
constitute one glyph class (class 1), the set of lowercase glyphs would constitute a
second class (class 2), and the space glyph would constitute a third class (class 3). The
input context might be specified as a pattern of one glyph from class 3, followed by one
glyph from class 1, followed by one glyph from class 2.
Format 2 contextual substitutions are implemented using a SequenceContextFormat2
table. See Sequence context format 2: class-based glyph contexts in the OpenType
Layout Common Table Formats chapter for complete details.
Example 8 at the end of this chapter uses a SequenceContextFormat2 table to substitute
Arabic mark glyphs for base glyphs of different heights.
Contextual substitution format 3: coverage-based glyph contexts
Format 3 defines a context for glyph substitutions as an input sequence pattern, with
the pattern expressed in terms of Coverage tables. A different Coverage table is defined
for each sequence position.
Format 3 is like format 2 in that patterns are defined using sets of glyphs. However, with
the glyph classes used in format 2, each glyph is in exactly one class. With format 3, any
glyph can occur in multiple Coverage tables.
Unlike Formats 1 and 2, however, this format can define only one context.
For example, consider an input context that contains a lowercase glyph (position 0),
followed by an uppercase glyph (position 1), either a lowercase or numeral glyph
(position 2), and then either a lowercase or uppercase vowel (position 3). This context
requires four Coverage tables, one for each position:

For position 0, the Coverage table lists the set of lowercase glyphs.
For position 1, the Coverage table lists the set of uppercase glyphs.
For position 2, the Coverage table lists the set of lowercase and numeral glyphs, a
superset of the glyphs defined in the Coverage table for position 0.
For position 3, the Coverage table lists the set of lowercase and uppercase vowels,
a subset of the glyphs defined in the Coverage tables for both positions 0 and 1.
Format 3 contextual substitutions are implemented using a SequenceContextFormat3
table. See Sequence context format 3: coverage-based glyph contexts in the OpenType
Layout Common Table Formats chapter for complete details.
Example 9 at the end of this chapter uses SequenceContextFormat3 to substitute swash
glyphs for two out of three glyphs in a sequence.

Lookup type 6 subtable: chained contexts substitution
A chained contexts substitution subtable describes glyph substitutions in context with
an ability to look back and/or look ahead in the sequence of glyphs. The design of the
chained contexts substitution subtable is parallel to that of the contextual substitution
subtable, including the availability of three formats. Each format can describe one or
more chained backtrack, input, and lookahead sequence combinations, and one or more
substitutions for glyphs in each input sequence.
Note: Substitutions can be specified only for the input sequence context, not for
backtrack and lookahead sequences.
See the introduction to the Contextual substitution section for general remarks
regarding contextual substitutions, which also apply to chained contexts substitutions.
Note that backtrack sequences are specified in reverse logical order. See the Chained
sequence context format 1 section in the OpenType Layout Common Table Formats
chapter for details regarding chained backtrack, input, and lookahead sequences.
Chained contexts substitution format 1: simple glyph contexts
Format 1 defines the context for a glyph substitution as a particular sequence of glyphs.
For example, a context could be <xyz>, <holiday>, <!?*#@>, or any other glyph
sequence. Specific glyph sequences are used for input, backtrack or lookahead contexts.
Format 1 chained context substitutions are implemented using a
ChainedSequenceContextFormat1 table. See Chained sequence context format 1: simple
glyph contexts in the OpenType Layout Common Table Formats chapter for complete
details.

Chained contexts substitution format 2: class-based glyph contexts
Format 2 defines contexts for glyph substitutions as patterns expressed in terms of
glyph classes. The glyph classes are defined using a Class Definition table. Several
sequence patterns may be specified, with each pattern specifying a class of glyphs for
each sequence position.
To chain contexts, three separate Class Definition tables are used for the backtrack
sequence, input sequence, and lookahead sequence.
Format 2 contextual substitutions are implemented using a
ChainedSequenceContextFormat2 table. See Chained sequence context format 2: classbased glyph contexts in the OpenType Layout Common Table Formats chapter for
complete details.
Chained contexts substitution format 3: coverage-based glyph contexts
Format 3 defines contexts for glyph substitutions as patterns expressed in terms of
Coverage tables. A different Coverage table is defined for each position in a sequence.
To chain contexts, three separate sets of Coverage tables are used for the backtrack
sequence, input sequence, and lookahead sequence.
Format 3 is like format 2 in that patterns are defined using sets of glyphs. However, with
the glyph classes used in format 2, each glyph is in exactly one class. With format 3, any
glyph can occur in multiple Coverage tables.
Format 3 contextual substitutions are implemented using a
ChainedSequenceContextFormat3 table. See Chained sequence context format 3:
coverage-based glyph contexts in the OpenType Layout Common Table Formats chapter
for complete details.

Lookup type 7 subtable: substitution subtable extension
This lookup type provides a way to access lookup subtables within the GSUB table using
32-bit offsets. This is needed if the total size of the subtables exceeds the 16-bit limits of
the various other offsets in the GSUB table. In this specification, the subtable stored at
the 32-bit offset location is termed the “extension” subtable.
This subtable type uses one format.
Substitution extension format 1
SubstExtensionFormat1 subtable

ﾉ

Expand table

Type

Name

Description

uint16

format

Format identifier. Set to 1.

uint16

extensionLookupType

Lookup type of subtable referenced by extensionOffset (that
is, the extension subtable).

Offset32

extensionOffset

Offset to the extension subtable, of lookup type
extensionLookupType, relative to the start of the
ExtensionSubstFormat1 subtable.

The extensionLookupType field must be set to any lookup type other than 7. If a lookup
table uses extension subtables, then all of the extension subtables must have the same
extensionLookupType. All offsets to extension subtables are set in the usual way—that
is, relative to start of the ExtensionSubstFormat1 subtable.
When a layout engine encounters a GSUB type 7 Lookup table, it shall:
Proceed as though the Lookup table’s lookupType field were set to the
extensionLookupType of the subtables.
Proceed as though each extension subtable referenced by extensionOffset
replaced the type 7 subtable that referenced it.

Lookup type 8 subtable: reverse chained contexts single
substitution
The reverse chaining contextual single substitution subtable (ReverseChainSingleSubst)
describes single-glyph substitutions in context with an ability to look back and/or look
ahead in the sequence of glyphs. The major difference between this and other lookup
types is that processing of input glyph sequence goes from end to start.
Compared to chained contexts substitution (lookup subtable type 6), this format is
restricted to only a coverage-based subtable format, input sequences can contain only a
single glyph, and only single substitutions are allowed on this glyph. This constraint is
integrated into the subtable format.
This lookup type is designed specifically for Arabic script writing styles like Nastaliq in
which the shape of the glyph is determined by the following glyph, beginning at the last
glyph of the “joor”, or set of connected glyphs.
This subtable type uses one format.
Reverse chained contexts single substitution format 1: coverage-based glyph contexts

Format 1 defines a chaining context rule as a sequence of Coverage tables. Each
position in the sequence may define a different Coverage table for the set of glyphs that
matches the context pattern. With format 1, the glyph sets defined in the different
Coverage tables may intersect.
Despite reverse order processing, the order of the Coverage tables listed in the
Coverage array must be in logical order (follow the writing direction). The backtrack
sequence is as illustrated for the Chained sequence context format 1 table, in the
OpenType Layout Common Table Formats chapter. The input sequence is one glyph
located at i in the logical string. The backtrack begins at i - 1 and increases in offset
value as one moves toward the logical beginning of the string. The lookahead sequence
begins at i + 1 and increases in offset value as one moves toward the logical end of the
string. In processing a reverse chaining substitution, i begins at the logical end of the
string and moves to the beginning.
The subtable contains a Coverage table for the input glyph and Coverage table arrays
for backtrack and lookahead sequences. It also contains an array of substitute glyph
indices (substituteGlyphIDs), which are substitutions for glyphs in the Coverage table,
and a count of glyphs in the substituteGlyphIDs array. The substituteGlyphIDs array
must contain the same number of glyph indices as the Coverage table. To locate the
corresponding output glyph index in the substituteGlyphIDs array, this format uses the
Coverage index returned from the Coverage table.
Example 10 at the end of this chapter uses ReverseChainSingleSubstFormat1 to
substitute Arabic glyphs with a correct stroke thickness on the left (exit) to match the
stroke thickness on the right (entry) of the following glyph (in logical order).
ReverseChainSingleSubstFormat1 subtable
ﾉ

Expand table

Type

Name

Description

uint16

format

Format identifier: format = 1.

Offset16

coverageOffset

Offset to Coverage table, from
beginning of substitution
subtable.

uint16

backtrackGlyphCount

Number of glyphs in the
backtrack sequence.

Offset16

backtrackCoverageOffsets[backtrackGlyphCount]

Array of offsets to coverage
tables in backtrack sequence, in
glyph sequence order.

uint16

lookaheadGlyphCount

Number of glyphs in lookahead
sequence.

Offset16

lookaheadCoverageOffsets[lookaheadGlyphCount]

Array of offsets to coverage
tables in lookahead sequence, in
glyph sequence order.

uint16

glyphCount

Number of glyph IDs in the
substituteGlyphIDs array.

uint16

substituteGlyphIDs[glyphCount]

Array of substitute glyph IDs —
ordered by Coverage index.

GSUB structure examples
The rest of this chapter describes and illustrates examples of the various GSUB
subtables, including each of the three formats available for contextual substitutions. All
the examples reflect unique parameters described below, but the samples provide a
useful reference for building subtables specific to other situations.
All the examples have three columns showing hex data, source, and comments.

Example 1: GSUB Header
Example 1 shows a typical GSUB Header table definition.
Example 1
ﾉ

Hex Data

Source

Comments

GSUBHeader
TheGSUBHeader

GSUBHeader table definition

00010000

0x00010000

major/minor version

000A

TheScriptList

offset to ScriptList table

001E

TheFeatureList

offset to FeatureList table

002C

TheLookupList

offset to LookupList table

Example 2: SingleSubstFormat1 subtable

Expand table

Example 2 illustrates the SingleSubstFormat1 subtable , which uses ranges to replace
single input glyphs with their corresponding output glyphs. The indices of the output
glyphs are calculated by adding a constant delta value to the indices of the input glyphs.
In this example, the Coverage table has a format identifier of 2 to indicate the range
format, which is used because the input glyph indices are in consecutive order in the
font. The Coverage table specifies one range that contains a startGlyphID for the “0”
(zero) glyph and an endGlyphID for the “9” glyph.
Example 2
ﾉ

Hex
Data

Expand table

Source

Comments

SingleSubstFormat1
LiningNumeralSubtable

SingleSubst subtable definition

0001

1

format: calculated output glyph indices

0006

LiningNumeralCoverage

offset to Coverage table for input glyphs

00C0

192

deltaGlyphID = 192: add to each input glyph index to
produce output glyph index

CoverageFormat2

Coverage table definition

LiningNumeralCoverage
0002

2

coverageFormat: ranges

1

rangeCount

rangeRecords[0]
004E

78

Start glyph ID for numeral zero glyph

0058

87

End glyph ID for numeral nine glyph

0000

0

startCoverageIndex: first CoverageIndex = 0

Example 3: SingleSubstFormat2 subtable
Example 3 uses the SingleSubstFormat2 subtable for lists to substitute punctuation
glyphs in Japanese text that is written vertically. Horizontally oriented parentheses and
square brackets (the input glyphs) are replaced with vertically oriented parentheses and
square brackets (the output glyphs).

The Coverage table, format 1, identifies each input glyph index. The number of input
glyph indices listed in the Coverage table matches the number of output glyph indices
listed in the subtable. For correct substitution, the order of the glyph indices in the
Coverage table (input glyphs) must match the order in the Substitute array (output
glyphs).
Example 3
ﾉ

Hex
Data

Expand table

Source

Comments

SingleSubstFormat2
VerticalPunctuationSubtable

SingleSubst subtable definition

0002

2

format: lists

000E

VerticalPunctuationCoverage

offset to Coverage table

0004

4

glyphCount — equals glyphCount in Coverage
table

0131

VerticalOpenBracketGlyph

substituteGlyphIDs[0], ordered by Coverage
index

0135

VerticalClosedBracketGlyph

substituteGlyphIDs[1]

013E

VerticalOpenParenthesisGlyph

substituteGlyphIDs[2]

0143

VerticalClosedParenthesisGlyph

substituteGlyphIDs[3]

CoverageFormat1
VerticalPunctuationCoverage

Coverage table definition

0001

1

coverageFormat: lists

0004

4

glyphCount

003C

HorizontalOpenBracketGlyph

glyphArray[0], ordered by glyph ID

0040

HorizontalClosedBracketGlyph

glyphArray[1]

004B

HorizontalOpenParenthesisGlyph

glyphArray[2]

004F

HorizontalClosedParenthesisGlyph

glyphArray[3]

Example 4: MultipleSubstFormat1 subtable

Example 4 uses a MultipleSubstFormat1 subtable to replace a single “ffi” ligature with
three individual glyphs that form the string <ffi>. The subtable defines a format
identifier of 1, an offset to a Coverage table that specifies the glyph index of the “ffi”
ligature (the input glyph), an offset to a Sequence table that specifies the sequence of
glyph indices for the <ffi> string in its substitute array (the output glyph sequence), and
a count of Sequence table offsets.
Example 4
ﾉ

Hex Data

Source

Comments

MultipleSubstFormat1

MultipleSubst subtable definition

Expand table

FfiDecompSubtable
0001

1

format

0008

FfiDecompCoverage

offset to Coverage table

0001

1

sequenceCount — equals glyphCount in Coverage table

000E

FfiDecompSequence

sequenceOffsets[0] (offset to Sequence table 0)

CoverageFormat1

Coverage table definition

FfiDecompCoverage
0001

1

coverageFormat: lists

0001

1

glyphCount

00F1

ffiGlyphID

ligature glyph

Sequence
FfiDecompSequence

Sequence table definition

0003

3

glyphCount

001A

fGlyphID

first glyph in sequence order

001A

fGlyphID

second glyph

001D

iGlyphID

third glyph

Example 5: AlternateSubstFormat 1 subtable
Example 5 uses the AlternateSubstFormat1 subtable to replace the default ampersand
glyph (input glyph) with one of two alternative ampersand glyphs (output glyph).

In this case, the Coverage table specifies the index of a single glyph, the default
ampersand, because it is the only glyph covered by this lookup. The AlternateSet table
for this covered glyph identifies the alternative glyphs: AltAmpersand1GlyphID and
AltAmpersand2GlyphID.
In Example 5, the index position of the AlternateSet table offset in the AlternateSet array
is zero (0), which correlates with the index position (also zero) of the default ampersand
glyph in the Coverage table.
Example 5
ﾉ

Hex
Data

Expand table

Source

Comments

AlternateSubstFormat1
AltAmpersandSubtable

AlternateSubstFormat1 subtable definition

0001

1

format

0008

AltAmpersandCoverage

offset to Coverage table

0001

1

alternateSetCount — equals glyphCount in Coverage
table

000E

AltAmpersandSet

alternateSetOffsets[0] (offset to AlternateSet table 0)

CoverageFormat1
AltAmpersandCoverage

Coverage table definition

0001

1

coverageFormat: lists

0001

1

glyphCount

003A

DefaultAmpersandGlyphID

glyphArray[0]

AlternateSet

AlternateSet table definition

AltAmpersandSet
0002

2

glyphCount

00C9

AltAmpersand1GlyphID

alternateGlyphIDs[0] — glyphs in arbitrary order

00CA

AltAmpersand2GlyphID

alternateGlyphIDs[1]

Example 6: LigatureSubstFormat1 subtable

Example 6 shows a LigatureSubstFormat1 subtable that defines data to replace a string
of glyphs with a single ligature glyph. Because a LigatureSubstFormat1 subtable can
specify glyph substitutions for more than one ligature, this subtable defines three
ligatures: “etc”, “ffi”, and “fi.”
The sample subtable contains a format identifier (4) and an offset to a Coverage table.
The Coverage table, which lists an index for each first glyph in the ligatures, lists indices
for the “e” and “f” glyphs. The Coverage table range format is used here because the “e”
and “f” glyph indices are numbered consecutively.
In the LigatureSubst subtable, ligatureSetCount specifies two LigatureSet tables, one for
each covered glyph, and the ligatureSetOffsets array stores offsets to them. In this array,
the “e” LigatureSet precedes the “f” LigatureSet, matching the order of the
corresponding first-glyph components in the Coverage table.
Each LigatureSet table identifies all ligatures that begin with a covered glyph. The
sample LigatureSet table defined for the “e” glyph contains only one ligature, “etc.” A
LigatureSet table defined for the “f” glyph contains two ligatures, “ffi” and “fi.”
The sample FLigaturesSet table has offsets to two Ligature tables, one for “ffi” and one
for “fi.” The ligatureOffsets array lists the “ffi” Ligature table first to indicate that the “ffi”
ligature is preferred to the “fi” ligature.
Example 6
ﾉ

Hex
Data

Expand table

Source

Comments

LigatureSubstFormat1
LigaturesSubtable

LigatureSubstFormat1 subtable definition

0001

1

format

000A

LigaturesCoverage

offset to Coverage table

0002

2

ligatureSetCount

0014

ELigaturesSet

ligatureSetOffsets[0] (offset to LigatureSet table 0) —
LigatureSet tables in Coverage index order

0020

FLigaturesSet

ligatureSetOffsets[1]

CoverageFormat2
LigaturesCoverage

Coverage table definition

0002

2

coverageFormat: ranges

0001

1

rangeCount

rangeRecords[0]
0019

eGlyphID

Start, first glyph ID

001A

fGlyphID

End, last glyph ID in range

0000

0

startCoverageIndex: coverage index of start glyph ID = 0

LigatureSet
ELigaturesSet

LigatureSet table definition — all ligatures that start with e

0001

1

ligatureCount

0004

etcLigature

ligatureOffsets[0] (offset to Ligature table 0)

Ligature
etcLigature

Ligature table definition

015B

etcGlyphID

ligatureGlyph — output glyph ID

0003

3

componentCount

0028

tGlyphID

componentGlyphIDs[0] — second component in ligature

0017

cGlyphID

componentGlyphIDs[1] — third component in ligature

LigatureSet
FLigaturesSet

LigatureSet table definition all ligatures start with f

0002

2

ligatureCount

0006

ffiLigature

ligatureOffsets[0] — listed first because ffi ligature is preferred
to fi ligature

000E

fiLigature

ligatureOffsets[1]

Ligature
ffiLigature

Ligature table definition

00F1

ffiGlyphID

ligatureGlyph — output glyph ID

0003

3

componentCount

001A

fGlyphID

componentGlyphIDs[0] — second component in ligature

001D

iGlyphID

componentGlyphIDs[1] — third component in ligature

Ligature
fiLigature

Ligature table definition

00F0

fiGlyphID

ligatureGlyph — output glyph ID

0002

2

componentCount

001D

iGlyphID

componentGlyphIDs[0] — second component in ligature

Example 7: Contextual substitution format 1
Example 7 illustrates format 1 contextual substitution, using a SequenceContextFormat1
subtable to replace a string of three glyphs with another string. For the French language
system, the subtable defines a contextual substitution that replaces the input sequence,
space-dash-space, with the output sequence, thin space-dash-thin space.
The contextual substitution, called Dash Lookup in this example, contains one
SequenceContextFormat1 subtable called the DashSubtable. The subtable specifies two
contexts: a SpaceGlyph followed by a DashGlyph, and a DashGlyph followed by a
SpaceGlyph. In each sequence, a single substitution replaces the SpaceGlyph with a
ThinSpaceGlyph.
The Coverage table, labeled DashCoverage, lists two glyph IDs for the first glyphs in the
SpaceGlyph and DashGlyph sequences. One SequenceRuleSet table is defined for each
covered glyph.
SpaceAndDashSubRuleSet lists all the contexts that begin with a SpaceGlyph. It contains
an offset to one SequenceRule table (SpaceAndDashSubRule), which specifies two
glyphs in the context sequence, the second of which is a DashGlyph. The SequenceRule
table contains a SequenceLookupRecord that lists the position in the sequence where
the glyph substitution should occur (position 0) and the index of the
SpaceToThinSpaceLookup applied there to replace the SpaceGlyph with a
ThinSpaceGlyph. DashAndSpaceSubRuleSet lists all the contexts that begin with a
DashGlyph. An offset points to a SequenceRule table (DashAndSpaceSubRule), which
specifies two glyphs in the context sequence, and the second one is a SpaceGlyph. The
SequenceRule table contains a SequenceLookupRecord that lists the position in the
sequence where the glyph substitution should occur, and an index to the same lookup
used in the SpaceAndDashSubRule. The lookup replaces the SpaceGlyph with a
ThinSpaceGlyph.
Example 7
ﾉ

Hex
Data

Source

Comments

Expand table

SequenceContextFormat1
DashSubtable

SequenceContextFormat1 subtable definition for
Lookup[0], DashLookup

0001

1

format

000A

DashCoverage

offset to Coverage table

0002

2

seqRuleSetCount

0012

SpaceAndDashSubRuleSet

seqRuleSetOffsets[0] (offset to SequenceRuleSet table 0) —
SequenceRuleSets ordered by Coverage index

0020

DashAndSpaceSubRuleSet

seqRuleSetOffsets[1]

CoverageFormat1
DashCoverage

Coverage table definition

0001

1

coverageFormat: lists

0002

2

glyphCount

0028

SpaceGlyph

glyphArray[0] — glyphs in numeric order

005D

DashGlyph

glyphArray[1], dash glyph ID

SequenceRuleSet

SequenceRuleSet[0] table definition

SpaceAndDashSubRuleSet
0001

1

seqRuleCount

0004

SpaceAndDashSubRule

seqRuleOffsets[0] (offset to SequenceRule table 0) —
SequenceRule tables ordered by preference

SequenceRule
SpaceAndDashSubRule

SequenceRule[0] table definition

0002

2

glyphCount — number in input sequence

0001

1

seqLookupCount

005D

DashGlyph

inputSequence[0], starting with second glyph —
SpaceGlyph, in Coverage table, is first glyph

seqLookupRecords[0]
0000

0

sequenceIndex — substitution at first glyph position (0)

0001

1

lookupListIndex — index for SpaceToThinSpaceLookup in
LookupList

SequenceRuleSet
DashAndSpaceSubRuleSet

SequenceRuleSet[1] table definition

0001

1

seqRuleCount

0004

DashAndSpaceSubRule

seqRuleOffsets[0] (offset to SequenceRule table 0) —
SequenceRule tables ordered by preference

SequenceRule

SequenceRule[0] table definition

DashAndSpaceSubRule
0002

2

glyphCount — number in the input glyph sequence

0001

1

seqLookupCount

0028

SpaceGlyph

inputSequence[0] — starting with second glyph

seqLookupRecords[0]
0001

1

sequenceIndex — substitution at second glyph position
(glyph sequence index = 1)

0001

1

lookupListIndex — index for SpaceToThinSpaceLookup

Example 8: Contextual substitution format 2
Example 8 illustrates a format 2 contextual substitution using a
SequenceContextFormat2 subtable with glyph classes to replace default mark glyphs
with their alternative forms. Glyph alternatives are selected depending upon the height
of the base glyph that they combine with; that is, the mark glyph used above a high
base glyph differs from the mark glyph above a very high base glyph.
In the example, SetMarksHighSubtable contains a Class Definition table that defines four
glyph classes: default mark glyphs (class 1), high base glyphs (class 2), very high base
glyphs (class 3), and all remaining glyphs, including medium-height base glyphs. The
subtable also contains a Coverage table that lists each base glyph that functions as a
first component in a context, ordered by glyph index.
Two ClassSequenceRuleSet tables are defined, one for substituting high marks and one
for very high marks. No ClassSequenceRuleSets are specified for class 0 and class 1
glyphs because no contexts begin with glyphs from these classes. The
classSeqRuleSetOffsets lists offsets to the ClassSequenceRuleSet tables in class value
order, so the offset for ClassSequenceRuleSet for class 2 precedes that for class 3.
Within each ClassSequenceRuleSet, a ClassSequencRule is defined. In
SetMarksHighSubClassSet2, corresponding to contexts that begin with a glyph in class
2, the ClassSequenceRule table specifies an input sequence with two glyphs: the first
glyph in class 2 (a high glyph), and the second in class 1 (a mark glyph). The

SequenceLookupRecord specifies applying SubstituteHighMarkLookup at the second
position in the sequence—that is, a high mark glyph will replace the default mark glyph.
In SetMarksVeryHighSubClassSet3, corresponding to contexts that begin with a glyph in
class 3, the ClassSequencRule specifies an input sequence with two glyphs: the first in
class 3 (a very high glyph), and the second in class 1 (a mark glyph). The
SequenceLookupRecord specifies applying SubstituteVeryHighMarkLookup at the
second position in the sequence—that is, a very high mark glyph will replace the default
mark glyph.
Example 8
ﾉ

Hex
Data

Expand table

Source

Comments

SequenceContextFormat2
SetMarksHighSubtable

SequenceContextFormat2 subtable definition

0002

2

format

0010

SetMarksHighCoverage

offset to Coverage table

001C

SetMarksHighClassDef

offset to Class Def table

0004

4

classSeqRuleSetCount

0000

NULL

classSeqRuleSetOffsets[0] — NULL: no contexts that
begin with Class 0 glyphs are defined

0000

NULL

classSeqRuleSetOffsets[1] — no contexts that begin
with Class 1 glyphs are defined

0032

SetMarksHighSubClassSet2

classSeqRuleSetOffsets[2] — offset to
ClassSequencRuleSet table for contexts that begin
with Class 2 glyphs (high base glyphs)

0040

SetMarksVeryHighSubClassSet3

classSeqRuleSetOffsets[3] — offset to
ClassSequencRuleSet table for contexts that begin
with Class 3 glyphs (very high base glyphs)

CoverageFormat1
SetMarksHighCoverage

Coverage table definition

0001

1

coverageFormat: lists

0004

4

glyphCount

0030

tahGlyphID

glyphArray[0], high base glyph

0031

dhahGlyphID

glyphArray[1], high base glyph

0040

cafGlyphID

glyphArray[2], very high base glyph

0041

gafGlyphID

glyphArray[3], very high base glyph

ClassDefFormat2
SetMarksHighClassDef

Class table definition

0002

2

classFormat: ranges

0003

3

classRangeCount

classRangeRecords[0]

ClassRangeRecords ordered by startGlyphID; record
for Class 2, high base glyphs

0030

tahGlyphID

Start, first Glyph ID in range

0031

dhahGlyphID

End, last Glyph ID in range

0002

2

class: 2

classRangeRecords[1]

ClassRangeRecord for Class 3, very high base glyphs

0040

cafGlyphID

Start, first Glyph ID in the range

0041

gafGlyphID

End, last Glyph ID in the range

0003

3

class: 3
ClassRange[2] for Class 1, mark gyphs

classRangeRecords[2]

ClassRangeRecord for Class 1, mark glyphs

00D2

fathatanDefaultGlyphID

Start, first Glyph ID in range default fathatan mark

00D3

dammatanDefaultGlyphID

End, last Glyph ID in the range default dammatan
mark

0001

1

class: 1

ClassSequencRuleSet
SetMarksHighSubClassSet2

ClassSequencRuleSet[2] table definition— all contexts
that begin with Class 2 glyphs

0001

1

classSeqRuleCount

0004

SetMarksHighSubClassRule2

classSeqRuleOffsets[0] (offset to ClassSequenceRule
table 0) — ClassSequenceRule tables ordered by
preference

ClassSequenceRule
SetMarksHighSubClassRule2

ClassSequenceRule[0] table definition, Class 2 glyph
(high base) glyph followed by a Class 1 glyph (mark)

2

glyphCount

0002

0001

1

seqLookupCount

0001

1

inputSequence[0] — input sequence beginning with
the second Class in the input context sequence; Class
1, mark glyphs

0001

seqLookupRecords[0]

seqLookupRecords array in design order

1

sequenceIndex — apply substitution to position 2, a
mark

0001

1

lookupListIndex

ClassSequencRuleSet

ClassSequencRuleSet[3] table definition — all

SetMarksVeryHighSubClassSet3

contexts that begin with Class 3 glyphs

0001

1

classSeqRuleCount

0004

SetMarksVeryHighSubClassRule3

classSeqRuleOffsets[0]

ClassSequenceRule
SetMarksVeryHighSubClassRule3

ClassSequenceRule[0] table definition — Class 3
glyph (very high base glyph) followed by a Class 1
glyph (mark)

0002

2

glyphCount

0001

1

seqLookupCount

0001

1

inputSequence[0] — input sequence beginning with
the second Class in the input context sequence; Class
1, mark glyphs

seqLookupRecords[0]

seqLookupRecords array in design order

0001

1

sequenceIndex — apply substitution to position 2,
second glyph class (mark)

0002

2

lookupListIndex

Example 9: Contextual substitution format 3
Example 9 illustrates a format 3 contextual substitution, using a
SequenceContextFormat3 subtable with Coverage tables to describe a context sequence
of three lowercase glyphs in the pattern: any ascender or descender glyph in position 0
(zero), any x-height glyph in position 1, and any descender glyph in position 2. The
overlapping sets of covered glyphs for positions 0 and 2 make Format 3 better for this
context than the class-based Format 2.

In positions 0 and 2, swash versions of the glyphs replace the default glyphs. The
contextual-substitution lookup is SwashLookup (LookupList index = 0), and its subtable
is SwashSubtable. The SwashSubtable defines three Coverage tables:
AscenderDescenderCoverage, XheightCoverage, and DescenderCoverage-one for each
glyph position in the context sequence, respectively.
The SwashSubtable also defines two SequenceLookupRecords: one that applies to
position 0, and one for position 2. (No substitutions are applied to position 1.) The
record for position 0 uses a single substitution lookup called AscDescSwashLookup to
replace the current ascender or descender glyph with a swash ascender or descender
glyph. The record for position 2 uses a single substitution lookup called
DescSwashLookup to replace the current descender glyph with a swash descender
glyph.
Example 9
ﾉ

Hex
Data

Expand table

Source

Comments

SequenceContextFormat3
SwashSubtable

SequenceContextFormat3 subtable definition

0003

3

format

0003

3

glyphCount — number in input glyph sequence

0002

2

seqLookupCount

0014

AscenderDescenderCoverage

coverageOffsets[0] — offsets to Coverage tables, in
context sequence order

0030

XheightCoverage

coverageOffsets[1]

0052

DescenderCoverage

coverageOffsets[2]

seqLookupRecords[0]

SequenceLookupRecords in glyph position order

0000

0

sequenceIndex

0001

1

lookupListIndex — single substitution to output
ascender or descender swash

seqLookupRecords[1]
0002

2

sequenceIndex

0002

2

lookupListIndex — single substitution to output
descender swash

CoverageFormat1
AscenderDescenderCoverage

Coverage table definition

0001

1

coverageFormat: lists

000C

12

glyphCount

0033

bGlyphID

glyphArray[0] — glyphs in glyph ID order

0035

dGlyphID

glyphArray[1]

0037

fGlyphID

glyphArray[2]

0038

gGlyphID

glyphArray[3]

0039

hGlyphID

glyphArray[4]

003B

jGlyphID

glyphArray[5]

003C

kGlyphID

glyphArray[6]

003D

lGlyphID

glyphArray[7]

0041

pGlyphID

glyphArray[8]

0042

qGlyphID

glyphArray[9]

0045

tGlyphID

glyphArray[10]

004A

yGlyphID

glyphArray[11]

CoverageFormat1
XheightCoverage

Coverage table definition

0001

1

coverageFormat: lists

000F

15

glyphCount

0032

aGlyphID

glyphArray[0]

0034

cGlyphID

glyphArray[1]

0036

eGlyphID

glyphArray[2]

003A

iGlyphID

glyphArray[3]

003E

mGlyphID

glyphArray[4]

003F

nGlyphID

glyphArray[5]

0040

oGlyphID

glyphArray[6]

0043

rGlyphID

glyphArray[7]

0044

sGlyphID

glyphArray[8]

0045

tGlyphID

glyphArray[9]

0046

uGlyphID

glyphArray[10]

0047

vGlyphID

glyphArray[11]

0048

wGlyphID

glyphArray[12]

0049

xGlyphID

glyphArray[13]

004B

zGlyphID

GlyphArray[14]

CoverageFormat1

Coverage table definition

DescenderCoverage
0001

1

coverageFormat: lists

0005

5

glyphCount

0038

gGlyphID

glyphArray[0]

003B

jGlyphID

glyphArray[1]

0041

pGlyphID

glyphArray[2]

0042

qGlyphID

glyphArray[3]

004A

yGlyphID

glyphArray[4]

Example 10: ReverseChainSingleSubstFormat1 subtable
Example 10 uses a ReverseChainSingleSubstFormat1 subtable to substitute glyphs with a
form that has a thick connection to the left (thick exit). This allows the glyph to correctly
connect to the letter form to the left of it.
The ThickExitCoverage table is the listing of glyphs to be matched for substitution.
The LookaheadCoverage table, labeled ThickEntryCoverage, lists four glyph IDs for the
glyph following a substitution coverage glyph. This lookahead coverage attempts to
match the context that will cause the substitution to take place.
The substituteGlyphIDs array provides the glyphs to replace glyphs that correspond in
order in the ThickExitCoverage table.

Example 10
ﾉ

Hex

Expand table

Source

Comments

ReverseChainSingleSubstFormat1

ReverseChainSingleSubstFormat1 subtable

ThickConnect

definition

0001

1

format

0068

ThickExitCoverage

offset to Coverage table

0000

0

backtrackGlyphCount

0000

null - not used

backtrackCoverageOffsets[0]

0001

1

lookaheadGlyphCount

0026

ThickEntryCoverage

lookaheadCoverageOffsets[0]

000C

12

glyphCount

00A7

BEm2

substituteGlyphIDs[0] — substitute glyphs ordered
by Coverage index

00B9

BEi3

substituteGlyphIDs[1]

00C5

JIMm3

substituteGlyphIDs[2]

00D4

JIMi2

substituteGlyphIDs[3]

00EA

SINm2

substituteGlyphIDs[4]

00F2

SINi2

substituteGlyphIDs[5]

00FD

SADm2

substituteGlyphIDs[6]

010D

SADi2

substituteGlyphIDs[7]

011B

TOEm3

substituteGlyphIDs[8]

012B

TOEi3

substituteGlyphIDs[9]

013B

AINm2

substituteGlyphIDs[10]

0141

AINi2

substituteGlyphIDs[11]

CoverageFormat1

Coverage table definition

Data

ThickEntryCoverage
0001

1

coverageFormat: lists

001F

31

glyphCount

00A5

ALEFf1

glyphArray[0] — glyphs in glyph ID order

00A9

BEm4

glyphArray[1]

00AA

BEm5

glyphArray[2]

00E2

DALf1

glyphArray[3]

0167

KAFf1

glyphArray[4]

0168

KAFfs1

glyphArray[5]

0169

KAFm1

glyphArray[6]

016D

KAFm5

glyphArray[7]

016E

KAFm6

glyphArray[8]

0170

KAFm8

glyphArray[9]

0183

GAFf1

glyphArray[10]

0184

GAFfs1

glyphArray[11]

0185

GAFm1

glyphArray[12]

0189

GAFm5

glyphArray[13]

018A

GAFm6

glyphArray[14]

018C

GAFm8

glyphArray[15]

019F

LAMf1

glyphArray[16]

01A0

LAMm1

glyphArray[17]

01A1

LAMm2

glyphArray[18]

01A2

LAMm3

glyphArray[19]

01A3

LAMm4

glyphArray[20]

01A4

LAMm5

glyphArray[21]

01A5

LAMm6

glyphArray[22]

01A6

LAMm7

glyphArray[23]

01A7

LAMm8

glyphArray[24]

01A8

LAMm9

glyphArray[25]

01A9

LAMm10

glyphArray[26]

01AA

LAMm11

glyphArray[27]

01AB

LAMm12

glyphArray[28]

01AC

LAMm13

glyphArray[29]

01EC

HAYf2

glyphArray[30]

CoverageFormat1

Coverage table definition

ThickExitCoverage
0001

1

coverageFormat: lists

000C

12

glyphCount

00A6

BEm1

glyphArray[0]

00B7

BEi1

glyphArray[1]

00C3

JIMm1

glyphArray[2]

00D2

JIMi1

glyphArray[3]

00E9

SINm1

glyphArray[4]

00F1

SINi1

glyphArray[5]

00FC

SADm1

glyphArray[6]

010C

SADi1

glyphArray[7]

0119

TOEm1

glyphArray[8]

0129

TOEi1

glyphArray[9]

013A

AINm1

glyphArray[10]

0140

AINi1

glyphArray[11]

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

more information, see our
contributor guide.

gvar — Glyph Variations Table
Article • 05/29/2024

OpenType Font Variations allow a font designer to incorporate multiple faces within a
font family into a single font resource. In a variable font, the font variations ('fvar') table
defines a set of design variations supported by the font, and then various tables provide
data that specify how different font values, such as X-height or X and Y coordinates for
glyph outline points, are adjusted for different variation instances. The glyph variations
('gvar') table provides all of the variation data that describe how TrueType glyph outlines
in a 'glyf' table change across the font’s variation space.
For a general overview of OpenType Font Variations, see the chapter, OpenType Font
Variations Overview.

Introduction
The glyph variations table can only be used in combination with TrueType outlines — a
glyph ('glyf') table — and also in combination with a font variations ('fvar') table and
other required or optional tables used in variable fonts.
The 'gvar' table contains glyph variation data sub-tables with variation data for each
glyph in the 'glyf' table. The glyph variation data is a specific variant of the tuple
variation store format, which is described in detail in the chapter OpenType Font
Variations Common Table Formats. Another variant of the tuple variation store is also
used in the 'cvar' table. Differences between these and details specific to the 'gvar' table
are described in the Common Table Formats chapter.
Variation data is comprised of many adjustment-delta values. These deltas apply to
particular target items, such as the X or Y coordinate of some glyph outline point, and
are applicable for instances within a particular region of the font’s variation space. The
tuple variation store format organizes deltas into groupings by region of applicability,
with a different group of data for each region. As glyph outlines often comprise the
largest volume of data in a font, the tuple variation store format uses run-length
encoding and other optimization mechanisms to provide efficient representation of the
variation data.
Each region-specific grouping of data includes data covering all of the outline points for
the given glyph. This means that the tuple variation store formats are suited to
unpacking and processing delta values for all outline points at once, rather than for
random outline points. In most application scenarios, glyph outline processing involves

the entire glyph outline at once, so this bias in the format is generally not a particular
limitation.
A notable exception, however, is the use of horizontal or vertical glyph metrics in textlayout operations that occur prior to rendering. The TrueType rasterizer dynamically
generates “phantom” points for each glyph that represent horizontal and vertical
advance widths and side bearings, and the variation data within the 'gvar' table includes
data for these phantom points. (See the chapter Instructing TrueType Glyphs for more
background on phantom points.) Thus, a text-layout implementation could utilize the
'gvar' table to obtain interpolated glyph metrics for a given variation instance. Doing so,
however, would require invocation of the rasterizer and processing of data for all outline
points of each glyph rather than just the glyph-metric phantom points. As an alternative,
the horizontal metrics variations (HVAR) and vertical metrics variations (VVAR) tables can
provide variation data for glyph metrics that can be processed without invoking the
rasterizer, and that use different formats that are better suited to processing data for
particular items — advances or side bearings for specific glyphs. For this reason, it is
recommended that variable fonts include an HVAR table, and also a VVAR table if the
font has 'vhea' and 'vmtx' tables to support vertical layout.

Glyph variations table format
The glyph variations table is comprised of a header followed by GlyphVariationData
subtables for each glyph that describe the ways that each glyph is transformed across
the font’s variation space.
Each glyph variation data table includes sets of data that reference various regions
within the font’s variation space. Each region is defined using one or three tuple records,
with a “peak” tuple record required. In many cases, a region referenced by one glyph will
also be referenced by many other glyphs. As an optimization, the 'gvar' table allows for
a shared set of tuple records that can be referenced by the tuple variation store data for
any glyph.
The high-level structure of the 'gvar' table is as follows:

Figure: High-level organization of 'gvar' table
The header includes offsets to the start of the shared tuples data, and to the start of the
glyph variation data tables.
Each glyph variation data table provides variation data for a particular glyph. These are
variable in size. For this reason, the header also includes an array of offsets for each
glyph variation data table from the start of the glyph variation data table array. There is
one offset corresponding to each glyph ID, plus one extra offset. (Note that the same
scheme is also used in the index to location ('loca') table.) The difference between two
consecutive offsets in the array indicates the size of a given table, with an extra offset in
the array to indicate the size of the last table. Some sizes derived in this way may be
zero, in which case there is no glyph variation data for that particular glyph, and the
same outline is used for that glyph ID across the entire variation space.

'gvar' header
The glyph variations table header format is as follows:
'gvar' header:
ﾉ

Expand table

Type

Name

Description

uint16

majorVersion

Major version number of the glyph
variations table — set to 1.

uint16

minorVersion

Minor version number of the glyph
variations table — set to 0.

uint16

axisCount

The number of variation axes for this font.
This must be the same number as
axisCount in the 'fvar' table.

uint16

sharedTupleCount

The number of shared tuple records. Shared
tuple records can be referenced within
glyph variation data tables for multiple
glyphs, as opposed to other tuple records
stored directly within a glyph variation data
table.

Offset32

sharedTuplesOffset

Offset from the start of this table to the
shared tuple records.

uint16

glyphCount

The number of glyphs in this font. This
must match the number of glyphs stored
elsewhere in the font.

uint16

flags

Bit-field that gives the format of the offset
array that follows. If bit 0 is clear, the offsets
are uint16; if bit 0 is set, the offsets are
uint32.

Offset32

glyphVariationDataArrayOffset

Offset from the start of this table to the
array of GlyphVariationData tables.

Offset16

glyphVariationDataOffsets[glyphCount

Offsets from the start of the

or
Offset32

+ 1]

GlyphVariationData array to each
GlyphVariationData table.

If the short format (Offset16) is used for offsets, the value stored is the offset divided by
2. Hence, the actual offset for the location of the GlyphVariationData table within the
font will be the value stored in the offsets array multiplied by 2.

Shared tuples array
The shared tuples array provides a set of variation-space positions that can be
referenced by variation data for any glyph. The shared tuples array follows the
GlyphVariationData offsets array at the end of the 'gvar' header. This data is simply an
array of tuple records, each representing a position in the font’s variation space.
Shared tuples array:
ﾉ

Type

Name

Description

Expand table

Tuple

sharedTuples[sharedTupleCount]

Array of tuple records shared across all glyph variation
data tables.

Tuple records that are in the shared array or that are contained directly within a given
glyph variation data table use 2.14 values to represent normalized coordinate values.
See the Common Table Formats chapter for details.

The GlyphVariationData table array
The GlyphVariationData table array follows the 'gvar' header and shared tuples array.
Each GlyphVariationData table describes the variation data for a single glyph in the font.
The glyph variation data table is a specific form of the tuple variation store format,
described in the chapter OpenType Font Variations Common Table Formats. It is
comprised of a header, followed by serialized data.

High-level organization of GlyphVariationData table
The variation data includes logical groupings of data that apply to different regions of
the variation space — tuple variation data tables. These logical groupings are stored in
two parts: a header, and serialized data. The glyph variation data header includes an
array of tuple variation-data headers, each of which is associated with a particular
portion of the serialized data.
The serialized data includes adjustment delta values and also packed “point” numbers
that identify the points in the glyph outline to which the deltas apply. In the case of a
composite glyph, these numbers are component indices rather than point number
indices. The serialized data for a given region can include point number data that
applies to that specific tuple-variation data, but there can also be a shared set of point

number data, stored at the start of the serialized data. Shared point number data can be
used in relation to multiple tuple-variation data tables for the given glyph.
The GlyphVariationData header is structured as follows.
GlyphVariationData header:
ﾉ

Expand table

Type

Name

Description

uint16

tupleVariationCount

A packed field. The high 4 bits are
flags, and the low 12 bits are the
number of tuple variation tables for
this glyph. The number of tuple
variation tables can be any number
between 1 and 4095.

Offset16

dataOffset

Offset from the start of the
GlyphVariationData table to the
serialized data

TupleVariationHeader

tupleVariationHeaders[tupleCount]

Array of tuple variation headers.

Complete details regarding the tupleVariationCount field and the flags used in that field,
the TupleVariationHeader format, and the format of the serialized data are provided in
the chapter, OpenType Font Variations Common Table Formats.

Processing the 'gvar' table
When processing glyph data in a variable font for a particular variation instance, default
glyph outline data will be obtained from 'glyf' table, which is combined with the
corresponding glyph variation data subtable within the 'gvar' table.
The tuple variation headers within the selected glyph variation data table will each
specify a particular region of applicability within the font’s variation space. These will be
compared with the coordinates for the selected variation instance to determine which of
the tuple-variation data tables are applicable, and to calculate a scalar value for each.
These comparisons and scalar calculations are done using normalized-scale coordinate
values.
For each of the tuple-variation data tables that are applicable, the point number and
delta data will be unpacked and processed. The data for applicable regions can be
processed in any order. Derived delta values will correspond to particular point numbers
derived from the packed point number data. For a given point number, the computed

scalar is applied to the X coordinate and Y coordinate deltas as a coefficient, and then
resulting delta adjustments applied to the X and Y coordinates of the point.
There are two aspects of processing that are specific to the 'gvar' table. First, in the case
of composite glyphs, point numbers refer either to components or to phantom points.
Adjustments of phantom points are handled as for regular points, but adjustment to
components are handled differently. Additional information regarding processing of
variation data for composite glyphs is provided below.
Secondly, within a given tuple-variation data table, deltas may be provided for all of the
glyph’s points (and phantom points), or only for some points. If deltas are provided for
only some point numbers in a glyph outline, then delta values for un-referenced points
may need to be inferred using interpolation. This is additional processing specific to the
'gvar' table, and is described below.

Point numbers and processing for composite
glyphs
The general discussion above and in the description of interpolation in the Overview
chapter assumes simple glyphs. Certain special considerations apply to composite
glyphs.
The variation data for composite glyphs also use packed point number data
representing a series of numbers, but the numbers in this case, apart from the last four
“phantom” point numbers, refer to the components that make up the glyph rather than
to outline points. The glyph components of a composite glyph are assigned these
pseudo-point numbers according to the order the components are given in the glyph
entry, starting with 0. The four phantom point numbers representing side bearings are
still added at the end, as for simple glyphs.
For example, consider a composite glyph for “é” made up of two components: the base
glyph “e”, and a glyph for the accent, positioned at a specified offset. Pseudo- and
phantom point numbers would be as follows:
ﾉ

Point number

Element

0

Base glyph

1

Accent glyph

2

Left side bearing point

Expand table

3

Right side bearing point

4

Top side bearing point

5

Bottom side bearing point

Packed point number data for this glyph could include numbers referencing any or all of
these elements.
The adjustment deltas for component glyphs adjust the placement of the component. If
a glyph component is not referenced in the packed point numbers, then its position is
not adjusted. Each component glyph within a composite will have its own glyph entry
that, itself, has its own variation data. The processing of component glyphs must begin
with the most deeply-nested, non-composite glyphs.
The position of a component can be represented in one of two ways: directly using X
and Y offset values, or indirectly using point numbers in the parent and component
glyphs that get aligned. Which method is used is determined by a bit in the flags field of
a composite glyph description: if ARGS_ARE_XY_VALUES (bit 1) is set, then X and Y
offsets are used; if that bit is clear, then point numbers are used. If the position of a
component is represented using X and Y offsets — the ARGS_ARE_XY_VALUES flag is set
— then adjustment deltas can be applied to those offsets. However, if the position of a
component is represented using point numbers — the ARGS_ARE_XY_VALUES flag is not
set — then adjustment deltas have no effect on that component and should not be
specified.
In addition to a component’s placement, the composite glyph description can also
specify a scale value or a 2 × 2 matrix transformation to be applied to the component.
Adjustment deltas do not have any effect on scaling or 2 × 2 transformations applied to
a component. The deltas only affect the positioning of the component.
If any component entry in a composite glyph has the USE_MY_METRICS flag set, then
the hinted glyph metrics for the composite as a whole are taken from that component,
rather than using the values given for the composite glyph itself. That is, the positions of
phantom points for the composite glyph are set to the hinted positions of the
component’s phantom points. If more than one component glyph has this flag set, then
the metrics for the composite glyph are taken from the last component that has this flag
set. In a variable font, if a component entry has this flag set, then the phantom point
positions for the composite glyph are set to the interpolated and hinted positions of the
component’s phantom point, and delta values for the composite glyph’s phantom
points are not used.

Note: When a composite glyph has a component with the USE_MY_METRICS flag
set, the 'hmtx' and HVAR data for the composite glyph are used in the same manner
in which the 'hmtx' data would be used for a non-variable font. The 'hmtx' and
HVAR data should be set to appropriate values for the composite glyph, though the
hinted phantom point positions might not exactly match the linearly-scaled metrics
obtained from the 'hmtx' and HVAR data.
The process for transforming a composite glyph is as follows.
Let componentCount be the number of components in the composite glyph. Let
components[] be the component descriptions of a composite glyph (base 0 index),
and let C be a component entry in a composite glyph description.
Using the standard variation interpolation algorithm, process the variation data for
the glyph to obtain net X and Y delta adjustments for each of the components and
phantom points.
Apply the net X and Y delta adjustments to the phantom points (p =
componentCount to componentCount + 3; note that the phantom point positions
may be later overridden by a component):
For AW and LSB points, apply the net X delta adjustments, and ignore Y deltas.
For AH and TSB points, apply the net Y delta adjustments, and ignore X deltas.
For p = 0 to componentCount - 1:
C = components[p]
For the glyph at C.glyphIndex, apply the variation interpolation process and run
the hinting program.
If ARGS_ARE_XY_VALUES is set in C.flags:
Apply net X and Y delta adjustments for index p to the X and Y positioning
offsets for C:
X position offset = C.argument1 + netAdjustmentX
Y position offset = C.argument2 + netAdjustmentY
Else (ARGS_ARE_XY_VALUES is not set):
Ignore any delta adjustments provided for this component.

Apply scaling to C as applicable — if positioning offsets are scaled, it is the
delta-adjusted offsets that are scaled.
If USE_MY_METRICS is set in C.flags:
Set the positions of the composite’s phantom points equal to the hinted
positions of the phantom points for C .
Loop (next p)
For example, consider glyph 128 of the Skia font, which is the glyph for “Ä”. The glyph
entry has two component entries, both with ARGS_ARE_XY_VALUES set. The advance
width in the 'hmtx' table is 1358, and the left side bearing from the 'hmtx' table is 16,
and xMin is 16. This puts left side bearing and right side bearing phantom points (point
indices 2 and 3) at (0, 0) and (1358, 0). Relevant details from the composite glyph
description are as follows:
ﾉ

Expand table

Component

glyphIndex

argument1 (X offset)

argument2 (Y offset)

0

65

0

0

1

315

286

0

Glyph 128 has tuple variation data for various regions within the variation space; three
will be considered for this example, with normalized coordinate positions as follows:

Region

(weight, width)

R1

(1,0)

R2

(0,1)

R3

(1,1)

ﾉ

Expand table

ﾉ

Expand table

For this glyph, the variation data for R1 has the following deltas:

pt 0

pt 1

pt 2

pt 3

X

0

69

58

145

Y

0

0

0

0

The data for R2 has the following deltas:
ﾉ

pt 0

pt 1

pt 2

pt 3

X

0

53

38

351

Y

0

0

0

0

Expand table

The data for R3 has deltas for points 0, 1 and 2 only:
ﾉ

pt 0

pt 1

pt 2

X

0

-8

-30

Y

0

0

0

Expand table

pt 3

As all of the Y delta values are zero, there is no adjustment to Y coordinate values.
Now consider a variation instance with coordinates (0.2, 0.7). Variation data for all three
of the regions above will have an effect, with scalar values as follow:
ﾉ

Region

Scaler

R1

0.2

R2

0.7

R3

0.14

Expand table

The net adjustment to X coordinate values for component offsets and phantom points
will be as follows:
ﾉ

Item

Expand table

Derived X coordinate adjustment

Component 1 X offset

0.2 × 69 + 0.7 × 53 + 0.14 × -8
= 49.78

Left side bearing point X coordinate

0.2 × 58 + 0.7 × 38 + 0.14 × 30
= 42.4

Right side bearing point X coordinate

0.2 × 145 + 0.7 × 351 + 0.14 × 0
= 274.7

Combining these adjustments with the default values in the 'glyf' entry yields the
following:
ﾉ

Component 0 (X, Y) offset

(0,0)

Component 1 (X, Y) offset

(286 + 49.78, 0)

Expand table

= (335.78, 0)
Left side bearing phantom point

(0 + 42.4, 0)
= (42.4, 0)

Right side bearing phantom point

(1358 + 274.7, 0)
= (1632.7, 0)

Inferred deltas for un-referenced point
numbers
The tuple variation data for a given glyph and region (a given tuple variation data set)
may include deltas for all outline points, or for only some. The packed point number
data identifies the points for which deltas are provided. If some points are omitted from
the list of point numbers, then the data does not explicitly include delta values for them,
and deltas may need to be inferred. This is done for a given glyph on a region-by-region
basis based on the point numbers specified with each set of tuple variation data.
Note: Inferring of deltas for un-referenced points applies only to simple glyphs, not
to composite glyphs.
A single set of point-number data is used for both X- and Y-direction deltas. If a point
has explicit deltas, then it has explicit deltas for both X and Y directions. If the point
requires inferred deltas, then both X and Y deltas are inferred. The values of inferred X
and Y deltas are calculated separately.

The scalar calculated for a given region and variation instance is applied to the inferred
deltas to obtain scaled delta adjustments that are applied to the point coordinates, just
as for explicit deltas.
The process of calculating inferred variation deltas is somewhat comparable to the
TrueType Interpolate Untouched Points (IUP) instruction. (See the chapter, The TrueType
Instruction Set for more information regarding the IUP instruction.) Both calculate an
adjustment for an unaffected point based on the adjustments to adjacent, affected
points. In the case of the IUP instruction, however, the calculated adjustment is based on
the position of adjacent points after other instructions have applied. In contrast,
calculation of inferred variation deltas is based on the default positions of points and the
unscaled delta values for a given region. It is not impacted by the order in which the
tuple-variation data for different regions is processed, and the inferred deltas can be
pre-computed before any processing for a specific instance is done. Also, the
calculations used for deriving the value of inferred deltas are slightly different from the
calculations used for the IUP instruction.
Calculation of inferred deltas is done for a given glyph and a given region on a contourby-contour basis.
For a given contour, if the point number list does not include any of the points in that
contour, then none of the points in the contour are affected and no inferred deltas need
to be computed.
If the point number list includes some but not all of the points in a given contour, then
inferred deltas must be derived for the points that were not included in the point
number list, as follows.
First, for any un-referenced point, identify the nearest points before and after, in point
number order, that are referenced. Note that the same referenced points will be used
for calculating both X and Y inferred deltas. If there is no lower point number from that
contour that was referenced, then the highest, referenced point number from that
contour is used. Similarly, if no higher point number from that contour was referenced,
then the lowest, referenced point number is used.
Once the adjacent, referenced points are identified, then inferred-delta calculation is
done separately for X and Y directions.
Next, the (X or Y) grid coordinate values of the adjacent, referenced points are
compared. If these coordinates are the same, then the delta values for the adjacent
points are compared: if the delta values are the same, then this value is used as the
inferred delta for the target, un-referenced point. If the delta values are different, then
the inferred delta for the target point is zero.

Note: If exactly one point from the contour is referenced in the point number list,
then every point in that contour uses the same X and Y delta values as that point.
This follows as a specific case of the above: for all other points that are not
referenced, the one referenced point is at once both the preceding adjacent point
and the following adjacent point. Hence, the adjacent points have the same
coordinate value and the same delta, and therefore the un-referenced points get an
inferred delta of the same value.
If the coordinates of the adjacent, referenced points are different, then the coordinate
for the same (X or Y) direction of the target point is compared to those coordinates. If
the coordinate of the target point is between the coordinates of the adjacent points,
then a delta is interpolated, as described below. But if the coordinate of the target point
is not between the coordinates of the adjacent points, then the inferred delta is the
delta for whichever of the adjacent points is closer in the given direction.
The following pseudo-code summarizes the above details.

if precedingPoint.coord = followingPoint.coord
{
if precedingPoint.delta = followingPoint.delta
targetPoint.delta = precedingPoint.delta
else
targetPoint.delta = 0
}
else /* precedingPoint.coord <> followingPoint.coord */
{
if targetPoint.coord <= min(precedingPoint.coord, followingPoint.coord)
{
if precedingPoint.coord < followingPoint.coord
targetPoint.delta = precedingPoint.delta
else /* followingPoint.coord < precedingPoint.coord */
targetPoint.delta = followingPoint.delta
}
else if targetPoint.coord >= max(precedingPoint.coord,
followingPoint.coord)
{
if precedingPoint.coord > followingPoint.coord, then
targetPoint.delta = precedingPoint.delta
else /* followingPoint.coord > precedingPoint.coord */
targetPoint.delta = followingPoint.delta
}
else /* target point coordinate is between adjacent point coordinates
*/
{
/* target point delta is derived from the adjacent point deltas
using linear interpolation */

}
}

When the coordinates of the two adjacent points are different and the coordinate of the
target point is between those coordinates, then a delta for the target point is computed
by linear interpolation of the deltas for the two adjacent points. The following describes
this calculation for either X or Y direction.
Note: The logical flow of the algorithm to this point implies that the coordinates of
the two adjacent points are different. This avoids a division by zero in the following
calculations that would otherwise occur.
Select one of the two adjacent points as the reference point, and let the other be the
comparison point. It doesn’t matter which is which. Let refCoord be the coordinate
value for the current direction of the former, and let compCoord be the coordinate
value for the latter. Let targetCoord be the coordinate value for the target, unreferenced point. Calculate a proportion, proportion, as follows:

Now let deltaRef and deltaComp be the unscaled adjustment-delta values in the
variation data for the reference and comparison points. The inferred delta for the target
point, deltaTarget, is calculated as follows:

The following example illustrates the process for obtaining inferred deltas. Suppose P1,
P2 and P3 are points in the same contour, with coordinate positions as shown below,
and that P1 and P3 are referenced in the point number data while P2 is not.

Note that P1 and P3 have different X and Y coordinates. Also note that, in the X
direction, P2 is between the two adjacent points, while in the Y direction it is not. For the
Y direction, the inferred delta will be the delta of the closer point, P3.
For the X direction, let P1 be the reference point; P3 is the comparison point. A
proportion is calculated:

Now suppose that P1 and P3 have X and Y deltas in the variation data as follows:
ﾉ

Point

X delta

Y delta

P1

+28

-62

P3

-42

-57

Expand table

The inferred X delta for P2, deltaX_P2, is calculated as follows:

The inferred Y delta for P2 is the value of the Y delta for P3. Thus, the deltas for all three
points is obtained:
ﾉ

Point

X delta

Y delta

P1

+28

-62

P2

+10.5

-57

P3

-42

-57

Expand table

These delta values can now be used in the interpolation algorithm, with a scalar applied
to each based on the region coordinates and the coordinates for the current variation

instance.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

hdmx — Horizontal Device Metrics
Article • 05/31/2024

The 'hdmx' table can be used in fonts with TrueType outlines to store integer advance
widths scaled to particular pixel sizes. This allows the text layout engine to build integer
width tables without calling the scaler for each glyph. Typically, this table will contain
widths for only certain pixel sizes.
For non-square pixel grids, the em square width (in pixels) is used to determine which
device record to use. For example, a 12 point em square on a device with a resolution of
72x96 would be 12 pixels high and 16 pixels wide. The 'hdmx' device record for 16 pixels
per em would be used.
If bit 4 of the flags field in the 'head' table is not set, then it is assumed that the font
scales linearly; in this case an 'hdmx' table is not necessary and should not be built. If bit
4 of the flag field is set, then one or more glyphs in the font are assumed to scale
nonlinearly. In this case, performance can be improved by including the 'hdmx' table
with width data for important sizes. Please see the chapter “Recommendations for
OpenType Fonts” for more detail.
The table begins as follows:
HdmxHeader
ﾉ

Expand table

Type

Name

Description

uint16

version

Table version number—set to 0.

uint16

numRecords

Number of device records.

uint32

sizeDeviceRecord

Size of a device record, 32-bit aligned.

DeviceRecord

records[numRecords]

Array of device records.

The records array must be sorted in increasing pixel size order. The DeviceRecord format
is as follows:
DeviceRecord
ﾉ

Type

Name

Description

Expand table

uint8

pixelSize

Pixel size for following widths (as ppem).

uint8

maxWidth

Maximum width.

uint8

widths[numGlyphs]

Array of widths (numGlyphs is from the 'maxp' table).

Each DeviceRecord is padded with 0s to make it 32-bit aligned.
Each value in the widths array is the width of the particular glyph, in pixels, at the pixels
per em (ppem) size given in the pixelSize field.
The ppem sizes are measured along the y axis.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

head — Font Header Table
Article • 05/31/2024

This table gives global information about the font. The bounding box values should be
computed using only glyphs that have contours. Glyphs with no contours should be
ignored for the purposes of these calculations.
ﾉ

Expand table

Type

Name

Description

uint16

majorVersion

Major version number of the font header table — set
to 1.

uint16

minorVersion

Minor version number of the font header table — set
to 0.

Fixed

fontRevision

Set by font manufacturer.

uint32

checksumAdjustment

To compute: set it to 0, sum the entire font as uint32,
then store 0xB1B0AFBA - sum. If the font is used as a
component in a font collection file, the value of this
field will be invalidated by changes to the file structure
and font table directory, and must be ignored.

uint32

magicNumber

Set to 0x5F0F3CF5.

uint16

flags

Bit 0: Baseline for font at y=0.
Bit 1: Left sidebearing point at x=0 (relevant only for
TrueType rasterizers) — see additional information
below regarding variable fonts.
Bit 2: Instructions may depend on point size.
Bit 3: Force ppem to integer values for all internal
scaler math; may use fractional ppem sizes if this bit is
clear. It is strongly recommended that this be set in
hinted fonts.
Bit 4: Instructions may alter advance width (the
advance widths might not scale linearly).
Bit 5: This bit is not used in OpenType, and should not
be set in order to ensure compatible behavior on all
platforms. If set, it may result in different behavior for
vertical layout in some platforms. (See Apple’s
specification for details regarding behavior in Apple

Type

Name

Description
platforms.)
Bits 6 – 10: These bits are not used in OpenType and
should always be cleared. (See Apple’s specification
for details regarding legacy use in Apple platforms.)
Bit 11: Font data is “lossless” as a result of having been
subjected to optimizing transformation and/or
compression (such as compression mechanisms
defined by ISO/IEC 14496-18, MicroType® Express,
WOFF 2.0, or similar) where the original font
functionality and features are retained but the binary
compatibility between input and output font files is not
guaranteed. As a result of the applied transform, the
DSIG table may also be invalidated.
Bit 12: Font converted (produce compatible metrics).
Bit 13: Font optimized for ClearType®. Note, fonts that
rely on embedded bitmaps (EBDT) for rendering should
not be considered optimized for ClearType, and
therefore should keep this bit cleared.
Bit 14: Last Resort font. If set, indicates that the glyphs
encoded in the 'cmap' subtables are simply generic
symbolic representations of code point ranges and do
not truly represent support for those code points. If
unset, indicates that the glyphs encoded in the 'cmap'
subtables represent proper support for those code
points.
Bit 15: Reserved, set to 0.

uint16

unitsPerEm

Set to a value from 16 to 16384. Any value in this range
is valid. In fonts that have TrueType outlines, a power of
2 is recommended as this allows performance
optimization in some rasterizers.

LONGDATETIME

created

Number of seconds since 12:00 midnight that started
January 1st, 1904, in GMT/UTC time zone.

LONGDATETIME

modified

Number of seconds since 12:00 midnight that started
January 1st, 1904, in GMT/UTC time zone.

int16

xMin

Minimum x coordinate across all glyph bounding
boxes.

int16

yMin

Minimum y coordinate across all glyph bounding

Type

Name

Description
boxes.

int16

xMax

Maximum x coordinate across all glyph bounding
boxes.

int16

yMax

Maximum y coordinate across all glyph bounding
boxes.

uint16

macStyle

Bit 0: Bold (if set to 1);
Bit 1: Italic (if set to 1)
Bit 2: Underline (if set to 1)
Bit 3: Outline (if set to 1)
Bit 4: Shadow (if set to 1)
Bit 5: Condensed (if set to 1)
Bit 6: Extended (if set to 1)
Bits 7 – 15: Reserved (set to 0).

uint16

lowestRecPPEM

Smallest readable size in pixels.

int16

fontDirectionHint a

Deprecated (Set to 2).
0: Fully mixed directional glyphs;
1: Only strongly left to right;
2: Like 1 but also contains neutrals;
-1: Only strongly right to left;
-2: Like -1 but also contains neutrals.

a

int16

indexToLocFormat

0 for short offsets (Offset16), 1 for long (Offset32).

int16

glyphDataFormat

0 for current format.

The fontDirectionHint field was intended for support of right-to-left scripts. Strong left

to right, strong right to left, and neutral are properties of characters. A neutral character
has no inherent directionality; it is not a character with zero (0) width. Spaces and
punctuation are examples of neutral characters. Non-neutral characters are those with
inherent directionality. For example, Roman letters (left-to-right) and Arabic letters
(right-to-left) have strong directionality. In a “normal” Roman font where spaces and
punctuation are present, the font direction hints should be set to two (2).
The unitsPerEm value determines the granularity of the font’s coordinate grid at which
coordinates can be specified for visual elements such as outline control points or markattachment anchor positions. See the TrueType Fundamentals chapter for more
information.
A glyph’s bounding box is the smallest rectangle that contains all of the glyph’s control
points. (See the 'glyf' table chapter for more information.) The xMin, yMin, xMax and

yMax values provide a bounding box that will contain all glyphs from the font. Glyphs
without contours are ignored.
The macStyle bits must agree with the fsSelection bits in the OS/2 table. The fsSelection
bits are used over the macStyle bits in Windows. The PANOSE values and 'post' table
values are ignored for determining bold or italic fonts.
For historical reasons, the fontRevision value contained in this table is not used by
Windows to determine the version of a font. Instead, Windows evaluates the version
string (ID 5) in the 'name' table.
The left sidebearing point for each glyph corresponds to the first phantom point (“pp1”
below—see Phantom points) and relates to the glyph left sidebearing (lsb) and xMin as
follows:
pp1 = xMin - lsb
If bit 1 of the flags field is set, then pp1 = 0 for all glyphs and the xMin and left
sidebearing for each glyph must be equal.
In a variable font with TrueType outlines, the left side bearing for each glyph must equal
xMin, and bit 1 in the flags field must be set. Also, bit 5 must be cleared in all variable
fonts. For general information on OpenType Font Variations, see the chapter, OpenType
Font Variations Overview.
Also, in a variable font, the minimum or maximum x or y values of control points can
vary, and a tight bounding rectangle containing the outline or all points for an instance
of any given glyph can be smaller or larger than for the default instance of that glyph.
The xMin, yMin, xMax and yMax values in this table might or might not encompass the
derived glyph outlines for an instance. In addition, variation deltas are not provided for
these values. If an application requires a bounding rectangle that encompasses the
glyphs for a non-default instance of the font, the derived glyph outlines for the instance
should be processed to determine a bounding rectangle.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

more information, see our
contributor guide.

hhea — Horizontal Header Table
Article • 01/10/2023

This table contains information for horizontal layout. The values in the
minRightSidebearing, minLeftSideBearing and xMaxExtent should be computed using
only glyphs that have contours. Glyphs with no contours should be ignored for the
purposes of these calculations. All reserved areas must be set to 0.
ﾉ

Expand table

Type

Name

Description

uint16

majorVersion

Major version number of the horizontal header table — set to
1.

uint16

minorVersion

Minor version number of the horizontal header table — set to
0.

FWORD

ascender

Typographic ascent—see remarks below.

FWORD

descender

Typographic descent—see remarks below.

FWORD

lineGap

Typographic line gap.
Negative lineGap values are treated as zero in some legacy
platform implementations.

UFWORD

advanceWidthMax

Maximum advance width value in 'hmtx' table.

FWORD

minLeftSideBearing

Minimum left sidebearing value in 'hmtx' table for glyphs with
contours (empty glyphs should be ignored).

FWORD

minRightSideBearing

Minimum right sidebearing value; calculated as min(aw - (lsb
+ xMax - xMin)) for glyphs with contours (empty glyphs
should be ignored).

FWORD

xMaxExtent

Max(lsb + (xMax - xMin)).

int16

caretSlopeRise

Used to calculate the slope of the cursor (rise/run); 1 for
vertical.

int16

caretSlopeRun

0 for vertical.

int16

caretOffset

The amount by which a slanted highlight on a glyph needs to
be shifted to produce the best appearance. Set to 0 for nonslanted fonts

int16

(reserved)

set to 0

int16

(reserved)

set to 0

int16

(reserved)

set to 0

int16

(reserved)

set to 0

int16

metricDataFormat

0 for current format.

uint16

numberOfHMetrics

Number of hMetric entries in 'hmtx' table

The ascender, descender and linegap values in this table are Apple specific; see Apple's
specification

for details regarding Apple platforms. The sTypoAscender,

sTypoDescender and sTypoLineGap fields in the OS/2 table are used on the Windows
platform, and are recommended for new text-layout implementations. Font developers
should evaluate behavior in target applications that may use fields in this table or in the
OS/2 table to ensure consistent layout. See the descriptions of the OS/2 fields for
additional details.

'hhea' Table and OpenType Font Variations
In a variable font, various font-metric values within the horizontal header table may
need to be adjusted for different variation instances. Variation data for 'hhea' entries can
be provided in the metrics variations (MVAR) table. Different 'hhea' entries are
associated with particular variation data in the MVAR table using value tags, as follows:
ﾉ

'hhea' entry

Tag

caretOffset

'hcof'

caretSlopeRise

'hcrs'

caretSlopeRun

'hcrn'

Expand table

For general information on OpenType Font Variations, see the chapter, OpenType Font
Variations Overview.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue

more information, see our
contributor guide.

 Provide product feedback

hmtx — Horizontal Metrics Table
Article • 01/10/2023

Glyph metrics used for horizontal text layout include glyph advance widths, side
bearings and X-direction min and max values (xMin, xMax). These are derived using a
combination of the glyph outline data ('glyf', 'CFF ' or CFF2) and the horizontal metrics
table. The horizontal metrics ('hmtx') table provides glyph advance widths and left side
bearings.
In a font with TrueType outline data, the 'glyf' table provides xMin and xMax values, but
not advance widths or side bearings. The advance width is always obtained from the
'hmtx' table. In some fonts, depending on the state of flags in the 'head' table, the left
side bearings may be the same as the xMin values in the 'glyf' table, though this is not
true for all fonts. (See the description of bit 1 of the flags field in the 'head' table.) For
this reason, left side bearings are provided in the 'hmtx' table. The right side bearing is
always derived using advance width and left side bearing values from the 'hmtx' table,
plus bounding-box information in the glyph description — see below for more details.
In a variable font with TrueType outline data, the left side bearing value in the 'hmtx'
table must always be equal to xMin (bit 1 of the 'head' flags field must be set). Hence,
these values can also be derived directly from the 'glyf' table. Note that these values
apply only to the default instance of the variable font: non-default instances may have
different side bearing values. These can be derived from interpolated “phantom point”
coordinates using the 'gvar' table (see below for additional details), or by applying
variation data in the HVAR table to default-instance values from the 'glyf' or 'hmtx' table.
In a font with CFF version 1 outline data, the 'CFF ' table does include advance widths.
These values are used by PostScript processors, but are not used in OpenType layout. In
an OpenType context, the 'hmtx' table is required and must be used for advance widths.
Note that fonts in a Font Collection file that share a 'CFF ' table may specify different
advance widths in font-specific 'hmtx' tables for a particular glyph index. Also note that
the CFF2 table does not include advance widths. In addition, for either CFF or CFF2 data,
there are no explicit xMin and xMax values; side bearings are implicitly contained within
the CharString data, and can be obtained from the CFF / CFF2 rasterizer. Some layout
engines may use left side bearing values in the 'hmtx' table, however; hence, font
production tools should ensure that the left side bearing values in the 'hmtx' table
match the implicit xMin values reflected in the CharString data. In a variable font with
CFF2 outline data, left side bearing and advance width values for non-default instances
should be obtained by combining information from the 'hmtx' and HVAR tables.

The table uses a LongHorMetric record to give the advance width and left side bearing
of a glyph. Records are indexed by glyph ID. As an optimization, the number of records
can be less than the number of glyphs, in which case the advance width value of the last
record applies to all remaining glyph IDs. This can be useful in monospaced fonts, or in
fonts that have a large number of glyphs with the same advance width (provided the
glyphs are ordered appropriately). The number of LongHorMetric records is determined
by the numberOfHMetrics field in the 'hhea' table.
If numberOfHMetrics is less than the total number of glyphs, then the hMetrics array is
followed by an array for the left side bearing values of the remaining glyphs. The
number of elements in the leftSideBearings array will be derived from the numGlyphs
field in the 'maxp' table minus numberOfHMetrics.
Horizontal Metrics Table:
ﾉ

Expand table

Type

Name

Description

LongHorMetric

hMetrics[numberOfHMetrics]

Paired advance width and left side bearing
values for each glyph. Records are indexed
by glyph ID.

FWORD

leftSideBearings[numGlyphs numberOfHMetrics]

Left side bearings for glyph IDs greater
than or equal to numberOfHMetrics.

LongHorMetric Record:
ﾉ

Type

Name

Description

UFWORD

advanceWidth

Advance width, in font design units.

FWORD

lsb

Glyph left side bearing, in font design units.

Expand table

In a font with TrueType outlines, xMin and xMax values for each glyph are given in the
'glyf' table. The advance width (“aw”) and left side bearing (“lsb”) can be derived from
the glyph “phantom points”, which are computed by the TrueType rasterizer; or they can
be obtained from the 'hmtx' table. In a font with CFF or CFF2 outlines, xMin (= left side
bearing) and xMax values can be obtained from the CFF / CFF2 rasterizer. From those
values, the right side bearing (“rsb”) is calculated as follows:

rsb = aw - (lsb + xMax - xMin)

If pp1 and pp2 are TrueType phantom points used to control lsb and rsb, their initial
position in the X-direction is calculated as follows:

pp1 = xMin - lsb
pp2 = pp1 + aw

If a glyph has no contours, xMax/xMin are not defined. The left side bearing indicated in
the 'hmtx' table for such glyphs should be zero.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

HVAR — Horizontal Metrics Variations
Table
Article • 10/20/2022

The HVAR table is used in variable fonts to provide variations for horizontal glyph
metrics values. This can be used to provide variation data for advance widths in the
'hmtx' table. In fonts with TrueType outlines, it can also be used to provide variation data
for left and right side bearings obtained from the 'hmtx' table and glyph bounding
boxes.
For a general overview of OpenType Font Variations and terminology related to
variations, see the chapter, OpenType Font Variations Overview.
In a font with TrueType outlines, the rasterizer will generate “phantom” points that
represent left, right, top and bottom side bearings. (See the chapter Instructing TrueType
Glyphs for more background on phantom points.) In a TrueType variable font, the glyph
variations ('gvar') table will include variation data for the phantom points of each glyph,
allowing glyph metrics to be interpolated for different variation instances as part of
deriving the interpolated glyph outlines. For this reason, the HVAR table is not required
in variable fonts that have TrueType outlines. For text-layout operations that require
glyph metrics but not actual glyph outlines, however, there can be significant
performance benefits by being able to obtain adjusted glyph metrics for an instance
without needing to interpolate glyph outlines. For this reason, it is recommended that
an HVAR table be included in variable fonts that have TrueType outlines.
The CFF2 rasterizer does not generate phantom points as in the TrueType rasterizer. For
this reason, an HVAR table is required to handle any variation in horizontal glyph metrics
in a variable font with CFF2 outlines.
Take note that, in a variable font with TrueType outlines, the left side bearing for each
glyph must equal xMin, and bit 1 in the flags field of the 'head' table must be set.
The HVAR table contains an item variation store table to represent variation data. The
item variation store and constituent formats are described in the chapter, OpenType
Font Variations Common Table Formats. The item variation store is also used in the
VVAR, GDEF and certain other tables, but is different from the formats for variation data
used in the 'cvar' or 'gvar' tables.
The item variation store format uses delta-set indices to reference variation delta data
for particular target, font-data items to which they are applied, such as the advance
width of a particular glyph. Data external to the item variation store identifies the delta-

set index to be used for each given target item. Within the HVAR table, glyph IDs can be
used as implicit indices for advance width variations, or an optional delta-set index
mapping table can be used that explicitly provides delta-set indices for advance widths
to be associated with each glyph ID.
An advance width mapping subtable adds additional data within the HVAR table, but it
also makes it possible to use a more compact representation of the data in the item
variation store. For example, if multiple glyphs have the same advance widths, the
mapping subtable allows all of them to reference a single delta set within the store.
Additional optimizations within the item variation store are possible. See the Common
Table Formats chapter for more discussion about size optimization. In general, inclusion
of an advance width mapping subtable is recommended.
Optional mapping subtables can also be used to provide delta-set indices for glyph side
bearings. In variable fonts with TrueType outlines, variation data for side bearings is
recommended. If variation data for side bearings is provided, it should include data for
both left and right side bearings, and mapping subtables for left and right side bearings
must also be included.

Related and Co-Requisite Tables
The HVAR table is used only in variable fonts. It must be used in combination with a
horizontal metrics ('hmtx') table, and also in combination with a font variations ('fvar')
table, and other required or optional tables used in variable fonts. See Variation data
tables and miscellaneous requirements in the OpenType Font Variations Overview
chapter for general information.
For variable fonts that have TrueType outlines, the HVAR table is optional but
recommended. For variable fonts that have CFF 2 outlines, the HVAR table is required if
there is any variation in glyph advance widths across the variation space.
Note: The 'hdmx' table is not used in variable fonts.

Table Formats
The horizontal metrics variations table has the following format.
Horizontal metrics variations table:
ﾉ

Type

Name

Description

Expand table

uint16

majorVersion

Major version number of the horizontal metrics
variations table — set to 1.

uint16

minorVersion

Minor version number of the horizontal metrics
variations table — set to 0.

Offset32

itemVariationStoreOffset

Offset in bytes from the start of this table to the item
variation store table.

Offset32

advanceWidthMappingOffset

Offset in bytes from the start of this table to the deltaset index mapping for advance widths (may be NULL).

Offset32

lsbMappingOffset

Offset in bytes from the start of this table to the deltaset index mapping for left side bearings (may be
NULL).

Offset32

rsbMappingOffset

Offset in bytes from the start of this table to the deltaset index mapping for right side bearings (may be
NULL).

The item variation store table is documented in the chapter, OpenType Font Variations
Common Table Formats.
Mapping subtables are represented using a DeltaSetIndexMap table; see Associating
Target Items to Variation Data in the Common Table Formats chapter for the definition
of this table. In the HVAR table, only format 0 of the DeltaSetIndexMap is used. Mapping
subtables are optional. If a given mapping subtable is not provided, the offset is set to
NULL.
Variation data for advance widths is required. A delta-set index mapping subtable for
advance widths can be provided, but is optional. If a mapping subtable is not provided,
glyph indices are used as implicit delta-set indices. To access the delta set for the
advance of given glyph, the delta-set outer-level index is zero, and the glyph ID is used
as the inner-level index.
Variation data for side bearings are optional. If included, mapping tables are required to
provide the delta-set index for each glyph.

Processing
When performing text layout using a particular variation instance of a variable font, the
application will need to obtain adjusted glyph metrics for that instance. The application
obtains default values from the 'hmtx' and 'glyf' tables, and uses the HVAR table to
obtain interpolated adjustment values that are applied to the defaults.

Delta-set indices are obtained based on the glyph ID. If there is no delta-set index
mapping subtable for advance widths (advanceWidthMappingOffset is NULL), then
glyph IDs implicitly provide the indices: for a given glyph ID, the delta-set outer-level
index is zero, and the glyph ID is the delta-set inner-level index. If a delta-set index
mapping table is provided, glyph IDs are used to lookup a mapping entry, which
provides the outer- and inner-level delta-set indices in a packed format. See Associating
Target Items to Variation Data for details.
The delta-set indices are used to reference a delta set for the target advance width or
side bearing within the item variation store. The two-level organization of data within
the item variation store is described in the chapter OpenType Font Variations Common
Table Formats. Each delta set includes different deltas that apply to variation instances
falling within different regions of the variation space. The process by which the deltas
are processed to derive an interpolated value for a given target item is described in the
chapter, OpenType Font Variations Overview.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

JSTF — Justification Table
Article • 03/19/2025

Overview
The Justification table (JSTF) provides font developers with additional control over glyph
substitution and positioning that can be used in layout of justified text. It provides textprocessing clients with more options to expand or shrink word and glyph spacing when
fitting text into a specified column width.
When justifying text, the text-processing client distributes the characters in each line to
completely fill the specified line length. Whether removing space to fit more characters
in the line or adding more space to spread the characters, justification can produce
large gaps between words, cramped or extended glyph spacing, uneven line break
patterns, and other jarring visual effects. For example:

Figure 6a. Poorly justified text
To offset these effects, text-processing clients have used justification algorithms that
redistribute the space with a series of glyph spacing adjustments that progress from
least to most obvious. Typically, the client will begin by expanding or compressing the
space between words. If these changes aren’t enough or look distracting, the client
might hyphenate the word at the end of the line or adjust the space between glyphs in
one or more lines.
To disguise spacing inconsistencies so they won’t disrupt the flow of text for a reader,
the font developer can use the JSTF table to enable or disable individual glyph
substitution and positioning actions that apply to specific scripts, language systems, and
glyphs in the font.
For instance, a ligature glyph can replace multiple glyphs, shortening the line of text
with an unobtrusive, localized adjustment (see Figure 6b). Font-specific positioning
changes can be applied to particular glyphs in a text line that combines two or more
fonts. Other options include repositioning the individual glyphs in the line, expanding
the space between specific pairs of glyphs, and decreasing the spacing within particular
glyph sequences.

Figure 6b. JSTF shortens the top line of this example by using the “ffi” ligature
The font designer or developer defines JSTF data as prioritized suggestions. Each
suggestion lists the particular actions that the client can use to adjust the line of text.
Justification actions may apply to both vertical and horizontal text.

JSTF table organization
The JSTF table organizes data by script and language system, as do the GSUB and GPOS
tables. The JSTF table begins with a header that lists scripts in an array of
JstfScriptRecords (see Figure 6c). Each record contains a ScriptTag and an offset to a
JstfScript table that contains script and language-specific data:
A default justification language system table (JstfLangSys) defines script-specific
data that applies to the entire script in the absence of any language-specific
information.
A justification language system table stores the justification data for each language
system.

Figure 6c. High-level organization of JSTF table
A JstfLangSys table contains a list of justification suggestions. Each suggestion consists
of a list of GSUB or GPOS LookupList indices to lookups that may be enabled or
disabled to add or remove space in the line of text. In addition, each suggestion can
include a set of dedicated justification lookups with maximum adjustment values to
extend or shrink the amount of space.

The font developer prioritizes suggestions based on how they affect the appearance and
function of the text line, and the client applies the suggestions in that order. Lownumbered (high-priority) suggestions correspond to “least bad” options.
The font developer can also supply a list of extender glyphs for each script, such as
kashidas in Arabic. A client may use the extender glyphs in addition to the justification
suggestions.
A client begins justifying a line of text only after implementing all selected GSUB and
GPOS features for the string. Starting with the lowest-numbered suggestion, the client
enables or disables the lookups specified in the JSTF table, reassembles the lookups in
the LookupList order, and applies them to each glyph in the string one after another. If
the line still is not the correct length, the client processes the next suggestion in
ascending order of priority. This continues until the line length meets the justification
requirements.
If any JSTF suggestion at any priority level modifies a GSUB or GPOS lookup that was
previously applied to the glyph string, then the text processing client must apply the
JSTF suggestion to an unmodified version of the glyph string.
A FeatureVariations table may be used in either the GSUB or GPOS table to substitute
the lookups triggered by a given feature with an alternate set of lookups based on
certain conditions. (Currently, these conditions can pertain only to the use of variable
fonts, which are discussed further below.) The actual lookups that were applied for a
given feature may be different from the default set of lookups for that feature. When
processing a justification suggestion, the list of lookups to check for previous
application should be the actual lookups that applied, with any feature variations in
effect, not the default lookups. Also, when adding data in the JSTF table to disable GSUB
or GPOS lookups, the font developer should consider possible interactions with feature
variation tables, such as a need to include such alternate lookups in the set of lookups
to disable. Note that this applies only to features and lookups in the GSUB and GPOS
table: for lookups contained directly within the JSTF table, there is no analogous featurevariation mechanism.
Later in this chapter, the following tables and records used by the JSTF table for scripts
and language systems will be described:
Script information, including the JstfScript table (plus its associated
JstfLangSysRecords) and the ExtenderGlyph table.
Language system information, including the JstfLangSys table, JstfPriority table
(and its associated JstfDataRecord), the JstfModList table, and the JstfMax table.

JSTF table and OpenType Font Variations
OpenType Font Variations allow a single font to support many design variations along
one or more axes of design variation. For example, a font with weight and width
variations might support weights from thin to black, and widths from ultra-condensed
to ultra-expanded. For general information on OpenType Font Variations, see the
chapter, OpenType Font Variations Overview.
When different variation instances are selected, the design and metrics of individual
glyphs change, and the metric characteristics of the font as a whole can also change. As
metrics are relevant for justification, the interaction between justification data and
variations requires consideration.
As noted above, justification is assumed to be an iterative process in which the
application tests different suggestions defined in the font in priority order to find a
suggestion that results in a line length that meets application-determined justification
requirements. When an instance of a variable font is selected, the line layout will use
glyph outlines and metrics that are adjusted for that instance. Thus, the metrics for one
variation instance may be different from another, and the text content of a given line
after justification may be different if formatted with different variation instances, but the
justification processing proceeds in the same manner.
As also noted above, justification suggestions are applied to the results after selected
GSUB and GPOS features have been processed. If the GSUB or GPOS table includes a
FeatureVariations table, there may be interactions between the effects of the
FeatureVariations table and the justification suggestions. See above for additional
discussion.
As noted, justification suggestions can make use of GPOS lookups contained within the
GPOS table or directly within the JSTF table. GPOS lookup subtables contain X or Y fontunit values that specify modifications to individual glyph positions or metrics. In a
variable font, these X and Y values apply to the default instance, and may require
adjustment for different variation instances. This is done using variation data with
processes similar to those used for glyph outlines and other font data, as described in
the chapter, OpenType Font Variations Overview. Variation data for adjustment of X or Y
values in GPOS lookups is stored within an item variation store table located within the
GDEF table. This is true for lookups in either the GPOS or the JSTF table. The same item
variation store is also used for adjustment of values in the GDEF table. See the GPOS
chapter for additional details regarding variation of GPOS lookup values in variable
fonts.

JSTF table structures
JSTF Header
The JSTF table begins with a header that contains a version number for the table, a
count of the number of scripts used in the font, and an array of script records. Each
record contains a script tag (jstfScriptTag) and an offset to a JstfScript table.
Note that the jstfScriptTag values must correspond with the script tags listed in the
GSUB and GPOS tables.
Example 1 at the end of this chapter shows a JSTF Header table and JstfScriptRecord.
JSTF header
ﾉ

Expand table

Type

Name

Description

uint16

majorVersion

Major version of the JSTF table, = 1.

uint16

minorVersion

Minor version of the JSTF table, = 0.

uint16

jstfScriptCount

Number of JstfScriptRecords in this table.

JstfScriptRecord

jstfScriptRecords[jstfScriptCount]

Array of JstfScriptRecords, in alphabetical
order by jstfScriptTag.

JstfScriptRecord
ﾉ

Expand table

Type

Name

Description

Tag

jstfScriptTag

4-byte JstfScript identification.

Offset16

jstfScriptOffset

Offset to JstfScript table, from beginning of JSTF Header.

Justification script table
A justification script (JstfScript) table describes the justification information for a single
script. It consists of an offset to a table that defines extender glyphs, an offset to a
default justification language system table for the script, a count of the language
systems that define justification data (jstfLangSysCount), and an array of justification
language system records for specific language systems.

If a script uses the same justification information for all language systems, the font
developer defines only the default language system table and sets the jstfLangSysCount
value to zero (0). However, if any language system has unique justification suggestions,
jstfLangSysCount will be a positive value, and the JstfScript table must include an array
of justification language system records, one for each language system. Each
JstfLangSysRecord contains a language system tag and an offset to a justification
language system table. In the jstfLangSysRecords array, records are ordered
alphabetically by language system tag.
Note: No JstfLangSysRecord is defined for the default script data; the data is stored
in the default JstfLangSys table instead.
Example 2 at the end of the chapter shows a JstfScript table for the Arabic script and a
JstfLangSysRecord for the Farsi language system.
JstfScript table
ﾉ

Expand table

Type

Name

Description

Offset16

extenderGlyphOffset

Offset to ExtenderGlyph table, from
beginning of JstfScript table (may be
NULL).

Offset16

defJstfLangSysOffset

Offset to default JstfLangSys table,
from beginning of JstfScript table
(may be NULL).

uint16

jstfLangSysCount

Number of JstfLangSysRecords in
this table- may be zero (0).

JstfLangSysRecord

jstfLangSysRecords[jstfLangSysCount]

Array of JstfLangSysRecords, in
alphabetical order by JstfLangSysTag.

JstfLangSysRecord
ﾉ

Expand table

Type

Name

Description

Tag

jstfLangSysTag

4-byte JstfLangSys identifier.

Offset16

jstfLangSysOffset

Offset to JstfLangSys table, from beginning of JstfScript table.

Extender glyph table
The extender glyph table (ExtenderGlyph) lists indices of glyphs, such as Arabic kashidas,
that a client can insert to extend the length of the line for justification. The table consists
of a count of the extender glyphs for the script and an array of extender glyph indices,
arranged in increasing numerical order.
Example 2 at the end of this chapter shows an ExtenderGlyph table for Arabic kashida
glyphs.
ExtenderGlyph table
ﾉ

Expand table

Type

Name

Description

uint16

glyphCount

Number of extender glyphs in this script.

uint16

extenderGlyphs[glyphCount]

Extender glyph IDs — in increasing numerical order.

Justification language system table
The justification language system (JstfLangSys) table contains an array of justification
suggestions, ordered by priority. A text-processing client doing justification should
begin with the suggestion that has a zero (0) priority, and then, as needed, apply
suggestions of increasing priority until the text is justified.
The font developer defines the number and the meaning of the priority levels. Each
priority level stands alone; its suggestions are not added to the previous levels. The
JstfLangSys table consists of a count of the number of priority levels and an array of
offsets to justification priority tables (jstfPriorityOffsets), stored in priority order. Example
2 at the end of the chapter shows how to define a JstfLangSys table.
JstfLangSys table
ﾉ

Expand table

Type

Name

Description

uint16

jstfPriorityCount

Number of JstfPriority tables.

Offset16

jstfPriorityOffsets[jstfPriorityCount]

Array of offsets to JstfPriority tables, from
beginning of JstfLangSys table, in priority order.

Justification priority table
A justification priority (JstfPriority) table defines justification suggestions for a single
priority level. Each priority level specifies whether to enable or disable GSUB and GPOS
lookups or apply text justification lookups to shrink and extend lines of text.
JstfPriority has offsets to four tables with line shrinkage data: two are justification
modification tables for enabling and disabling glyph substitution (GSUB) lookups, and
two are justification modification tables for enabling and disabling glyph positioning
(GPOS) lookups. Offsets to GSUB and GPOS justification modification tables also are
defined for line extension.
Example 3 at the end of this chapter demonstrates two JstfPriority tables for two
justification suggestions.
JstfPriority table
ﾉ

Expand table

Type

Name

Description

Offset16

gsubShrinkageEnableOffset

Offset to GSUB shrinkage-enable JstfModList table,
from beginning of JstfPriority table (may be NULL).

Offset16

gsubShrinkageDisableOffset

Offset to GSUB shrinkage-disable JstfModList table,
from beginning of JstfPriority table (may be NULL).

Offset16

gposShrinkageEnableOffset

Offset to GPOS shrinkage-enable JstfModList table,
from beginning of JstfPriority table (may be NULL).

Offset16

gposShrinkageDisableOffset

Offset to GPOS shrinkage-disable JstfModList table,
from beginning of JstfPriority table (may be NULL).

Offset16

shrinkageJstfMaxOffset

Offset to shrinkage JstfMax table, from beginning of
JstfPriority table (may be NULL).

Offset16

gsubExtensionEnableOffset

Offset to GSUB extension-enable JstfModList table, from
beginnning of JstfPriority table (may be NULL).

Offset16

gsubExtensionDisableOffset

Offset to GSUB extension-disable JstfModList table,
from beginning of JstfPriority table (may be NULL).

Offset16

gposExtensionEnableOffset

Offset to GPOS extension-enable JstfModList table,
from beginning of JstfPriority table (may be NULL).

Offset16

gposExtensionDisableOffset

Offset to GPOS extension-disable JstfModList table,
from beginning of JstfPriority table (may be NULL).

Offset16

extensionJstfMaxOffset

Offset to extension JstfMax table, from beginning of
JstfPriority table (may be NULL).

Justification modification list table
A justification modification list table (JstfModList) contains a list of indices into
LookupList tables within either the GSUB or GPOS table. JstfModList tables are used
within a JstfPriority table to specify GSUB or GPOS lookups that can be either enabled or
disabled for the purpose of either extending or shrinking the length of text. The client
can enable or disable the lookups to justify text. For example, to increase line length, the
client might disable a GSUB ligature substitution.
Each JstfModList table consists of a count of Lookups and an array of lookup indices.
During justification of a line of text, to implement modifications specified for a given
priority level, a text-processing client enables or disables the specified lookups in a
JstfModList table, reassembles the lookups in the LookupList order, and applies them to
each glyph in the string one after another.
If any JSTF suggestion at any priority level modifies a GSUB or GPOS lookup previously
applied to the glyph string, then the text-processing client must apply the JSTF
suggestion to an unmodified version of the glyph string.
Example 3 at the end of this chapter shows JstfModList tables with data for shrinking
and extending text line lengths.
JstfModList table
ﾉ

Expand table

Type

Name

Description

uint16

lookupCount

Number of lookups for this modification.

uint16

lookupIndices[lookupCount]

Array of Lookup indices into the GSUB or GPOS
LookupList, in increasing numerical order.

Justification maximum table
A justification maximum table (JstfMax) consists of an array of offsets to justification
lookups. JstfMax lookups typically are located after the JstfMax table in the font
definition.

JstfMax tables have the same format as lookup tables and subtables in the GPOS table,
but the JstfMax lookups reside in the JSTF table and contain justification data only. The
lookup data might specify a single adjustment value for positioning all glyphs in the
script, or it might specify more elaborate adjustments, such as different values for
different glyphs or special values for specific pairs of glyphs.
All GPOS lookup types except contextual positioning lookups may be defined in a
JstfMax table.
JstfMax lookup values are defined in GPOS ValueRecords and may be specified for any
advance or placement position, whether horizontal or vertical. These values define the
maximum shrinkage or extension allowed per glyph. To justify text, a text-processing
client may choose to adjust a glyph’s positioning by any amount from zero (0) to the
specified maximum.
Example 4 at the end of this chapter shows a JstfMax table. It defines a justification
lookup to change the size of the word space glyph to extend line lengths.
JstfMax table
ﾉ

Expand table

Type

Name

Description

uint16

lookupCount

Number of lookup Indices for this modification.

Offset16

lookupOffsets[lookupCount]

Array of offsets to GPOS-type lookup tables, from
beginning of JstfMax table, in design order.

JSTF structure examples
The rest of this chapter describes examples of all the JSTF table formats. All the
examples reflect unique parameters described below, but the samples provide a useful
reference for building tables specific to other situations.
The examples have three columns showing hex data, source, and comments.

Example 1: JSTF Header and JstfScriptRecord
Example 1 demonstrates how a script is defined in the JSTF Header with a
JstfScriptRecord that identifies the script and references its JstfScript table.
Example 1

ﾉ

Hex Data

Source

Comments

JSTFHeader
TheJSTFHeader

JSTFHeader table definition

00010000

0x00010000

major/minor version

0001

1

jstfScriptCount

Expand table

jstfScriptRecords[0]
74686169

'thai'

jstfScriptTag

000C

ThaiScript

offset to JstfScript table

Example 2: JstfScript table, ExtenderGlyph table,
JstfLangSysRecord, and JstfLangSys table
Example 2 shows a JstfScript table for the Arabic script and the tables it references. The
default JstfLangSys table defines justification data to apply to the script in the absence
of language-specific information. In the example, the table lists two justification
suggestions in priority order.
JstfScript also supplies language-specific justification data for the Farsi language. The
JstfLangSysRecord identifies the language and references its JstfLangSys table. The
FarsiJstfLangSys lists one suggestion for justifying Farsi text.
The ExtenderGlyph table in JstfScript lists the indices of all the extender glyphs used in
the script.
Example 2
ﾉ

Hex Data

Source

Comments

JstfScript

JstfScript table definition

Expand table

ArabicScript
000C

ArabicExtenders

extenderGlyphOffset

0012

ArabicDefJstfLangSys

offset to default JstfLangSys table

0001

1

jstfLangSysCount

jstfLangSysRecords[0]
50455220

“FAR ”

jstfLangSysTag

0018

FarsiJstfLangSys

jstfLangSysOffset

ExtenderGlyph

ExtenderGlyph table definition

ArabicExtenders
0002

2

glyphCount

01D3

TatweelGlyphID

extenderGlyphs[0]

01D4

LongTatweelGlyphID

extenderGlyphs[1]

JstfLangSys

JstfLangSys table definition

ArabicDefJstfLangSys
0002

2

jstfPriorityCount

000A

ArabicScriptJstfPriority1

jstfPriorityOffsets[0]

001E

ArabicScriptJstfPriority2

jstfPriorityOffsets[1]

JstfLangSys
FarsiJstfLangSys

JstfLangSys table definition

0001

1

jstfPriorityCount

002C

FarsiLangJstfPriority1

jstfPriorityOffsets[0]

Example 3: JstfPriority table and JstfModList table
Example 3 shows the JstfPriority and JstfModList table definitions for two justification
suggestions defined in priority order. The first suggestion uses ligature substitution to
shrink the lengths of text lines, and it extends line lengths by replacing ligatures with
their individual glyph components. Other lookup actions are not recommended at this
priority level and are set to NULL. The associated JstfModList tables enable and disable
three substitution lookups.
The second suggestion enables glyph kerning to reduce line lengths and disables glyph
kerning to extend line lengths. Each action uses three lookups. This suggestion also
includes a JstfMax table to extend line lengths, called WordSpaceExpandMax, which is
described in Example 4.
Example 3

ﾉ

Hex

Expand table

Source

Comments

JstfPriority
USEnglishFirstJstfPriority

JstfPriority table definition

0028

EnableGSUBLookupsToShrink

gsubShrinkageEnableOffset (offset to GSUB shrinkageenable JstfModList table)

0000

NULL

gsubShrinkageDisableOffset

0000

NULL

gposShrinkageEnableOffset

0000

NULL

gposShrinkageDisableOffset

0000

NULL

shrinkageJstfMaxOffset

0000

NULL

gsubExtensionEnableOffset

0038

DisableGSUBLookupsToExtend

gsubExtensionDisableOffset

0000

NULL

gposExtensionEnableOffset

0000

NULL

gposExtensionDisableOffset

0000

NULL

extensionJstfMaxOffset

JstfPriority
USEnglishSecondJstfPriority

JstfPriority table definition

0000

NULL

gsubShrinkageEnableOffset

0000

NULL

gsubShrinkageDisableOffset

0000

NULL

gposShrinkageEnableOffset

001C

DisableGPOSLookupsToShrink

gposShrinkageDisableOffset

0000

NULL

shrinkageJstfMaxOffset

0000

NULL

gsubExtensionEnableOffset

0000

NULL

gsubExtensionDisableOffset

002C

EnableGPOSLookupsToExtend

gposExtensionEnableOffset

0000

NULL

gposExtensionDisableOffset

0000

NULL

extensionJstfMaxOffset

JstfModList

JstfModList table definition, enable three ligature

Data

EnableGSUBLookupsToShrink

substitution lookups

0003

3

lookupCount

002E

46

gsubLookupIndices[0]

0035

53

gsubLookupIndices[1]

0063

99

gsubLookupIndices[2]

JstfModList

JstfModList table definition, disable three tight kerning

DisableGPOSLookupsToShrink

lookups

0003

3

lookupCount

006C

108

gposLookupIndices[0]

006E

110

gposLookupIndices[1]

0070

112

gposLookupIndices[2]

JstfModList
DisableGSUBLookupsToExtend

JstfModList table definition, disable three ligature
substitution lookups

0003

3

lookupCount

002E

46

gsubLookupIndices[0]

0035

53

gsubookupIndices[1]

0063

99

gsubLookupIndices[2]

JstfModList
EnableGPOSLookupsToExtend

JstfModList table definition enable three tight kerning
lookups

0003

3

lookupCount

006C

108

gposLookupIndices[0]

006E

110

gposLookupIndices[1]

0070

112

gposLookupIndices[2]

Example 4: JstfMax table
The JstfMax table in Example 4 defines a lookup to expand the advance width of the
word space glyph and extend line lengths. The lookup definition is identical to the
SinglePos lookup type in the GPOS table although it is enabled only when justifying text.
The ValueRecord in the WordSpaceExpand lookup subtable specifies an XAdvance
adjustment of 360 units, which is the maximum value the font developer recommends

for acceptable text rendering. The text-processing client may implement the lookup
using any value between zero and the maximum.
Example 4
ﾉ

Hex

Expand table

Source

Comments

JstfMax
WordSpaceExpandMax

JstfMax table definition

0001

1

lookupCount

0004

WordSpaceExpandLookup

lookupOffsets[0] (offset to JSTF Lookup table)

Lookup
WordSpaceExpandLookup

Jstf Lookup table definition

0001

1

lookupType: SinglePos Lookup

0000

0x0000

lookupFlag

0001

1

subTableCount

0008

WordSpaceExpandSubtable

subtableOffsets[0], SinglePos subtable

SinglePosFormat1

SinglePos subtable definition

Data

WordSpaceExpandSubtable
0001

1

format

0008

WordSpaceCoverage

offset to Coverage table

0004

0x0004

valueFormat: xAdvance only

0168

360

value — xAdvance value in Jstf: this is a max value,
expand word space from zero to this amount

CoverageFormat1

Coverage table definition

WordSpaceCoverage
0001

1

format

0001

1

glyphCount

0022

WordSpaceGlyphID

glyphArray[0]

kern — Kerning
Article • 05/31/2024

The kerning table contains values that control inter-character spacing for the glyphs in a
font. Fonts containing CFF outlines are not supported by the 'kern' table and require use
of the GPOS table to provide kerning.
Note: Apple specifications define a version of the 'kern' table with additional
functionality. Those extensions are not supported in OpenType.
A 'kern' table has one or more subtables. Each subtable varies in format and can contain
information for vertical or horizontal text. A subtable can contain kerning values or
minimum values. Kerning values are used to adjust inter-character spacing, and
minimum values are used to limit the amount of adjustment that the scaler applies by
the combination of kerning and tracking. Because the adjustments are additive, the
order of the subtables containing kerning values is not important. However, tables
containing minimum values should usually be placed last, so that they can be used to
limit the total effect of other subtables.
The kerning table has a header that contains the format number and the number of
subtables present.
KernHeader
ﾉ

Type

Field

Description

uint16

version

Table version number—set to 0.

uint16

nTables

Number of subtables in the kerning table.

Expand table

The kerning subtables follow immediately after the KernHeader. There are different
subtable formats that share the same header. The subtable header is used to identify
the format of the subtable and the kind of information it contains:
ﾉ

Type

Field

Description

uint16

version

Kern subtable version number—set to 0.

uint16

length

Length of the subtable, in bytes (including this header).

Expand table

uint16

coverage

What type of information is contained in this table.

The coverage field is divided into the following sub-fields, with sizes given in bits:
ﾉ

Expand table

Sub-field

Bit(s)

Description

horizontal

0

1 if table has horizontal data, 0 if vertical.

minimum

1

If this bit is set to 1, the table has minimum values. If set to 0, the table has
kerning values.

cross-

2

If set to 1, kerning is perpendicular to the flow of the text.

stream
If the text is normally written horizontally, kerning will be done in the up and
down directions. If kerning values are positive, the text will be kerned
upwards; if they are negative, the text will be kerned downwards.
If the text is normally written vertically, kerning will be done in the left and
right directions. If kerning values are positive, the text will be kerned to the
right; if they are negative, the text will be kerned to the left.
The value 0x8000 in the kerning data resets the cross-stream kerning back
to 0.
override

3

If this bit is set to 1 the value in this table should replace the value currently
being accumulated.

reserved1

4-7

Reserved—set to zero.

format

8-15

Format of the subtable. Only formats 0 and 2 have been defined. Formats 1
and 3 through 255 are reserved for future use.

Remaining subtable data follows the subtable header according to the format specified
in the coverage field. The length field in the subtable header indicates the total length of
the subtable, including the header and the format-specific data that follows it.

Format 0
Format 0 is the only subtable format supported by Windows.
This subtable is a sorted list of kerning pairs and values. The list is preceded by
information which makes it possible to make an efficient binary search of the list:
KernSubtableFormat0

ﾉ

Expand table

Type

Field

Description

uint16

nPairs

This gives the number of kerning pairs in the table.

uint16

searchRange

The largest power of two less than or equal to the value of nPairs,
multiplied by the size in bytes of an entry in the table.

uint16

entrySelector

This is calculated as log2 of the largest power of two less than or
equal to the value of nPairs. This value indicates how many
iterations of the search loop will have to be made. (For example, in a
list of eight items, there would have to be three iterations of the
loop).

uint16

rangeShift

The value of nPairs minus the largest power of two less than or
equal to nPairs, and then multiplied by the size in bytes of an entry
in the table.

KernPair

kernPairs[nPairs]

Array of KernPair records.

The kernPairs array provides a list of kerning pairs and values. Each KernPair record has
the following format:
KernPair record
ﾉ

Expand table

Type

Field

Description

uint16

left

The glyph index for the left-hand glyph in the kerning pair.

uint16

right

The glyph index for the right-hand glyph in the kerning pair.

FWORD

value

The kerning value for the above pair, in font design units. If this value is greater
than zero, the characters will be moved apart. If this value is less than zero, the
character will be moved closer together.

The KernPair records must be ordered by combining the left and right values to form an
unsigned 32-bit integer (left as the high-order word), then ordering records numerically
using these combined values.
A binary search is most efficiently coded if the search range is a power of two. The
search range can be reduced by half by shifting instead of dividing. In general, the
number of kerning pairs, nPairs, will not be a power of two. The value of the search
range, searchRange, should be the largest power of two less than or equal to nPairs. The
number of pairs not covered by searchRange (that is, nPairs - searchRange) is the value
rangeShift.

Format 2
This subtable is a two-dimensional array of kerning values. The glyphs are mapped to
classes, using a different mapping for left- and right-hand glyphs. This allows glyphs
that have similar right- or left-side shapes to be handled together. Each similar right- or
left-hand shape is said to be single class.
Each row in the kerning array represents one left-hand glyph class, each column
represents one right-hand glyph class, and each cell contains a kerning value. Row and
column 0 always represent glyphs that do not kern and contain all zeros.
The values in the right class table are stored pre-multiplied by the number of bytes in a
single kerning value, and the values in the left class table are stored pre-multiplied by
the number of bytes in one row. This eliminates a need to multiply the row and column
values together to determine the location of the kerning value. The array can be indexed
by doing the right- and left-hand class mappings, adding the class values to the address
of the array, and fetching the kerning value to which the new address points.
The header for the simple array has the following format:
KernSubtableFormat2
ﾉ

Expand table

Type

Field

Description

uint16

rowWidth

The width, in bytes, of a row in the table.

Offset16

leftClassOffset

Offset from beginning of this subtable to left-hand class table.

Offset16

rightClassOffset

Offset from beginning of this subtable to right-hand class table.

Offset16

kerningArrayOffset

Offset from beginning of this subtable to the start of the kerning
array.

Each class table has the following header:
ﾉ

Type

Field

Description

uint16

firstGlyph

First glyph in class range.

uint16

nGlyphs

Number of glyph in class range.

Expand table

This header is followed by nGlyphs number of class values, which are in uint16 format.
Entries for glyphs that don’t participate in kerning should point to the row or column at
position zero.
The array itself is a left by right array of kerning values, which are FWORDs, where left is
the number of left-hand classes and R is the number of right-hand classes. The array is
stored by row.
Note: This format is the quickest to process since each lookup requires only a few
index operations. The table can be quite large since it will contain the number of
cells equal to the product of the number of right-hand classes and the number of
left-hand classes, even though many of these classes do not kern with each other.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

loca — Index to Location
Article • 05/31/2024

The index to location ('loca') table stores an array of offsets to the locations of glyph
descriptions in the 'glyf' table, relative to the beginning of that table. Offsets in the array
are referenced by corresponding glyph IDs.
Offsets must be in ascending order, with loca[n] <= loca[n+1]. The length of each glyph
description is determined by the difference between two consecutive entries: loca[n+1] loca[n]. To compute the length of the last glyph description, there is an extra entry in the
offsets array after the entry for the last valid glyph ID. Thus, the number of elements in
the offsets array is numGlyphs + 1.
By definition, glyph index zero points to the “missing character” glyph, which is the
glyph that is displayed if a character is not found in the font’s 'cmap' table. A missing
character is commonly represented by a blank box or a space. If the font does not
contain an outline for this glyph, then the first and second offsets should have the same
value. This also applies to any other glyphs without an outline, such as the glyph for the
space character: if a glyph has no outline or instructions, then loca[n] = loca[n+1].
There are two formats of this table: a short format, and a long format. The format is
specified by the indexToLocFormat entry in the 'head' table.
Short format
ﾉ

Expand table

Type

Name

Description

Offset16

offsets[numGlyphs + 1]

The local offset divided by 2 is stored.

Long format
ﾉ

Type

Name

Description

Offset32

offsets[numGlyphs + 1]

The actual local offset is stored.

６ Collaborate with us on

Expand table

OpenType specification feedback

GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

LTSH — Linear Threshold
Article • 05/31/2024

The LTSH table can be used in fonts containing TrueType outlines. There can be
noticeable improvements to fonts on the screen when instructions are carefully applied
to the sidebearings. The gain in readability is offset by the necessity for the text layout
engine to grid fit the glyphs to determine the actual advance widths for the glyphs
(since instructions may be moving the sidebearing points). The TrueType outline format
already has two mechanisms to sidestep the speed issues. One is the 'hdmx' and VDMX
tables, in which precomputed horizontal and vertical advance widths can be saved for
selected ppem sizes. The LTSH table (Linear ThreSHold) is a second, complementary
method.
The LTSH table defines the size, on a glyph-by-glyph basis, at which it is reasonable to
assume linearly scaled advance widths. This table should not be included unless bit 4 of
the “flags” field in the 'head' table is set. The criteria for linear scaling are:
(ppem size is ≥ 50) AND (difference between the rounded linear width and the
rounded instructed width ≤ 2% of the rounded linear width); or
Linear width == Instructed width
The LTSH table records the ppem height for each glyph at which the scaling becomes
linear again, despite instructions affecting the advance width. At and above the
recorded threshold size, the glyph must remain linear in its scaling. For example, it is not
valid to set the threshold for a glyph at 55 ppem if the glyph scaling becomes nonlinear
again at 90 ppem.
The format for the table is:
ﾉ

Expand table

Type

Name

Description

uint16

version

Version number—set to 0.

uint16

numGlyphs

Number of glyphs (from numGlyphs in 'maxp' table).

uint8

yPixels[numGlyphs]

The vertical pixel height at which the glyph can be assumed to
scale linearly. On a per glyph basis.

Glyphs that do not have instructions on their sidebearings should have yPixels = 1 (the
glyph scales linearly at all sizes).

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

MATH - The Mathematical Typesetting
Table
Article • 05/29/2024

Overview
Mathematical formulas are complex text objects in which multiple elements with various
metric, style or positioning attributes are combined. In order for a math layout engine to
support layout of mathematical formulas, several types of font-specific information
particular to the layout of formulas are required. The MATH table provides this fontspecific information necessary for math formula layout.
Note that this is not a complete specification of math layout. The MATH table provides
font data required for math layout, but detailed algorithms for use of the data are not
specified. Different math layout engine implementations can use this data to produce
different layout results in accordance with different purposes or goals.
Layout of math formulas is quite different from regular text layout that is done using
tables such as GSUB and GPOS. Regular text layout mainly deals with a line of text, often
formatted with a single font. In this situation, actions such as contextual substitution or
kerning can be done with access to the complete context of the line of text, and the
rules can be expressed in terms of known glyph sequences. Math layout is quite
different from this.
The general structure of math formulas is hierarchical, with formulas composed of
smaller sub-formula expressions, where each expression may be composed of even
simpler expressions, and so on down to individual strings — operator symbols, variable
names and numbers.

Figure MATH.1. A complex math formula and a diagram showing the pieces of metal
type and spacing materials used in a traditional printing application
Likewise, the process of math formula layout is also recursive. Child components are
formatted first and then arranged to form their parent’s layout with this process
repeated on every level starting from simplest blocks up to the whole formula. Each
sub-formula has its own component structure and rules for how to perform layout. For
example, a fraction expression consists of numerator and denominator sub-expressions,
which will be placed on top one another with a fraction rule separating them. An
integral expression contains an integral sign, optional upper-limit and lower-limit
expressions, and a following sub-expression.
The simplest blocks within a formula typically contain strings. In isolation, each could be
laid out by regular text-layout processing using other tables such as GSUB and GPOS.
Math layout goes beyond this. It deals mainly with layout processing involved in
composing these simple blocks together into a complex, hierarchical formula. The data
provided in the MATH table allows math layout processing to be typographically aware,
so that presentation with high typographic quality can be achieved.
A math layout engine works with boxes representing individual formula components as
units of layout. During the layout process, individual boxes can be arranged relative to
each other; they can be stretched, depending on the sizes of other boxes they interact
with; or they can use different glyph variants, based on the box size or position in the
formula. The MATH table provides data that informs how these operations are done.
Each box has an associated font that supplies information comprising typographic
requirements for that box. These may be requirements for that box alone, based on the
results of layout operations internal to the box; or they may be requirements on how
other boxes interact with that box in layout.

By providing information about a font generally or about specific glyphs in the font, the
MATH table can enable math-layout engines to produce layout that is appropriate for
the font design, and that realizes the font’s full typographic potential by using stylistic
and stretching glyph variants provided by the font.

MATH table structures
Shared formats: MathValueRecord, Coverage table
MathValueRecord
MATH subtables use math value records to describe values that place or adjust elements
of math formulas. These values are expressed in font design units.
A MathValueRecord may also specify an offset to a device table which provides
corrections to a given value at particular display resolutions. The device table format is
described in the OpenType Layout Common Table Formats chapter. The device table can
provide multiple correction values to be used for several different PPEM sizes. Different
formats for representing the correction values are provided to allow for efficient
representation, according to the size requirements of the correction values. When used
in MathValueRecords, format 1 is recommended.
When designing a MATH table, device tables can be specified for many values used for
positioning elements of a formula. This creates the potential that many device
corrections could accumulate in a given layout. However, such accumulation would
result in metrics for formula elements that are significantly different from scale-adjusted
dimensions of the same elements rendered on a high-resolution device. It would
produce inconsistencies between screen and print renditions, and could also lead to
clipping. For these reasons, accumulation of many corrections is undesirable.
While a font may specify device corrections, use of these corrections is under the control
of a given layout engine implementation. To maintain consistency across devices with
different resolutions, an engine may limit the number of device corrections that are
accumulated, or may ignore them altogether. A layout engine may also supply its own
corrections where none are indicated in the font. Since the accumulated size of
corrections should be kept to a minimum, it is recommended that device tables
referenced by a MathValueRecord use format 1 for representation of correction values.
This format allows corrections of at most -2 to +1 pixels. The recommended values to
use in MathValueRecords are -1, 0, or 1.
MathValueRecord

ﾉ

Expand table

Type

Name

Description

FWORD

value

The X or Y value in design units.

Offset16

deviceOffset

Offset to the device table, from the beginning of parent table. May be
NULL. Suggested format for device table is 1.

Coverage table
MATH subtables make use of Coverage tables, defined in the OpenType Layout
Common Table Formats chapter, to specify sets of glyphs. All Coverage table formats
may be used in the MATH table.

MATH Header
The MATH table begins with a header that consists of a version number for the table
(majorVersion/minorVersion), which is currently set to 1.0, and specified offsets to the
following tables that store information on positioning of math formula elements:
MathConstants table stores font parameters to be used in typesetting of each
supported mathematical function, such as a fraction or a radical.
MathGlyphInfo table supplies positioning information that is defined on a perglyph basis.
MathVariants table contains information to be used in constructing glyph variants
of different height or width, either by finding a pre-defined glyph with desired
measurements in the font, or by assembling the required shape from pieces found
in the glyph set.
MATH Header
ﾉ

Expand table

Type

Name

Description

uint16

majorVersion

Major version of the MATH table, = 1.

uint16

minorVersion

Minor version of the MATH table, = 0.

Offset16

mathConstantsOffset

Offset to MathConstants table, from the beginning of MATH
table.

Offset16

mathGlyphInfoOffset

Offset to MathGlyphInfo table, from the beginning of MATH
table.

Offset16

mathVariantsOffset

Offset to MathVariants table, from the beginning of MATH
table.

MathConstants table
The MathConstants table defines a number of constants required to properly position
elements of mathematical formulas. These constants belong to several groups of
semantically-related values, such as values for positioning of accents, positioning of
superscripts and subscripts, and positioning of elements of fractions. The table also
contains general-use constants that may affect all parts of the formula, such as axis
height and math leading. Note that most of the constants deal with aspects of vertical
positioning.
In most cases, values in the MathConstants table are assumed to be positive. For
example, for descenders and shift-down values a positive constant signifies movement
in a downwards direction. Most values in the MathConstants table are represented by a
MathValueRecord, which allows the font designer to supply device corrections to those
values when necessary.
For values that pertain to layout interactions between a base and dependent elements
(e.g., superscripts or limits), the specific value used is taken from the font associated with
the base, and the size of the value is relative to the size of the base.
The following naming convention are used for fields in the MathConstants table:
Height — Specifies a distance from the main baseline.
Kern — Represents a fixed amount of empty space to be introduced.
Gap — Represents an amount of empty space that may need to be increased to
meet certain criteria.
Drop and Rise — Specifies the relationship between measurements of two
elements to be positioned relative to each other (but not necessarily in a stack-like
manner) that must meet certain criteria. For a Drop, one of the positioned
elements has to be moved down to satisfy those criteria; for a Rise, the movement
is upwards.
Shift — Defines a vertical shift applied to an element sitting on a baseline. Note
that the value is an amount of adjustment to the position of an element, not the
resulting distance from the baseline or other reference line.
Dist — Defines a distance between baselines of two elements.
The descriptions for several fields refer to default rule thickness. Layout engines control
how rules are drawn and how their thickness is set. It is recommended that rules have
the same thickness as a minus sign, low line, or a similar font value such as

OS/2.yStrikeoutSize. For fields that are described in reference to default rule thickness,
one of these should be assumed.
MathConstants table
ﾉ

Expand table

Type

Name

Description

int16

scriptPercentScaleDown

Percentage of scaling down for
level 1 superscripts and subscripts.
Suggested value: 80%.

int16

scriptScriptPercentScaleDown

Percentage of scaling down for
level 2 (scriptScript) superscripts
and subscripts. Suggested value:
60%.

UFWORD

delimitedSubFormulaMinHeight

Minimum height required for a
delimited expression (contained
within parentheses, etc.) to be
treated as a sub-formula.
Suggested value: normal line
height × 1.5.

UFWORD

displayOperatorMinHeight

Minimum height of n-ary
operators (such as integral and
summation) for formulas in display
mode (that is, appearing as
standalone page elements, not
embedded inline within text).

MathValueRecord

mathLeading

White space to be left between
math formulas to ensure proper
line spacing. For example, for
applications that treat line gap as a
part of line ascender, formulas with
ink going above
(os2.sTypoAscender +
os2.sTypoLineGap - MathLeading)
or with ink going below
os2.sTypoDescender will result in
increasing line height.

MathValueRecord

axisHeight

Axis height of the font.
In math typesetting, the term axis
refers to a horizontal reference line
used for positioning elements in a
formula. The math axis is similar to

but distinct from the baseline for
regular text layout. For example, in
a simple equation, a minus symbol
or fraction rule would be on the
axis, but a string for a variable
name would be set on a baseline
that is offset from the axis. The
axisHeight value determines the
amount of that offset.
MathValueRecord

accentBaseHeight

Maximum (ink) height of accent
base that does not require raising
the accents. Suggested: x‑height of
the font (os2.sxHeight) plus any
possible overshots.

MathValueRecord

flattenedAccentBaseHeight

Maximum (ink) height of accent
base that does not require
flattening the accents. Suggested:
cap height of the font
(os2.sCapHeight).

MathValueRecord

subscriptShiftDown

The standard shift down applied to
subscript elements. Positive for
moving in the downward direction.
Suggested: os2.ySubscriptYOffset.

MathValueRecord

subscriptTopMax

Maximum allowed height of the
(ink) top of subscripts that does
not require moving subscripts
further down. Suggested: 4/5 xheight.

MathValueRecord

subscriptBaselineDropMin

Minimum allowed drop of the
baseline of subscripts relative to
the (ink) bottom of the base.
Checked for bases that are treated
as a box or extended shape.
Positive for subscript baseline
dropped below the base bottom.

MathValueRecord

superscriptShiftUp

Standard shift up applied to
superscript elements. Suggested:
os2.ySuperscriptYOffset.

MathValueRecord

superscriptShiftUpCramped

Standard shift of superscripts
relative to the base, in cramped
style.

MathValueRecord

superscriptBottomMin

Minimum allowed height of the
(ink) bottom of superscripts that

does not require moving subscripts
further up. Suggested: ¼ x-height.
MathValueRecord

superscriptBaselineDropMax

Maximum allowed drop of the
baseline of superscripts relative to
the (ink) top of the base. Checked
for bases that are treated as a box
or extended shape. Positive for
superscript baseline below the
base top.

MathValueRecord

subSuperscriptGapMin

Minimum gap between the
superscript and subscript ink.
Suggested: 4 × default rule
thickness.

MathValueRecord

superscriptBottomMaxWithSubscript

The maximum level to which the
(ink) bottom of superscript can be
pushed to increase the gap
between superscript and subscript,
before subscript starts being
moved down. Suggested: 4/5 xheight.

MathValueRecord

spaceAfterScript

Extra white space to be added after
each subscript and superscript that
occurs after a baseline element,
and before each subscript and
superscript that occurs before a
baseline element. Suggested: 0.5
pt for a 12 pt font.
Note that, in some math layout
implementations, a constant value,
such as 0.5 pt, could be used for all
text sizes. Some implementations
could use a constant ratio of text
size, such as 1/24 of em.

MathValueRecord

upperLimitGapMin

Minimum gap between the (ink)
bottom of the upper limit, and the
(ink) top of the base operator.

MathValueRecord

upperLimitBaselineRiseMin

Minimum distance between
baseline of upper limit and (ink)
top of the base operator.

MathValueRecord

lowerLimitGapMin

Minimum gap between (ink) top of
the lower limit, and (ink) bottom of
the base operator.

MathValueRecord

lowerLimitBaselineDropMin

Minimum distance between
baseline of the lower limit and (ink)
bottom of the base operator.

MathValueRecord

stackTopShiftUp

Standard shift up applied to the
top element of a stack.

MathValueRecord

stackTopDisplayStyleShiftUp

Standard shift up applied to the
top element of a stack in display
style.

MathValueRecord

stackBottomShiftDown

Standard shift down applied to the
bottom element of a stack. Positive
for moving in the downward
direction.

MathValueRecord

stackBottomDisplayStyleShiftDown

Standard shift down applied to the
bottom element of a stack in
display style. Positive for moving in
the downward direction.

MathValueRecord

stackGapMin

Minimum gap between (ink)
bottom of the top element of a
stack, and the (ink) top of the
bottom element. Suggested: 3 ×
default rule thickness.

MathValueRecord

stackDisplayStyleGapMin

Minimum gap between (ink)
bottom of the top element of a
stack, and the (ink) top of the
bottom element in display style.
Suggested: 7 × default rule
thickness.

MathValueRecord

stretchStackTopShiftUp

Standard shift up applied to the
top element of the stretch stack.

MathValueRecord

stretchStackBottomShiftDown

Standard shift down applied to the
bottom element of the stretch
stack. Positive for moving in the
downward direction.

MathValueRecord

stretchStackGapAboveMin

Minimum gap between the ink of
the stretched element, and the
(ink) bottom of the element above.
Suggested: same value as
upperLimitGapMin.

MathValueRecord

stretchStackGapBelowMin

Minimum gap between the ink of
the stretched element, and the
(ink) top of the element below.

Suggested: same value as
lowerLimitGapMin.
MathValueRecord

fractionNumeratorShiftUp

Standard shift up applied to the
numerator.

MathValueRecord

fractionNumeratorDisplayStyleShiftUp

Standard shift up applied to the
numerator in display style.
Suggested: same value as
stackTopDisplayStyleShiftUp.

MathValueRecord

fractionDenominatorShiftDown

Standard shift down applied to the
denominator. Positive for moving
in the downward direction.

MathValueRecord

fractionDenominatorDisplayStyleShiftDown

Standard shift down applied to the
denominator in display style.
Positive for moving in the
downward direction. Suggested:
same value as
stackBottomDisplayStyleShiftDown.

MathValueRecord

fractionNumeratorGapMin

Minimum tolerated gap between
the (ink) bottom of the numerator
and the ink of the fraction bar.
Suggested: default rule thickness.

MathValueRecord

fractionNumDisplayStyleGapMin

Minimum tolerated gap between
the (ink) bottom of the numerator
and the ink of the fraction bar in
display style. Suggested: 3 ×
default rule thickness.

MathValueRecord

fractionRuleThickness

Thickness of the fraction bar.
Suggested: default rule thickness.

MathValueRecord

fractionDenominatorGapMin

Minimum tolerated gap between
the (ink) top of the denominator
and the ink of the fraction bar.
Suggested: default rule thickness.

MathValueRecord

fractionDenomDisplayStyleGapMin

Minimum tolerated gap between
the (ink) top of the denominator
and the ink of the fraction bar in
display style. Suggested: 3 ×
default rule thickness.

MathValueRecord

skewedFractionHorizontalGap

Horizontal distance between the
top and bottom elements of a
skewed fraction.

MathValueRecord

skewedFractionVerticalGap

Vertical distance between the ink
of the top and bottom elements of
a skewed fraction.

MathValueRecord

overbarVerticalGap

Distance between the overbar and
the (ink) top of the base.
Suggested: 3 × default rule
thickness.

MathValueRecord

overbarRuleThickness

Thickness of overbar. Suggested:
default rule thickness.

MathValueRecord

overbarExtraAscender

Extra white space reserved above
the overbar. Suggested: default
rule thickness.

MathValueRecord

underbarVerticalGap

Distance between underbar and
(ink) bottom of the base.
Suggested: 3 × default rule
thickness.

MathValueRecord

underbarRuleThickness

Thickness of underbar. Suggested:
default rule thickness.

MathValueRecord

underbarExtraDescender

Extra white space reserved below
the underbar. Always positive.
Suggested: default rule thickness.

MathValueRecord

radicalVerticalGap

Space between the (ink) top of the
expression and the bar over it.
Suggested: 1¼ default rule
thickness.

MathValueRecord

radicalDisplayStyleVerticalGap

Space between the (ink) top of the
expression and the bar over it.
Suggested: default rule thickness +
¼ x-height.

MathValueRecord

radicalRuleThickness

Thickness of the radical rule. This is
the thickness of the rule in
designed or constructed radical
signs. Suggested: default rule
thickness.

MathValueRecord

radicalExtraAscender

Extra white space reserved above
the radical. Suggested: same value
as radicalRuleThickness.

MathValueRecord

radicalKernBeforeDegree

Extra horizontal kern before the
degree of a radical, if such is
present. Suggested: 5/18 of em.

MathValueRecord

radicalKernAfterDegree

Negative kern after the degree of a
radical, if such is present.
Suggested: −10/18 of em.

int16

radicalDegreeBottomRaisePercent

Height of the bottom of the radical
degree, if such is present, in
proportion to the height (ascender
+ descender) of the radical sign.
Suggested: 60%.

MathGlyphInfo table
The MathGlyphInfo table contains positioning information that is defined on per-glyph
basis. The table consists of the following parts:
A MathItalicsCorrectionInfo table that contains information on italics correction
values.
A MathTopAccentAttachment table that contains horizontal positions for attaching
mathematical accents.
An Extended Shape coverage table. The glyphs covered by this table are to be
considered extended shapes.
A MathKernInfo table that provides per-glyph information for mathematical
kerning.
MathGlyphInfo table
ﾉ

Expand table

Type

Name

Description

Offset16

mathItalicsCorrectionInfoOffset

Offset to MathItalicsCorrectionInfo table, from the
beginning of the MathGlyphInfo table.

Offset16

mathTopAccentAttachmentOffset

Offset to MathTopAccentAttachment table, from
the beginning of the MathGlyphInfo table.

Offset16

extendedShapeCoverageOffset

Offset to ExtendedShapes coverage table, from the
beginning of the MathGlyphInfo table. When the
glyph to the left or right of a box is an extended
shape variant, the (ink) box should be used for
vertical positioning purposes, not the default
position defined by values in MathConstants table.
May be NULL.

Offset16

mathKernInfoOffset

Offset to MathKernInfo table, from the beginning
of the MathGlyphInfo table.

MathItalicsCorrectionInfo table
The MathItalicsCorrectionInfo table contains italics correction values for slanted glyphs
used in math layout. The top portion of slanted glyphs may protrude beyond the glyph’s
advance width. This can result in collision with other interacting elements, or an
appearance in the placement of other interacting elements that is unpleasing unless
some accommodation is made for the protrusion. The MathItalicsCorrectionInfo table
provides correction values to accommodate for such protrusion.
The table consists of the following parts:
Coverage of glyphs for which the italics correction values are provided. Italics
correction is assumed to be zero for all other glyphs.
Count of covered glyphs.
Array of italic correction values for each covered glyph, in order of coverage. The
italics correction value can be used as an adjustment for positioning of interacting
elements to make allowance for protrusion to the right of the top part of the
glyph. For example, taller letters tend to have larger italics correction, and a V will
probably have larger italics correction than an L.
Italics correction can be used in the following situations:
When a run of slanted characters is followed by a straight character (such as an
operator or a delimiter), the italics correction of the last glyph is added to its
advance width.
When positioning limits on an N-ary operator (e.g., integral sign), the horizontal
position of the upper limit is moved to the right by ½ of the italics correction,
while the position of the lower limit is moved to the left by the same distance.
When positioning superscripts and subscripts, their default horizontal positions are
also different by the amount of the italics correction of the preceding glyph.
MathItalicsCorrectionInfo table
ﾉ

Expand table

Type

Name

Description

Offset16

italicsCorrectionCoverageOffset

Offset to Coverage table, from the
beginning of
MathItalicsCorrectionInfo table.

uint16

italicsCorrectionCount

Number of italics correction values.
Should coincide with the number of
covered glyphs.

MathValueRecord

italicsCorrection[italicsCorrectionCount]

Array of MathValueRecords
defining italics correction values for
each covered glyph.

MathTopAccentAttachment table
The MathTopAccentAttachment table contains information on horizontal positioning of
top math accents. The table consists of the following parts:
Coverage of glyphs for which information on horizontal positioning of math
accents is provided. To position accents over any other glyph, its geometrical
center (with respect to advance width) can be used.
Count of covered glyphs.
Array of top accent attachment points for each covered glyph, in order of
coverage. These attachment points are to be used for finding horizontal positions
of accents over characters. It is done by aligning the attachment point of the base
glyph with the attachment point of the accent. Note that this is very similar to
mark-to-base attachment, but here alignment only happens in the horizontal
direction, and the vertical positions of accents are determined by different means.
MathTopAccentAttachment table
ﾉ

Expand table

Type

Name

Description

Offset16

topAccentCoverageOffset

Offset to Coverage table,
from the beginning of the
MathTopAccentAttachment
table.

uint16

topAccentAttachmentCount

Number of top accent
attachment point values.
Must be the same as the
number of glyph IDs
referenced in the Coverage
table.

MathValueRecord

topAccentAttachment[topAccentAttachmentCount]

Array of MathValueRecords
defining top accent
attachment points for each
covered glyph.

ExtendedShapeCoverage table

The glyphs covered by this table are to be considered extended shapes. These glyphs
are variants extended in the vertical direction, e.g., to match the height of another part
of the formula. Because their dimensions may be very large in comparison with normal
glyphs in the glyph set, the standard positioning algorithms will not produce the best
results when applied to them. In the vertical direction, other formula elements will be
positioned not relative to those glyphs, but instead to the ink box of the subexpression
containing them.
For example, consider a fraction enclosed in parentheses with a superscript. Notice how
the superscripts on ‘z’ and ‘Z’ are aligned vertically, although they have different heights.
If the right parenthesis was not considered an extended shape, the superscript would be
put in position aligned with any other superscript on the line, like this:

Because this is undesirable, the right parenthesis in this case should be considered an
extended shape, resulting in superscript positioned relative to the whole subexpression:

MathKernInfo table
The MathKernInfo table provides mathematical kerning values used for kerning of
subscript and superscript glyphs relative to a base glyph. Its purpose is to improve
spacing in situations such as 𝜔𝑓 or 𝑉𝐴.
Mathematical kerning is height dependent; that is, different kerning amounts can be
specified for different heights within a glyph’s vertical extent. For any given glyph,
different values can be specified for four corner positions — top-right, to-left, etc. —
allowing for different kerning adjustments according to whether the glyph occurs as a
subscript, a superscript, a base being kerned with a subscript, or a base being kerned
with a superscript.
The kerning algorithm for subscripts and superscripts is as follows:
Calculate the vertical positions of subscripts and superscripts using the
MathConstants table.
Set the default horizontal position for a subscript immediately after the base glyph.
Set the default horizontal position for a superscript after the base, applying a shift
for italics correction if indicated for the base glyph in the MathItalicsCorrectionInfo
table.

Calculate a superscript kerning value as follows:
Evaluate two correction heights (illustrated in the figure below):
At the bottom of the superscript-glyph bounding box. (The corresponding
height for the base glyph is the distance from the base-glyph baseline to the
bottom of the superscript bounding box.)
At the top of the base-glyph bounding box. (The corresponding height for
the superscript glyph is the distance from the superscript baseline to the top
of the base-glyph bounding box.)
For each correction height, add the top-right kerning value for the base glyph
to the bottom-left kerning value for the superscript glyph.
Take the minimum of these two sums: kern the base and superscript by that
amount.
Calculate a subscript kerning value as follows:
Evaluate two correction heights:
At the top of the subscript-glyph bounding box. (The corresponding height
for the base glyph is the distance from the base-glyph baseline to the top of
the subscript bounding box.)
At the bottom of the base-glyph bounding box. (The corresponding height
for the subscript glyph is the distance from the subscript baseline to the
bottom of the base-glyph bounding box.)
For each correction height, add the bottom-right kerning value for the base
glyph to the top-left kerning value for the subscript glyph.
Take the minimum of these two sums: kern the base and subscript by that
amount.
If a base expression, subscript expression or superscript expression is a box, a mathlayout engine may use kerning values of zero for each corner of the box, or may
calculate height-dependent kerning amounts by some means.
The following figure illustrates the correction heights for a base and superscript:

Figure MATH.2. Example of horizontal and vertical kerning adjustments for superscript
positioning
The MathKernInfo table consists of the following fields:
A Coverage table of glyphs for which mathematical kerning information is
provided. Mathematical kerning amounts are assumed to be zero for all other
glyphs.
Count of MathKernInfoRecords.
Array of MathKernInfoRecords for each covered glyph, following the order of
glyphs in the Coverage table.
MathKernInfo table
ﾉ

Expand table

Type

Name

Description

Offset16

mathKernCoverageOffset

Offset to Coverage table, from
the beginning of the
MathKernInfo table.

uint16

mathKernCount

Number of
MathKernInfoRecords. Must be
the same as the number of glyph
IDs referenced in the Coverage
table.

MathKernInfoRecord

mathKernInfoRecords[mathKernCount]

Array of MathKernInfoRecords,
one for each covered glyph.

MathKernInfoRecord
Each MathKernInfoRecord points to up to four kern tables for each of the corners
around the glyph. If no kern table is provided for a corner, a kerning amount of zero is
assumed.
MathKernInfoRecord
ﾉ

Expand table

Type

Name

Description

Offset16

topRightMathKernOffset

Offset to MathKern table for top right corner, from the
beginning of the MathKernInfo table. May be NULL.

Offset16

topLeftMathKernOffset

Offset to MathKern table for the top left corner, from
the beginning of the MathKernInfo table. May be NULL.

Offset16

bottomRightMathKernOffset

Offset to MathKern table for bottom right corner, from
the beginning of the MathKernInfo table. May be NULL.

Offset16

bottomLeftMathKernOffset

Offset to MathKern table for bottom left corner, from
the beginning of the MathKernInfo table. May be NULL.

MathKern table
The MathKern table provides kerning amounts for different heights in a glyph’s vertical
extent. An array of kerning values is provided, each of which applies to a height range. A
corresponding array of heights indicate the transition points between consecutive
ranges.
Correction heights for each glyph are relative to the glyph baseline, with positive height
values above the baseline, and negative height values below the baseline. The
correctionHeights array is sorted in increasing order, from lowest to highest.
The kerning value corresponding to a particular height is determined by finding two
consecutive entries in the correctionHeight array such that the given height is greater
than or equal to the first entry and less than the second entry. The index of the second
entry is used to look up a kerning value in the kernValues array. If the given height is
less than the first entry in the correctionHeights array, the first kerning value (index 0) is
used. For a height that is greater than or equal to the last entry in the correctionHeights
array, the last entry is used.
MathKern table
ﾉ

Expand table

Type

Name

Description

uint16

heightCount

Number of heights at which the kern value
changes.

MathValueRecord

correctionHeight[heightCount]

Array of correction heights, in design units,
sorted from lowest to highest.

MathValueRecord

kernValues[heightCount + 1]

Array of kerning values for different height
ranges. Negative values are used to move
glyphs closer to each other.

Math variants

MathVariants table
The MathVariants table solves the following problem: given a particular default glyph
shape and a certain width or height, find a variant shape glyph (or construct created by
putting several glyphs together) that has the required measurement. This functionality is
needed for growing the parentheses to match the height of the expression within,
growing the radical sign to match the height of the expression under the radical,
stretching accents like tilde when they are put over several characters, for stretching
arrows, horizontal curly braces, and so forth.
The MathVariants table consists of the following fields:
Count and coverage of glyphs that can grow in the vertical direction.
Count and coverage of glyphs that can grow in the horizontal direction.
The minConnectorOverlap field defines by how much two glyphs need to overlap
with each other when used to construct a larger shape. Each glyph to be used as a
building block in constructing extended shapes will have a straight part at either or
both ends. This connector part is used to connect that glyph to other glyphs in the
assembly. These connectors need to overlap to compensate for rounding errors
and hinting corrections at a lower resolution. The minConnectorOverlap value tells
how much overlap is necessary for this particular font.
Two arrays of offsets to MathGlyphConstruction tables: one array for glyphs that
grow in the vertical direction, and the other array for glyphs that grow in the
horizontal direction. The arrays must be arranged in coverage order and have
specified sizes.
MathVariants table
ﾉ

Expand table

Type

Name

Description

UFWORD

minConnectorOverlap

Minimum overlap of connecting
glyphs during glyph construction,
in design units.

Offset16

vertGlyphCoverageOffset

Offset to Coverage table, from the
beginning of the MathVariants
table.

Offset16

horizGlyphCoverageOffset

Offset to Coverage table, from the
beginning of the MathVariants
table.

uint16

vertGlyphCount

Number of glyphs for which
information is provided for

vertically growing variants. Must
be the same as the number of
glyph IDs referenced in the
vertical Coverage table.
uint16

horizGlyphCount

Number of glyphs for which
information is provided for
horizontally growing variants.
Must be the same as the number
of glyph IDs referenced in the
horizontal Coverage table.

Offset16

vertGlyphConstructionOffsets[vertGlyphCount]

Array of offsets to
MathGlyphConstruction tables,
from the beginning of the
MathVariants table, for shapes
growing in the vertical direction.

Offset16

horizGlyphConstructionOffsets[horizGlyphCount]

Array of offsets to
MathGlyphConstruction tables,
from the beginning of the
MathVariants table, for shapes
growing in the horizontal
direction.

MathGlyphConstruction table
The MathGlyphConstruction table provides information on finding or assembling
extended variants for one particular glyph. It can be used for shapes that grow in either
horizontal or vertical directions.
The first entry is the offset to the GlyphAssembly table that specifies how the shape for
this glyph can be assembled from parts found in the glyph set of the font. If no such
assembly exists, this offset will be set to NULL.
The MathGlyphConstruction table also contains the count and array of ready-made
glyph variants for the specified glyph. Each variant consists of the glyph index and this
glyph’s measurement in the direction of extension (vertical or horizontal).
Note that it is quite possible that both the GlyphAssembly table and some variants are
defined for a particular glyph. For example, the font may provide several variants of
curly braces with different sizes, and also a general mechanism for constructing larger
versions of curly braces by stacking parts found in the glyph set. First, an attempt is
made to find glyph among provided variants. If the required size is larger than any of
the glyph variants provided, however, then the general mechanism can be employed to
typeset the curly braces as a glyph assembly.

MathGlyphConstruction table
ﾉ

Expand table

Type

Name

Description

Offset16

glyphAssemblyOffset

Offset to the
GlyphAssembly table for
this shape, from the
beginning of the
MathGlyphConstruction
table. May be NULL.

uint16

variantCount

Count of glyph growing
variants for this glyph.

MathGlyphVariantRecord

mathGlyphVariantRecords[variantCount]

MathGlyphVariantRecords
for alternative variants of
the glyphs.

MathGlyphVariantRecord
ﾉ

Expand table

Type

Name

Description

uint16

variantGlyph

Glyph ID for the variant.

UFWORD

advanceMeasurement

Advance width/height, in design units, of the variant, in the
direction of requested glyph extension.

GlyphAssembly table
The GlyphAssembly table specifies how the shape for a particular glyph can be
constructed from parts found in the glyph set. The table defines the italics correction of
the resulting assembly, and a number of parts that have to be put together to form the
required shape. Some glyph parts can be designated as extenders, which can be
repeated as needed to obtain a target size.
GlyphAssembly table
ﾉ

Type

Name

Description

Expand table

MathValueRecord

italicsCorrection

Italics correction of this GlyphAssembly. Should not
depend on the assembly size.

uint16

partCount

Number of parts in this assembly.

GlyphPart

partRecords[partCount]

Array of GlyphPart records, from left to right (for
assemblies that extend horizontally) or bottom to
top (for assemblies that extend vertically).

The result of the assembly process is an array of glyphs with an offset specified for each
of those glyphs. When drawn consecutively at those offsets, the glyphs should combine
correctly and produce the required shape.
The offsets in the direction of growth (advance offsets), as well as the number of
extender parts, are determined based on the size requirement for the resulting
assembly.
Note that the glyphs comprising the assembly should be designed so that they align
properly in the direction that is orthogonal to the direction of growth.
Thus, a GlyphPart record consists of the following fields:
Glyph ID for the part.
Lengths of the connectors on each end of the glyph. The connectors are straight
parts of the glyph that can be used to link it with the next or previous part. The
connectors of neighboring parts can overlap by varying amounts, providing
flexibility in how these glyphs can be put together. However, the overlap should
not be less than the minConnectorOverlap value defined in the MathVariants
tables, and it should not exceed the specified connector length for that end of the
glyph. If the part does not have a connector on one of its ends, the corresponding
connector length should be set to zero.
The full advance of the part. It is also used to determine the measurement of the
result by using the following formula:
Size of Assembly = Offset of the Last Part + Full Advance of the Last Part
PartFlags is the last field. It identifies certain parts as extenders: those parts that can
be repeated (that is, multiple instances of them can be used in place of one) or
skipped altogether. Usually, the extenders are vertical or horizontal bars of the
appropriate thickness, aligned with the rest of the assembly.
To ensure that the width/height is distributed equally and the symmetry of the shape is
preserved, the following steps can be used by the math-layout engine.

1. Assemble all parts with all extenders removed and with connections overlapping
by the maximum amount. This gives the smallest possible result.
2. Determine how much extra width/height can be obtained from all existing
connections between neighboring parts by using minimal overlaps. If that is
enough to achieve the size goal, extend each connection equally by changing
overlaps of connectors to finish the job.
3. If all connections have been extended to the minimum overlap and further growth
is needed, add one of each extender, and repeat the process from the first step.
Note that for assemblies growing in the vertical direction, the distribution of height
between ascent and descent is not defined. The math-layout engine is responsible for
positioning the resulting assembly relative to the baseline.
GlyphPart record
ﾉ

Expand table

Type

Name

Description

uint16

glyphID

Glyph ID for the part.

UFWORD

startConnectorLength

Advance width/ height, in design units, of the straight bar
connector material at the start of the glyph in the direction of
the extension (the left end for horizontal extension, the
bottom end for vertical extension).

UFWORD

endConnectorLength

Advance width/ height, in design units, of the straight bar
connector material at the end of the glyph in the direction of
the extension (the right end for horizontal extension, the top
end for vertical extension).

UFWORD

fullAdvance

Full advance width/height for this part in the direction of the
extension, in design units.

uint16

partFlags

Part qualifiers. PartFlags enumeration currently uses only one
bit:
0x0001 EXTENDER_FLAG: If set, the part can be skipped or
repeated.
0xFFFE Reserved.

OpenType Layout tags used with the MATH
table
The following OpenType Layout tags can be used by a math layout engine to access a
particular set of glyph variants. For detailed descriptions of the feature tags, see the

Feature Tags section of the OpenType Layout Tag Registry.
OpenType Layout tags for math processing
ﾉ

Expand table

Tag

Description

'math'

Script tag to be used for features in math layout. The only language system supported
with this tag is the default language system.

'ssty'

Math Script-style Alternates
This feature provides glyph variants adjusted to be more suitable for use in subscripts
and superscripts.
These script style forms should not be scaled or moved in the font; scaling and moving
them is done by the math layout engine. Instead, the 'ssty' feature should provide glyph
forms that result in shapes that look good as superscripts and subscripts when scaled
and positioned by the math engine. When designing the script forms, the font developer
may assume that the scriptPercentScaleDown and scriptScriptPercentScaleDown values in
the MathConstants table will be scaling factors applied to the size of the alternate glyphs
by the math engine.
This feature can have a parameter indicating the script level: 1 for simple subscripts and
superscripts, 2 for second level subscripts and superscripts (that is, scripts on scripts), and
so on. (Currently, only the first two alternates are used).
For glyphs that are not covered by this feature, the original glyph is used in subscripts
and superscripts.
Recommended format: Alternate Substitution table (Single Substitution if there are no
second level forms). There should be no context.

'flac'

Flattened Accent Forms
This feature provides flattened forms of accents to be used over high-rise bases such as
capitals.
This feature should only change the shape of the accent and should not move it in the
vertical or horizontal direction. Moving of the accents is done by the math layout engine.
Accents are flattened by the math engine if their base is higher than the
flattenedAccentBaseHeight value in the MathConstants table.
Recommended format: Single Substitution table. There should be no context.

'dtls'

Dotless Forms
This feature provides dotless forms for Math Alphanumeric characters, such as U+1D422

MATHEMATICAL BOLD SMALL I, U+1D423 MATHEMATICAL BOLD SMALL J, U+1D456
U+MATHEMATICAL ITALIC SMALL I, U+1D457 MATHEMATICAL ITALIC SMALL J, and so
on.
The dotless forms are to be used as base forms for placing mathematical accents over
them.
Recommended format: Single Substitution table. There should be no context.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

maxp — Maximum Profile
Article • 12/09/2021

This table establishes the memory requirements for this font. Fonts with CFF or CFF2
outlines must use Version 0.5 of this table, specifying only the numGlyphs field. Fonts
with TrueType outlines must use Version 1.0 of this table, where all data is required.
Version 0.5
ﾉ

Type

Name

Description

Version16Dot16

version

0x00005000 for version 0.5

uint16

numGlyphs

The number of glyphs in the font.

Expand table

Version 1.0
ﾉ

Expand table

Type

Name

Description

Version16Dot16

version

0x00010000 for version 1.0.

uint16

numGlyphs

The number of glyphs in the font.

uint16

maxPoints

Maximum points in a non-composite glyph.

uint16

maxContours

Maximum contours in a non-composite glyph.

uint16

maxCompositePoints

Maximum points in a composite glyph.

uint16

maxCompositeContours

Maximum contours in a composite glyph.

uint16

maxZones

1 if instructions do not use the twilight zone (Z0), or
2 if instructions do use Z0; should be set to 2 in
most cases.

uint16

maxTwilightPoints

Maximum points used in Z0.

uint16

maxStorage

Number of Storage Area locations.

uint16

maxFunctionDefs

Number of FDEFs, equal to the highest function
number + 1.

uint16

maxInstructionDefs

Number of IDEFs.

Type

Name

Description

uint16

maxStackElements

Maximum stack depth across Font Program ('fpgm'
table), CVT Program ('prep' table) and all glyph
instructions (in the 'glyf' table).

uint16

maxSizeOfInstructions

Maximum byte count for glyph instructions.

uint16

maxComponentElements

Maximum number of components referenced at
“top level” for any composite glyph.

uint16

maxComponentDepth

Maximum levels of recursion; 1 for simple
components.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

MERG — Merge Table
Article • 05/29/2024

The MERG table enables a font to specify whether antialias filtering of glyphs within a
glyph run can be performed separately for each glyph, or whether certain glyph pairs or
sequences should be composed together—or merged—before antialiasing is performed.
When glyphs are composed together after antialiasing has been performed, that can
result in rendering artifacts in some cases in which glyphs touch or overlap. (This is true
of any per-primitive antialiasing.) Merging glyphs together before antialiasing eliminates
those artifacts, but it also adds a significant performance cost. A font can use the MERG
table to indicate specific glyph pairs or sequences for which pre-antialias merging is
required in order to avoid the risk of rendering artifacts, while implicitly declaring that
other glyph pairs or sequences do not require pre-antialias merging.
Note: Hereafter, “merging” will be used to refer to composing of glyphs together
prior to antialias filtering.
Note: Some implementations could use caching of glyph-rendering results as a
means of performance optimization. If merging of glyph sequences is not required,
then the cached renderings can be composed without a need to render glyphs or
the glyph sequence again.
The approach used is to give a positive declaration of cases in which merging should be
performed. If a MERG table is provided but no declarations are made for any pairs, then
the intended interpretation is that no merging is necessary. (Some implementations
could still merge glyphs before antialiasing, however.) If no MERG table is provided, then
implementations should always merge glyphs before filtering in order to avoid artifacts.
Data is provided for pairs of glyph classes. The first and second glyph elements in a pair
correspond to logical ordering of glyphs in a run. Since glyphs are processed in logical
order but could be presented in visual left-to-right or right-to-left order, it is possible to
give separate recommendations for either left-to-right or right-to-left order.
In some cases, it could be necessary to consider interaction of sequences of more than
two glyphs rather than simply a pair. The data format allows the font developer to
specify sequences that need to be treated together in merging; this is explained further
below.
Determination of whether or not merging should be done is a design consideration on
the part of the font developer. Glyphs could touch or overlap, but there might not be

any perceptible artifacts in visual results. If the designer determines that merging for a
particular pair or sequence is not needed to provide adequate visual results, then there
will be performance benefits from not declaring that pair or sequence as requiring
merging.
Note that different platforms can support different rendering techniques, and might or
might not support the MERG table. On some platforms, glyphs sequences might always
be merged before antialiasing is performed, regardless of whether MERG data is
provided in the font. Similarly, in some other platforms, glyphs might always be
composed after antialiasing is performed, regardless of whether MERG data is provided
in the font. Font developers should consult developer documentation for the different
platforms on which fonts will be used to determine what benefits a MERG table might
provide, and should evaluate rendered results on relevant platforms to determine which
glyph pairs or sequences should be declared as requiring merging.
To construct a MERG table, the first step is to classify glyphs based on desired merging
behavior such that each glyph has an associated merge class (represented by a zerobased index). The system of classification and number of classes will depend on the font
and the font developer’s discretion, but could take into account such properties as a
glyph’s general shape and whether it connects to other glyphs. After assigning glyphs
into classes, one then selects a recommended merging behavior for each pair of merge
classes.
Note that the number of pairs for which data is provided is the square of the number of
merge classes. Therefore, the number of merge classes should be as small as possible.

Grouping of glyphs
In some cases, a sequence of glyphs might need to be treated as a unit for purposes of
merging. For example, a glyph for a combining accent might not typographically
interact at all with following glyphs, yet it might come in logical order between glyphs
that do interact and that could require merging. This is illustrated in the following figure
(assume left-to-right visual order).

Accent glyph logically between two typographically interacting glyphs
In this case, the accent and the base “e” glyph can be treated as a unit for purposes of
evaluating the required merge behavior with the following “f” glyph. Note that, if
merging of the “e” and “f” glyphs is required, then the accent will also need to be
included in the sequence that gets antialiased together.

The merge data entries that specify how pairs of glyphs should be handled include
values that indicate that the pair of glyphs should be grouped together as a unit, without
specifying whether merging is required. Whether or not merging is needed will get
determined only as this group is compared with other glyphs. In the above figure, the
accent is grouped together with the “e” glyph, but whether or not any merging is
required will be determined by comparing that combination with the following “f” glyph.
Whenever a pair of glyphs is grouped or merged, then one or the other will be most
relevant when the combination is evaluated in relation to the following glyph. In the
example above, the required behavior for the “e”-plus-accent combination when it
interacts with the following glyph can be determined by the “e”. In a different example,
it could be the second of a pair of glyphs that is most relevant for purposes of
interaction with subsequent glyphs. Thus, whenever a pair of glyphs is grouped or
merged, the data indicates whether the merge class of the sequence takes on the class
of the first or the second element of the pair. This is indicated by use of a flag: in the
unmarked case (flag is not set), the sequence takes the merge class of the second glyph.
But if a second is subordinate flag is set, then the sequence takes on the merge class of
the first element of the pair.
See the following sections for complete details regarding the merge entry values and
how they are processed.

Table formats
The MERG table is comprised by a header, a set of class-definition tables, and an array
of merge-entry data. The format of the header is as follows.
MergHeader
ﾉ

Expand table

Type

Name

Description

uint16

version

Version number of the merge table — set to 0.

uint16

mergeClassCount

The number of merge classes.

Offset16

mergeDataOffset

Offset to the array of merge-entry data.

uint16

classDefCount

The number of class definition tables.

Offset16

offsetToClassDefOffsets

Offset to an array of offsets to class definition tables — in
bytes from the start of the MERG table.

The offsetToClassDefOffsets field provides an offset to the start of an array of offsets.
Each element in the array is an offset (Offset16) from the start of the MERG table to a
class definition table. The classDefCount field gives the number of elements in the
offsets array, and the number of class definition tables.
Note: A given class definition table can be used to assign different glyphs into
multiple classes. The number of class definition tables does not determine the
number of merge classes. Rather, the mergeClassCount field determines the number
of classes that can be referenced by the merge-entry data. Specifically, merge
entries are provided for merge classes 0 to mergeClassCount - 1. If any glyph is
assigned to a class ID greater than or equal to mergeClassCount, there will be no
merge entries for pairs involving that class, which effectively means that merging of
that glyph with other glyphs is never required.
The class definition tables use the same formats as are used in OpenType Layout tables.
Both ClassDefFormat1 and ClassDefFormat2 may be used. For details on class definition
table formats, see the Class Definition Table section of the OpenType Layout Common
Table Formats chapter.
Note: A class definition table gives an explicit assignment of glyphs to specific class
IDs. Any glyph that is not assigned to a class are implicitly assigned to class zero.
Any given glyph must be assigned to at most one class. Moreover, as the class definition
tables are read in order, glyph ID references must be in strictly increasing order. If glyph
IDs are given out of order, the MERG table is invalid and is ignored.
The merge-entry data array is a 2D table of entries for glyph-class pairs. Each entry is a
uint8 value, and the total size of the data is mergeClassCount^2. The data are organized
as mergeClassCount number of rows each having mergeClassCount number of column
entries.
MergeEntry table
ﾉ

Expand table

Type

Name

Description

MergeEntryRow

mergeEntryRows[mergeClassCount]

Array of merge-entry rows.

MergeEntryRow record
ﾉ

Expand table

Type

Name

Description

uint8

mergeEntries[mergeClassCount]

Array of merge entries.

Each merge entry specifies a behavior for a pair of merge classes: the row index
represents the class of the first element, in logical order, and the column index
represents the class of the second element.
Each merge entry is a bit field with six flags defined. These describe three different
processing behaviors for both left-to-right and right-to-left visual orders. The flags are
assigned as follows:
Merge entry flags
ﾉ

Expand table

Mask

Name

Description

0x01

MERGE_LTR

Merge glyphs, for LTR visual order.

0x02

GROUP_LTR

Group glyphs, for LTR visual order.

0x04

SECOND_IS_SUBORDINATE_LTR

Second glyph is subordinate to the first glyph, for LTR
visual order.

0x08

Reserved

Flag reserved for future use — set to 0.

0x10

MERGE_RTL

Merge glyphs, for RTL visual order.

0x20

GROUP_RTL

Group glyphs, for RTL visual order.

0x40

SECOND_IS_SUBORDINATE_RTL

Second glyph is subordinate to the first glyph, for RTL
visual order.

0x80

Reserved

Flag reserved for future use — set to 0.

The Merge flags (MergeLTR, MergeRTL) indicate that the pair of items should be merged
prior to antialiasing.
The Group flags, described in the previous section, indicate that the pair should be
treated as a unit, without indicating whether or not merging is required — that will be
determined by evaluating the combination in relation to other glyphs.
The SecondIsSubordinate flags, also described in the previous section, are used only if
the Merge or Group flag for the same visual order was set. These indicate whether the
class for the merged or grouped sequence should be that of the first or second item of

the pair. If a SecondIsSubordinate flag is set but neither the Merge or Group flag for the
same visual order was set, then it is ignored.
A detailed description of handling of the Merge, Group and SecondIsSubordinate flags
is provided in the following section.

Processing
The merge entries are used while processing glyphs in a glyph run to determine which
sequences of glyphs require merging before antialias filtering is performed. The
following description is given in a way that is generic with regard to visual order. So, for
instance “the Merge flag” refers to the MergeLTR flag if the visual order is LTR, or to the
MergeRTL flag if the visual order is RTL.
In the following description, a merge group is a sequence of one or more glyphs that are
processed as a unit. In addition to the glyph sequence, a merge group has a boolean
mergeRequired property that is set by default to false. The group also has a mergeClass
property, that is set as described below.
Merge processing proceeds as follows:
1. Start: The start state for the processing algorithm is one in which the current glyph
did not need to be merged with a preceding glyph or glyph sequence. (This
includes the start of a glyph run.) The current glyph is the start of a new merge
group with group.mergeRequired = false.
2. Determine the merge class of the current glyph. Set the group.mergeClass to this
class ID.
3. Process next glyph: Determine the merge class of the next glyph.
4. Using group.mergeClass as a row index and the merge class of the next glyph as a
column index, retrieve the merge entry for the given row and column.
5. If the merge entry is zero, or if the merge class for either the current or next glyph
was greater or equal to mergeClassCount, then the next glyph does not need to be
merged into the current merge sequence. Do not add the next glyph into the
merge group, but proceed to step 10.
6. Else, if the merge entry has the Merge flag set, then the next glyph is added to the
current merge group, and group.mergeRequired is set to true. Proceed to step 8.
7. Else, if the merge entry has the Group flag set, then the next glyph is added to the
current merge group. The group.mergeRequired property is not changed. Proceed
to step 8.
8. Determine the new merge class for the group:
a. If the merge entry has the SecondIsSubordinate flag set then the
group.mergeClass property is not changed.

b. Else (the SecondIsSubordinate flag is clear), then set the group.mergeClass
property to be the merge class of the next glyph.
9. The merge group has been extended; proceed to the next glyph: next becomes
current, and the group properties remain as set in steps 6 – 8. Return to step 3.
10. The merge group is terminated:
a. If group.mergeRequired is true, then merge all of the glyphs in this merge
group prior to antialias filtering.
b. Else (group.mergeRequired is false), then merging is not required for any of the
glyphs in the merge group.
c. Proceed to next glyph (next becomes current) and return to the start state, step
1.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

meta — Metadata Table
Article • 05/31/2024

The metadata table contains various metadata values for the font. Different categories
of metadata are identified by four-character tags. Values for different categories can be
either binary or text.

Table formats
The metadata table begins with a header, structured as follows:
MetaHeader
ﾉ

Expand table

Type

Name

Description

uint32

version

Version number of the metadata table — set to 1.

uint32

flags

Flags — currently unused; set to 0.

uint32

(reserved)

Not used; set to 0.

uint32

dataMapsCount

The number of data maps in the table.

DataMap

dataMaps[dataMapsCount]

Array of data map records.

Note: The reserved field was originally documented in Apple’s TrueType specification
as a data offset. This was redundant: DataMap records include offsets from the start
of the 'meta' table, therefore an additional offset is not used.
The data map record has the following format:
DataMap record
ﾉ

Expand table

Type

Name

Description

Tag

tag

A tag indicating the type of metadata.

Offset32

dataOffset

Offset in bytes from the beginning of the metadata table to the data for
this tag.

uint32

dataLength

Length of the data, in bytes. The data is not required to be padded to
any byte boundary.

The data for a given record may be either textual or binary. The representation format is
specified for each tag. Depending on the tag, multiple records for a given tag may be
permitted, or multiple, delimited values may be permitted in the data referenced by a
single record, as specified for each tag. If only one record or value is permitted for a tag,
then any instances after the first may be ignored.

Metadata tags
Metadata tags identify the category of information provided and representation format
used for a given metadata value. A registry of commonly-used tags is maintained, but
private, vendor-determined tags can also be used.
Like other OpenType tags, metadata tags are four unsigned bytes that can equivalently
be interpreted as a string of four ASCII characters. Metadata tags must begin with a
letter (0x41 to 0x5A, 0x61 to 0x7A) and must use only letters, digits (0x30 to 0x39) or
space (0x20). Space characters must only occur as trailing characters in tags that have
fewer than four letters or digits.
Privately-defined metadata tags must begin with an uppercase letter (0x41 to 0x5A), and
must use only uppercase letters or digits. Registered metadata tags must not use that
pattern, but may be any other valid pattern.
Every registered tag defines the semantics of the associated metadata values, and the
representation format of those values. Values for registered tags may be either textual
or binary. If textual, it will be in UTF-8 encoding unless explicitly indicated otherwise.
The following registered tags are defined or reserved at this time:
ﾉ

Format

Expand table

Tag

Name

Description

appl

(reserved)

Reserved — used by Apple.

bild

(reserved)

Reserved — used by Apple.

dlng

Design

Text, using only

Indicates languages and/or scripts for the user

languages

Basic Latin (ASCII)
characters.

audiences that the font was primarily designed for.
Only one instance is used. See below for additional
details.

slng

Supported

Text, using only

Indicates languages and/or scripts that the font is

languages

Basic Latin (ASCII)
characters.

declared to be capable of supporting. Only one
instance is used. See below for additional details.

'dlng' and 'slng': design and supported
languages
The values for 'dlng' and 'slng' are comprised of a series of comma-separated
ScriptLangTags, which are described in detail below. Spaces may follow the comma
delimiters and are ignored. Each ScriptLangTag identifies a language or script. A list of
tags is interpreted to imply that all the languages or scripts are included.
The 'dlng' value is used to indicate the languages or scripts of the primary user
audiences for which the font was designed. This value can be useful for selecting default
font formatting based on content language, for presenting filtered font options based
on user language preferences, or similar applications involving the language or script of
content or user settings.
The 'slng' value is used to declare languages or scripts that the font is functionally
capable of supporting. This value can be useful for font fallback mechanisms or other
applications involving the language or script of content or user settings.
'slng' values can be used to provide more insight than could otherwise be obtained by
inspecting a font’s 'cmap' table. For example, a font created for displaying a large range
of Unicode characters in code charts could be capable of displaying default glyphs for
Latin script and Devanagari script characters, but not support correct shaping for
Devanagari script. Inspection of the 'cmap' table would indicate support for both Latin
and Devanagari characters, but other analysis would be needed to detect that the font
functionally supports Latin script but does not functionally support Devanagari script. In
this case, it would be appropriate to use 'slng' data to declare that the font functionally
supports Latin script, but not Devanagari script.
The Unicode range fields in the OS/2 table (see 5.1.8.18) are somewhat similar to 'slng'
metadata values but operate on the level of Unicode blocks, which do not always
correspond to languages or scripts, and which do not support any characters encoded
in Unicode later than Unicode 5.1. Implementations that use 'slng' values in a font may
ignore Unicode-range bits set in the OS/2 table.
Note: A font developer can choose not to declare that a font supports certain
languages or scripts even if the font is functionally capable of doing so. For
example, an operating system could include several fonts designed for different

scripts and include glyphs for a basic set of Latin characters in those fonts. If the
Latin support in those fonts does not add functionality for Latin script in the overall
product, however, the vendor could choose not to declare support for Latin script in
those fonts.
'dlng' values can be used to provide further insight beyond that provided by 'slng': not
only is the font functionally capable of supporting certain languages, but it is also
designed to provide value for content in those scripts or languages. For example, a font
designed for supporting Japanese could be functionally capable of supporting Latin
script but not be a particularly useful option to offer in a font picker for French or
German documents. In this case, it could be appropriate to declare Latin script as an
'slng' value but not as a 'dlng' value.
In many cases, the 'dlng' and 'slng' values declared in a font could be the same, and in
general the 'slng' values should be the same as or a superset of those provided by
'dlng'. Font developers should consider whether there are appropriate differences
between the 'slng' and 'dlng' declarations added into a font, and applications should
make appropriate use of the differences.
If a font contains 'dlng' values but not 'slng' values, applications may infer that an 'slng'
declaration using the 'dlng' values. The opposite should not be done, however: if a font
has 'slng' values but not 'dlng' values, applications should not infer a 'dlng' declaration
from the 'slng' declaration.
Some additional examples will help to understand the distinction between design and
supported languages:
Consider the case of accented Latin letters: Although the accents are used in
common by a number of languages, the precise shape of the accents can depend
on the typographic traditions of a specific language. Polish, for example, prefers
steeper accents than French. A font that was designed with accents specifically for
Polish could declare Polish as a design language ('dlng'), but declare support
('slng') for any language using Latin script.
Fonts designed for East Asian markets will generally include glyphs for Latin, Greek
and Cyrillic because these characters are included in important East Asian character
set standards, but using East Asian fonts for languages that are written with those
scripts is generally unsatisfactory. Such fonts could include these scripts in the
'slng' value, but omit them from their 'dlng' value.
There are some systematic differences in glyph design for the characters shared by
Simplified and Traditional Chinese, such as the way the “bone” radical is drawn in
all characters using it. A font specifically designed for use with Simplified Chinese
could be used to display Traditional Chinese, but any character with the “bone”

radical will look wrong to readers of Traditional Chinese. Such a font could include
Simplified Chinese 'dlng' value, but both Simplified and Traditional Chinese in its
'slng' value.

ScriptLangTag values
The 'dlng' and 'slng' metadata use ScriptLangTag values, defined here.
A ScriptLangTag denotes a particular language or script associated with a font. These are
adapted from the IETF BCP 47 specification, “Tags for Identifying Languages” (see
https://www.rfc-editor.org/info/bcp47

).

BCP 47 language tags can include various subtags that provide different types of
qualifiers, such as language, script or region. In a BCP 47 language tag, a language
subtag element is mandatory and other subtags are optional. ScriptLangTag values used
for 'dlng' and 'slng' metadata values use a modification of the BCP 47 syntax: a tag must
include either a language or a script subtag; other subtags are optional. The following
augmented BNF syntax, adapted from BCP 47, is used:

ScriptLangTag = (language | script | language "-" script)
["-" region]
*("-" variant)
*("-" extension)
["-" privateuse]

The expansion of the elements and the intended semantics associated with each are as
defined in BCP 47. Script subtags are taken from ISO 15924. At present, no extensions
are defined for use in ScriptLangTags, and any extension may be ignored. Private-use
elements, which are prefixed with “-x”, are defined by private agreement between the
source and recipient and may be ignored.
Subtags must be valid for use in BCP 47 and contained in the Language Subtag Registry
maintained by IANA. See http://www.iana.org/assignments/language-subtagregistry/language-subtag-registry

and section 3 of BCP 47 for details.

Note: OpenType Layout script and language system tags are not the same as those
used in BCP 47 and should not be referenced when creating or processing
ScriptLangTags.
A ScriptLangTag that has a language subtag without a script subtag may be used but is
strongly discouraged; a ScriptLangTag should always include a script subtag. Use of a

language subtag without a script subtag should only be considered if the record for the
language subtag in the IANA Language Subtag Registry includes a "Suppress-Script"
value (see section 3.1.9

of BCP 47), in which case applications may infer that script

subtag. Even in such cases, however, omission of the script subtag is not recommended.
Applications may ignore tags that do not include a script subtag.
Any ScriptLangTag value not conforming to these specifications must be ignored.
A ScriptLangTag can denote fairly specific information; for example, “en-Latn-IN” would
represent Latin script as used for the English language in India. In most cases, however,
generic tags should be used, and it is anticipated that most tags used in 'dlng' and 'slng'
metadata declarations will consist only of a script subtag. Language or other subtags
may be included, however, and could be appropriate in some cases. Implementations
must allow for ScriptLangTags that include additional subtags, but they may also choose
to interpret only the script subtag and ignore other subtags.
Examples:
“Latn” denotes Latin script (and any language or writing system using Latin script).
“Cyrl” denotes Cyrillic script.
“sr-Cyrl” denotes Cyrillic script as used for writing the Serbian language; a font that
has this property value might not be suitable for displaying text in Russian or other
languages written using Cyrillic script.
“en-Dsrt” denotes English written with the Deseret script.
“Hant” denotes Traditional Chinese.
“Hant-HK” denotes Traditional Chinese as used in Hong Kong SAR.
“Jpan” denotes Japanese writing — ISO 15924 defines “Jpan” as an alias for Han +
Hiragana + Katakana.
“Kore” denotes Korean writing — ISO 15924 defines “Kore” as an alias for Hangul +
Han.
“Hang” denotes Hangul script (exclusively — Hanja are not implied by “Hang”).
The Unicode Standard uses the ISO 15924 identifiers “Zinh” (inherited) and “Zyyy”
(undetermined). These should not be used in ScriptLangTags. Similarly, “Zxxx” (unwritten
document) and “Zzzz” (unencoded script) should never be used.
On the other hand, “Zmth” (mathematical notation), “Zsym” (symbols) and “Zsye”
(Symbols (Emoji variant)) are not used in the Unicode Standard, yet they can be very
useful as declarations in font files.
In relation to East Asian scripts, a declaration of “Jpan” can be used to cover hiragana,
katakana and kanji. Similarly, “Kore” can be used to cover Hangul and hanja, though a
Korean font with only Hangul support should use “Hang”. For Chinese fonts, “Hans” and

“Hant” should normally be used to distinguish between Simplified and Traditional
orthographies rather than the more generic declaration “Hani”. Region-specific
variations such as “Hant-HK” can also be declared. In some cases, it could be
appropriate to describe a font capability (but probably not design target) using the
generic declaration “Hani” (denoting Han ideographs / Hanzi / Kanji / Hanja).
The BCP 47 specification for region subtags allows for continental and sub-continental
regions. For example, “039” can be used to denote Southern Europe. Use of such
extended-region subtags in ScriptLangTag values is not recommended as software
implementations might not have the logic to make appropriate correlations to more
specific regions or languages associated with those regions.

MVAR — Metrics Variations Table
Article • 10/20/2022

The metrics variations table is used in variable fonts to provide variations for font-wide
metric values found in the OS/2 table and other font tables. For a general overview of
OpenType Font Variation and terminology related to variations, see the chapter,
OpenType Font Variations Overview.
The metrics variations table contains an item variation store structure to represent
variation data. The item variation store and constituent formats are described in the
chapter, OpenType Font Variations Common Table Formats. The item variation store is
also used in the HVAR and GDEF tables, but is different from the formats for variation
data used in the 'cvar' or 'gvar' tables.
The item variation store format uses delta-set indices to reference variation delta data
for particular target font-data items to which they are applied. Data external to the item
variation store identifies the delta-set index to be used for each given target item.
Within the MVAR table, an array of value tag records identifies a set of target items, and
provides the delta-set index used for each. The target items are identified by four-byte
tags, with a given tag representing some font-wide value found in another table. For
example, the tag 'hasc' represents the OS/2.sTypoAscender value. More details on tags
are provided below.
The item variation store format uses a two-level organization for variation data: a store
can have multiple item variation data subtables, and each subtable has multiple deltaset rows. A delta-set index is a two-part index: an outer index that selects a particular
item variation data subtable, and an inner index that selects a particular delta-set row
within that subtable. A value record specifies both the outer and inner portions of the
delta-set index.
Note: Apple platforms allow for use of a font metrics ('fmtx') table to specify various
font-wide metric values by reference to the X or Y coordinates of contour points for
a specified “magic” glyph. OpenType Font Variations does not use the font metrics
table.
The metrics variations table must be used in combination with a font variations ('fvar')
table and other required or optional tables used in variable fonts. See Variation Data
Tables and Miscellaneous Requirements in the OpenType Font Variations Overview
chapter for additional details.

Table Formats
The metrics variations table has the following format.
Metrics variations table:
ﾉ

Expand table

Type

Name

Description

uint16

majorVersion

Major version number of the metrics variations
table — set to 1.

uint16

minorVersion

Minor version number of the metrics variations
table — set to 0.

uint16

(reserved)

Not used; set to 0.

uint16

valueRecordSize

The size in bytes of each value record — must
be greater than zero.

uint16

valueRecordCount

The number of value records — may be zero.

Offset16

itemVariationStoreOffset

Offset in bytes from the start of this table to
the item variation store table. If
valueRecordCount is zero, set to zero; if
valueRecordCount is greater than zero, must be
greater than zero.

ValueRecord

valueRecords[valueRecordCount]

Array of value records that identify target items
and the associated delta-set index for each. The
valueTag records must be in binary order of
their valueTag field.

The valueRecordSize field indicates the size of each value record. Future, minor version
updates of the MVAR table may define compatible extensions to the value record
format with additional fields. Implementations must use the valueRecordSize field to
determine the start of each record.
The valueRecords array is an array of value records that identify the target, font-wide
measures for which variation adjustment data is provided (target items), and outer and
inner delta-set indices for each item into the item variation store data.
ValueRecord:
ﾉ

Expand table

Type

Name

Description

Tag

valueTag

Four-byte tag identifying a font-wide measure.

uint16

deltaSetOuterIndex

A delta-set outer index — used to select an item variation data
subtable within the item variation store.

uint16

deltaSetInnerIndex

A delta-set inner index — used to select a delta-set row within an
item variation data subtable.

The value records must be given in binary order of the valueTag values. Each tag
identifies a font-wide measure found in some other font table. For example, if a value
record has a value tag of 'hasc', this corresponds to the OS/2.sTypoAscender field.
Details on the tags used within the MVAR table are provided below.

Processing
When reading a value within a variable font, such as the OS/2.sCapHeight value (the
target item), the value tags array in the metrics variations table is scanned to find the tag
that corresponds to that target item. Records in the array are stored in binary order of
values in the valueTag fields. If the tag does not occur in the tag array, then the item is
constant across the font’s variation space. If the tag does occur, however, then the deltaset index is used to reference a set of deltas within the item variation store. The twolevel organization of data within the item variation store is described in the chapter
OpenType Font Variations Common Table Formats. Each delta set includes different
deltas that apply to variation instances falling within different regions of the variation
space. The process by which the deltas are processed to derive an interpolated value for
a given target item is described in the chapter, OpenType Font Variations Overview.

Value Tags
Four-byte tags are used to represent particular metric or other values. For example, the
tag 'hasc' (horizontal ascent) is used to represent the OS/2.sTypoAscender value. Tags
are defined for various values found in the OS/2 and Windows metrics (OS/2) table, the
horizontal header ('hhea') table, the grid-fitting and scan-conversion ('gasp') table, the
PostScript ('post') table, and the vertical metrics header ('vhea') table.
Note: The OS/2.usWeightClass, OS/2.usWidthClass and post.italicAngle values are
not supported by variation data in the MVAR table. This is because values for these
three fields correspond directly to input axis values for the 'wght', 'wdth' and 'slnt'
variation axes. See the discussion of these axes in the OpenType Design-Variation

Axis Tag Registry for details on the relationship between these fields and the
corresponding design axes.
Tags in the metrics variations table are case sensitive. Tags defined in this table use only
lowercase letters or digits.
Tags that are used in a font’s metrics variations table should be those that are
documented in this table specification. A font may also use privately-defined tags, which
have semantics known only by private agreement. Private-use tags must begin with an
uppercase letter and use only uppercase letters or digits. If a private-use tag is used in a
given font, any application that does not recognize that tag should ignore it.
The following tags are defined:
Value tags, ordered by logical groupings:
ﾉ

Tag

Mnemonic

Value represented

'hasc'

horizontal ascender

OS/2.sTypoAscender

'hdsc'

horizontal descender

OS/2.sTypoDescender

'hlgp'

horizontal line gap

OS/2.sTypoLineGap

'hcla'

horizontal clipping ascent

OS/2.usWinAscent

'hcld'

horizontal clipping descent

OS/2.usWinDescent

'vasc'

vertical ascender

vhea.ascent

'vdsc'

vertical descender

vhea.descent

'vlgp'

vertical line gap

vhea.lineGap

'hcrs'

horizontal caret rise

hhea.caretSlopeRise

'hcrn'

horizontal caret run

hhea.caretSlopeRun

'hcof'

horizontal caret offset

hhea.caretOffset

'vcrs'

vertical caret rise

vhea.caretSlopeRise

'vcrn'

vertical caret run

vhea.caretSlopeRun

'vcof'

vertical caret offset

vhea.caretOffset

'xhgt'

x height

OS/2.sxHeight

Expand table

'cpht'

cap height

OS/2.sCapHeight

'sbxs'

subscript em x size

OS/2.ySubscriptXSize

'sbys'

subscript em y size

OS/2.ySubscriptYSize

'sbxo'

subscript em x offset

OS/2.ySubscriptXOffset

'sbyo'

subscript em y offset

OS/2.ySubscriptYOffset

'spxs'

superscript em x size

OS/2.ySuperscriptXSize

'spys'

superscript em y size

OS/2.ySuperscriptYSize

'spxo'

superscript em x offset

OS/2.ySuperscriptXOffset

'spyo'

superscript em y offset

OS/2.ySuperscriptYOffset

'strs'

strikeout size

OS/2.yStrikeoutSize

'stro'

strikeout offset

OS/2.yStrikeoutPosition

'unds'

underline size

post.underlineThickness

'undo'

underline offset

post.underlinePosition

'gsp0'

gaspRange[0]

gasp.gaspRange[0].rangeMaxPPEM

'gsp1'

gaspRange[1]

gasp.gaspRange[1].rangeMaxPPEM

'gsp2'

gaspRange[2]

gasp.gaspRange[2].rangeMaxPPEM

'gsp3'

gaspRange[3]

gasp.gaspRange[3].rangeMaxPPEM

'gsp4'

gaspRange[4]

gasp.gaspRange[4].rangeMaxPPEM

'gsp5'

gaspRange[5]

gasp.gaspRange[5].rangeMaxPPEM

'gsp6'

gaspRange[6]

gasp.gaspRange[6].rangeMaxPPEM

'gsp7'

gaspRange[7]

gasp.gaspRange[7].rangeMaxPPEM

'gsp8'

gaspRange[8]

gasp.gaspRange[8].rangeMaxPPEM

'gsp9'

gaspRange[9]

gasp.gaspRange[9].rangeMaxPPEM

Value tags, in alphabetical order of tags:
ﾉ

Tag

Mnemonic

Value represented

Expand table

'cpht'

cap height

OS/2.sCapHeight

'gsp0'

gaspRange[0]

gasp.gaspRange[0].rangeMaxPPEM

'gsp1'

gaspRange[1]

gasp.gaspRange[1].rangeMaxPPEM

'gsp2'

gaspRange[2]

gasp.gaspRange[2].rangeMaxPPEM

'gsp3'

gaspRange[3]

gasp.gaspRange[3].rangeMaxPPEM

'gsp4'

gaspRange[4]

gasp.gaspRange[4].rangeMaxPPEM

'gsp5'

gaspRange[5]

gasp.gaspRange[5].rangeMaxPPEM

'gsp6'

gaspRange[6]

gasp.gaspRange[6].rangeMaxPPEM

'gsp7'

gaspRange[7]

gasp.gaspRange[7].rangeMaxPPEM

'gsp8'

gaspRange[8]

gasp.gaspRange[8].rangeMaxPPEM

'gsp9'

gaspRange[9]

gasp.gaspRange[9].rangeMaxPPEM

'hasc'

horizontal ascender

OS/2.sTypoAscender

'hcla'

horizontal clipping ascent

OS/2.usWinAscent

'hcld'

horizontal clipping descent

OS/2.usWinDescent

'hcof'

horizontal caret offset

hhea.caretOffset

'hcrn'

horizontal caret run

hhea.caretSlopeRun

'hcrs'

horizontal caret rise

hhea.caretSlopeRise

'hdsc'

horizontal descender

OS/2.sTypoDescender

'hlgp'

horizontal line gap

OS/2.sTypoLineGap

'sbxo'

subscript em x offset

OS/2.ySubscriptXOffset

'sbxs'

subscript em x size

OS/2.ySubscriptXSize

'sbyo'

subscript em y offset

OS/2.ySubscriptYOffset

'sbys'

subscript em y size

OS/2.ySubscriptYSize

'spxo'

superscript em x offset

OS/2.ySuperscriptXOffset

'spxs'

superscript em x size

OS/2.ySuperscriptXSize

'spyo'

superscript em y offset

OS/2.ySuperscriptYOffset

'spys'

superscript em y size

OS/2.ySuperscriptYSize

'stro'

strikeout offset

OS/2.yStrikeoutPosition

'strs'

strikeout size

OS/2.yStrikeoutSize

'undo'

underline offset

post.underlinePosition

'unds'

underline size

post.underlineThickness

'vasc'

vertical ascender

vhea.ascent

'vcof'

vertical caret offset

vhea.caretOffset

'vcrn'

vertical caret run

vhea.caretSlopeRun

'vcrs'

vertical caret rise

vhea.caretSlopeRise

'vdsc'

vertical descender

vhea.descent

'vlgp'

vertical line gap

vhea.lineGap

'xhgt'

x height

OS/2.sxHeight

Note that the tags 'gsp0' to 'gsp9' are used to provide variation data for the
rangeMaxPPEM member of records in a grid-fitting and scan-conversion procedure
('gasp') table. The last 'gasp' table entry always uses a rangeMaxPPEM value of 0xFFFF.
The maximum number of value records for 'gasp' entries must never be more than one
less the number of entries in the 'gasp' table.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

name — Naming Table
Article • 05/31/2024

The naming table allows multilingual strings to be associated with the OpenType™ font.
These strings can represent copyright notices, font names, family names, style names,
and so on. To keep this table short, the font manufacturer may wish to make a limited
set of entries in some small set of languages; later, the font can be “localized” and the
strings translated or added. Other parts of the OpenType font that require these strings
can refer to them using a language-independent name ID. In addition to language
variants, the table also allows for platform-specific character-encoding variants.
Applications that need a particular string can look it up by its platform ID, encoding ID,
language ID and name ID. Note that different platforms may have different
requirements for the encoding of strings.
Many newer platforms can use strings intended for different platforms if a font does not
include strings for that platform. Some applications might display incorrect strings,
however, if strings for the current platform are not included.

Naming table header
There are two versions of the Naming Table. Version 0 uses platform-specific, numeric
language identifiers. Version 1 allows for use of language-tag strings to indicate the
language of strings. Both versions include variable-size string-data storage, and an array
of name records that are used to identify the type of string (name ID), platform,
encoding and language variants of the string, and the location within the storage.

Naming table version 0
The version 0 naming table is organized as follows:
ﾉ

Expand table

Type

Name

Description

uint16

version

Table version number (=0).

uint16

count

Number of name records.

Offset16

storageOffset

Offset to start of string storage (from start of table).

NameRecord

nameRecord[count]

The name records where count is the number of records.

Type

Name

(Variable)

Description
Storage for the actual string data.

Version 0 differs from version 1 in regard to handling of language identification: it uses
only numeric language IDs, which generally are values less than 0x8000 and have
platform-specific interpretations. See Name Records below for more detail.

Naming table version 1
The version 1 naming table adds additional elements, as follows:
ﾉ

Expand table

Type

Name

Description

uint16

version

Table version number (=1).

uint16

count

Number of name records.

Offset16

storageOffset

Offset to start of string storage (from start of
table).

NameRecord

nameRecord[count]

The name records where count is the number of
records.

uint16

langTagCount

Number of language-tag records.

LangTagRecord

langTagRecord[langTagCount]

The language-tag records where langTagCount
is the number of records.

(Variable)

Storage for the actual string data.

When version 1 is used, the language IDs in name records can be less than or greater
than 0x8000. If a language ID is less than 0x8000, it has a platform-specific
interpretation as with a version 0 naming table. If a language ID is equal to or greater
than 0x8000, it is associated with a language-tag record (LangTagRecord) that
references a language-tag string. In this way, the language ID is associated with a
language-tag string that specifies the language for name records using that language
ID, regardless of the platform. These can be used for any platform that supports this
language-tag mechanism.
A font using a version 1 naming table may use a combination of platform-specific
language IDs as well as language-tag records for a given platform and encoding.
Each LangTagRecord is organized as follows:

ﾉ

Expand table

Type

Name

Description

uint16

length

Language-tag string length (in bytes).

Offset16

langTagOffset

Language-tag string offset from start of storage area (in bytes).

Language-tag strings stored in the naming table must be encoded in UTF-16BE. The
language tags must conform to IETF specification BCP 47

. This provides tags such as

“en”, “fr-CA” and “zh-Hant” to identify languages, including dialects, written form and
other language variants.
The language-tag records are associated sequentially with language IDs starting with
0x8000. Each language-tag record corresponds to a language ID one greater than that
for the previous language-tag record. Thus, language IDs associated with language-tag
records must be within the range 0x8000 to 0x8000 + langTagCount - 1. If a name
record uses a language ID that is greater than this, the identity of the language is
unknown; such name records should not be used.
For example, suppose a font has two language-tag records referencing strings in the
storage: the first references the string “en”, and the second references the string “zhHant-HK” In this case, the language ID 0x8000 is used in name records to index Englishlanguage strings. The language ID 0x8001 is used in name records to index strings in
Traditional Chinese as used in Hong Kong SAR.

Name records
Each string in the string storage is referenced by a name record. The name record has a
multi-part key, to identify the logical type of string and its language or platform-specific
implementation variants, plus the location of the string in the string storage.
Each NameRecord is organized as follows:
ﾉ

Type

Name

Description

uint16

platformID

Platform ID.

uint16

encodingID

Platform-specific encoding ID.

uint16

languageID

Language ID.

uint16

nameID

Name ID.

Expand table

uint16

length

String length (in bytes).

Offset16

stringOffset

String offset from start of storage area (in bytes).

The name ID identifies a logical string category, such as family name or copyright. Name
IDs are the same for all platforms and languages; these are described in detail below.
The other three elements of the key allow for platform-specific implementations: a
platform ID, a platform-specific encoding ID, and a language ID.
As with encoding records in the 'cmap' table, name records must be sorted first by
platform ID, then by platform-specific encoding ID, then by language ID, and then by
name ID. Descriptions of the various IDs follow.

Platform, encoding and language
The platform, encoding and language IDs of a name record allow for platform-specific
implementations. Different platforms can support different encodings, and different
languages. All encoding IDs are platform-specific. Language IDs are similarly platformspecific, except in the case of IDs used in conjunction with the language-tag mechanism
of naming table version 1, described above.
Note: Platform IDs, platform-specific encoding IDs and, in some cases, platformspecific language IDs are also used in the 'cmap' table.
Language IDs refer to a value that identifies the language in which a particular string is
written. Values less than 0x8000 are defined on a platform-specific basis. A version 0
naming table must use only language ID values less than 0x8000 from the platformspecific enumerations given below. (Exceptions to this requirement are permitted,
however, in the case of user-defined platforms — platform IDs 240 to 255.) Values
greater than or equal to 0x8000 may be used in a version 1 naming table in conjunction
with language-tag records, as described above. Not all platforms have platform-specific
language IDs, and not all platforms support language-tag records.
Tables with detailed listings of platform, encoding and language IDs used within the
'name' table are provided at the end of this chapter. See Platform, encoding and
language IDs.

Name IDs
The following name IDs are pre-defined and apply to all platforms unless indicated
otherwise. Name IDs 26 to 255, inclusive, are reserved for future standard names. Name

IDs 256 to 32767, inclusive, are reserved for font-specific names such as those
referenced by a font’s layout features.
ﾉ

Expand table

ID

Meaning

0

Copyright notice.

1

Font Family name. The Font Family name is used in combination with Font Subfamily name
(name ID 2), and should be shared among at most four fonts that differ only in weight or
style (italic/oblique), as described below.
This four-way distinction should also be reflected in the OS/2.fsSelection field, using bits 0
and 5.
While some platforms or applications do not have this constraint, many existing applications
that use this pair of names assume that a Font Family name is shared by at most four fonts
that form a font style-linking group: regular, italic (or oblique), bold, and bold italic (or bold
oblique). To be compatible with the broadest range of platforms and applications, it is
strongly recommended that fonts limit use of Font Family name in this manner.
For extended typographic families that includes fonts other than the four basic styles
(regular, italic, bold, bold italic), it is strongly recommended that name IDs 16 and 17 be used
in fonts to create an extended, typographic grouping. (See examples provided below.)
It is also strongly recommended that applications support extended typographic-family
groupings using name IDs 16 and 17. Note that variable fonts can include a large number of
named instances, each of which will use a shared typographic family name (name ID 16) and
will have a typographic subfamily name (equivalent to name ID 17). Applications that assume
a four-style family grouping based on name IDs 1 and 2 are likely to provide a poor user
experience with variable fonts.
For fonts within an extended typographic family that fall outside the basic four-way
distinction, the distinguishing attributes should be reflected in the Font Family name so that
those fonts appear as a separate font family in applications that support only four-member
families. For example, the Font Family name for the Arial Narrow font is “Arial Narrow”; the
Font Family name for the Arial Black font is “Arial Black”. Note that, in such cases, name ID 16
should also be included with a shared name (e.g., "Arial") that reflects the full, typographic
family.

2

Font Subfamily name. The Font Subfamily is used in combination with Font Family name
(name ID 1), and distinguishes the fonts in a group with the same Font Family name. This
should be used for weight and style (italic/oblique) variants only, as described below.
This four-way distinction should also be reflected in the OS/2.fsSelection field, using bits 0
and 5.
While some platforms or applications do not have this constraint, many existing applications

that use name IDs 1 and 2 assume that a Font Family name is shared by at most four fonts
that form a font style-linking group, and that Font Subfamily names would reflect one of the
four basic styles, regular, italic (or oblique), bold, and bold italic (or bold oblique). To be
compatible with the broadest range of platforms and applications, it is strongly
recommended that fonts should limit use of Font Subfamily in this manner.
For extended typographic families that includes fonts other than the four basic styles
(regular, italic, bold, bold italic), it is strongly recommended that name IDs 16 and 17 be used
in fonts to create an extended, typographic grouping.
Within an extended typographic family that includes fonts beyond regular, bold, italic, or
bold italic, distinctions for these other fonts are made in the Font Family name so that fonts
appear to be in separate families. In some cases, this can lead to specifying a Subfamily name
of “Regular” for a font that might not otherwise be considered a regular font. For example,
the Arial Black font has a Font Family name of “Arial Black” and a Subfamily name of
“Regular”. Note that, in such cases, name IDs 16 and 17 should also be included, using a
shared value for name ID 16 (e.g., "Arial") that reflects the full typographic family, and values
for name ID 17 that appropriately reflect the actual design variant of each font.
Fonts that are not part of an extended typographic family and with no distinctive weight or
style (e.g., medium weight, not italic) should use "Regular" as the Font Subfamily name (for
English).
3

Unique font identifier.

4

Full font name that reflects all family and relevant subfamily descriptors. The full font name is
generally a combination of name IDs 1 and 2, or of name IDs 16 and 17, or a similar humanreadable variant.
For fonts in extended typographic families (that is, families that include more than regular,
italic, bold, and bold italic variants), values for name IDs 1 and 2 are normally chosen to
provide compatibility with certain applications that assume a family has at most four stylelinked fonts. In that case, some fonts may end up with a Subfamily name (name ID 2) of
“Regular” even though the font would not be considered, typographically, a regular font. For
such non-regular fonts in which name ID 2 is specified as “Regular”, the “Regular” descriptor
would generally be omitted from name ID 4. For example, the Arial Black font has a Font
Family name (name ID 1) of “Arial Black” and a Subfamily name (name ID 2) of “Regular”, but
has a full font name (name ID 4) of “Arial Black”. Note that name IDs 16 and 17 should also
be included in these fonts, and that name ID 4 would typically be a combination of name IDs
16 and 17, without needing any additional qualifications regarding “Regular”.

5

Version string. Should begin with the pattern “Version <number>.<number>” (upper case,
lower case, or mixed, with a space between “Version” and the number).
The string must contain a version number of the following form: one or more digits (0-9) of
value less than 65,535, followed by a period, followed by one or more digits of value less
than 65,535. Any character other than a digit will terminate the minor number. A character
such as “;” is helpful to separate different pieces of version information.
The first such match in the string can be used by installation software to compare font

versions. Some installers could require the string to start with “Version ”, followed by a
version number as above.
6

PostScript name for the font. Name ID 6 specifies a string which is used to invoke a
PostScript language font that corresponds to this OpenType font. When translated to ASCII,
the name string must be no longer than 63 characters and restricted to the printable ASCII
subset, codes 33 to 126, except for the 10 characters '[', ']', '(', ')', '{', '}', '<', '>', '/', '%'.
In a CFF OpenType font, there is no requirement that this name be the same as the font
name in the CFF’s Name INDEX. Thus, the same CFF may be shared among multiple font
components in a Font Collection. See the 'name' table section of “Recommendations for
OpenType fonts” for additional information.

7

Trademark. This is used to save any trademark notice/information for this font. Such
information should be based on legal advice. This is distinctly separate from the copyright.

8

Manufacturer Name.

9

Designer. Name of the designer of the typeface.

10

Description. Description of the typeface. Can contain revision information, usage
recommendations, history, features, etc.

11

URL of Vendor. URL of font vendor (with protocol, e.g., http://, ftp://). If a unique serial
number is embedded in the URL, it can be used to register the font.

12

URL of Designer. URL of typeface designer (with protocol, e.g., http://, ftp://).

13

License Description. Description of the license or licenses under which the font is provided.
This could be a reference to a named license agreement (e.g., a common open source
licenses), identification of a software-use license under which a font is bundled, information
about where to locate an external license (see also name ID 14), a summary of permitted
uses, or the full legal text of a license agreement. It is prudent to seek legal advice on the
content of this name ID to avoid possible conflict of interpretation between it and the
license(s).

14

License Info URL. URL where additional licensing information can be found.

15

Reserved.

16

Typographic Family name. The typographic family grouping doesn’t impose any constraints
on the number of faces within it, in contrast with the 4-style family grouping (ID 1), which is
present both for historical reasons and to express style linking groups. If name ID 16 is
absent, then name ID 1 is considered to be the typographic family name. (In earlier versions
of the specification, name ID 16 was known as “Preferred Family”.)

17

Typographic Subfamily name. This allows font designers to specify a subfamily name within
the typographic family grouping. This string must be unique within a particular typographic
family. If it is absent, then name ID 2 is considered to be the typographic subfamily name. (In
earlier versions of the specification, name ID 17 was known as “Preferred Subfamily”.)

18

Compatible Full (Macintosh only). On the Macintosh, the menu name is constructed using
the FOND resource. This usually matches the Full Name. If you want the name of the font to
appear differently than the Full Name, you can insert the Compatible Full Name in ID 18.

19

Sample text. This can be the font name, or any other text that the designer thinks is the best
sample to display the font in.

20

PostScript CID findfont name. Its presence in a font means that the nameID 6 holds a
PostScript font name that is meant to be used with the “composefont” invocation in order to
invoke the font in a PostScript interpreter. See the definition of name ID 6.
The value held in the name ID 20 string is interpreted as a PostScript font name that is meant
to be used with the “findfont” invocation, in order to invoke the font in a PostScript
interpreter.
When translated to ASCII, this name string must be restricted to the printable ASCII subset,
codes 33 through 126, except for the 10 characters: '[', ']', '(', ')', '{', '}', '<', '>', '/', '%'.
See “Recommendations for OTF fonts” for additional information

21

WWS Family Name. Used to provide a WWS-conformant family name in case the entries for
IDs 16 and 17 do not conform to the WWS model. (That is, in case the entry for ID 17
includes qualifiers for some attribute other than weight, width or slope.) If bit 8 of the OS/2
fsSelection field is set, a WWS Family Name entry should not be needed and should not be
included. Conversely, if an entry for this ID is included, bit 8 should not be set. (See
OS/2.fsSelection field for details.) Examples of name ID 21: “Minion Pro Caption” and “Minion
Pro Display”. (Name ID 16 would be “Minion Pro” for these examples.)
See additional remarks regarding IDs 21 and 22 below.

22

WWS Subfamily Name. Used in conjunction with ID 21, this ID provides a WWS-conformant
subfamily name (reflecting only weight, width and slope attributes) in case the entries for IDs
16 and 17 do not conform to the WWS model. As in the case of ID 21, use of this ID should
correlate inversely with bit 8 of the OS/2 fsSelection field being set. Examples of name ID 22:
“Semibold Italic”, “Bold Condensed”. (Name ID 17 could be “Semibold Italic Caption”, or
“Bold Condensed Display”, for example.)
See additional remarks regarding IDs 21 and 22 below.

23

Light Background Palette. This ID, if used in the CPAL table’s Palette Labels Array, specifies
that the corresponding color palette in the CPAL table is appropriate to use with the font
when displaying it on a light background such as white. Strings for this ID are for use as user
interface strings associated with this palette.

24

Dark Background Palette. This ID, if used in the CPAL table’s Palette Labels Array, specifies
that the corresponding color palette in the CPAL table is appropriate to use with the font
when displaying it on a dark background such as black. Strings for this ID are for use as user
interface strings associated with this palette.

25

Variations PostScript Name Prefix. If present in a variable font, it may be used as the family
prefix in the PostScript Name Generation for Variation Fonts algorithm. The character set is
restricted to ASCII-range uppercase Latin letters, lowercase Latin letters, and digits. All name
strings for name ID 25 within a font, when converted to ASCII, must be identical. See Adobe
Technical Note #5902: “PostScript Name Generation for Variation Fonts” for reasons to
include name ID 25 in a font, and for examples. For general information on OpenType Font
Variations, see the chapter, OpenType Font Variations Overview.

For a typographic family that includes member faces that differ from Regular in relation
to attributes other than weight, width or slope, there may also be some member faces
that differ only in relation to these three attributes. For example, the Minion Pro family
includes Minion Pro Display, but also includes Minion Pro Bold and Minion Pro Italic. IDs
21 and 22 should be used only in those fonts that differ from the Regular face in terms
of an attribute other than weight, width or slope. For example, IDs 21 and 22 should be
used in Minion Pro Display, but not in Minion Pro Bold or Minion Pro Italic.
Note: While both Apple and Microsoft support the same set of name strings, the
interpretations may be somewhat different. But since name strings are stored by
platform, encoding and language (placing separate strings for both Apple and MS
platforms), this should not present a problem.
The key information for this table for Microsoft platforms relates to the use of name IDs
1, 2, 4, 16 and 17. Note that some newer applications will use name IDs 16 and 17, while
some legacy applications require name IDs 1 and 2 and also assume certain limitations
on these values (see descriptions of name IDs 1 and 2 above). Fonts should include all of
these strings for the broadest application compatibility. To better understand how to set
values for these name IDs, some examples of name usage, weight class and style flags
have been created.

Name ID examples
The following are examples of how these strings might be defined, based on Times New
Roman Bold:
0. The copyright string from the font vendor. © Copyright the Monotype Corporation plc,
1990
1. The name the user sees. Times New Roman
2. The name of the style. Bold
3. A unique identifier that applications can store to identify the font being used.

Monotype: Times New Roman Bold: 1990
4. The complete, unique, human readable name of the font. This name is used by
Windows. Times New Roman Bold
5. Release and version information from the font vendor. Version 1.00 June 1, 1990,
initial release
6. The name the font will be known by on a PostScript printer. TimesNewRoman-Bold
7. Trademark string. Times New Roman is a registered trademark of the Monotype
Corporation.
8. Manufacturer. Monotype Corporation
9. Designer. Stanley Morison
10. Description. Designed in 1932 for the Times of London newspaper. Excellent readability
and a narrow overall width, allowing more words per line than most fonts.
11. URL of Vendor. http://www.monotype.com
12. URL of Designer. http://www.monotype.com
13. License Description. This font may be installed on all of your machines and printers,
but you may not sell or give these fonts to anyone else.
14. License Info URL. http://www.monotype.com/license/
15. Reserved.
16. Preferred Family. No name string present, since it is the same as name ID 1 (Font
Family name).
17. Preferred Subfamily. No name string present, since it is the same as name ID 2 (Font
Subfamily name).
18. Compatible Full (Macintosh only). No name string present, since it is the same as
name ID 4 (Full name).
19. Sample text. The quick brown fox jumps over the lazy dog.

20. PostScript CID findfont name. No name string present. Thus, the PostScript Name
defined by name ID 6 should be used with the “findfont” invocation for locating the font
in the context of a PostScript interpreter.
21. WWS family name: Since Times New Roman is a WWS font, this field does not need
to be specified. If the font contained styles such as “caption”, “display”, “handwriting”,
etc., that would be noted here.
22. WWS subfamily name: Since Times New Roman is a WWS font, this field does not
need to be specified.
23. Light background palette name. No name string present, since this is not a color
font.
24. Dark background palette name. No name string present, since this is not a color
font.
25. Variations PostScript name prefix. No name string present, since this is not a variable
font.
The following is an example of only name IDs 6 and 20 in the CFF OpenType Japanese
font Kozuka Mincho Std Regular (other name IDs are also present in this font):
6. PostScript name: KozMinStd-Regular. Since a name ID 20 is present in the font (see
below), then the PostScript name defined by name ID 6 should be used with the
“composefont” invocation for locating the font in the context of a PostScript interpreter.
20. PostScript CID findfont name: KozMinStd-Regular-83pv-RKSJ-H, in a name record of
Platform 1 [Macintosh], Platform-specific script 1 [Japanese], Language: 0xFFFF [English].
This name string is a PostScript name that should be used with the “findfont” invocation
for locating the font in the context of a PostScript interpreter, and is associated with the
encoding specified by the following 'cmap' subtable, which must be present in the font:
Platform: 1 [Macintosh]; Platform-specific encoding: 1 [Japanese]; Language: 0 [not
language-specific].
The following is an example of family/subfamily naming for an extended, WWS-only
family. Consider Adobe Caslon Pro, with six members: upright and italic versions of
regular, semibold and bold weights. (Bit 8 of the fsSelection field of the OS/2 table,
version 4, should be set for all six fonts, and none should include 'name' entries for IDs
21 or 22.)

Adobe Caslon Pro Regular:
Name ID 1: Adobe Caslon Pro
Name ID 2: Regular
Adobe Caslon Pro Italic:
Name ID 1: Adobe Caslon Pro
Name ID 2: Italic
Adobe Caslon Pro Semibold:
Name ID 1: Adobe Caslon Pro
Name ID 2: Bold
Name ID 16: Adobe Caslon Pro
Name ID 17: Semibold
Adobe Caslon Pro Semibold Italic:
Name ID 1: Adobe Caslon Pro
Name ID 2: Bold Italic
Name ID 16: Adobe Caslon Pro
Name ID 17: Semibold Italic
Adobe Caslon Pro Bold:
Name ID 1: Adobe Caslon Pro Bold
Name ID 2: Regular
Name ID 16: Adobe Caslon Pro
Name ID 17: Bold
Adobe Caslon Pro Bold Italic:
Name ID 1: Adobe Caslon Pro Bold
Name ID 2: Italic
Name ID 16: Adobe Caslon Pro
Name ID 17: Bold Italic
The following is an example of family/subfamily naming for an extended, non-WWS
family. Consider Minion Pro Opticals, with 32 member fonts: upright and italic versions
of regular, medium, semibold and bold weights in each of four optical sizes: regular,
caption, display and subhead. The following show names for a sampling of the fonts in
this family. (Bit 8 of the fsSelection field in the OS/2 table, version 4, should be set in
those fonts that do not include 'name' entries for IDs 21 or 22, and only in those fonts.)
Minion Pro Regular:
Name ID 1: Minion Pro
Name ID 2: Regular
Minion Pro Italic:
Name ID 1: Minion Pro
Name ID 2: Italic

Minion Pro Semibold:
Name ID 1: Minion Pro SmBd
Name ID 2: Regular
Name ID 16: Minion Pro
Name ID 17: Semibold
Minion Pro Semibold Italic:
Name ID 1: Minion Pro SmBd
Name ID 2: Italic
Name ID 16: Minion Pro
Name ID 17: Semibold Italic
Minion Pro Caption:
Name ID 1: Minion Pro Capt
Name ID 2: Regular
Name ID 16: Minion Pro
Name ID 17: Caption
Name ID 21: Minion Pro Caption
Name ID 22: Regular
Minion Pro Semibold Italic Caption:
Name ID 1: Minion Pro SmBd Capt
Name ID 2: Italic
Name ID 16: Minion Pro
Name ID 17: Semibold Italic Caption
Name ID 21: Minion Pro Caption
Name ID 22: Semibold Italic

Platform, encoding and language IDs
The following sections provide details regarding platform IDs, platform-specific
encoding IDs, and platform-specific language IDs used in the 'name' table. For details
regarding platform, encoding or language IDs used in the 'cmap' table, see Encoding
records and encodings in the 'cmap' table chapter.

Platform IDs
The following platform IDs may be used in the 'name' table:
ﾉ

Expand table

Platform ID

Platform name

Platform-specific encoding IDs

Language IDs

0

Unicode

Various

None

Platform ID

Platform name

Platform-specific encoding IDs

Language IDs

1

Macintosh

Script manager code

Various

3

Windows

Windows encoding

Various

Note that other platform IDs have been defined for use only in the 'cmap' table.

Unicode platform (platform ID = 0)
The following encoding IDs for the Unicode platform may be used in the 'name' table:
ﾉ

Encoding ID

Description

0

Unicode 1.0 semantics—deprecated

1

Unicode 1.1 semantics—deprecated

2

ISO/IEC 10646 semantics—deprecated

3

Unicode 2.0 and onwards semantics, Unicode BMP only

4

Unicode 2.0 and onwards semantics, Unicode full repertoire

Expand table

Use of encoding IDs 0, 1 or 2 is deprecated. Either encoding ID 3 or 4 may be used for
'name' entries.
Note that other platform IDs have been defined for use only in the 'cmap' table. Also
note that a new encoding ID for the Unicode platform may sometimes be assigned
when new 'cmap' subtable formats are defined, and these may also be appropriate for
use in the 'name' table. For example, when 'cmap' subtable formats 10 and 12 were
added to the specification, encoding ID 4 was added as well.
There are no platform-specific language IDs defined for the Unicode platform. Language
ID = 0 may be used for Unicode-platform strings, but this does not indicate any
particular language. Language IDs greater than or equal to 0x8000 may be used
together with language-tag records, as described above.
Strings for the Unicode platform must be encoded in UTF-16BE.

Macintosh platform (platform ID = 1)
Macintosh encoding IDs (script manager codes)

The following encoding IDs are defined for use with the Macintosh platform:
ﾉ

Expand table

Encoding ID

Script

Encoding ID

Script

0

Roman

17

Malayalam

1

Japanese

18

Sinhalese

2

Chinese (Traditional)

19

Burmese

3

Korean

20

Khmer

4

Arabic

21

Thai

5

Hebrew

22

Laotian

6

Greek

23

Georgian

7

Russian

24

Armenian

8

RSymbol

25

Chinese (Simplified)

9

Devanagari

26

Tibetan

10

Gurmukhi

27

Mongolian

11

Gujarati

28

Geez

12

Odia

29

Slavic

13

Bangla

30

Vietnamese

14

Tamil

31

Sindhi

15

Telugu

32

Uninterpreted

16

Kannada

Strings for the Macintosh platform (platform ID 1) use platform-specific single- or
double-byte encodings according to the specified encoding ID for a given name record.

Macintosh language IDs
For information on Macintosh platform-specific language IDs, consult Apple’s TrueType
Reference Manual

.

Windows platform (platform ID= 3)

Windows encoding IDs
The following encoding IDs are defined for use with the Windows platform:
ﾉ

Encoding ID

Description

0

Symbol

1

Unicode BMP

2

ShiftJIS

3

PRC

4

Big5

5

Wansung

6

Johab

7

Reserved

8

Reserved

9

Reserved

10

Unicode full repertoire

Expand table

Encoding IDs for platform 3 'name' entries should match the encoding IDs used for
platform 3 subtables in the 'cmap' table. When building a Unicode font for Windows,
the platform ID should be 3 and the encoding ID should be 1. When building a symbol
font for Windows, the platform ID should be 3 and the encoding ID should be 0. If a font
has records for encoding IDs 3, 4 or 5, the corresponding string data should be encoded
using code pages 936, 950 and 949, respectively. Otherwise, all string data for platform
3 must be encoded in UTF-16BE.
Note: Some legacy Traditional Chinese fonts had name entries for platform 3,
encoding ID 4 (Big5) with some string data encoded using code page 950 but with
the string data for name ID 2 (font subfamily) encoded, instead, in UTF-16BE. For
example, this was the case in the MingLi font included in the Traditional Chinese
edition of Windows 95. Some older software implementations, including Windows
GDI, allow for this exception.

Windows language IDs

For information on Windows platform-specific language IDs and corresponding BCP 47
language tags, see [MS-LCID]: Windows Language Code Identifier (LCID) Reference.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

Name String Examples
Article • 12/09/2021

The following is an example of how name strings would be made for the Arial family.
ﾉ

Expand table

Font

Name ID 1

Name ID 2

Name ID 4

Name ID 16

Name ID 17

Arial Narrow

Arial Narrow

Regular

Arial Narrow

Arial

Narrow

Arial Narrow Italic

Arial Narrow

Italic

Arial Narrow Italic

Arial

Narrow Italic

Arial Narrow Bold

Arial Narrow

Bold

Arial Narrow Bold

Arial

Narrow Bold

Arial Narrow Bold Italic

Arial Narrow

Bold Italic

Arial Narrow Bold Italic

Arial

Narrow Bold Italic

Arial

Arial

Regular

Arial

Arial

Arial Italic

Arial

Italic

Arial Italic

Arial

Italic

Arial Bold

Arial

Bold

Arial Bold

Arial

Bold

Arial Bold Italic

Arial

Bold Italic

Arial Bold Italic

Arial

Bold Italic

Arial Black

Arial Black

Regular

Arial Black

Arial

Black

Arial Black Italic

Arial Black

Italic

Arial Black Italic

Arial

Black Italic

In addition to name strings, OS/2.usWeightClass, OS/2.usWidthClass, OS/2.fsSelection style bits, and head.macStyle
bits are shown. These settings allow the fonts to fit together into a single family of varying weight and
compression/expansion.
ﾉ

Font

OS/2
usWeightClass

OS/2
usWidthClass

Arial
Narrow

400

3

Arial
Narrow
Italic

400

3

Arial
Narrow
Bold

700

3

Arial
Narrow
Bold
Italic

700

3

Arial

400

5

Arial
Italic

400

5

Arial

700

5

OS/2
fsSelection
Italic

OS/2
fsSelection
Bold

OS/2
fsSelection
Regular

'head'
macStyle
Bold

'head'
macStyle
Italic

x

x

x

x

x

x

x

x

x

x

x

x

x

x

x

'head'
macStyle
Condensed
x

x

Expand table

x

'head'
macStyle
Extended

Bold
Arial

700

5

900

5

900

5

x

x

x

x

x

x

x

x

Bold
Italic
Arial
Black
Arial
Black

x

x

Italic

６ Collaborate with us on GitHub

OpenType specification feedback

The source for this content can be
found on GitHub, where you can
also create and review issues and
pull requests. For more information,
see our contributor guide.

OpenType specification is an open source project. Select a link to
provide feedback:
 Open a documentation issue
 Provide product feedback

OS/2 — OS/2 and Windows Metrics
Table
Article • 05/31/2024

The OS/2 table consists of a set of metrics and other data that are required in OpenType
fonts.

OS/2 Table Formats
Six versions of the OS/2 table have been defined: versions 0 to 5. All versions are
supported, but use of version 4 or later is strongly recommended.

Version 5
The format of version 5 is as follows:
ﾉ

Type

Name

Comments

uint16

version

0x0005

FWORD

xAvgCharWidth

uint16

usWeightClass

uint16

usWidthClass

uint16

fsType

FWORD

ySubscriptXSize

FWORD

ySubscriptYSize

FWORD

ySubscriptXOffset

FWORD

ySubscriptYOffset

FWORD

ySuperscriptXSize

FWORD

ySuperscriptYSize

FWORD

ySuperscriptXOffset

FWORD

ySuperscriptYOffset

Expand table

Type

Name

Comments

FWORD

yStrikeoutSize

FWORD

yStrikeoutPosition

int16

sFamilyClass

uint8

panose[10]

uint32

ulUnicodeRange1

Bits 0 – 31

uint32

ulUnicodeRange2

Bits 32 – 63

uint32

ulUnicodeRange3

Bits 64 – 95

uint32

ulUnicodeRange4

Bits 96 – 127

Tag

achVendID

uint16

fsSelection

uint16

usFirstCharIndex

uint16

usLastCharIndex

FWORD

sTypoAscender

FWORD

sTypoDescender

FWORD

sTypoLineGap

UFWORD

usWinAscent

UFWORD

usWinDescent

uint32

ulCodePageRange1

Bits 0 – 31

uint32

ulCodePageRange2

Bits 32 – 63

FWORD

sxHeight

FWORD

sCapHeight

uint16

usDefaultChar

uint16

usBreakChar

uint16

usMaxContext

uint16

usLowerOpticalPointSize

uint16

usUpperOpticalPointSize

Version 4
Version 4 was defined in OpenType 1.5. Version 4 has two fewer fields than version 5,
and the same fields as in version 3. Although new fields were not added beyond those
in version 3, the specification of certain fields was revised. The format of version 4 is as
follows:
ﾉ

Type

Name

uint16

version

FWORD

xAvgCharWidth

uint16

usWeightClass

uint16

usWidthClass

uint16

fsType

FWORD

ySubscriptXSize

FWORD

ySubscriptYSize

FWORD

ySubscriptXOffset

FWORD

ySubscriptYOffset

FWORD

ySuperscriptXSize

FWORD

ySuperscriptYSize

FWORD

ySuperscriptXOffset

FWORD

ySuperscriptYOffset

FWORD

yStrikeoutSize

FWORD

yStrikeoutPosition

int16

sFamilyClass

uint8

panose[10]

uint32

ulUnicodeRange1

uint32

ulUnicodeRange2

uint32

ulUnicodeRange3

Expand table

Type

Name

uint32

ulUnicodeRange4

Tag

achVendID

uint16

fsSelection

uint16

usFirstCharIndex

uint16

usLastCharIndex

FWORD

sTypoAscender

FWORD

sTypoDescender

FWORD

sTypoLineGap

UFWORD

usWinAscent

UFWORD

usWinDescent

uint32

ulCodePageRange1

uint32

ulCodePageRange2

FWORD

sxHeight

FWORD

sCapHeight

uint16

usDefaultChar

uint16

usBreakChar

uint16

usMaxContext

Version 3
Version 3 was defined in OpenType 1.4. Version 3 has the same fields as in version 4, and
as in version 2. Although new fields were not added beyond those in version 2, the
specification of certain fields was revised to reflect changes in Unicode 3.2. The format
of version 3 is identical to the format for version 4, given above.

Version 2
Version 2 was defined in OpenType 1.1. Version 2 has the same fields as in version 3, and
five additional fields beyond those in version 1. The format of version 2 is identical to
the format for version 4, given above.

Version 1
Version 1 was defined in TrueType revision 1.66. Version 1 has five fewer fields than
version 2, and two additional fields beyond those in version 0. The format of version 1 is
as follows:
ﾉ

Type

Name

uint16

version

FWORD

xAvgCharWidth

uint16

usWeightClass

uint16

usWidthClass

uint16

fsType

FWORD

ySubscriptXSize

FWORD

ySubscriptYSize

FWORD

ySubscriptXOffset

FWORD

ySubscriptYOffset

FWORD

ySuperscriptXSize

FWORD

ySuperscriptYSize

FWORD

ySuperscriptXOffset

FWORD

ySuperscriptYOffset

FWORD

yStrikeoutSize

FWORD

yStrikeoutPosition

int16

sFamilyClass

uint8

panose[10]

uint32

ulUnicodeRange1

uint32

ulUnicodeRange2

uint32

ulUnicodeRange3

uint32

ulUnicodeRange4

Expand table

Type

Name

Tag

achVendID

uint16

fsSelection

uint16

usFirstCharIndex

uint16

usLastCharIndex

FWORD

sTypoAscender

FWORD

sTypoDescender

FWORD

sTypoLineGap

UFWORD

usWinAscent

UFWORD

usWinDescent

uint32

ulCodePageRange1

uint32

ulCodePageRange2

Version 0
Version 0 was defined in TrueType revision 1.5. The format of version 0 is as follows:
ﾉ

Type

Name

uint16

version

FWORD

xAvgCharWidth

uint16

usWeightClass

uint16

usWidthClass

uint16

fsType

FWORD

ySubscriptXSize

FWORD

ySubscriptYSize

FWORD

ySubscriptXOffset

FWORD

ySubscriptYOffset

FWORD

ySuperscriptXSize

Expand table

Type

Name

FWORD

ySuperscriptYSize

FWORD

ySuperscriptXOffset

FWORD

ySuperscriptYOffset

FWORD

yStrikeoutSize

FWORD

yStrikeoutPosition

int16

sFamilyClass

uint8

panose[10]

uint32

ulUnicodeRange1

uint32

ulUnicodeRange2

uint32

ulUnicodeRange3

uint32

ulUnicodeRange4

Tag

achVendID

uint16

fsSelection

uint16

usFirstCharIndex

uint16

usLastCharIndex

FWORD

sTypoAscender

FWORD

sTypoDescender

FWORD

sTypoLineGap

UFWORD

usWinAscent

UFWORD

usWinDescent

Note: Documentation for OS/2 version 0 in Apple’s TrueType Reference Manual
stops at the usLastCharIndex field and does not include the last five fields of the
table as it was defined by Microsoft. Some legacy TrueType fonts could have been
built with a shortened version 0 OS/2 table. Applications should check the table
length for a version 0 OS/2 table before reading these fields.

OS/2 Field Details

This section provides details covering all versions of the OS/2 table.

version
ﾉ

Expand table

Format:

uint16

Units:

n/a

Title:

OS/2 table version number.

Description:

The version number for the OS/2 table: 0x0000 to 0x0005.

Comments:

The version number allows for identification of the precise contents and layout for
the OS/2 table.

xAvgCharWidth
ﾉ

Expand table

Format:

FWORD

Units:

Font design units

Title:

Average weighted escapement.

Description:

The Average Character Width field specifies the arithmetic average of the
escapement (width) of all non-zero width glyphs in the font.

Comments:

The value for xAvgCharWidth is calculated by obtaining the arithmetic average of
the width of all non-zero width glyphs in the font. It is strongly recommended that
implementers do not rely on this value for computing layout for lines of text,
especially for cases where complex scripts are used.
Note: Some fonts have xAvgCharWidth values that do not conform to this
calculation. Fonts could have been originally created with a version 0 to version 2
OS/2 table using the legacy calculation described below, then later updated with a
newer OS/2 table version but without changing the xAvgCharWidth value. In some
CJK fonts, the xAvgCharWidth can be almost half the value that would be expected
by the above calculation. Applications should not use xAvgCharWidth for
determining actual glyph advance widths.

Version
differences:

Versions 0 to 2: When first defined, the specification was biased toward Basic Latin
characters, and it was thought that the xAvgCharWidth value could be used to
estimate the average length of lines of text. The following formula for calculating
xAvgCharWidth was provided: For characters given in the table below, sum the
width of each character times the weight factor indicated, then divide the total by

1000. This method of calculating the value of this field was superseded with the
introduction of version 3 of the OS/2 table and is deprecated.
ﾉ

Expand table

Letter

Weight factor

Letter

Weight factor

a

64

o

56

b

14

p

17

c

27

q

4

d

35

r

49

e

100

s

56

f

20

t

71

g

14

u

31

h

42

v

10

i

63

w

18

j

3

x

3

k

6

y

18

l

35

z

2

m

20

space

166

n

56

usWeightClass
ﾉ

Expand table

Format:

uint16

Title:

Weight class.

Description:

Indicates the visual weight (degree of blackness or thickness of strokes) of the
characters in the font. Values from 1 to 1000 are valid.

Comments:

usWeightClass values use the same scale as the 'wght' axis that is used in the 'fvar'
table of variable fonts and in the STAT table. While integer values from 1 to 1000
are supported, some legacy platforms could have limitations on supported values.
The following are commonly used values:

ﾉ

Expand table

Value

Description

C Definition (from windows.h)

100

Thin

FW_THIN

200

Extra-light (Ultra-light)

FW_EXTRALIGHT

300

Light

FW_LIGHT

400

Normal (Regular)

FW_NORMAL

500

Medium

FW_MEDIUM

600

Semi-bold (Demi-bold)

FW_SEMIBOLD

700

Bold

FW_BOLD

800

Extra-bold (Ultra-bold)

FW_EXTRABOLD

900

Black (Heavy)

FW_BLACK

usWidthClass
ﾉ

Expand table

Format:

uint16

Title:

Width class.

Description:

Indicates a relative change from the normal aspect ratio (width to height ratio) as
specified by a font designer for the glyphs in a font.

Comments:

Although every glyph in a font can have a different numeric aspect ratio, each
glyph in a font of normal width is considered to have a relative aspect ratio of one.
When a new type style is created of a different width class (either by a font
designer or by some automated means) the relative aspect ratio of the glyphs in
the new font is some percentage greater or less than the corresponding glyphs in
the normal font — it is this difference that this field specifies.
The valid usWidthClass values are shown in the following table. Note that the
usWidthClass values are related to but distinct from the scale for the 'wdth' axis
that is used in the 'fvar' table of variable fonts and in the STAT table. The “% of
normal” column in the following table provides a mapping from usWidthClass
values 1 – 9 to 'wdth' values.
ﾉ

Expand table

Value

Description

C Definition

% of normal

1

Ultra-condensed

FWIDTH_ULTRA_CONDENSED

50

2

Extra-condensed

FWIDTH_EXTRA_CONDENSED

62.5

3

Condensed

FWIDTH_CONDENSED

75

4

Semi-condensed

FWIDTH_SEMI_CONDENSED

87.5

5

Medium (normal)

FWIDTH_NORMAL

100

6

Semi-expanded

FWIDTH_SEMI_EXPANDED

112.5

7

Expanded

FWIDTH_EXPANDED

125

8

Extra-expanded

FWIDTH_EXTRA_EXPANDED

150

9

Ultra-expanded

FWIDTH_ULTRA_EXPANDED

200

fsType
ﾉ

Expand table

Format:

uint16

Title:

Type flags.

Description:

Indicates font embedding licensing rights for the font. The interpretation of flags is
as follows:
ﾉ

Expand table

Bits

Mask

Description

0–

0x000F

Usage permissions. Valid fonts must set at most one of bits 1, 2

3

or 3; bit 0 is permanently reserved and must be zero. Valid
values for this sub-field are 0, 2, 4 or 8. The meaning of these
values is as follows:
0: Installable embedding: the font may be embedded, and may
be permanently installed for use on a remote systems, or for
use by other users. The user of the remote system acquires the
identical rights, obligations and licenses for that font as the
original purchaser of the font, and is subject to the same enduser license agreement, copyright, design patent, and/or
trademark as was the original purchaser.
2: Restricted License embedding: the font must not be

modified, embedded or exchanged in any manner without first
obtaining explicit permission of the legal owner.
4: Preview & Print embedding: the font may be embedded,
and may be temporarily loaded on other systems for purposes
of viewing or printing the document. Documents containing
Preview & Print fonts must be opened “read-only”; no edits
may be applied to the document.
8: Editable embedding: the font may be embedded, and may
be temporarily loaded on other systems. As with Preview &
Print embedding, documents containing Editable fonts may be
opened for reading. In addition, editing is permitted, including
ability to format new text using the embedded font, and
changes may be saved.
4–
7

0x00F0

Reserved, must be zero.

8

0x0100

No subsetting: When this bit is set, the font must not be
subsetted prior to embedding. Other embedding restrictions
specified in bits 0 – 3 and bit 9 also apply.

9

0x0200

Bitmap embedding only: When this bit is set, only bitmaps
contained in the font may be embedded. No outline data may
be embedded. If there are no bitmaps available in the font,
then the font is considered unembeddable and the embedding
services will fail. Other embedding restrictions specified in bits
0-3 and 8 also apply.

10 –

0xFC00

Reserved, must be zero.

15
Comments:

Embeddable fonts may be stored in a document. When a document with
embedded fonts is opened on a system that does not have the font installed (the
remote system), the embedded font may be loaded for temporary (and in some
cases, permanent) use on that system by an embedding-aware application.
Embedding licensing rights are granted by the vendor of the font.
Applications that implement support for font embedding must not embed fonts
which are not licensed to permit embedding. Also, when embedding a font into a
document, applications must not modify the embedding permissions and restrictions
indicated in this field. In addition, applications loading embedded fonts for
temporary use (Preview & Print or Editable embedding) must delete the fonts when
the document containing the embedded font is closed.
Bits 0 to 3 (the embedding permissions sub-field) are mutually exclusive: fonts
should never have more than one of these bits set. Note that, if two or more bits
are set, some applications could assume the least-restrictive permission indicated.
(See version differences for more discussion.) Caution: Font vendors are

responsible to set these bits correctly to obtain the desired application behaviors.
For Restricted License embedding to take effect, the Embedding permissions subfield must have the value 2 (that is, only bit 1 is set).
Note: Apple’s TrueType Reference Manual specifies bit 1 of the fsType field, and
only bit 1, as having an assigned semantic. This originated from a pre-release draft
specification for the OS/2 table. However, the final specification for version 0 of the
OS/2 table defined bits 0 to 3. Also, some early font implementations mistakenly
used the value 1 (bit 0 set), leading to problems of non-interoperability. For this
reason, bit 0 was specified as reserved in the final specification for version 0. Bit 0
is permanently reserved, and its use is deprecated.
Version
differences:

Versions 0 to 1: only bits 0 to 3 were assigned. Applications must ignore bits 4 to
15 when reading a version 0 or version 1 table.
Versions 0 to 2: The specification for versions 0 to 2 did not specify that bits 0 to 3
must be mutually exclusive. Rather, those specifications stated that, in the event
that more than one of bits 0 to 3 are set in a given font, then the least-restrictive
permission indicated take precedence. In particular, some fonts using a version 0 to
version 2 OS/2 table have both bit 2 and bit 3 set with the intent to indicate both
preview/print and edit permissions. Applications are permitted to use this behavior
for fonts with a version 0 to version 2 OS/2 table.
Versions 3 and later: The specification for version 3, added in OpenType 1.4,
introduced the explicit requirement that bits 0 to 3 must be mutually exclusive.

ySubscriptXSize
ﾉ

Expand table

Format:

FWORD

Units:

Font design units

Title:

Subscript horizontal font size.

Description:

The recommended horizontal size in font design units for subscripts for this font.
Should be > 0.

Comments:

If a font has two recommended sizes for subscripts, e.g., numerics and other, the
numeric sizes should be stressed. This size field maps to the em size of the font
being used for a subscript. The horizontal font size specifies a font designer’s
recommended horizontal size of subscript glyphs associated with this font. If a font
does not include all required subscript glyphs for an application, and the
application can substitute glyphs by scaling the glyphs of a font or by substituting
glyphs from another font, this field specifies the recommended nominal width for
those subscript glyphs.
For example, if the em for a font is 2048 units and ySubScriptXSize is set to 205,

then the horizontal size for a simulated subscript glyph would be 1/10th the size of
the normal glyph.
Note: This was implemented in the OS/2 platform as a signed value, even though
only values > 0 would be expected.

ySubscriptYSize
ﾉ

Expand table

Format:

FWORD

Units:

Font design units

Title:

Subscript vertical font size.

Description:

The recommended vertical size in font design units for subscripts for this font.
Should be > 0.

Comments:

If a font has two recommended sizes for subscripts, e.g. numerics and other, the
numeric sizes should be stressed. This size field maps to the em size of the font
being used for a subscript. The vertical font size specifies a font designer’s
recommendation for vertical size of subscript glyphs associated with this font. If a
font does not include all required subscript glyphs for an application, and the
application can substitute glyphs by scaling the glyphs in a font or by substituting
glyphs from another font, this field specifies the recommended nominal height for
those subscript glyphs.
For example, if the em for a font is 2048 units and ySubScriptYSize is set to 205,
then the vertical size for a simulated subscript glyph would be 1/10th the size of
the normal glyph.
Note: This was implemented in the OS/2 platform as a signed value, even though
only values > 0 would be expected.

ySubscriptXOffset
ﾉ

Expand table

Format:

FWORD

Units:

Font design units

Title:

Subscript x offset.

Description:

The recommended horizontal offset in font design units for subscripts for this font.

Comments:

The ySubscriptXOffset field specifies a font designer’s recommended horizontal
offset — from the glyph origin to the glyph origin of the subscript’s glyph — for
subscript glyphs associated with this font. If a font does not include all required
subscript glyphs for an application, and the application can substitute glyphs, this
field specifies the recommended horizontal position from the glyph escapement
point of the last glyph before the first subscript glyph. For upright glyphs, this value
is usually zero; however, if the glyphs of a font have an incline (italic or slant), the
reference point for subscript glyphs is usually adjusted to compensate for the angle
of incline.

ySubscriptYOffset
ﾉ

Expand table

Format:

FWORD

Units:

Font design units

Title:

Subscript y offset.

Description:

The recommended vertical offset in font design units from the baseline for
subscripts for this font.

Comments:

The ySubscriptYOffset field specifies a font designer’s recommended vertical offset
from the glyph baseline to the glyph baseline for subscript glyphs associated with
this font. Values are expressed as a positive offset below the glyph baseline. If a
font does not include all required subscript glyphs for an application, this field
specifies the recommended vertical distance below the glyph baseline for alternate
subscript glyphs supplied by the application.

ySuperscriptXSize
ﾉ

Expand table

Format:

FWORD

Units:

Font design units

Title:

Superscript horizontal font size.

Description:

The recommended horizontal size in font design units for superscripts for this font.
Should be > 0.

Comments:

If a font has two recommended sizes for superscripts, e.g., numerics and other, the
numeric sizes should be stressed. This size field maps to the em size of the font
being used for a superscript. The horizontal font size specifies a font designer’s
recommended horizontal size for superscript glyphs associated with this font. If a

font does not include all required superscript glyphs for an application, and the
application can substitute glyphs by scaling the glyphs of a font or by substituting
glyphs from another font, this field specifies the recommended nominal width for
those superscript glyphs.
For example, if the em for a font is 2048 units and ySuperScriptXSize is set to 205,
then the horizontal size for a simulated superscript glyph would be 1/10th the size
of the normal glyph.
Note: This was implemented in the OS/2 platform as a signed value, even though
only values > 0 would be expected.

ySuperscriptYSize
ﾉ

Expand table

Format:

FWORD

Units:

Font design units

Title:

Superscript vertical font size.

Description:

The recommended vertical size in font design units for superscripts for this font.
Should be > 0.

Comments:

If a font has two recommended sizes for superscripts, e.g., numerics and other, the
numeric sizes should be stressed. This size field maps to the em size of the font
being used for a superscript. The vertical font size specifies a font designer’s
recommended vertical size for superscript glyphs associated with this font. If a font
does not include all required superscript glyphs for an application, and the
application can substitute glyphs by scaling the glyphs of a font or by substituting
glyphs from another font, this field specifies the recommended nominal height for
those superscript glyphs.
For example, if the em for a font is 2048 units and ySuperScriptYSize is set to 205,
then the vertical size for a simulated superscript glyph would be 1/10th the size of
the normal glyph.
Note: This was implemented in the OS/2 platform as a signed value, even though
only values > 0 would be expected.

ySuperscriptXOffset
ﾉ

Format:

FWORD

Expand table

Units:

Font design units

Title:

Superscript x offset.

Description:

The recommended horizontal offset in font design units for superscripts for this
font.

Comments:

The ySuperscriptXOffset field specifies a font designer’s recommended horizontal
offset — from the glyph’s origin to the superscript glyph’s origin for the superscript
glyphs associated with this font. If a font does not include all required superscript
glyphs for an application, this field specifies the recommended horizontal position
from the escapement point of the glyph before the first superscript glyph. For
upright glyphs, this value is usually zero; however, if the glyphs of a font have an
incline (italic or slant), the reference point for superscript glyphs is usually adjusted
to compensate for the angle of incline.

ySuperscriptYOffset
ﾉ

Expand table

Format:

FWORD

Units:

Font design units

Title:

Superscript y offset.

Description:

The recommended vertical offset in font design units from the baseline for
superscripts for this font.

Comments:

The ySuperscriptYOffset field specifies a font designer’s recommended vertical
offset — from the glyph’s baseline to the superscript glyph’s baseline associated
with this font. Values for this field are expressed as a positive offset above the glyph
baseline. If a font does not include all required superscript glyphs for an
application, this field specifies the recommended vertical distance above the glyph
baseline for alternate superscript glyphs supplied by the application.

yStrikeoutSize
ﾉ

Format:

FWORD

Units:

Font design units

Title:

Strikeout size.

Description:

Thickness of the strikeout stroke in font design units. Should be > 0.

Expand table

Comments:

This field should normally be the thickness of the em dash for the current font, and
should also match the underline thickness, which is specified in the 'post' table.
Note: This was implemented in the OS/2 platform as a signed value, even though
only values > 0 would be expected.

yStrikeoutPosition
ﾉ

Expand table

Format:

FWORD

Units:

Font design units

Title:

Strikeout position.

Description:

The position of the top of the strikeout stroke relative to the baseline in font design
units.

Comments:

Positive values represent distances above the baseline; negative values represent
distances below the baseline. Aligning the strikeout position with the em dash is
suggested. Note, however, that the strikeout position should not interfere with the
recognition of standard characters, and therefore should not line up with crossbars
in the font.

sFamilyClass
ﾉ

Expand table

Format:

int16

Title:

Font-family class and subclass.

Description:

This field provides a classification of font-family design.

Comments:

The family class and subclass are assigned to a font based on the family design.
This field is intended for use in selecting an alternate font family when the
requested font is not available.
The class and subclass provide a two-level classification. The high byte of this field
contains the family class, while the low byte contains the family subclass. The
interpretation of subclass values depends on the class value.
Registered class and subclass values were originally defined by IBM. For details on
registered values, see IBM Font Family Classifications.

panose
ﾉ

Expand table

Format:

uint8[10]

Title:

PANOSE classification number

International:

Additional specifications are required for PANOSE to classify non-Latin character
sets.

Description:

This 10-byte array of numbers is used to describe the visual characteristics of a
given typeface. These characteristics are then used to associate the font with
other fonts of similar appearance having different names. The variables for each
digit are listed below.

Comments:

The PANOSE definition contains ten bytes, each of which can have multiple
possible values. The PANOSE values are fully described in the PANOSE
Classification Metrics Guide

. Note that the first byte is used for a high-level

classification, “Family Kind”, and that the interpretation of the remaining bytes is
contingent on the value of the first byte. For example, if the Family Kind value is 2
(Latin Text), then the next byte specifies “Serif Style”; but if the Family Kind value is
3 (Latin Hand Written), then the next byte specifies “Tool Kind”. Some applications
might support only certain Family Kind values. The following table gives the
interpretation for the panose array when the Family Kind is Latin Text:
ﾉ

Type

Name

uint8

bFamilyType

uint8

bSerifStyle

uint8

bWeight

uint8

bProportion

uint8

bContrast

uint8

bStrokeVariation

uint8

bArmStyle

uint8

bLetterform

uint8

bMidline

uint8

bXHeight

Expand table

Some applications can use the PANOSE values for font selection, to select a font
matching certain parameters. For example, Proportion (for Family Kind = Latin
Text) might be used to determine if a font is monospaced; or Serif Style might be
used to determine if a font falls into generic serif or sans serif classes. Some
applications will use Family Kind = 5 (Latin Symbol) to identify symbol fonts,
which might affect font selection or fallback behaviors. There are no requirements
for how applications should use the PANOSE values.
In a variable font that uses OpenType Font Variation mechanisms, there is no way
to represent different PANOSE values for different instances supported by the
font. The PANOSE values can be set based on the default instance.
Version

Early versions of this specification provided more details regarding PANOSE

differences:

values. However, the external specification cited above is the normative source
and should be referred to for such details.

ulUnicodeRange*
ulUnicodeRange1 (bits 0 – 31)
ulUnicodeRange2 (bits 32 – 63)
ulUnicodeRange3 (bits 64 – 95)
ulUnicodeRange4 (bits 96 – 127)

ﾉ

Expand table

Format:

uint32[4] (128 bits total)

Title:

Unicode Character Range

Description:

This field is used to specify the Unicode blocks or ranges encompassed by the font
file in 'cmap' subtables for platform 3, encoding ID 1 (Microsoft platform, Unicode
BMP) and platform 3, encoding ID 10 (Microsoft platform, Unicode full repertoire).
If a bit is set (1), then the Unicode ranges assigned to that bit are considered
functional. If the bit is clear (0), then the range is not considered functional. Each of
the bits is treated as an independent flag and the bits can be set in any
combination. The determination of “functional” is left up to the font designer,
although character set selection should attempt to be functional by ranges if at all
possible.
All reserved fields must be zero. Each uint32 is in Big-Endian form.
ﾉ

Bit

Unicode Range

Block
range

Notes

Expand table

0

Basic Latin

0000007F

1

Latin-1
Supplement

008000FF

2

Latin Extended-A

0100017F

3

Latin Extended-B

0180024F

4

IPA Extensions

025002AF

Phonetic

1D00-

Added in OpenType 1.5 for OS/2

Extensions

1D7F

version 4.

Phonetic

1D80-

Added in OpenType 1.5 for OS/2

Extensions

1DBF

version 4.

Supplement
5

6

Spacing Modifier

02B0-

Letters

02FF

Modifier Tone

A700-

Added in OpenType 1.5 for OS/2

Letters

A71F

version 4.

Combining

0300-

Diacritical Marks

036F

Combining

1DC0-

Added in OpenType 1.5 for OS/2

Diacritical Marks

1DFF

version 4.

Supplement
7

Greek and Coptic

037003FF

8

9

Coptic

2C80-

Added in OpenType 1.5 for OS/2

2CFF

version 4. See below for other version
differences.

Cyrillic

040004FF

Cyrillic Supplement

0500052F

Added in OpenType 1.4 for OS/2
version 3.

Cyrillic Extended-A

2DE02DFF

Added in OpenType 1.5 for OS/2
version 4.

Cyrillic Extended-B

A640A69F

10

Armenian

0530058F

11

Hebrew

059005FF

12

Vai

A500A63F

Added in OpenType 1.5 for OS/2
version 4.

Added in OpenType 1.5 for OS/2
version 4. See below for other version
differences.

13

Arabic

060006FF

Arabic Supplement

0750077F

Added in OpenType 1.5 for OS/2
version 4.

14

NKo

07C007FF

Added in OpenType 1.5 for OS/2
version 4. See below for other version
differences.

15

Devanagari

0900097F

16

Bangla

098009FF

17

Gurmukhi

0A000A7F

18

Gujarati

0A800AFF

19

Odia

0B000B7F

20

Tamil

0B800BFF

21

Telugu

0C000C7F

22

Kannada

0C800CFF

23

Malayalam

0D000D7F

24

Thai

0E000E7F

25

Lao

0E800EFF

26

Georgian

10A010FF

Georgian
Supplement

2D002D2F

Added in OpenType 1.5 for OS/2
version 4.

27

Balinese

1B001B7F

Added in OpenType 1.5 for OS/2
version 4. See below for other version
differences.

28

Hangul Jamo

110011FF

29

Latin Extended

1E00-

Additional

1EFF

Latin Extended-C

2C60-

Added in OpenType 1.5 for OS/2

2C7F

version 4.

A720-

Added in OpenType 1.5 for OS/2

A7FF

version 4.

Latin Extended-D

30

Greek Extended

1F001FFF

31

General

2000-

Punctuation

206F

Supplemental
Punctuation

2E002E7F

32

Superscripts And
Subscripts

2070209F

33

Currency Symbols

20A020CF

34

Combining
Diacritical Marks
For Symbols

20D020FF

35

Letterlike Symbols

2100214F

36

Number Forms

2150218F

37

Arrows

219021FF

Added in OpenType 1.5 for OS/2
version 4.

Supplemental

27F0-

Added in OpenType 1.4 for OS/2

Arrows-A

27FF

version 3.

Supplemental

2900-

Added in OpenType 1.4 for OS/2

Arrows-B

297F

version 3.

Miscellaneous

2B00-

Added in OpenType 1.5 for OS/2

Symbols and
Arrows

2BFF

version 4.

Mathematical
Operators

220022FF

Supplemental
Mathematical
Operators

2A002AFF

Added in OpenType 1.4 for OS/2
version 3.

Miscellaneous
Mathematical

27C027EF

Added in OpenType 1.4 for OS/2
version 3.

Miscellaneous
Mathematical
Symbols-B

298029FF

Added in OpenType 1.4 for OS/2
version 3.

39

Miscellaneous
Technical

230023FF

40

Control Pictures

2400243F

41

Optical Character
Recognition

2440245F

42

Enclosed
Alphanumerics

246024FF

43

Box Drawing

2500257F

44

Block Elements

2580259F

45

Geometric Shapes

25A0-

38

Symbols-A

25FF
46

47

Miscellaneous

2600-

Symbols

26FF

Dingbats

270027BF

48

CJK Symbols And
Punctuation

3000303F

49

Hiragana

3040309F

50

Katakana

30A030FF

Katakana Phonetic
Extensions

31F031FF

Bopomofo

3100312F

Bopomofo

31A0-

Added in OpenType 1.3, extending

Extended

31BF

OS/2 version 2.

Hangul

3130-

Compatibility Jamo

318F

Phags-pa

A840-

Added in OpenType 1.5 for OS/2

A87F

version 4. See below for other version
differences.

51

52

53

54

Enclosed CJK
Letters And
Months

320032FF

55

CJK Compatibility

330033FF

56

Hangul Syllables

AC00D7AF

57

Non-Plane 0

1000010FFFF

Added in OpenType 1.4 for OS/2
version 3.

Setting this bit implies there is at least
one character beyond the Basic
Multilingual Plane supported by this
font. First assigned in OpenType 1.3
for OS/2 version 2.

58

Phoenician

109001091F

First assigned in OpenType 1.5 for
OS/2 version 4.

59

CJK Unified
Ideographs

4E009FFF

CJK Radicals

2E80-

Added in OpenType 1.3 for OS/2

Supplement

2EFF

version 2.

Kangxi Radicals

2F00-

Added in OpenType 1.3 for OS/2

2FDF

version 2.

Ideographic
Description
Characters

2FF02FFF

Added in OpenType 1.3 for OS/2
version 2.

CJK Unified
Ideographs

34004DBF

Added in OpenType 1.3 for OS/2
version 2.

CJK Unified

20000-

Added in OpenType 1.4 for OS/2

Ideographs
Extension B

2A6DF

version 3.

Kanbun

3190319F

Added in OpenType 1.4 for OS/2
version 3.

60

Private Use Area
(plane 0)

E000F8FF

61

CJK Strokes

31C031EF

CJK Compatibility
Ideographs

F900FAFF

CJK Compatibility
Ideographs
Supplement

2F8002FA1F

Alphabetic

FB00-

Presentation Forms

FB4F

Arabic Presentation

FB50-

Forms-A

FDFF

Combining Half

FE20-

Marks

FE2F

Vertical Forms

FE10-

Added in OpenType 1.5 for OS/2

FE1F

version 4.

Extension A

62

63

64

65

CJK Compatibility
Forms

FE30FE4F

66

Small Form
Variants

FE50FE6F

67

Arabic Presentation
Forms-B

FE70FEFF

68

Halfwidth And
Fullwidth Forms

FF00FFEF

Added in OpenType 1.5 for OS/2
version 4.

Added in OpenType 1.4 for OS/2
version 3.

69

Specials

FFF0FFFF

70

71

72

73

Tibetan

Syriac

Thaana

Sinhala

0F00-

First assigned in OpenType 1.3,

0FFF

extending OS/2 version 2.

0700-

First assigned in OpenType 1.3,

074F

extending OS/2 version 2.

0780-

First assigned in OpenType 1.3,

07BF

extending OS/2 version 2.

0D80-

First assigned in OpenType 1.3,

0DFF

extending OS/2 version 2.

74

Myanmar

1000109F

First assigned in OpenType 1.3,
extending OS/2 version 2.

75

Ethiopic

1200137F

First assigned in OpenType 1.3,
extending OS/2 version 2.

Ethiopic
Supplement

1380139F

Added in OpenType 1.5 for OS/2
version 4.

Ethiopic Extended

2D802DDF

Added in OpenType 1.5 for OS/2
version 4.

76

Cherokee

13A013FF

First assigned in OpenType 1.3,
extending OS/2 version 2.

77

Unified Canadian
Aboriginal Syllabics

1400167F

First assigned in OpenType 1.3,
extending OS/2 version 2.

78

Ogham

1680169F

First assigned in OpenType 1.3,
extending OS/2 version 2.

79

Runic

16A016FF

First assigned in OpenType 1.3,
extending OS/2 version 2.

80

Khmer

178017FF

First assigned in OpenType 1.3,
extending OS/2 version 2.

Khmer Symbols

19E019FF

Added in OpenType 1.5 for OS/2
version 4.

81

Mongolian

180018AF

First assigned in OpenType 1.3,
extending OS/2 version 2.

82

Braille Patterns

2800-

First assigned in OpenType 1.3,

28FF

extending OS/2 version 2.

83

Yi Syllables

A000A48F

First assigned in OpenType 1.3,
extending OS/2 version 2.

Yi Radicals

A490A4CF

Added in OpenType 1.3, extending
OS/2 version 2.

Tagalog

1700171F

First assigned in OpenType 1.4 for
OS/2 version 3.

Hanunoo

1720173F

Added in OpenType 1.4 for OS/2
version 3.

Buhid

1740175F

Added in OpenType 1.4 for OS/2
version 3.

Tagbanwa

1760-

Added in OpenType 1.4 for OS/2

177F

version 3.

10300-

First assigned in OpenType 1.4 for

1032F

OS/2 version 3.

10330-

First assigned in OpenType 1.4 for

1034F

OS/2 version 3.

10400-

First assigned in OpenType 1.4 for

1044F

OS/2 version 3.

Byzantine Musical

1D000-

First assigned in OpenType 1.4 for

Symbols

1D0FF

OS/2 version 3.

Musical Symbols

1D1001D1FF

Added in OpenType 1.4 for OS/2
version 3.

Ancient Greek
Musical Notation

1D2001D24F

Added in OpenType 1.5 for OS/2
version 4.

89

Mathematical
Alphanumeric
Symbols

1D4001D7FF

First assigned in OpenType 1.4 for
OS/2 version 3.

90

Private Use (plane
15)

F0000FFFFD

First assigned in OpenType 1.4 for
OS/2 version 3.

Private Use (plane
16)

10000010FFFD

Added in OpenType 1.4 for OS/2
version 3.

Variation Selectors

FE00FE0F

First assigned in OpenType 1.4 for
OS/2 version 3.

Variation Selectors
Supplement

E0100E01EF

Added in OpenType 1.4 for OS/2
version 3.

84

85

86

87

88

91

Old Italic

Gothic

Deseret

92

Tags

E0000E007F

First assigned in OpenType 1.4 for
OS/2 version 3.

93

Limbu

1900194F

First assigned in OpenType 1.5 for
OS/2 version 4.

94

Tai Le

1950197F

First assigned in OpenType 1.5 for
OS/2 version 4.

95

New Tai Lue

198019DF

First assigned in OpenType 1.5 for
OS/2 version 4.

96

Buginese

1A001A1F

First assigned in OpenType 1.5 for
OS/2 version 4.

97

Glagolitic

2C002C5F

First assigned in OpenType 1.5 for
OS/2 version 4.

98

Tifinagh

2D302D7F

First assigned in OpenType 1.5 for
OS/2 version 4.

99

Yijing Hexagram
Symbols

4DC04DFF

First assigned in OpenType 1.5 for
OS/2 version 4.

100

Syloti Nagri

A800A82F

First assigned in OpenType 1.5 for
OS/2 version 4.

101

Linear B Syllabary

100001007F

First assigned in OpenType 1.5 for
OS/2 version 4.

Linear B Ideograms

10080100FF

Added in OpenType 1.5 for OS/2
version 4.

Aegean Numbers

10100-

Added in OpenType 1.5 for OS/2

1013F

version 4.

Ancient Greek

10140-

First assigned in OpenType 1.5 for

Numbers

1018F

OS/2 version 4.

Ugaritic

10380-

First assigned in OpenType 1.5 for

1039F

OS/2 version 4.

103A0-

First assigned in OpenType 1.5 for

103DF

OS/2 version 4.

10450-

First assigned in OpenType 1.5 for

1047F

OS/2 version 4.

10480104AF

First assigned in OpenType 1.5 for
OS/2 version 4.

102

103

104

105

106

Old Persian

Shavian

Osmanya

107

10800-

First assigned in OpenType 1.5 for

1083F

OS/2 version 4.

10A00-

First assigned in OpenType 1.5 for

10A5F

OS/2 version 4.

Tai Xuan Jing

1D300-

First assigned in OpenType 1.5 for

Symbols

1D35F

OS/2 version 4.

Cuneiform

12000-

First assigned in OpenType 1.5 for

123FF

OS/2 version 4.

Cuneiform

12400-

Added in OpenType 1.5 for OS/2

Numbers and
Punctuation

1247F

version 4.

111

Counting Rod
Numerals

1D3601D37F

First assigned in OpenType 1.5 for
OS/2 version 4.

112

Sundanese

1B801BBF

First assigned in OpenType 1.5 for
OS/2 version 4.

113

Lepcha

1C001C4F

First assigned in OpenType 1.5 for
OS/2 version 4.

114

Ol Chiki

1C501C7F

First assigned in OpenType 1.5 for
OS/2 version 4.

115

Saurashtra

A880A8DF

First assigned in OpenType 1.5 for
OS/2 version 4.

116

Kayah Li

A900A92F

First assigned in OpenType 1.5 for
OS/2 version 4.

117

Rejang

A930A95F

First assigned in OpenType 1.5 for
OS/2 version 4.

118

Cham

AA00-

First assigned in OpenType 1.5 for

AA5F

OS/2 version 4.

10190-

First assigned in OpenType 1.5 for

101CF

OS/2 version 4.

101D0-

First assigned in OpenType 1.5 for

101FF

OS/2 version 4.

102A0-

First assigned in OpenType 1.5 for

102DF

OS/2 version 4.

102801029F

Added in OpenType 1.5 for OS/2
version 4.

108

109

110

119

120

121

Cypriot Syllabary

Kharoshthi

Ancient Symbols

Phaistos Disc

Carian

Lycian

122

123127
Comments:

Lydian

109201093F

Added in OpenType 1.5 for OS/2
version 4.

Domino Tiles

1F0301F09F

First assigned in OpenType 1.5 for
OS/2 version 4.

Mahjong Tiles

1F0001F02F

First assigned in OpenType 1.5 for
OS/2 version 4.

Reserved

All available bits were exhausted as of Unicode 5.1. The bit assignments were last
updated for OS/2 version 4 in OpenType 1.5. There are many additional ranges
supported in the current version of Unicode that are not supported by these fields
in the OS/2 table. See the 'dlng' and 'slng' tags in the 'meta' table for an alternate
mechanism to declare what scripts or languages a font can support or is designed
for.

Version
differences:

Different versions of the OS/2 table were created when different Unicode versions
were current, and the initial specification for a given version defined fewer bit
assignments than for later versions. Some applications might not support all
assignments for fonts that have earlier OS/2 versions.
All of the bit assignments listed above are valid for any version of the OS/2 table,
though OS/2 versions 1 and 2 were specified with some assignments that did not
correspond to well-defined Unicode ranges and that conflict with later assignments
— see the details below. If a font has a version 1 or version 2 OS/2 table with one
of these bits set, the obsolete assignment could be the intended interpretation.
Because these assignments do not correspond to well-defined ranges, however,
the implied character coverage is unclear.
Version 0: When version 0 was first specified, no bit assignments were defined.
Some applications could ignore these fields in a version 0 OS/2 table.
Version 1:
Version 1 was first specified concurrent with Unicode 1.1, and bit assignments were
defined for bits 0 to 69 only. With fonts that have a version 1 table, some
applications might recognize only bits 0 to 69.
Also, version 1 was specified with some bit assignments that did not correspond to
a well-defined Unicode range:
Bit 8: “Greek Symbols and Coptic” (bit 7 was specified as “Basic Greek”)
Bit 12: “Hebrew Extended” (bit 11 was specified as “Basic Hebrew”)
Bit 14: “Arabic Extended” (bit 13 was specified as “Basic Arabic”)
Bit 27: “Georgian Extended” (bit 26 was specified as “Basic Georgian”)
These assignments were discontinued as of version 2.

In addition, versions 1 and 2 were defined with bit 53 specified as “CJK
Miscellaneous”, which also does not correspond to any well-defined Unicode
range. This assignment was discontinued as of version 3.
Version 2:
Version 2 was defined in OpenType 1.1, which was concurrent with Unicode 2.1. At
that time, bit assignments were defined for bits 0 to 69 only. Bit assignments for
version 2 were updated in OpenType 1.3, adding assignments for bits 70 to 83
corresponding to new blocks assigned in Unicode 2.0 and Unicode 3.0. With fonts
that have a version 2 table, some applications might recognize only those bits
assigned in OpenType 1.2 or OpenType 1.3.
Also, the specification for version 2 continued to use a problematic assignment for
bit 53 — see details for version 1. This assignment was discontinued as of version
3.
Version 3: Version 3 was defined in OpenType 1.4 with assignments for bits 84 to
92 corresponding to additional ranges in Unicode 3.2. In addition, some alreadyassigned bits were extended to cover additional Unicode ranges for related
characters; see details in the table above.
Version 4: Version 4 was defined in OpenType 1.5 with assignments for bit 58 and
bits 93 to 122 corresponding to additional ranges in Unicode 5.1. Also, bits 8, 12,
14, 27 and 53 were re-assigned (see version 1 for previous assignments). In
addition, some already-assigned bits were extended to cover additional Unicode
ranges for related characters; see details in the table above.

achVendID
ﾉ

Expand table

Format:

Tag

Title:

Font Vendor Identification

Description:

The four character identifier for the vendor of the given typeface.

Comments:

This is not the royalty owner of the original artwork. This is the company
responsible for the marketing and distribution of the typeface that is being
classified. For example, there can be multiple vendors of ITC Zapf Dingbats, with
some vendors providing differentiating benefits in their fonts (more kern pairs,
unregularized data, hand hinted, etc.). This identifier will allow for the correct
vendor’s type to be used over another, possibly inferior, font file.
A registry of vendor IDs is maintained by Microsoft. Registered IDs must be unique
to a single vendor. Non-registered IDs may also be used, but are discouraged:
vendors are strongly encouraged to register an ID to ensure that there are no
conflicts between different vendors in use of a given ID, and that customers are

able to find vendor contact information for a given font. This field can also be left
blank (set to null, or a tag comprised of four space characters).
All vendor IDs use the Tag data type, which is equivalent to a four-character string
composed of a limited set of ASCII characters. For details regarding the Tag data
type, see Data Types. By convention, only registered tags should be comprised of
only uppercase letters (or space).
For a list of registered Vendor IDs, or for details on registering a vendor ID or
updating vendor information, see Registered typography vendors .

fsSelection
Expand table

ﾉ

Format:

uint16

Title:

Font selection flags.

Description:

Contains information concerning the nature of the font patterns, as follows:
ﾉ

Expand table

Bit
#

macStyle
bit

C definition

Description

0

bit 1

ITALIC

Font contains italic or oblique glyphs,
otherwise they are upright.

1

UNDERSCORE

Glyphs are underscored.

2

NEGATIVE

Glyphs have their foreground and
background reversed.

3

OUTLINED

Outline (hollow) glyphs, otherwise
they are solid.

4

STRIKEOUT

Glyphs are overstruck.

BOLD

Glyphs are emboldened.

6

REGULAR

Glyphs are in the standard
weight/style for the font.

7

USE_TYPO_METRICS

If set, it is strongly recommended that
applications use OS/2.sTypoAscender
- OS/2.sTypoDescender +

5

bit 0

OS/2.sTypoLineGap as the default line
spacing for this font.

8

WWS

The font has 'name' table strings
consistent with a weight/width/slope
family without requiring use of name
IDs 21 and 22. (See a more detailed
description below.)

Comments:

9

OBLIQUE

Font contains oblique glyphs.

10–
15

Reserved

Reserved; set to 0.

All undefined bits must be zero.
The fsSelection field was originally created for compatibility with the OS/2 platform.
Some style description bits, such as bit 0, are used by modern applications, while
other style description bits are not.
Bit 0: The setting of bits 0 must match the setting of bit 1 in the macStyle field of
the 'head' table.
Bits 1 – 4: Bits 1 – 4 are rarely used bits that indicate the font is primarily a
decorative or special purpose font.
Bit 5: The setting of bit 5 must match the settings of bit 0 in the macStyle field of
the 'head' table.
Bit 6: Bit 6 is not used in widely used in modern applications. If bit 6 is set, then bits
0 and 5 must be clear, else the behavior is undefined. Note that, if both bit 0 and
bit 5 are clear, that does not give any indication as to whether or not bit 6 will be
clear. For example, Arial Light is not the regular style of Arial and would have all
bits cleared. In extended font families, bit 6 does not need to be set for fonts other
than the regular style that, nonetheless, use "Regular" for name ID 2. (See Name
IDs for more information.)
Bit 7:
Bit 7 was defined in version 4 and is used in many modern applications. For new
fonts, vendors are encouraged to use a version 4 or later OS/2 table and to have bit
7 set.
If a font was created with an earlier version of the OS/2 table and is updated to the
current version of the OS/2 table, then setting bit 7 could create potential for
reflow of existing documents which use the fonts. To minimize such risk, the bit
would be set only if using the OS/2.usWin* metrics for line height would yield
significantly inferior results than using the OS/2.sTypo* values.
Bit 8:
If bit 8 is set, then 'name' table strings for family and subfamily are provided that
are consistent with a weight/width/slope (WWS) family model without requiring the
use of name IDs 21 or 22.

Bit 8 and name IDs 21 and 22 were introduced for use by applications that assume
a WWS family model, given that there exist fonts with style variants that do not fit
into one of the three attributes, weight, width or slope.
Many typographic families include faces that differ only in one or more of these
three attributes. In such cases, name IDs 1 and 2 or IDs 16 and 17 will not present
challenges for software that assumes a WWS model. But some typographic families
include faces that differ in some other attributes. For example, a family might
include variations for “handwriting”, “caption”, “display”, “optical size”, etc. In such
cases, a font could incorporate that attribute into a typographic subfamily name (ID
17 string), whereas applications that assume a WWS model would require that
attribute to be incorporated into a family name (ID 1 or ID 16).
IF a face differs within its family only in terms of weight, width or slope attributes,
then bit 8 should be set. This applies even if the face is part of a large family that
includes other faces distinguished by other attributes. Setting bit 8 serves as an
indicator to apps that assume the WWS model that name IDs 1 and 2 or IDs 16 and
17 are consistent with the WWS model and no further treatment is required,
including checking to see whether name IDs 21 and 22 are present. Hence, when
bit 8 is set, name IDs 21 and 22 are never required and should not be included.
If a face differs within its family from Regular by attributes other than weight, width
or slope, then bit 8 should *not* be set, and name IDs 21 and 22 should be
included. By having bit 8 not set, that serves as an indicator to apps that assume a
WWS model that they should look for name IDs 21 and 22, or that some other
treatment of names could be required.
The STAT table was introduced in a later version of OpenType, after bit 8 and name
IDs 21 and 22 were defined. The STAT table was introduced, in part, to solve the
same kind of requirement but in a more general way that could be useful for
applications assuming other family models. If a face has attributes other than
weight, width or slope and does not have name IDs 21 and 22, some applications
that assume a WWS model could be able to support that font using information in
the STAT table. However, even if a STAT table is present (as is required for variable
fonts), the recommendations above regarding bit 8 and name IDs 21 and 22 should
still be followed.
In this context, “typographic family” is the Microsoft Unicode string for name ID 16,
if present, else the Microsoft Unicode string for name ID 1; “weight” is
OS/2.usWeightClass; “width” is OS/2.usWidthClass; “slope” is OS/2.fsSelection bit 0
(ITALIC) and bit 9 (OBLIQUE).
Bit 9:
If bit 9 is set, then this font is to be considered an “oblique” style by processes
which make a distinction between oblique and italic styles, such as Cascading Style
Sheets font matching. For example, a font created by algorithmically slanting an
upright face will set this bit.
If a font has a version 4 or later OS/2 table and this bit is not set, then this font is

not to be considered an “oblique” style. For example, a font that has a classic italic
design will not set this bit.
This bit, unlike the ITALIC bit (bit 0), is not related to style-linking in applications
that assume a four-member font-family model comprised of regular, italic, bold
and bold italic. It may be set or unset independently of the ITALIC bit. In most
cases, if OBLIQUE is set, then ITALIC will also be set, though this is not required.
Bit 15: Bit 15 is permanently reserved. It has been used in some legacy
implementations and could result in special behavior in some implementations. Use
of this bit is deprecated.
Version
differences:

Versions 0 to 3: Only bit 0 (italic) to bit 6 (regular) are assigned. Bits 7 to 15 are
reserved and must be set to 0. Applications should ignore bits 7 to 15 in a font that
has a version 0 to version 3 OS/2 table.
Version 4 to 5: Bits 7 to 9 were defined in version 4 (OpenType 1.5). Bits 10 to 15
are reserved and must be set to 0. Applications should ignore bits 10 to 15 in a font
that has a version 4 or version 5 OS/2 table.

usFirstCharIndex
ﾉ

Expand table

Format:

uint16

Description:

The minimum Unicode index (character code) in this font, according to the 'cmap'
subtable for platform ID 3 and platform- specific encoding ID 0 or 1. For most fonts
supporting Win-ANSI or other character sets, this value would be 0x0020. This field
cannot represent supplementary character values (codepoints greater than 0xFFFF).
Fonts that support supplementary characters should set the value in this field to
0xFFFF if the minimum index value is a supplementary character.

usLastCharIndex
ﾉ

Expand table

Format:

uint16

Description:

The maximum Unicode index (character code) in this font, according to the 'cmap'
subtable for platform ID 3 and encoding ID 0 or 1. This value depends on which
character sets the font supports. This field cannot represent supplementary
character values (codepoints greater than 0xFFFF). Fonts that support
supplementary characters should set the value in this field to 0xFFFF.

sTypoAscender
ﾉ

Expand table

Format:

FWORD

Units:

Font design units

Description:

The typographic ascender for this font. This field should be combined with the
sTypoDescender and sTypoLineGap values to determine default line spacing.

This field is similar to the ascender field in the 'hhea' table as well as to the
usWinAscent field in this table. However, legacy platform implementations used
those fields with platform-specific behaviors. As a result, those fields are
constrained by backward-compatibility requirements, and they do not ensure
consistent layout across implementations. The sTypoAscender, sTypoDescender and
sTypoLineGap fields are intended to allow applications to lay out documents in a
typographically correct and portable fashion.
The USE_TYPO_METRICS flag (bit 7) of the fsSelection field is used to choose
between using sTypo* values or usWin* values for default line metrics. See
fsSelection for additional details.
It is not a general requirement that sTypoAscender - sTypoDescender be equal to
unitsPerEm. These values should be set to provide default line spacing appropriate
for the primary languages the font is designed to support.
For CJK (Chinese, Japanese, and Korean) fonts that are intended to be used for
vertical (as well as horizontal) layout, the required value for sTypoAscender is that
which describes the top of the ideographic em-box. For example, if the ideographic
em-box of the font extends from coordinates 0,-120 to 1000,880 (that is, a 1000 ×
1000 box set 120 design units below the Latin baseline), then the value of
sTypoAscender must be set to 880. Failing to adhere to these requirements will
result in incorrect vertical layout.
Also see the Recommendations Section for more on this field.

sTypoDescender
ﾉ

Expand table

Format:

FWORD

Units:

Font design units

Description:

The typographic descender for this font. This field should be combined with the
sTypoAscender and sTypoLineGap values to determine default line spacing.

This field is similar to the descender field in the 'hhea' table as well as to the
usWinDescent field in this table. However, legacy platform implementations used
those fields with platform-specific behaviors. As a result, those fields are
constrained by backward-compatibility requirements, and they do not ensure
consistent layout across implementations. The sTypoAscender, sTypoDescender and
sTypoLineGap fields are intended to allow applications to lay out documents in a
typographically correct and portable fashion.
The USE_TYPO_METRICS flag (bit 7) of the fsSelection field is used to choose
between using sTypo* values or usWin* values for default line metrics. See
fsSelection for additional details.
It is not a general requirement that sTypoAscender - sTypoDescender be equal to
unitsPerEm. These values should be set to provide default line spacing appropriate
for the primary languages the font is designed to support.
For CJK (Chinese, Japanese, and Korean) fonts that are intended to be used for
vertical (as well as horizontal) layout, the required value for sTypoDescender is that
which describes the bottom of the ideographic em-box. For example, if the
ideographic em-box of the font extends from coordinates 0,-120 to 1000,880 (that
is, a 1000 × 1000 box set 120 design units below the Latin baseline), then the value
of sTypoDescender must be set to -120. Failing to adhere to these requirements will
result in incorrect vertical layout.
Also see the Recommendations Section for more on this field.

sTypoLineGap
ﾉ

Expand table

Format:

FWORD

Units:

Font design units

Description:

The typographic line gap for this font. This field should be combined with the
sTypoAscender and sTypoDescender values to determine default line spacing.
This field is similar to the lineGap field in the 'hhea' table. However, legacy platform
implementations treat that field with platform-specific behaviors. As a result, that
field is constrained by backward-compatibility requirements, and does not ensure
consistent layout across implementations. The sTypoAscender, sTypoDescender and
sTypoLineGap fields are intended to allow applications to lay out documents in a
typographically correct and portable fashion.
The USE_TYPO_METRICS flag (bit 7) of the fsSelection field is used to choose
between using sTypo* values or usWin* values for default line metrics. See
fsSelection for additional details.

usWinAscent
ﾉ

Expand table

Format:

UFWORD

Units:

Font design units

Description:

The “Windows ascender” metric. This should be used to specify the height above
the baseline for a clipping region.
This is similar to the sTypoAscender field, and also to the ascender field in the
'hhea' table. There are important differences between these, however.
In the Windows GDI implementation, the usWinAscent and usWinDescent values
have been used to determine the size of the bitmap surface in the TrueType
rasterizer. Windows GDI will clip any portion of a TrueType glyph outline that
appears above the usWinAscent value. If any clipping is unacceptable, then the
value should be set greater than or equal to yMax.
Note: This pertains to the default position of glyphs, not their final position in
layout after data from the GPOS or 'kern' table has been applied. Also, this clipping
behavior interacts with the VDMX table: if a VDMX table is present and there is data
for the current device aspect ratio and rasterization size, then the VDMX data will
supersede the usWinAscent and usWinDescent values.
Some legacy applications use the usWinAscent and usWinDescent values to
determine default line spacing. This is strongly discouraged. The sTypo* fields
should be used for this purpose.
Note that some applications use either the usWin* values or the sTypo* values to
determine default line spacing, depending on whether the USE_TYPO_METRICS flag
(bit 7) of the fsSelection field is set. This could be useful to provide compatibility
with legacy documents using older fonts, while also providing better and moreportable layout using newer fonts. See fsSelection for additional details.
Applications that use the sTypo* fields for default line spacing can use the usWin*
values to determine the size of a clipping region. Some applications use a clipping
region for editing scenarios to determine what portion of the display surface to redraw when text is edited, or how large a selection rectangle to draw when text is
selected. This is an appropriate use for the usWin* values.
Early versions of this specification suggested that the usWinAscent value be
computed as the yMax for all characters in the Windows “ANSI” character set. For
new fonts, the value should be determined based on the primary languages the
font is designed to support, and should take into consideration additional height
that could be required to accommodate tall glyphs or mark positioning.

usWinDescent
ﾉ

Expand table

Format:

UFWORD

Units:

Font design units

Description:

The “Windows descender” metric. This should be used to specify the vertical extent
below the baseline for a clipping region.
This is similar to the sTypoDescender field, and also to the descender field in the
'hhea' table. There are important differences between these, however. Some of
these differences are described below. In addition, the usWinDescent value treats
distances below the baseline as positive values; thus, usWinDescent is usually a
positive value, while sTypoDescender and hhea.descender are usually negative.
In the Windows GDI implementation, the usWinDescent and usWinAscent values
have been used to determine the size of the bitmap surface in the TrueType
rasterizer. Windows GDI will clip any portion of a TrueType glyph outline that
appears below (-1 × usWinDescent). If any clipping is unacceptable, then the value
should be set greater than or equal to (-yMin).
Note: This pertains to the default position of glyphs, not their final position in
layout after data from the GPOS or 'kern' table has been applied. Also, this clipping
behavior interacts with the VDMX table: if a VDMX table is present and there is data
for the current device aspect ratio and rasterization size, then the VDMX data will
supersede the usWinAscent and usWinDescent values.
Some legacy applications use the usWinAscent and usWinDescent values to
determine default line spacing. This is strongly discouraged. The sTypo* fields
should be used for this purpose.
Note that some applications use either the usWin* values or the sTypo* values to
determine default line spacing, depending on whether the USE_TYPO_METRICS flag
(bit 7) of the fsSelection field is set. This could be useful to provide compatibility
with legacy documents using older fonts, while also providing better and moreportable layout using newer fonts. See fsSelection for additional details.
Applications that use the sTypo* fields for default line spacing can use the usWin*
values to determine the size of a clipping region. Some applications use a clipping
region for editing scenarios to determine what portion of the display surface to redraw when text is edited, or how large a selection rectangle to draw when text is
selected. This is an appropriate use for the usWin* values.
Early versions of this specification suggested that the usWinDescent value be
computed as -yMin for all characters in the Windows “ANSI” character set. For new
fonts, the value should be determined based on the primary languages the font is
designed to support, and should take into consideration additional vertical extent

that could be required to accommodate glyphs with low descenders or mark
positioning.

ulCodePageRange*
ulCodePageRange1 (bits 0 – 31)
ulCodePageRange2 (bits 32 – 63)

ﾉ

Expand table

Format:

uint32[2] (64 bits total)

Title:

Code Page Character Range

Description:

This field is used to specify the code pages encompassed by the font file in the
'cmap' subtable for platform 3, encoding ID 1 (Windows platform, Unicode BMP).
If the font file is encoding ID 0, then the Symbol Character Set bit should be set.
If a given bit is set (1), then the code page is considered functional. If the bit is
clear (0) then the code page is not considered functional. Each of the bits is
treated as an independent flag and the bits can be set in any combination. The
determination of “functional” is left up to the font designer, although character set
selection should attempt to be functional by code pages if at all possible.
Symbol character sets have a special meaning. If the symbol bit (31) is set, and the
font file contains a 'cmap' subtable for platform of 3 and encoding ID of 1, then all
of the characters in the Unicode range 0xF000 - 0xF0FF (inclusive) will be used to
enumerate the symbol character set. If the bit is not set, any characters present in
that range will not be enumerated as a symbol character set.
All reserved fields must be zero. Each uint32 is in Big-Endian form.
ﾉ

Bit

Code Page

Description

0

1252

Latin 1

1

1250

Latin 2: Eastern Europe

2

1251

Cyrillic

3

1253

Greek

4

1254

Turkish

5

1255

Hebrew

Expand table

6

1256

Arabic

7

1257

Windows Baltic

8

1258

Vietnamese

9 – 15

Reserved for Alternate ANSI

16

874

Thai

17

932

JIS/Japan

18

936

Chinese: Simplified chars—PRC and Singapore

19

949

Korean Wansung

20

950

Chinese: Traditional chars—Taiwan and Hong Kong SAR

21

1361

Korean Johab

22 – 28

Reserved for Alternate ANSI or OEM

29

Macintosh Character Set (US Roman)

30

OEM Character Set

31

Symbol Character Set

32 – 47

Reserved for OEM

48

869

IBM Greek

49

866

MS-DOS Russian

50

865

MS-DOS Nordic

51

864

Arabic

52

863

MS-DOS Canadian French

53

862

Hebrew

54

861

MS-DOS Icelandic

55

860

MS-DOS Portuguese

56

857

IBM Turkish

57

855

IBM Cyrillic; primarily Russian

58

852

Latin 2

59

775

MS-DOS Baltic

Version
differences:

60

737

Greek; former 437 G

61

708

Arabic; ASMO 708

62

850

WE/Latin 1

63

437

US

Version 0: These fields were not defined in version 0. If the size of a version 0 OS/2
table extends beyond the usWinDescent field, additional data beyond the
usWinDescent field should be ignored.
Version 1: Bit 8 was not assigned in version 1. All other currently assigned bits
were defined in version 1.
Version 2 and later: All currently assigned bits were defined in version 2.

sxHeight
ﾉ

Expand table

Format:

FWORD

Units:

Font design units

Description:

This metric specifies the distance between the baseline and the approximate
height of non-ascending lowercase letters measured in font design units. This
value would normally be specified by a type designer but in situations where that
is not possible, for example when a legacy font is being converted, the value may
be set equal to the top of the unscaled and unhinted glyph bounding box of the
glyph encoded at U+0078 (LATIN SMALL LETTER X). If no glyph is encoded in this
position the field should be set to 0.
This metric, if specified, can be used in font substitution: the xHeight value of one
font can be scaled to approximate the apparent size of another.

Version
differences:

Version 0, version 1: This field was not defined in version 0 or version 1. If the size
of a version 0 OS/2 table extends beyond the usWinDescent field, or if the size of
a version 1 OS/2 table extends beyond the code page range fields, this additional
data should be ignored.
Version 2 and later: This field was defined in version 2 of the OS/2 table.

sCapHeight
ﾉ

Expand table

Format:

FWORD

Units:

Font design units

Description:

This metric specifies the distance between the baseline and the approximate
height of uppercase letters measured in font design units. This value would
normally be specified by a type designer but in situations where that is not
possible, for example when a legacy font is being converted, the value may be set
equal to the top of the unscaled and unhinted glyph bounding box of the glyph
encoded at U+0048 (LATIN CAPITAL LETTER H). If no glyph is encoded in this
position the field should be set to 0.
This metric, if specified, can be used in systems that specify type size by capital
height measured in millimeters. It can also be used as an alignment metric; the top
of a drop capital, for instance, can be aligned to the sCapHeight metric of the first
line of text.

Version
differences:

Version 0, version 1: This field was not defined in version 0 or version 1. If the size
of a version 0 OS/2 table extends beyond the usWinDescent field, or if the size of
a version 1 OS/2 table extends beyond the code page range fields, this additional
data should be ignored.
Version 2 and later: This field was defined in version 2 of the OS/2 table.

usDefaultChar
ﾉ

Expand table

Format:

uint16

Description:

This is the Unicode code point, in UTF-16 encoding, of a character that can be
used for a default glyph if a requested character is not supported in the font. If the
value of this field is zero, glyph ID 0 is to be used for the default character. This
field cannot represent supplementary-plane character values (code points greater
than 0xFFFF), and so applications are strongly discouraged from using this field.

Version
differences:

Version 0, version 1: This field was not defined in version 0 or version 1. If the size
of a version 0 OS/2 table extends beyond the usWinDescent field, or if the size of
a version 1 OS/2 table extends beyond the code page range fields, this additional
data should be ignored.
Version 2 and later: This field was defined in version 2 of the OS/2 table.

usBreakChar
ﾉ

Expand table

Format:

uint16

Description:

This is the Unicode code point, in UTF-16 encoding, of a character that can be
used as a default break character. The break character is used to separate words
and justify text. Most fonts specify U+0020 SPACE as the break character. This field
cannot represent supplementary-plane character values (code points greater than
0xFFFF), and so applications are strongly discouraged from using this field.

Version

Version 0, version 1: This field was not defined in version 0 or version 1. If the size

differences:

of a version 0 OS/2 table extends beyond the usWinDescent field, or if the size of
a version 1 OS/2 table extends beyond the code page range fields, this additional
data should be ignored.
Version 2 and later: This field was defined in version 2 of the OS/2 table.

usMaxContext
ﾉ

Expand table

Format:

uint16

Description:

The maximum length of a target glyph context for any feature in this font. For
example, a font which has only a pair kerning feature should set this field to 2. If
the font also has a ligature feature in which the glyph sequence “f f i” is
substituted by the ligature “ffi”, then this field should be set to 3. This field could
be useful to sophisticated line-breaking engines in determining how far they
should look ahead to test whether something could change that affects the line
breaking. For chaining contextual lookups, the length of the string (covered glyph)
+ (input sequence) + (lookahead sequence) should be considered.

Version
differences:

Version 0, version 1: This field was not defined in version 0 or version 1. If the size
of a version 0 OS/2 table extends beyond the usWinDescent field, or if the size of a
version 1 OS/2 table extends beyond the code page range fields, this additional
data should be ignored.
Version 2 and later: This field was defined in version 2 of the OS/2 table.

usLowerOpticalPointSize
ﾉ

Format:

uint16

Units:

TWIPs

Description:

This field is used for fonts with multiple optical styles.

Expand table

This value is the lower value of the size range for which this font has been
designed. The units for this field are TWIPs (one-twentieth of a point, or 1440 per
inch). The value is inclusive — meaning that that font was designed to work best at
this point size through, but not including, the point size indicated by
usUpperOpticalPointSize. When used with other optical-size-variant fonts within a
typographic family that also specify usLowerOpticalPointSize and
usUpperOpticalPointSize values, it would be expected that another font has the
usUpperOpticalPointSize field set to the same value as the value in this field, unless
this font is designed for the lowest size range among the fonts in the family. The
smallest font in an optical-size set should set this value to 0. When working across
multiple optical-size-variant fonts within a typographic family, there should be no
intentional gaps or overlaps in the ranges.
The usLowerOpticalPointSize value must be less than usUpperOpticalPointSize. The
maximum valid value is 0xFFFE.
For fonts that were not designed for multiple optical-size variants, this field should
be set to 0 (zero), and usUpperOpticalPointSize should be set to 0xFFFF.
Note: Use of this field has been superseded by the STAT table. See
Recommendations Section for more information.
Version
differences:

Versions 0 – 4: This field was not defined in versions 0 – 4. If the size of an OS/2
table extends beyond the last field defined for the given version, this additional
data should be ignored.
Version 5: This field was defined in version 5 of the OS/2 table.

usUpperOpticalPointSize
ﾉ

Format:

uint16

Units:

TWIPs

Description:

This field is used for fonts with multiple optical styles.

Expand table

This value is the upper value of the size range for which this font has been
designed. The units for this field are TWIPs (one-twentieth of a point, or 1440 per
inch). The value is exclusive — meaning that that font was designed to work best
below this point size down to the usLowerOpticalPointSize threshold. When used
with other optical-size-variant fonts within a typographic family that also specify
usLowerOpticalPointSize and usUpperOpticalPointSize values, it would be expected
that another font has the usLowerOpticalPointSize field set to the same value as
the value in this field, unless this font is designed for the highest size range among
the fonts in the family. The largest font in an optical-size set should set this value
to 0xFFFF, which is interpreted as infinity. When working across multiple optical-

size-variant fonts within a typographic family, there should be no intentional gaps
or overlaps left in the ranges.
The usUpperOpticalPointSize value must be greater than usLowerOpticalPointSize.
The minimum valid value for this field is 2 (two). The largest possible inclusive
point size represented by this field is 3276.65 points; any higher values would be
represented as infinity.
For fonts that were not designed for multiple optical-size variants, this field should
be set to 0xFFFF, and usLowerOpticalPointSize should be set to 0 (zero).
Note: Use of this field has been superseded by the STAT table. See
Recommendations Section for more information.
Version

Versions 0 – 4: This field was not defined in versions 0 – 4. If the size of an OS/2

differences:

table extends beyond the last field defined for the given version, this additional
data should be ignored.
Version 5: This field was defined in version 5 of the OS/2 table.

OS/2 Table and OpenType Font Variations
In variable fonts, default line metrics should always be set using the sTypoAscender,
sTypoDescender and sTypoLineGap values, and the USE_TYPO_METRICS flag in the
fsSelection field should be set. The ascender, descender and lineGap fields in the 'hhea'
table should be set to the same values as sTypoAscender, sTypoDescender and
sTypoLineGap. The usWinAscent and usWinDescent fields should be used to specify a
recommended clipping rectangle.
In a variable font, various font-metric values within the OS/2 table might need to be
adjusted for different variation instances. Variation data for OS/2 entries can be
provided in the metrics variations (MVAR) table. Different OS/2 entries are associated
with particular variation data in the MVAR table using value tags, as follows:
ﾉ

OS/2 entry

Tag

sCapHeight

'cpht'

sTypoAscender

'hasc'

sTypoDescender

'hdsc'

sTypoLineGap

'hlgp'

Expand table

sxHeight

'xhgt'

usWinAscent

'hcla'

usWinDescent

'hcld'

yStrikeoutPosition

'stro'

yStrikeoutSize

'strs'

ySubscriptXOffset

'sbxo'

ySubScriptXSize

'sbxs'

ySubscriptYOffset

'sbyo'

ySubscriptYSize

'sbys'

ySuperscriptXOffset

'spxo'

ySuperscriptXSize

'spxs'

ySuperscriptYOffset

'spyo'

ySuperscriptYSize

'spys'

Note: The usWeightClass and usWidthClass values are not adjusted by variation data
since these correspond to 'wght' and 'wdth' variation axes that can be used to
define a font’s variation space. Appropriate usWeightClass and usWidthClass values
for a variation instance can be derived from 'wght' and 'wdth' user coordinates that
are used to select a particular variation instance. For 'wdth' values greater than 200,
the usWidthClass value is clamped to 9. See the discussion of the 'wght' and 'wdth'
axes in the OpenType Design-Variation Axis Tag Registry for details on the
relationship between these OS/2 fields and the corresponding design axes.
Note: The usLowerOpticalPointSize and usUpperOpticalPointSize values are not
adjusted by variation data. These values (now superseded by the STAT table) are
used to indicate a range of sizes for which a given font has been designed. It is
assumed that variation that targets different sizes will be implemented using the
'opsz' variation axis. If a variable font supports 'opsz' as an axis of variation, then the
usLowerOpticalPointSize and usUpperOpticalPointSize fields can be set to the same
values as the minValue and maxValue fields for the 'opsz' axis in the 'fvar' table.
To have variable line metrics in a variable font, the 'hasc', 'hdsc' and 'hlgp' value tags
should be used in the MVAR table to vary the ascender, descender and line gap values
from defaults specified in the sTypoAscender, sTypoDescender and sTypoLineGap fields.

The 'hcla' and 'hcld' value tags can be used in addition to vary the size of a clipping
region from the default specified in the winAscent and winDescent fields. Other metrics
can be varied using value tags listed above.
For general information on OpenType Font Variations, see the chapter, OpenType Font
Variations Overview.

IBM Font Family Classifications
Article • 05/29/2024

The section defines the family class and subclass values that may be used in the
sFamilyClass field of a font’s OS/2 table. A font designer or supplier can assign these
values in a font to provide a classification of the font family design. The registered
values documented here were originally defined by IBM.
These values classify a font design as to its appearance, but do not identify the specific
font family, typeface variation, designer, supplier, size, or metric table differences. It
should be noted that some font designs can be classified equally well into more than
class or subclass. Such designs should be matched to a classification for which
substitution of another font design from the same class or subclass would generally
result in a similar appearance of the presented document.

Class ID = 0 No Classification
This class ID is used to indicate that the associated font has no design classification or
that the design classification is not of significance to the creator or user of the font
resource.

Class ID = 1 Oldstyle Serifs
This style is generally based upon the Latin printing style of the 15th to 17th century,
with a mild diagonal contrast in stroke emphasis (lighter in upper left to lower right,
heavier in upper right to lower left) and bracketed serifs. This IBM Class reflects the ISO
Serif Class, Oldstyle and Legibility Subclasses as documented in the ISO/IEC 9541-1
Amendment 1 standard.

Subclass ID = 0: No Classification
This subclass ID is used to indicate that the associated font has no design subclassification or that the design subclassification is not of significance to the creator or
user of the font resource.

Subclass ID = 1: IBM Rounded Legibility
This style is generally characterized by a large x-height, with short ascenders and
descenders. Specifically, it is distinguished by a medium resolution, hand tuned, bitmap

rendition of the more general rounded legibility subclass. This IBM Subclass is not
specifically reflected in the ISO/IEC 9541-1 Amendment 1 standard.

Subclass ID = 2: Garalde
This style is generally characterized by a medium x-height, with tall ascenders. An
example of this font style is the ITC Garamond family. This IBM Subclass reflects the ISO
Serif Class, Oldstyle Subclass, and Garalde Specific Group as documented in the ISO/IEC
9541-1 Amendment 1 standard.

Subclass ID = 3: Venetian
This style is generally characterized by a medium x-height, with a relatively monotone
appearance and sweeping tails based on the designs of the early Venetian printers. This
IBM Subclass is not specifically reflected in the ISO/IEC 9541-1 Amendment 1 standard.

Subclass ID = 4: Modified Venetian
This style is generally characterized by a large x-height, with a relatively monotone
appearance and sweeping tails based on the designs of the early Venetian printers. An
example of this font style is the Allied Linotype Palatino family. This IBM Subclass
reflects the ISO Serif Class, Transitional Subclass, and Modified Specific Group as
documented in the ISO/IEC 9541-1 Amendment 1 standard.

Subclass ID = 5: Dutch Modern
This style is generally characterized by a large x-height, with wedge shaped serifs and a
circular appearance to the bowls similar to the Dutch Traditional Subclass below, but
with lighter strokes. This IBM Subclass is not specifically reflected in the ISO/IEC 9541-1
Amendment 1 standard.

Subclass ID = 6: Dutch Traditional
This style is generally characterized by a large x-height, with wedge shaped serifs and a
circular appearance of the bowls. An example of this font style is the IBM Press Roman
family. This IBM Subclass reflects the ISO Serif Class and Legibility Subclass as
documented in the ISO/IEC 9541-1 Amendment 1 standard.

Subclass ID = 7: Contemporary

This style is generally characterized by a small x-height, with light strokes and serifs. An
example of this font style is the University family. This IBM Subclass reflects the ISO Serif
Class and Contemporary Subclass as documented in the ISO/IEC 9541-1 Amendment 1
standard.

Subclass ID = 8: Calligraphic
This style is generally characterized by the fine handwriting style of calligraphy, while
retaining the characteristic Oldstyle appearance. This IBM Subclass is not reflected in the
ISO/IEC 9541-1 Amendment 1 standard.

Subclass ID = 9-14: (reserved for future use)
These subclass IDs are reserved for future assignment, and shall not be used without
formal assignment by IBM.

Subclass ID = 15: Miscellaneous
This subclass ID is used for miscellaneous designs of the associated design class that are
not covered by another Subclass.

Class ID = 2 Transitional Serifs
This style is generally based upon the Latin printing style of the 18th to 19th century,
with a pronounced vertical contrast in stroke emphasis (vertical strokes being heavier
than the horizontal strokes) and bracketed serifs. This IBM Class reflects the ISO Serif
Class, Transitional Subclass as documented in the ISO/IEC 9541-1 Amendment 1
standard.

Subclass ID = 0: No Classification
This subclass ID is used to indicate that the associated font has no design subclassification or that the design sub-classification is not of significance to the creator or
user of the font resource.

Subclass ID = 1: Direct Line
This style is generally characterized by a medium x-height, with fine serifs, noticeable
contrast, and capital letters of approximately the same width. An example of this font
style is the Monotype Baskerville family. This IBM Subclass reflects the ISO Serif Class,

Transitional Subclass, and Direct Line Specific Group as documented in the ISO/IEC
9541-1 Amendment 1 standard.

Subclass ID = 2: Script
This style is generally characterized by a handwritten script appearance while retaining
the Transitional Direct Line style. An example of this font style is the IBM Nasseem
(Arabic) family. This IBM Subclass is not specifically reflected in the ISO/IEC 9541-1
Amendment 1 standard, though the ISO Serif Class, Transitional Subclass, and Direct
Line Specific Group would be a close approximation.

Subclass ID = 3-14: (reserved for future use)
These subclass IDs are reserved for future assignment, and shall not be used without
formal assignment by IBM.

Subclass ID = 15: Miscellaneous
This subclass ID is used for miscellaneous designs of the associated design class that are
not covered by another Subclass.

Class ID = 3 Modern Serifs
This style is generally based upon the Latin printing style of the 20th century, with an
extreme contrast between the thick and thin portion of the strokes. This IBM Class
reflects the ISO Serif Class, Modern Subclass as documented in the ISO/IEC 9541-1
Amendment 1 standard.

Subclass ID = 0: No Classification
This subclass ID is used to indicate that the associated font has no design subclassification or that the design sub-classification is not of significance to the creator or
user of the font resource.

Subclass ID = 1: Italian
This style is generally characterized by a medium x-height, with thin hairline serifs. An
example of this font style is the Monotype Bodoni family. This IBM Subclass reflects the
ISO Serif Class, Modern Subclass, and Italian Specific Group as documented in the
ISO/IEC 9541-1 Amendment 1 standard.

Subclass ID = 2: Script
This style is generally characterized by a handwritten script appearance while retaining
the Modern Italian style. An example of this font style is the IBM Narkissim (Hebrew)
family. This IBM Subclass is not specifically reflected in the ISO/IEC 9541-1 Amendment
1 standard, though the ISO Serif Class, Modern Subclass, and Italian Specific Group
would be a close approximation.

Subclass ID = 3-14: (reserved for future use)
These subclass IDs are reserved for future assignment, and shall not be used without
formal assignment by IBM.

Subclass ID = 15: Miscellaneous
This subclass ID is used for miscellaneous designs of the associated design class that are
not covered by another Subclass.

Class ID = 4 Clarendon Serifs
This style is a variation of the Oldstyle Serifs and the Transitional Serifs, with a mild
vertical stroke contrast and bracketed serifs. This IBM Class reflects the ISO Serif Class,
Square Serif Subclass as documented in the ISO/IEC 9541-1 Amendment 1 standard.

Subclass ID = 0: No Classification
This subclass ID is used to indicate that the associated font has no design subclassification or that the design sub-classification is not of significance to the creator or
user of the font resource.

Subclass ID = 1: Clarendon
This style is generally characterized by a large x-height, with serifs and strokes of equal
weight. An example of this font style is the Allied Linotype Clarendon family. This IBM
Subclass reflects the ISO Serif Class, Square Serif Subclass, and Clarendon Specific Group
as documented in the ISO/IEC 9541-1 Amendment 1 standard.

Subclass ID = 2: Modern

This style is generally characterized by a large x-height, with serifs of a lighter weight
than the strokes and the strokes of a lighter weight than the Traditional. An example of
this font style is the Monotype Century Schoolbook family. This IBM Subclass reflects the
ISO Serif Class, Square Serif Subclass, and Clarendon Specific Group as documented in
the ISO/IEC 9541-1 Amendment 1 standard.

Subclass ID = 3: Traditional
This style is generally characterized by a large x-height, with serifs of a lighter weight
than the strokes. An example of this font style is the Monotype Century family.This IBM
Subclass reflects the ISO Serif Class, Square Serif Subclass, and Clarendon Specific Group
as documented in the ISO/IEC 9541-1 Amendment 1 standard.

Subclass ID = 4: Newspaper
This style is generally characterized by a large x-height, with a simpler style of design
and serifs of a lighter weight than the strokes. An example of this font style is the Allied
Linotype Excelsior Family. This IBM Subclass reflects the ISO Serif Class, Square Serif
Subclass, and Clarendon Specific Group as documented in the ISO/IEC 9541-1
Amendment 1 standard.

Subclass ID = 5: Stub Serif
This style is generally characterized by a large x-height, with short stub serifs and
relatively bold stems. An example of this font style is the Cheltenham Family. This IBM
Subclass reflects the ISO Serif Class, Square Serif Subclass, and Short Specific Group as
documented in the ISO/IEC 9541-1 Amendment 1 standard.

Subclass ID = 6: Monotone
This style is generally characterized by a large x-height, with monotone stems. An
example of this font style is the ITC Korinna Family. This IBM Subclass is not specifically
reflected in the ISO/IEC 9541-1 Amendment 1 standard.

Subclass ID = 7: Typewriter
This style is generally characterized by a large x-height, with moderate stroke thickness
characteristic of a typewriter. An example of this font style is the Prestige Elite Family.
This IBM Subclass reflects the ISO Serif Class, Square Serif Subclass, and Typewriter
Specific Group as documented in the ISO/IEC 9541-1 Amendment 1 standard.

Subclass ID = 8-14: (reserved for future use)
These subclass IDs are reserved for future assignment, and shall not be used without
formal assignment by IBM.

Subclass ID = 15: Miscellaneous
This subclass ID is used for miscellaneous designs of the associated design class that are
not covered by another Subclass.

Class ID = 5 Slab Serifs
This style is characterized by serifs with a square transition between the strokes and the
serifs (no brackets). This IBM Class reflects the ISO Serif Class, Square Serif Subclass
(except the Clarendon Specific Group) as documented in the ISO/IEC 9541-1
Amendment 1 standard.

Subclass ID = 0: No Classification
This subclass ID is used to indicate that the associated font has no design subclassification or that the design sub-classification is not of significance to the creator or
user of the font resource.

Subclass ID = 1: Monotone
This style is generally characterized by a large x-height, with serifs and strokes of equal
weight. An example of this font style is the ITC Lubalin Family. This IBM Subclass reflects
the ISO Serif Class, Square Serif Subclass, and Monotone Specific Group as documented
in the ISO/IEC 9541-1 Amendment 1 standard.

Subclass ID = 2: Humanist
This style is generally characterized by a medium x-height, with serifs of lighter weight
that the strokes. An example of this font style is the Candida Family. This IBM Subclass
reflects the ISO Serif Class, Square Serif Subclass, and Monotone Specific Group as
documented in the ISO/IEC 9541-1 Amendment 1 standard.

Subclass ID = 3: Geometric

This style is generally characterized by a large x-height, with serifs and strokes of equal
weight and a geometric (circles and lines) design. An example of this font style is the
Monotype Rockwell Family. This IBM Subclass reflects the ISO Serif Class, Square Serif
Subclass, and Monotone Specific Group as documented in the ISO/IEC 9541-1
Amendment 1 standard.

Subclass ID = 4: Swiss
This style is generally characterized by a large x-height, with serifs and strokes of equal
weight and an emphasis on the white space of the characters. An example of this font
style is the Allied Linotype Serifa Family. This IBM Subclass reflects the ISO Serif Class,
Square Serif Subclass, and Monotone Specific Group as documented in the ISO/IEC
9541-1 Amendment 1 standard.

Subclass ID = 5: Typewriter
This style is generally characterized by a large x-height, with serifs and strokes of equal
but moderate thickness, and a geometric design. An example of this font style is the IBM
Courier Family. This IBM Subclass is not specifically reflected in the ISO/IEC 9541-1
Amendment 1 standard, though the ISO Serif Class, Square Serif Subclass, and
Monotone Specific Group would be a close approximation.

Subclass ID = 6-14: (reserved for future use)
These subclass IDs are reserved for future assignment, and shall not be used without
formal assignment by IBM.

Subclass ID = 15: Miscellaneous
This subclass ID is used for miscellaneous designs of the associated design class that are
not covered by another Subclass.

Class ID = 6 (reserved for future use)
This class ID is reserved for future assignment, and shall not be used without formal
assignment by IBM.

Class ID = 7 Freeform Serifs

This style includes serifs, but which expresses a design freedom that does not generally
fit within the other serif design classifications. This IBM Class reflects the remaining ISO
Serif Class subclasses as documented in the ISO/IEC 9541-1 Amendment 1 standard.

Subclass ID = 0: No Classification
This subclass ID is used to indicate that the associated font has no design subclassification or that the design sub-classification is not of significance to the creator or
user of the font resource.

Subclass ID = 1: Modern
This style is generally characterized by a medium x-height, with light contrast in the
strokes and a round full design. An example of this font style is the ITC Souvenir Family.
This IBM Subclass is not reflected in the ISO/IEC 9541-1 Amendment 1 standard.

Subclass ID = 2-14: (reserved for future use)
These subclass IDs are reserved for future assignment, and shall not be used without
formal assignment by IBM.

Subclass ID = 15: Miscellaneous
This subclass ID is used for miscellaneous designs of the associated design class that are
not covered by another Subclass.

Class ID = 8 Sans Serif
This style includes most basic letter forms (excluding Scripts and Ornamentals) that do
not have serifs on the strokes. This IBM Class reflects the ISO Sans Serif Class as
documented in the ISO/IEC 9541-1 Amendment 1 standard.

Subclass ID = 0: No Classification
This subclass ID is used to indicate that the associated font has no design subclassification or that the design sub-classification is not of significance to the creator or
user of the font resource.

Subclass ID = 1: IBM Neo-grotesque Gothic

This style is generally characterized by a large x-height, with uniform stroke width and a
simple one-story design distinguished by a medium resolution, hand tuned, bitmap
rendition of the more general Neo-grotesque Gothic Subclass. An example of this font
style is the IBM Sonoran Sans Serif family. This IBM Subclass is not specifically reflected
in the ISO/IEC 9541-1 Amendment 1 standard.

Subclass ID = 2: Humanist
This style is generally characterized by a medium x-height, with light contrast in the
strokes and a classic Roman letterform. An example of this font style is the Allied
Linotype Optima family. This IBM Subclass reflects the ISO Sans Serif Class, Humanist
Subclass as documented in the ISO/IEC 9541-1 Amendment 1 standard.

Subclass ID = 3: Low-x Round Geometric
This style is generally characterized by a low x-height, with monotone stroke weight and
a round geometric design. An example of this font style is the Fundicion Tipograficia
Neufville Futura family. This IBM Subclass reflects the ISO Sans Serif Class, Geometric
Subclass, Round Specific Group as documented in the ISO/IEC 9541-1 Amendment 1
standard.

Subclass ID = 4: High-x Round Geometric
This style is generally characterized by a high x-height, with uniform stroke weight and a
round geometric design. An example of this font style is the ITC Avant Garde Gothic
family. This IBM Subclass reflects the ISO Sans Serif Class, Geometric Subclass, Round
Specific Group as documented in the ISO/IEC 9541-1 Amendment 1 standard.

Subclass ID = 5: Neo-grotesque Gothic
This style is generally characterized by a high x-height, with uniform stroke width and a
simple one-story design. An example of this font style is the Allied Linotype Helvetica
family. This IBM Subclass reflects the ISO Sans Serif Class, Gothic Subclass, Neogrotesque Specific Group as documented in the ISO/IEC 9541-1 Amendment 1 standard.

Subclass ID = 6: Modified Neo-grotesque Gothic
This style is similar to the Neo-grotesque Gothic style, with design variations to the G
and Q. An example of this font style is the Allied Linotype Univers family. This IBM
Subclass is not specifically reflected in the ISO/IEC 9541-1 Amendment 1 standard,

though the ISO Sans Serif Class, Gothic Subclass, Neo-grotesque Specific Group would
be a close approximation.

Subclass ID = 7-8: (reserved for future use)
These subclass IDs are reserved for future assignment, and shall not be used without
formal assignment by IBM.

Subclass ID = 9: Typewriter Gothic
This style is similar to the Neo-grotesque Gothic style, with moderate stroke thickness
characteristic of a typewriter. An example of this font style is the IBM Letter Gothic
family. This IBM Subclass reflects the ISO Sans Serif Class, Gothic Subclass, Typewriter
Specific Group as documented in the ISO/IEC 9541-1 Amendment 1 standard.

Subclass ID = 10: Matrix
This style is generally a simple design characteristic of a dot matrix printer. An example
of this font style is the IBM Matrix Gothic family. This IBM Subclass is not reflected in the
ISO/IEC 9541-1 Amendment 1 standard.

Subclass ID = 11-14: (reserved for future use)
These subclass IDs are reserved for future assignment, and shall not be used without
formal assignment by IBM.

Subclass ID = 15: Miscellaneous
This subclass ID is used for miscellaneous designs of the associated design class that are
not covered by another Subclass.

Class ID = 9 Ornamentals
This style includes highly decorated or stylized character shapes that are typically used
in headlines. This IBM Class reflects the ISO Ornamental Class and the ISO Blackletter
Class as documented in the ISO/IEC 9541-1 Amendment 1 standard.

Subclass ID = 0: No Classification

This subclass ID is used to indicate that the associated font has no design subclassification or that the design sub-classification is not of significance to the creator or
user of the font resource.

Subclass ID = 1: Engraver
This style is characterized by fine lines or lines engraved on the stems. An example of
this font style is the Copperplate family. This IBM Subclass reflects the ISO Ornamental
Class and Inline Subclass, or the Serif Class and Engraving Subclass as documented in
the ISO/IEC 9541-1 Amendment 1 standard.

Subclass ID = 2: Black Letter
This style is generally based upon the printing style of the German monasteries and
printers of the 12th to 15th centuries. An example of this font style is the Old English
family. This IBM Subclass reflects the ISO Blackletters Class as documented in the
ISO/IEC 9541-1 Amendment 1 standard.

Subclass ID = 3: Decorative
This style is characterized by ornamental designs (typically from nature, such as leaves,
flowers, animals, etc.) incorporated into the stems and strokes of the characters. An
example of this font style is the Saphire family. This IBM Subclass reflects the ISO
Ornamental Class and Decorative Subclass as documented in the ISO/IEC 9541-1
Amendment 1 standard.

Subclass ID = 4: Three Dimensional
This style is characterized by a three-dimensional (raised) appearance of the characters
created by shading or geometric effects. An example of this font style is the Thorne
Shaded family. This IBM Subclass reflects the ISO Ornamental Class and Three
Dimensional Subclass as documented in the ISO/IEC 9541-1 Amendment 1 standard.

Subclass ID = 5-14: (reserved for future use)
These subclass IDs are reserved for future assignment, and shall not be used without
formal assignment by IBM.

Subclass ID = 15: Miscellaneous

This subclass ID is used for miscellaneous designs of the associated design class that are
not covered by another Subclass.

Class ID = 10 Scripts
This style includes those typefaces that are designed to simulate handwriting. This IBM
Class reflects the ISO Script Class and Uncial Class as documented in the ISO/IEC 9541-1
Amendment 1 standard.

Subclass ID = 0: No Classification
This subclass ID is used to indicate that the associated font has no design subclassification or that the design sub-classification is not of significance to the creator or
user of the font resource.

Subclass ID = 1: Uncial
This style is characterized by unjoined (nonconnecting) characters that are generally
based on the handwriting style of Europe in the 6th to 9th centuries. An example of this
font style is the Libra family. This IBM Subclass reflects the ISO Uncial Class as
documented in the ISO/IEC 9541-1 Amendment 1 standard.

Subclass ID = 2: Brush Joined
This style is characterized by joined (connecting) characters that have the appearance of
being painted with a brush, with moderate contrast between thick and thin strokes. An
example of this font style is the Mistral family. This IBM Subclass reflects the ISO Script
Class, Joined Subclass, and Informal Specific Group as documented in the ISO/IEC 95411 Amendment 1 standard.

Subclass ID = 3: Formal Joined
This style is characterized by joined (connecting) characters that have a printed (or
drawn with a stiff brush) appearance with extreme contrast between the thick and thin
strokes. An example of this font style is the Coronet family. This IBM Subclass reflects
the ISO Script Class, Joined Subclass, and Formal Specific Group as documented in the
ISO/IEC 9541-1 Amendment 1 standard.

Subclass ID = 4: Monotone Joined

This style is characterized by joined (connecting) characters that have a uniform
appearance with little or no contrast in the strokes. An example of this font style is the
Kaufmann family. This IBM Subclass reflects the ISO Script Class, Joined Subclass, and
Monotone Specific Group as documented in the ISO/IEC 9541-1 Amendment 1
standard.

Subclass ID = 5: Calligraphic
This style is characterized by beautifully hand drawn, unjoined (non-connecting)
characters that have an appearance of being drawn with a broad edge pen. An example
of this font style is the Thompson Quillscript family. This IBM Subclass reflects the ISO
Script Class, Unjoined Subclass, and Calligraphic Specific Group as documented in the
ISO/IEC 9541-1 Amendment 1 standard.

Subclass ID = 6: Brush Unjoined
This style is characterized by unjoined (non-connecting) characters that have the
appearance of being painted with a brush, with moderate contrast between thick and
thin strokes. An example of this font style is the Saltino family. This IBM Subclass reflects
the ISO Script Class, Unjoined Subclass, and Brush Specific Group as documented in the
ISO/IEC 9541-1 Amendment 1 standard.

Subclass ID = 7: Formal Unjoined
This style is characterized by unjoined (non-connecting) characters that have a printed
(or drawn with a stiff brush) appearance with extreme contrast between the thick and
thin strokes. An example of this font style is the Virtuosa family. This IBM Subclass
reflects the ISO Script Class, Unjoined Subclass, and Formal Specific Group as
documented in the ISO/IEC 9541-1 Amendment 1 standard.

Subclass ID = 8: Monotone Unjoined
This style is characterized by unjoined (non-connecting) characters that have a uniform
appearance with little or no contrast in the strokes. An example of this font style is the
Gilles Gothic family. This IBM Subclass reflects the ISO Script Class, Unjoined Subclass,
and Monotone Specific Group as documented in the ISO/IEC 9541-1 Amendment 1
standard.

Subclass ID = 9-14: (reserved for future use)

These subclass IDs are reserved for future assignment, and shall not be used without
formal assignment by IBM.

Subclass ID = 15: Miscellaneous
This subclass ID is used for miscellaneous designs of the associated design class that are
not covered by another Subclass.

Class ID = 11 (reserved for future use)
This class ID is reserved for future assignment, and shall not be used without formal
assignment by IBM.

Class ID = 12 Symbolic
This style is generally design independent, making it suitable for Pi and special
characters (icons, dingbats, technical symbols, etc.) that may be used equally well with
any font. This IBM Class reflects various ISO Specific Groups, as noted below and
documented in the ISO/IEC 9541-1 Amendment 1 standard.

Subclass ID = 0: No Classification
This subclass ID is used to indicate that the associated font has no design subclassification or that the design sub-classification is not of significance to the creator or
user of the font resource.

Subclass ID = 1-2: (reserved for future use)
These subclass IDs are reserved for future assignment, and shall not be used without
formal assignment by IBM.

Subclass ID = 3: Mixed Serif
This style is characterized by either both or a combination of serif and sans serif designs
on those characters of the font for which design is important (e.g., superscript and
subscript characters, numbers, copyright or trademark symbols, etc.). An example of this
font style is found in the IBM Symbol family. This IBM Subclass is not reflected in the
ISO/IEC 9541-1 Amendment 1 standard.

Subclass ID = 4-5: (reserved for future use)
These subclass IDs are reserved for future assignment, and shall not be used without
formal assignment by IBM.

Subclass ID = 6: Oldstyle Serif
This style is characterized by a Oldstyle Serif IBM Class design on those characters of the
font for which design is important (e.g., superscript and subscript characters, numbers,
copyright or trademark symbols, etc.). An example of this font style is found in the IBM
Sonoran Pi Serif family. This IBM Subclass is not directly reflected in the ISO/IEC 9541-1
Amendment 1 standard, though it is indirectly by the ISO Serif Class and Legibility
Subclass (implies that all characters of the font exhibit the design appearance, while only
a subset of the characters actually exhibit the design).

Subclass ID = 7: Neo-grotesque Sans Serif
This style is characterized by a Neo-grotesque Sans Serif IBM Font Class and Subclass
design on those characters of the font for which design is important (e.g., superscript
and subscript characters, numbers, copyright or trademark symbols, etc.). An example of
this font style is found in the IBM Sonoran Pi Sans Serif family. This IBM Subclass is not
directly reflected in the ISO/IEC 9541-1 Amendment 1 standard, though it is indirectly by
the ISO Sans Serif Class and Gothic Subclass (implies that all characters of the font
exhibit the design appearance, while only a subset of the characters actually exhibit the
design).

Subclass ID = 8-14: (reserved for future use)
These subclass IDs are reserved for future assignment, and shall not be used without
formal assignment by IBM.

Subclass ID = 15: Miscellaneous
This subclass ID is used for miscellaneous designs of the associated design class that are
not covered by another Subclass.

Class ID = 13 Reserved
Class ID = 14 Reserved

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

PCLT — PCL 5 Table
Article • 05/31/2024

The PCLT table was introduced for compatibility with Hewlett-Packard PCL 5 printer
language. Use of the PCLT table in OpenType fonts is strongly discouraged. More
information on fields in this table can be found in PCL 5 Printer Language Technical
Reference Manual, available from Hewlett-Packard Boise Printer Division.
The format for the table is:
ﾉ

Type

Name

uint16

majorVersion

uint16

minorVersion

uint32

fontNumber

uint16

pitch

uint16

xHeight

uint16

style

uint16

typeFamily

uint16

capHeight

uint16

symbolSet

int8

typeface[16]

int8

characterComplement[8]

int8

fileName[6]

int8

strokeWeight

int8

widthType

uint8

serifStyle

uint8

(reserved—set to 0)

majorVersion and minorVersion

Expand table

The current PCLT table version is 1.0.

fontNumber
This 32-bit number is segmented in two parts. The most significant bit indicates native
versus converted format. Only font vendors should create fonts with this bit zeroed. The
7 next most significant bits are assigned by Hewlett-Packard Boise Printer Division to
major font vendors. The least significant 24 bits are assigned by the vendor. Font
vendors should attempt to ensure that each of their fonts is marked with unique values.
ﾉ

Code

Vendor

A

Adobe Systems

B

Bitstream Inc.

C

Agfa Corporation

H

Bigelow & Holmes

L

Linotype Company

M

Monotype Typography Ltd.

Expand table

pitch
The width of the space in font design units, as defined by the unitsPerEm field of the
'head' table. Monospace fonts derive the width of all characters from this field.

xHeight
The height of the optical line describing the height of the lowercase x in font design
units. This might not be the same as the measured height of the lowercase x.

style
The most significant 6 bits are reserved. The 5 next most significant bits encode
structure. The next 3 most significant bits encode appearance width. The 2 least
significant bits encode posture.
Structure (bits 5 – 9)

ﾉ

Expand table

0

Solid (normal, black)

1

Outline (hollow)

2

Inline (incised, engraved)

3

Contour, edged (antique, distressed)

4

Solid with shadow

5

Outline with shadow

6

Inline with shadow

7

Contour, or edged, with shadow

8

Pattern filled

9

Pattern filled #1 (when more than one pattern)

10

Pattern filled #2 (when more than two patterns)

11

Pattern filled #3 (when more than three patterns)

12

Pattern filled with shadow

13

Pattern filled with shadow #1 (when more than one pattern or shadow)

14

Pattern filled with shadow #2 (when more than two patterns or shadows)

15

Pattern filled with shadow #3 (when more than three patterns or shadows)

16

Inverse

17

Inverse with border

18 – 31

(reserved)

Width (bits 2 – 4)
ﾉ

0

normal

1

condensed

2

compressed, extra condensed

3

extra compressed

Expand table

4

ultra compressed

5

(reserved)

6

expanded, extended

7

extra expanded, extra extended

Posture (bits 0 – 1)
ﾉ

0

upright

1

oblique, italic

2

alternate italic (backslanted, cursive, swash)

3

(reserved)

Expand table

typeFamily
The 4 most significant bits are font vendor codes. The 12 least significant bits are
typeface family codes. Both are assigned by HP Boise Division.
Vendor Codes (bits 12 – 15)
ﾉ

0

(reserved)

1

Agfa Corporation

2

Bitstream Inc.

3

Linotype Company

4

Monotype Typography Ltd.

5

Adobe Systems

6

font repackagers

7

vendors of unique typefaces

8 – 15

(reserved)

Expand table

capHeight
The height of the optical line describing the top of the uppercase H in font design units.
This might not be the same as the measured height of the uppercase H.

symbolSet
The most significant 11 bits are the value of the symbol set “number” field. The value of
the least significant 5 bits, when added to 64, is the ASCII value of the symbol set “ID”
field. Symbol set values are assigned by HP Boise Division. Unbound fonts, or
“typefaces” should have a symbol set value of 0. See the PCL 5 Printer Language
Technical Reference Manual or the PCL 5 Comparison Guide for the most recent
published list of codes.
Examples
ﾉ

Expand table

PCL

decimal

Windows 3.1 “ANSI”

19U

629

Windows 3.0 “ANSI”

9U

309

Adobe “Symbol”

19M

621

Macintosh

12J

394

PostScript ISO Latin 1

11J

362

PostScript Std. Encoding

10J

330

Code Page 1004

9J

298

DeskTop

7J

234

typeface
This 16-byte ASCII string appears in the “font print” of PCL printers. Care should be
taken to ensure that the base string for all typefaces of a family are consistent, and that
the designators for bold, italic, etc. are standardized.
Example

ﾉ

Expand table

Times New
Times New

Bd

Times New

It

Times New

BdIt

Courier New
Courier New

Bd

Courier New

It

Courier New

BdIt

characterComplement
This 8-byte field identifies the symbol collections provided by the font, each bit
identifies a symbol collection and is independently interpreted. Symbol set bound fonts
should have all bits in this field set (except bit 0).
Examples

DOS/PCL Complement

0xFFFFFFFF003FFFFE

Windows 3.1 “ANSI”

0xFFFFFFFF37FFFFFE

Macintosh

0xFFFFFFFF36FFFFFE

ISO 8859-1 Latin 1

0xFFFFFFFF3BFFFFFE

ISO 8859-1,2,9 Latin 1,2,5

0xFFFFFFFF0BFFFFFE

ﾉ

Expand table

ﾉ

Expand table

The character collections identified by each bit are as follows:

31

ASCII (supports several standard interpretations)

30

Latin 1 extensions

29

Latin 2 extensions

28

Latin 5 extensions

27

Desktop Publishing Extensions

26

Accent Extensions (East and West Europe)

25

PCL Extensions

24

Macintosh Extensions

23

PostScript Extensions

22

Code Page Extensions

The character complement field also indicates the index mechanism used with an
unbound font. Bit 0 must always be cleared when the font elements are provided in
Unicode order.

fileName
This 6-byte field is composed of 3 parts. The first 3 bytes are an industry standard
typeface family string. The fourth byte is a treatment character, such as R, B, I. The last
two characters are either zeroes for an unbound font or a two-character mnemonic for a
symbol set if symbol set found.
Examples
ﾉ

TNRR00

Times New (text weight, upright)

TNRI00

Times New Italic

TNRB00

Times New Bold

TNRJ00

Times New Bold Italic

COUR00

Courier

COUI00

Courier Italic

COUB00

Courier Bold

COUJ00

Courier Bold Italic

Treatment flags

Expand table

ﾉ

R

Text, normal, book, etc.

I

Italic, oblique, slanted, etc.

B

Bold

J

Bold Italic, Bold Oblique

D

Demibold

E

Demibold Italic, Demibold Oblique

K

Black

G

Black Italic, Black Oblique

L

Light

P

Light Italic, Light Oblique

C

Condensed

A

Condensed Italic, Condensed Oblique

F

Bold Condensed

H

Bold Condensed Italic, Bold Condensed Oblique

S

Semibold (lighter than demibold)

T

Semibold Italic, Semibold Oblique

Expand table

Other treatment flags are assigned over time.

strokeWeight
This int8 field contains the PCL stroke weight value. Only values in the range -7 to 7 are
valid:
ﾉ

-7

Ultra Thin

-6

Extra Thin

-5

Thin

-4

Extra Light

Expand table

-3

Light

-2

Demilight

-1

Semilight

0

Book, text, regular, etc.

1

Semibold (Medium, when darker than Book)

2

Demibold

3

Bold

4

Extra Bold

5

Black

6

Extra Black

7

Ultra Black, or Ultra

Type designers often use interesting names for weights or combinations of weights and
styles, such as Heavy, Compact, Inserat, Bold No. 2, etc. PCL stroke weights are assigned
on the basis of the entire family and use of the faces. Typically, display faces don’t have
a “text” weight assignment.

widthType
This int8 field contains the PCL appearance width value. The values are not directly
related to those in the appearance with field of the style word above. Only values in the
range -5 to 5 are valid.
ﾉ

-5

Ultra Compressed

-4

Extra Compressed

-3

Compressed, or Extra Condensed

-2

Condensed

0

Normal

2

Expanded

3

Extra Expanded

Expand table

serifStyle
This uint8 field contains the PCL serif style value. The most significant 2 bits of this byte
specify the serif/sans or contrast/monoline characteristics of the typeface.
Bottom 6 bit values:

0

Sans Serif Square

1

Sans Serif Round

2

Serif Line

3

Serif Triangle

4

Serif Swath

5

Serif Block

6

Serif Bracket

7

Rounded Bracket

8

Flair Serif, Modified Sans

9

Script Nonconnecting

10

Script Joining

11

Script Calligraphic

12

Script Broken Letter

ﾉ

Expand table

ﾉ

Expand table

Top 2 bit values:

0

(reserved)

1

Sans Serif/Monoline

2

Serif/Contrasting

3

(reserved)

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

post — PostScript Table
Article • 05/31/2024

Overview
This table contains additional information needed to use OpenType™ fonts on
PostScript printers. This includes certain data found in the FontInfo dictionary of Type 1
fonts and the PostScript names of all the glyphs. For more information about PostScript
names, see the Adobe Glyph List Specification

.

Versions 1.0, 2.0, and 2.5 of the 'post' table are used only in fonts with TrueType or CFF
version 2 outline data. Fonts with TrueType or CFF version 2 data may also use a version
3.0 'post' table. OpenType fonts with CFF version 1 outline data must only use a version
3.0 'post' table.

Header
The table begins as follows:
ﾉ

Type

Name

Description

Version16Dot16

version

0x00010000 for version 1.0
0x00020000 for version 2.0
0x00025000 for version 2.5 (deprecated)

Expand table

0x00030000 for version 3.0
Fixed

italicAngle

Italic angle in counter-clockwise degrees from the
vertical. Zero for upright text, negative for text that leans
to the right (forward).

FWORD

underlinePosition

Suggested y-coordinate of the top of the underline.

FWORD

underlineThickness

Suggested values for the underline thickness. In general,
the underline thickness should match the thickness of the
underscore character (U+005F LOW LINE), and should
also match the strikeout thickness, which is specified in
the OS/2 table.

uint32

isFixedPitch

Set to 0 if the font is proportionally spaced, non-zero if
the font is not proportionally spaced (i.e. monospaced).

Type

Name

Description

uint32

minMemType42

Minimum memory usage when an OpenType font is
downloaded.

uint32

maxMemType42

Maximum memory usage when an OpenType font is
downloaded.

uint32

minMemType1

Minimum memory usage when an OpenType font is
downloaded as a Type 1 font.

uint32

maxMemType1

Maximum memory usage when an OpenType font is
downloaded as a Type 1 font.

Note: The PostScript language defines the UnderLinePosition FontInfo key as
specifying the distance from the baseline to the center of the underline. This
definition is not used in the 'post' table.
The last four entries in the table are present because PostScript drivers can do better
memory management if the virtual memory (VM) requirements of a downloadable
OpenType font are known before the font is downloaded. This information should be
supplied if known. If it is not known, set the value to zero. The driver will still work but
will be less efficient.
Maximum memory usage is minimum memory usage plus maximum runtime memory
use. Maximum runtime memory use depends on the maximum band size of any bitmap
potentially rasterized by the font scaler. Runtime memory usage could be calculated by
rendering characters at different point sizes and comparing memory use.
If the version is 1.0 or 3.0, the table ends here. The additional entries for versions 2.0 and
2.5 are shown below. A version 4.0 is defined by Apple for use in their platforms (see
Apple’s specification

), but is not supported in OpenType.

Version 1.0
This version is used in order to supply PostScript glyph names when the font file
contains exactly the 258 glyphs in the standard Macintosh TrueType font file (see 'post'
Format 1 in Apple’s specification

for a list of the 258 Macintosh glyph names), and the

font does not otherwise supply glyph names. As a result, the glyph names are taken
from the system with no storage required by the font.

Version 2.0

Version 2.0 is used for fonts that use glyph names that are not in the set of Macintosh
glyph names. A given font may map some of its glyphs to the standard Macintosh glyph
names, and some to its own custom names. A version 2.0 'post' table can be used in
fonts with TrueType or CFF version 2 outlines.
For version 2.0, the following fields are appended at the end of the header:
ﾉ

Expand table

Type

Name

Description

uint16

numGlyphs

Number of glyphs (this should be the same as
numGlyphs in 'maxp' table).

uint16

glyphNameIndex[numGlyphs]

Array of indices into the string data. See below for
details.

uint8

stringData[variable]

Storage for the string data.

This font file contains glyphs not in the standard Macintosh set, or the ordering of the
glyphs in the font file differs from the standard Macintosh set. The glyphNameIndex
array maps glyph IDs to a glyph name index. If the glyph name index is between 0 and
257 (inclusive), treat that index as a glyph index in the Macintosh standard glyph set and
use the Macintosh glyph name. If the glyph name index is between 258 and 65535, then
subtract 258 and use that to index into the list of Pascal strings at the end of the table.
For example, suppose glyphNameIndex[302] (for glyph ID 302) is 217: since that glyph
name index is less than 258, the glyph name is the Macintosh glyph name for glyph ID
217. Suppose glyphNameIndex[408] is 262: subtracting 258, the difference is 4; the
glyph name for that glyph is the fifth string (index 4, base 0) in the string data.
The string data extends from the last version 2.0 header field to the end of the table.
Strings are in Pascal string format, meaning that the first byte of a given string is a
length: the number of characters in that string. The length byte is not included; for
example, a length byte of 8 indicates that the 8 bytes following the length byte
comprise the string character data. To find the string for a given glyph name index, start
with the first length byte, advance that number of bytes to find the length byte for the
next string entry, and so on.
Glyph name strings are encoded in ASCII. Valid characters are limited to A–Z, a–z, 0–9, “.”
(FULL STOP), and “_” (LOW LINE). Names must be no longer than 63 characters; some
older implementations can assume a length limit of 31 characters.
If you do not want to associate a PostScript name with a particular glyph, use 0, which
refers to the name .notdef, as the glyphNameIndex entry for that glyph ID.

Version 2.5
Version 2.5 of the 'post' table is deprecated.
This version provides a space-saving table for fonts containing TrueType outlines which
contain a pure subset of, or a simple reordering of, the standard Macintosh glyph set.
ﾉ

Expand table

Type

Name

Description

uint16

numGlyphs

Number of glyphs.

int8

offset[numGlyphs]

Difference between the glyph index and the standard order of the
glyph.

This version has been used in some legacy fonts with TrueType outlines that contain only
glyphs in the standard Macintosh glyph set but that have those glyphs arranged in a
non-standard order or that are missing some glyphs. The table contains one byte for
each glyph in the font file. The byte is treated as a signed offset that maps the glyph
index used in the font into the standard glyph index. For example, assuming that the
font contains the three glyphs A, B, and C which are the 37th, 38th, and 39th glyphs in
the standard ordering, the 'post' table would contain the bytes +36, +36, +36.

Version 3.0
This version makes it possible to create a font that is not burdened with a large set of
glyph names. A version 3.0 'post' table can be used by OpenType fonts with TrueType or
CFF (version 1 or 2) data.
This version specifies that no PostScript name information is provided for the glyphs in
this font file. The printing behavior of this version on PostScript printers is unspecified,
except that it should not result in a fatal or unrecoverable error. Some drivers may print
nothing; other drivers may attempt to print using a default naming scheme.
Note: Windows makes use of the italic angle value in the 'post' table but does not
actually require any glyph names to be stored as Pascal strings.

'post' Table and OpenType Font Variations
In a variable font, various font-metric values within the 'post' table may need to be
adjusted for different variation instances. Variation data for 'post' entries can be

provided in the metrics variations (MVAR) table. Different 'post' entries are associated
with particular variation data in the MVAR table using value tags, as follows:
ﾉ

'post' entry

Tag

underlinePosition

'undo'

underlineThickness

'unds'

Expand table

Note: The italicAngle value is not adjusted by variation data since this corresponds
to the 'slnt' variation axis that can be used to define a font’s variation space.
Appropriate post.italicAngle values for a variation instance can be derived from the
'slnt' user coordinates that are used to select a particular variation instance. See the
discussion of the 'slnt' axis in the OpenType Design-Variation Axis Tag Registry for
details on the relationship between italicAngle and the 'slnt' axis.
For general information on OpenType Font Variations, see the chapter, OpenType Font
Variations Overview.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

prep — Control Value Program
Article • 05/31/2024

The Control Value (CV) Program consists of a set of TrueType instructions that can be
used to make font-wide changes in the Control Value Table. Any instruction is valid in
the CV Program but since no glyph is associated with it, instructions intended to move
points within a particular glyph outline have no effect in the CV Program.
The CV Program can potentially be executed before any glyph is processed, as
determined by the rasterizer implementation. The CV Program will always be executed
before the first glyph is processed after a change in font, point size, global
transformation matrix, or other values that can be obtained from the GET INFOrmation
instruction. The CV Program is not re-executed for components in a composite glyph,
including cases in which a composite glyph description applies a transform to a
component.
Note: The tag 'prep' is anachronistic: in earlier specifications, the table was referred
to as the Pre Program table.

ﾉ

Expand table

Type

Description

uint8[
n]

Set of instructions executed whenever point size or font or transformation change. n is
the number of uint8 items that fit in the size of the table.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

sbix — Standard Bitmap Graphics Table
Article • 05/30/2024

This table provides access to bitmap data in a standard graphics format, such as PNG,
JPEG or TIFF.
The 'sbix' table has functionality somewhat similar to the EBDT table in that both provide
bitmap data for glyph presentation. They are different in three important respects,
however. First, whereas the EBDT table supports only black/white or grayscale bitmaps,
the 'sbix' table supports color bitmaps. Secondly, whereas the EBDT table uses formats
specific to the OpenType specification, the 'sbix' table uses standard bitmap graphics
formats that are in common use. Thirdly, whereas the EBDT table must be used in
conjunction with other tables (EBLC and EBSC) for processing the bitmap data, the 'sbix'
table contains complete data required for processing bitmaps.
A font that includes an 'sbix' table may also include outline glyph data in a 'glyf' or 'CFF '
table. An 'sbix' table can provide bitmap data for all glyph IDs, or for only a subset of
glyph IDs. A font can also include different bitmap data for different sizes (“strikes”), and
the glyph coverage for one size can be different from that for another size.

Header
The 'sbix' table begins with a header:
sbixHeader
ﾉ

Type

Name

Description

uint16

version

Table version number — set to 1

uint16

flags

Bit 0: Set to 1.

Expand table

Bit 1: Draw outlines.
Bits 2 to 15: reserved (set to 0).
uint32

numStrikes

Number of bitmap strikes.

Offset32

strikeOffsets[numStrikes]

Offsets from the beginning of the 'sbix' table to data for
each individual bitmap strike.

For historical reasons, bit 0 of the flags field should always be set to 1.

If bit 1 of the flags field is clear, then the application is instructed to draw only the
bitmaps for each glyph supported in the 'sbix' table. If bit 1 is set, then the application is
instructed to draw the bitmap and the outline, in that order (that is, with the outline
overlaid on top of the bitmap). If the 'sbix' table does not contain bitmap data for a
glyph, then the outline is always drawn, regardless of the state of bit 1.
Note: Application support for bit 1 of the flags field is optional. To ensure the best
compatibility, set this bit to 0.

Strikes
Each strike includes a header and the glyph bitmap data. The header has the following
format:
ﾉ

Expand table

Type

Name

Description

uint16

ppem

The PPEM size for which this strike was designed.

uint16

ppi

The device pixel density (in PPI) for which this strike
was designed. (E.g., 96 PPI, 192 PPI.)

Offset32

glyphDataOffsets[numGlyphs+1]

Offset from the beginning of the strike data header
to bitmap data for an individual glyph ID.

The glyphDataOffset array includes offsets for every glyph ID, plus one extra. The
number of glyphs is determined from the 'maxp' table. The length of the bitmap data
for each glyph is variable, and can be determined from the difference between two
consecutive offsets. Hence, the length of data for glyph N is glyphDataOffset[N+1] glyphDataOffset[N]. If this is zero, there is no bitmap data for that glyph in this strike.
There is one extra offset in the array in order to provide the length of data for the last
glyph.
Note: The length of data for non-printing glyphs, such as space, should always be
zero.
A strike does not need to include data for every glyph, and does not need to include
data for the same set of glyphs as other strikes. If the application is using bitmap data to
draw text and there is bitmap data for a glyph in any strike, then the glyph must be
drawn using a bitmap from some strike. If the exact size is not available,
implementations may choose a bitmap based on the closest available larger size, or the
closest available integer-multiple larger size, or on some other basis. The only cases in

which a glyph is not drawn using a bitmap are if the application has not requested that
text be drawn using bitmap data or if there is no bitmap data for the glyph in any strike.
Each strike targets a specific PPEM size and device pixel density (PPI). Thus, a font can
contain two strikes for the same PPEM but different pixel densities, or two strikes for the
same pixel density but different PPEMs. Note that some platforms might not support
selection of strikes for particular pixel densities.

Glyph data
The data for each glyph includes a header and the actual, embedded graphic data, with
the following format:
ﾉ

Expand table

Type

Name

Description

int16

originOffsetX

The horizontal (x-axis) position of the left edge of the bitmap graphic in
relation to the glyph design space origin.

int16

originOffsetY

The vertical (y-axis) position of the bottom edge of the bitmap graphic in
relation to the glyph design space origin.

Tag

graphicType

Indicates the format of the embedded graphic data: one of 'jpg ', 'png ' or
'tiff', or the special format 'dupe'.

uint8

data[]

The actual embedded graphic data. The total length is inferred from
sequential entries in the glyphDataOffsets array and the fixed size (8 bytes)
of the preceding fields.

The originOffsetX and originOffsetY values give the placement of the bitmap graphic in
relation to the standard coordinate system of the glyph design space. For example, if
originOffsetX equals 20, the left edge of the bitmap is placed 20 units to the right of the
origin; if originOffsetY equals -30, then the bottom edge of the graphic is 30 units below
the origin.
When placing the graphic within the line of text, the placement depends upon whether
there are contours in the 'glyf' table for the current glyph ID:
If there is no glyph contour, the glyph design space origin for the graphic is placed
at the starting drawing position for this glyph. The lsb value for the current glyph
ID from the 'hmtx' table has no effect.
If there is a glyph contour, the glyph design space origin for the graphic is placed
at the lower left corner of the glyph bounding box (xMin, yMin).

The graphicType field indicates the format of the embedded graphic data. Three
standard formats are supported: JPEG, PNG and TIFF; these are indicated using tag
values 'jpg ', 'png ' and 'tiff', respectively.
The special graphicType of 'dupe' indicates that the data field contains a uint16, bigendian glyph ID. The bitmap data for the indicated glyph must be used for the current
glyph.
Note: Apple’s specification for TrueType fonts allows for a graphicType tag value of
'pdf ' or 'mask'. These values are not supported in the OpenType specification,
however.

Table dependencies
The glyph count is derived from the 'maxp' table. Advance and side-bearing glyph
metrics are stored in the 'hmtx' table for horizontal layout, and the 'vmtx' table for
vertical layout.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

STAT — Style Attributes Table
Article • 05/30/2024

The style attributes table describes design attributes that distinguish font-style variants
within a font family. It also provides associations between those attributes and name
elements that may be used to present font options within application user interfaces.
This information is especially important for variable fonts, but also relevant for nonvariable fonts.

Introduction
A font family is a set of font faces with key aspects of design that are common to all of
the fonts in the family, and that differentiate that family from other font families. The
fonts within a family also differ from one another in particular ways: in stroke
thicknesses, in contrast, etc.; or combinations of such differences. In this way, the fonts
within a family are style variants of the family design.
A given family will have a particular set of attribute types by which the member fonts
differ: the axes of variation. These may be implemented as dynamic variations in a
variable font; or they may be implemented in the form of discrete, static instance fonts.
For example, weight is a variable axis in the Skia variable font, but is also reflected as an
axis of design variation in the Arial family with static instances that include “Arial
Regular” and “Arial Bold”.
The STAT table provides richer information about the axes of variation and individual
styles within a family, as well as relationships between the styles. This information may
be used for different purposes, including:
It provides a way to accommodate rich typographic families with many styles in
legacy applications that use a more limited understanding of font families. This is
especially relevant for variable fonts.
By providing more information about styles within a family, it can support alternate
designs for font-selection user interfaces that may be useful with rich typographic
families.
By providing more information about relationships between styles within a family,
it can support application logic for selection of styles in particular application
conditions.
Note that, in regard to the first purpose of bridging between different notions of what is
included in a font family, this has been handled in the past using separate
family/subfamily name pairs in the 'name' table: name IDs 1 and 2 versus name IDs 16

and 17 versus name IDs 21 and 22. The STAT table provides a way to bridge between
different family models without proliferation of additional family/subfamily pairs in the
'name' table.
The information in the STAT table can characterize a font in relation to the entire family
to which it belongs, not just the font in isolation. For example, the face name “Arial
Bold” reflects that the Arial family includes weight as an axis of design variation, but not
that the family also includes an italic axis of design variation. The STAT table provides a
way to indicate in the Arial Bold font that the family includes an italic axis variation, and
that this font has a particular value—non-italic—in regard to that axis.
A style attributes table is required in all variable fonts. For a general overview of
OpenType Font Variations, see the chapter, OpenType Font Variations Overview.
The style attributes table is also recommended for all new, non-variable fonts, especially
if fonts have style attributes in axes other than weight, width, or slope.
The information provided in the STAT table includes string labels for specific style
attributes. For example, “Bold” and “Condensed” as individual style attribute labels
within a “Condensed Bold” font. These may be used in user interfaces but are not
intended to supersede subfamily names provided in the 'name' table or in the 'fvar'
table of variable fonts.

Alternate Font Family Models
From a design perspective, a typographically rich font family can potentially include a
large number of style variants involving many axes of design variation. Some variable
fonts, for example, have a dozen or more axes. Modern applications should be designed
to accommodate families with such variety.
Many applications, however, are constrained by legacy assumptions regarding the faces
or axes of design variation that can be included within a font family. Some applications
use a font family model that allows only weight, width or slope (italic/oblique/slant) as
design axes (a “WWS” model). Some applications use an even more limited model that
allows for only regular, bold, italic, or bold italic fonts within a family (the “R/B/I/BI”
model).
In applications that use a limited font family model, any style distinctions within a font’s
typographic family that do not fit within the application’s family model must be treated
as a separate family. For example, if an application uses the R/B/I/BI model, the Calibri
Light font must be treated as the “Regular” style in a “Calibri Light” family. Thus, the

typographic family and subfamily names need to be projected into the legacy font
family model with alternate family and subfamily names.
In non-variable fonts, alternate family and subfamily names are accommodated using
different name ID pairs in the 'name' table:
Name IDs 16 (Typographic Family) and 17 (Typographic Subfamily) support an
unrestricted family model.
Name IDs 1 (Font Family) and 2 (Font Subfamily) support the R/B/I/BI family model.
Name IDs 21 (WWS Family) and 22 (WWS Subfamily) support the WWS family
model.
So, for example, the Calibri Light font includes “Calibri Light” as name ID 1 (family
name), and “Regular” as name ID 2 (subfamily name).
In variable fonts, however, this is not possible. The font includes strings for name IDs 16
and 17, with the latter used for the default instance; and the 'fvar' table provides
alternate subfamily strings for named instances that are the equivalents to name ID 17
for each named instance. For legacy font family models, however, the 'fvar' table does
not provide named instance strings for name IDs 1 and 2, or for name IDs 21 and 22.
Even if a variable font only has a single axis, such as weight, instance names such as
“Light” or “Extrabold” must be handled in older applications by some means other than
alternate name IDs.
The STAT table accommodates this through axis value tables. An axis value table can
provide a string label for a specific axis value on any axis that is relevant for the font or
font family. (For special cases, an axis value table can also provide a label for a
combination of values from a set of relevant axes.) These labels, together with the
typographic family name (name ID 16), can be used to compose alternate names
dynamically to fit the requirements of different font family models.
For example, consider the Sitka font family, and the Sitka Display Bold font. The family
has optical size and weight (and also italic) axes of design variation. The optical size axis
is not supported in either the WWS or the R/B/I/BI family models. The Sitka Display Bold
font can include axis value tables that provide the label “Display” for that value on the
optical size axis, the label “Bold” for that value on the weight axis. An application can use
these to dynamically compose an alternate family name “Sitka Display” and alternate
subfamily name “Bold” to fit the requirements of these alternate font family models.
In a similar way, a variable font with any number of variation axes can provide a
complete set of labels for the axis values that pertain to the font’s named instances.
Using these, a compatibility layer can project names for any of the named instances into

a legacy font family model, allowing all of the variable font’s named instances to work in
older applications.
The STAT table also provides additional information regarding the axes of design
variation. This includes an axis ordering value that can be used to influence the relative
ordering of axis value labels when multiple labels need to be combined in a dynamically
generated name. See Axis Records for more information.
Note: When generating family and subfamily names for compatibility with the R/B/I/BI
family model, then any subfamily name elements that are not “Regular”, “Bold”, “Italic”
or “Oblique” will be moved into the family name. For example, given a family name
“Selawik” and a subfamily name “Condensed Bold”, this will be transformed into the
R/B/I/BI model as family name “Selawik Condensed” and subfamily name “Bold”.
Similarly, when names are generated for compatibility with the WWS family model, any
subfamily name elements that do not represent a weight value, a width value, or italic or
oblique will be moved into family names. For this reason, it is recommended that width,
weight and italic/oblique labels always be placed last in a subfamily name, to minimize
differences in how names will appear in different applications that use different family
models.

Style Attributes Header
The style attributes table, version 1.2, is organized as follows:
Style attributes header:
ﾉ

Expand table

Type

Name

Description

uint16

majorVersion

Major version number of the style attributes table — set to
1.

uint16

minorVersion

Minor version number of the style attributes table — set to
2.

uint16

designAxisSize

The size in bytes of each axis record.

uint16

designAxisCount

The number of axis records. In a font with an 'fvar' table,
this value must be greater than or equal to the axisCount
value in the 'fvar' table. In all fonts, must be greater than
zero if axisValueCount is greater than zero.

Offset32

designAxesOffset

Offset in bytes from the beginning of the STAT table to the
start of the design axes array. If designAxisCount is zero, set

to zero; if designAxisCount is greater than zero, must be
greater than zero.
uint16

axisValueCount

The number of axis value tables.

Offset32

offsetToAxisValueOffsets

Offset in bytes from the beginning of the STAT table to the
start of the design axes value offsets array. If
axisValueCount is zero, set to zero; if axisValueCount is
greater than zero, must be greater than zero.

uint16

elidedFallbackNameID

Name ID used as fallback when projection of names into a
particular font model produces a subfamily name
containing only elidable elements.

In version 1.0 of the STAT table, the elidedFallbackNameId field was not included. Use of
version 1.0 is deprecated. Version 1.1 adds the elidedFallbackNameId field. Version 1.2
adds support for the format 4 axis value table; otherwise, version 1.2 and version 1.1 are
the same.
The elidedFallbackNameId field provides a name that can be used when composing a
name if all of the axis-value names are elidable. For example, “Normal” weight and
“Roman” slant may both be marked as elidable axis-value names, and so a composed
name for normal weight and Roman slant may result in an empty string. The
elidedFallbackNameId is used to provide an alternative name ID to use in this case, such
as “Regular”. In many fonts, this may reference name ID 17 or name ID 2.
The header is followed by the design axes array, and the axis value offsets array. The
offsets to these arrays are provided by offset fields in the header. These arrays may be
contiguous in a font; parsers should, nevertheless, use the offset fields to locate each
array.
ﾉ

Expand table

Type

Name

Description

AxisRecord

designAxes[designAxisCount]

The design-axes array.

Offset16

axisValueOffsets[axisValueCount]

Array of offsets to axis value tables, in bytes from
the start of the axis value offsets array.

The designAxisSize field indicates the size of each axis record. Future minor-version
updates of the STAT table may define compatible extensions to the axis record format
with additional fields. Implementations must use the designAxisSize field to determine
the start of each record.

Axis Records
The axis record provides information about a single design axis.
AxisRecord:
ﾉ

Expand table

Type

Name

Description

Tag

axisTag

A tag identifying the axis of design variation.

uint16

axisNameID

The name ID for entries in the 'name' table that provide a display string
for this axis.

uint16

axisOrdering

A value that applications can use to determine primary sorting of face
names, or for ordering of labels when composing family or face names.

Each axis record has a tag designating the axis. Tag values must follow the rules for axis
tags described in the OpenType Design-Variation Axis Tag Registry. No two axis records
should have the same axisTag value.
The axisNameID field provides a name ID that can be used to obtain strings from the
'name' table that can be used to refer to the axis in application user interfaces. A defined
name ID can be used if strings for that name ID have the appropriate string for an axis
name. Otherwise, name IDs must be greater than 255 and less than 32768.
In a variable font, there must be an axis record for every axis defined in the 'fvar' table,
and it must use the same name ID used in the 'fvar' table. The order of axis records in
the STAT table is arbitrary and does not need to match the order of records in the 'fvar'
table.
If a variable font is part of a family that has additional axes of design variation but that
are not implemented as dynamic-variation axes in the 'fvar' table, records for these
other design variation axes should also be included.
A non-variable font should include axis records for any axes that are relevant for the
font or the family of which it is a member, especially if axes other than weight, width and
slope are used.
For every axis declared using an axis record, the axis should be a variation axis defined
in an 'fvar' table, or else it should be reflected in the font’s subfamily name (name ID 17
or name ID 2) except in the case that the font’s value on that axis is a “normal” value
that is suppressed from the subfamily name.

The axisOrdering field can be used when constructing alternate family and subfamily
names for compatibility with legacy font family models. (See Alternate Font Family
Models above for background information.) If labels pertaining to multiple axes of
design variation need to be combined, this field can be used to determine their relative
ordering. In this way, a font developer can indicate a preferred order of labels in these
alternate names.
The axisOrdering field can also be used by applications in the design of user interfaces.
For example, rather than listing the styles within a family in an arbitrary order, the
application could use the axis ordering information to sort the styles or present them in
groups in a more organized manner. Using this field, a font developer can indicate a
recommendation for how the styles within the family will be presented; for example,
whether they are sorted or grouped first by weight, then by width, or vice versa.
To ensure consistency in how face names are presented to users, the axis ordering given
in axis records should be consistent across different fonts within a family, and with the
ordering of axis-value labels used in the typographic subfamily (name ID 17). In a
variable font, the axis ordering should also be consistent with the ordering of axis-value
labels used in the strings referenced by named instances defined in the 'fvar' table.
Different fonts belonging to the same family should have matching axis records. If a set
of fonts for a family are released, and then at some later time the family is extended
with additional fonts using new axes of variation, the previously-shipped fonts would
not necessarily need to be updated with the additional axis records: because axis
records give characteristics for a font family, not just a single font within the family, axis
records in the newer fonts could provide axis details for the extended family.

Axis Value Tables
Axis value tables provide details regarding a specific style-attribute value on some
specific axis of design variation, or a combination of design-variation axis values. They
also provide the relationship from those values to labels used as elements in subfamily
names. This information can be useful for presenting fonts in application user interfaces.
It is also used by platforms to provide compatibility between rich typographic families
with a wide range of styles and older applications that use legacy font family models.
(See Alternate Font Family Models above for more information.)
In a variable font, it is strongly recommended that axis value tables be included for every
element of typographic subfamily names for all of the named instances defined in the
'fvar' table.

Note: Some applications could rely on these axis value tables to compose subfamily
names for named instances. Unexpected user interface behavior could result if a
complete set of axis value tables is not included in the font.
Additional axis value tables may be included for name elements that do not appear in
any named instances; these may be used by applications in user interfaces or for other
purposes, but are not required for compatibility with legacy font family models. Some
variable fonts may include axes that are not reflected in subfamily names for any named
instances — that is, variants along these axes are selectable only by means of numeric
axis values. In such cases, there is no requirement to assign names or to create axis
value tables for values on these axes.
In many cases, a name element will be associated with a particular value on a single axis.
For example, “Bold” representing a specific weight-axis value; or “Condensed”
representing a specific width value. Such name elements are assumed to be combinable
with name elements associated with values on other axes, as in an instance name “Bold
Condensed”. Name elements of this type are referred to as analytic names.
In other cases, a name element could be associated with a particular combination of
values on multiple axes, and not be amenable to analysis into simpler, independent
elements. For example, a variable font for lettering might use several custom axes to
provide different stroke or swash-terminal modifications, and named instances may be
defined for certain combinations of values for these axes with non-decomposable
names for those combinations; for example, “Florid” for a particular combination of
stroke- and termination-axes values. Name elements of this type are referred to as nonanalytic. Note that a font with non-analytic names might also use an axis such as weight
that uses analytic names, leading to some named instances that combine non-analytic
and analytic elements, such as “Florid Bold” and “Florid Semibold”.
Note that a variable font could have some distinguishing, subfamily attributes that are
static, not implemented as a variation, but that are relevant in relation to the complete
typographic family. For example, a weight-variation font may have a paired, italic
weight-variation font. Axis value tables (as well as axis records) should also be provided
for any such distinctions that are relevant within a family.
Axis value tables are particularly important for variable fonts but can also be used in
non-variable fonts. When used in non-variable fonts, axis value tables for any given
value should be implemented consistently across fonts in the family. In particular, two
different fonts within a family may share certain style attributes in common, and axis
value tables for these values should be implemented consistently. For example, Bold
Condensed and Bold Semi-Condensed fonts both have the same weight attribute, Bold,
and should have matching axis value tables for Bold. If they are not consistent, some

applications could exhibit unexpected behavior in font-related operations, such as how
the fonts are presented in user interfaces, or how the fonts are chosen in fallback or
other font-selection operations.
Four different axis value table formats are defined. Formats 1, 2 and 3 are appropriate
for single-axis values associated with analytic name elements. Format 4 is used
specifically for multi-axis value combinations associated with non-analytic name
elements. Additional formats may be supported in the future, with a minor-version
update of the STAT table.
Note: Use of format 1, format 2, or format 3 axis value tables is especially
recommended for values on 'wght' and 'wdth' axes, and also for “Italic” (value 1.0 on
the 'ital' axis) or “Oblique” (a non-zero value on the 'slnt' axis) variants.
Note: Use of format 4 axis value tables is especially recommended for non-analytic
subfamily names and the corresponding axis-value combinations in static-font
families, or for non-analytic subfamily names in variable fonts that also involve
'wght' or 'wdth' axes, or “Italic” or “Oblique” variants.
For any format of axis value table, the first field is read to determine the format. If the
format is not recognized, then the axis value table may be ignored.
Each format includes a valueNameID field, which references a display string to be
associated with the numeric axis value or combination of axis values. Defined name IDs,
such as name IDs 2, 17 or 22, can be used if those have the appropriate string for an axis
value. Otherwise, name IDs must be greater than 255 and less than 32768.
The different formats all include fields with numeric axis values. These values use the
same scale as is used for the given axis in the 'fvar' table.
In some cases, an attribute using a new design axis could be introduced into a family
after other fonts have been released, with the new attribute not anticipated in any way
in the initial fonts. For example, a font designer might initially create Regular, Bold and
Italic variants of a design, and then later add width variants such as Condensed. In that
case, the initial fonts might not have identified that they represent the “Normal”
attribute on the width scale. The newer fonts should include axis value tables that
describe the earlier fonts in relation to the new design axis. A flag is defined to
designate such axis value tables; this is described in detail below.
No two tables should provide information for the same combination of axis values:
There should not be a format 1 table with axisIndex and value that match the
axisIndex and value of a separate format 3 table.

There should not be a format 1 table with the same axisIndex as a separate format
2 table if the format 1 value is greater than the rangeMinValue and less than the
rangeMaxValue of the format 2 table. The format 1 value may be the same as the
minimum or maximum of the format 2 range, but the format 2 nominalValue
should be different.
Since format 2 and format 3 each provide additional and distinct information
associated with an axis value, a font may contain a format 2 table and a format 3
table with the same axisIndex where the format 2 nominal value is the same as the
format 3 value. The flags and valueNameID of the two tables must be the same.
A format 4 table may specify an axis value that is also specified in another table,
but only if there is some other difference in the combination of axis values
specified by those two tables.
Since use of format 4 tables is recommended only for multi-axis value combinations
associated with a non-analytic name element, there should not be cases of a format 4
table with a single axis value that matches the value or nominal value of another axis
value table.

Axis value table, format 1
Axis value table format 1 has the following structure.
AxisValueFormat1:
ﾉ

Expand table

Type

Name

Description

uint16

format

Format identifier — set to 1.

uint16

axisIndex

Zero-base index into the axis record array identifying the axis of design
variation to which the axis value table applies. Must be less than
designAxisCount.

uint16

flags

Flags — see below for details.

uint16

valueNameID

The name ID for entries in the 'name' table that provide a display string
for this attribute value.

Fixed

value

A numeric value for this attribute value.

A format 1 table is used simply to associate a specific axis value with a name.

Axis value table, format 2

Axis value table format 2 has the following structure.
AxisValueFormat2
ﾉ

Expand table

Type

Name

Description

uint16

format

Format identifier — set to 2.

uint16

axisIndex

Zero-base index into the axis record array identifying the axis of design
variation to which the axis value table applies. Must be less than
designAxisCount.

uint16

flags

Flags — see below for details.

uint16

valueNameID

The name ID for entries in the 'name' table that provide a display string
for this attribute value.

Fixed

nominalValue

A nominal numeric value for this attribute value.

Fixed

rangeMinValue

The minimum value for a range associated with the specified name ID.

Fixed

rangeMaxValue

The maximum value for a range associated with the specified name ID.

A format 2 table can be used if a given name is associated with a particular axis value,
but is also associated with a range of values. For example, in a family that supports
optical size variations, “Subhead” may be used in relation to a range of sizes. The
rangeMinValue and rangeMaxValue fields are used to define that range. In a variable
font, a named instance has specific coordinates for each axis. The nominalValue field
allows some specific, nominal value to be associated with a name, to align with the
named instances defined in the font variations table, while the rangeMinValue and
rangeMaxValue fields allow the same name also to be associated with a range of axis
values.
Some design axes may be open ended, having an effective minimum value of negative
infinity, or an effective maximum value of positive infinity. To represent an effective
minimum of negative infinity, set rangeMinValue to 0x80000000. To represent an
effective maximum of positive infinity, set rangeMaxValue to 0x7FFFFFFF.
The range specification of a format 2 table is inclusive: both the minimum and maximum
values are included within the range. Two tables for a given axis may have ranges that
touch (the rangeMaxValue of one range is the rangeMinValue of the other), but ranges
should not overlap more than that. In the case of two ranges that touch:
At most one of the ranges should have the nominalValue set to the axis value at
which the ranges touch.

When the requested axis value is the value at which the ranges touch, the higher
range must be used unless the nominalValue for the lower range is set to the value
at which the ranges touch, and the nominalValue for the higher range is greater
than that value.
Similar behavior is used if the value of a format 1 or format 3 table touches the range of
a format 2 table:
If the value of a format 1 or format 3 table is equal to the rangeMaxValue of a
format 2 table, the format 1 or format 3 table is used.
If the value of a format 1 or format 3 table is equal to the rangeMinValue of a
format 2 table, the format 1 or format 3 table is used except if the nominalValue of
the format 2 table is also equal to the rangeMinValue.
If two format 2 tables have ranges for the same axis with non-zero overlap, then the
following guidance is recommended for applications:
If two tables have identical ranges, the application should consistently choose one
and ignore the other, by its own criteria.
Else, if the range of one table is entirely contained within the range of other, then
the table with the smaller range should be ignored.
Else, for axis values within the overlapping range, use the table with the higher
range (both rangeMinValue and rangeMaxValue are higher).

Axis value table, format 3
Axis value table format 3 has the following structure:
AxisValueFormat3:
ﾉ

Expand table

Type

Name

Description

uint16

format

Format identifier — set to 3.

uint16

axisIndex

Zero-base index into the axis record array identifying the axis of design
variation to which the axis value table applies. Must be less than
designAxisCount.

uint16

flags

Flags — see below for details.

uint16

valueNameID

The name ID for entries in the 'name' table that provide a display string
for this attribute value.

Fixed

value

A numeric value for this attribute value.

Fixed

linkedValue

The numeric value for a style-linked mapping from this value.

A format 3 table can be used to indicate another value on the same axis that is to be
treated as a style-linked counterpart to the current value. This is primarily intended for
“bold” style linking on a weight axis. These mappings may be used in applications to
determine which style within a family should be selected when a user selects a “Bold”
formatting option. A mapping is defined from a “non-bold” value to its “bold”
counterpart. It is not necessary to provide a “bold” mapping for every weight value;
mappings should be provided for lighter weights, but heavier weights (typically,
semibold or above) would already be considered “bold” and would not require a “bold”
mapping.
Note: Applications are not required to use these style-linked mappings when
implementing text formatting user interfaces. This data can be provided in a font for
the benefit of applications that choose to do so. If a given application does not
apply such style mappings for the given axis, then the linkedValue field is ignored.

Axis value table, format 4
Axis value table format 4 has the following structure:
AxisValueFormat4:
ﾉ

Expand table

Type

Name

Description

uint16

format

Format identifier — set to 4.

uint16

axisCount

The total number of axes contributing to this axis-values
combination.

uint16

flags

Flags — see below for details.

uint16

valueNameID

The name ID for entries in the 'name' table that provide a
display string for this combination of axis values.

AxisValue

axisValues[axisCount]

Array of AxisValue records that provide the combination of
axis values, one for each contributing axis.

The axisCount value should be greater than 1.
The axisValues array uses AxisValue records, which have the following format.

AxisValue record:
ﾉ

Expand table

Type

Name

Description

uint16

axisIndex

Zero-base index into the axis record array identifying the axis to which this
value applies. Must be less than designAxisCount.

Fixed

value

A numeric value for this attribute value.

Each AxisValue record must have a different axisIndex value. The records can be in any
order.
When searching for an axis value table to match a particular combination of values, if
two format 4 tables are found to be a partial match for that combination of values, the
table that matches a greater number of values (the most specific match) should be used.
If two matching format 4 tables are equally specific—the same number of values for a
different set of axes—then the first matching table should be used.
Similarly, if a format 1, format 2 or format 3 table has a (nominal) value used in a format
4 table that also has values for other axes, the format 4 table, being the more specific
match, should be used.
Because a format 4 table combines values on multiple axes, there can be ambiguity
about axis ordering. This could arise when dynamically composing names using the
labels provided by axis value tables, or in other situations in which the axisOrdering
values of axis records are used. For a format 4 table, the axisOrdering value assumed
should be the lowest axisOrdering value for the axes referenced by the format 4 table.

Flags
The following axis value table flags are defined:
ﾉ

Expand table

Mask

Name

Description

0x0001

OLDER_SIBLING_FONT_ATTRIBUTE

If set, this axis value table provides axis value
information that is applicable to other fonts within
the same font family. This is used if the other fonts
were released earlier and did not include
information about values for some axis. If newer
versions of the other fonts include the information

themselves and are present, then this table is
ignored.
0x0002

ELIDABLE_AXIS_VALUE_NAME

If set, it indicates that the axis value represents the
“normal” value for the axis and may be omitted
when composing name strings.

0xFFFC

Reserved

Reserved for future use — set to zero.

When the OLDER_SIBLING_FONT_ATTRIBUTE flag is used, implementations may use the
information provided to determine behavior associated with a different font in the same
family. If a previously released family is extended with fonts for style variants from a new
axis of design variation, then all of them should include a
OLDER_SIBLING_FONT_ATTRIBUTE table for the “normal” value of earlier fonts. The
values in the different fonts should match; if they do not, application behavior may be
unpredictable.
Note: When the OLDER_SIBLING_FONT_ATTRIBUTE flag is set, that axis value table is
intended to provide default information about other fonts in the same family, but
not about the font in which that axis value table is contained. The font should
contain different axis value tables that do not use this flag to make declarations
about itself.
The ELIDABLE_AXIS_VALUE_NAME flag can be used to designate a “normal” value for an
axis that should not normally appear in a face name. For example, the designer may
prefer that face names not include “Normal” width or “Regular” weight. If this flag is set,
applications are permitted to omit these labels from face names, though they may also
include them in certain scenarios.
Note: Fonts should provide axis value tables for “normal” axis values even if they
should not normally be reflected in face names.
Note: If a font or a variable-font instance is selected for which all axis values have
the ELIDABLE_AXIS_VALUE_NAME flag set, then applications may keep the name for
the weight axis, if present, to use as a constructed subfamily name, with names for
all other axis values omitted.
When the OLDER_SIBLING_FONT_ATTRIBUTE flag is set, this will typically be providing
information regarding the “normal” value on some newly introduced axis. In this case,
the ELIDABLE_AXIS_VALUE_NAME flag may also be set, as desired. When applied to the
earlier fonts, those likely would not have included any labels for the new axis, and so the
effects of the ELIDABLE_AXIS_VALUE_NAME flag are implicitly assumed.

If multiple axis value tables have the same axis index, then one of the following should
be true:
The font is a variable font, and the axis is defined in the font variations table as a
variation axis.
The OLDER_SIBLING_FONT_ATTRIBUTE flag is set in one of the tables.

Examples
The following examples illustrate data provided by a style attributes table for various
font scenarios. Except where indicated otherwise, axis value data shown could be
implemented using AxisValueTable format 1 or, if a linked value is included, format 3.

Example 1: Family with different weight variants using
non-variable fonts
Suppose a font family has Regular, Bold and Heavy weight variants. These fonts would
have matching axis records:

Axis tag

Axis name

Axis ordering

'wght'

Weight

0

ﾉ

Expand table

ﾉ

Expand table

The three fonts would have axis value data as follows:

Font

Axis tag

Value

Name string

Flag

Other data

Font 1

'wght'

400

Regular

ELIDABLE_AXIS_VALUE_NAME

linkedValue = 700

Font 2

'wght'

700

Bold

Font 3

'wght'

900

Heavy

Example 2: Family using non-variable fonts for different
weight values plus italic
Suppose the font family from example 1 also has italic variants. The fonts would have
matching axis records reflecting weight and italic axes:

ﾉ

Axis tag

Axis name

Axis ordering

'wght'

Weight

0

'ital'

Italic

1

Expand table

Each of the three non-italic fonts would include an additional axis value table to reflect
the non-italic attribute. The six fonts would have data as follows:
ﾉ

Expand table

Font

Axis tag

Value

Name string

Flag

Other data

Font 1

'wght'

400

Regular

ELIDABLE_AXIS_VALUE_NAME

linkedValue = 700

Font 1

'ital'

0

Regular

ELIDABLE_AXIS_VALUE_NAME

linkedValue = 1

Font 2

'wght'

700

Bold

Font 2

'ital'

0

Regular

ELIDABLE_AXIS_VALUE_NAME

linkedValue = 1

Font 3

'wght'

900

Heavy

Font 3

'ital'

0

Regular

ELIDABLE_AXIS_VALUE_NAME

linkedValue = 1

Font 4

'wght'

400

Regular

ELIDABLE_AXIS_VALUE_NAME

linkedValue = 700

Font 4

'ital'

1

Italic

Font 5

'wght'

700

Bold

Font 5

'ital'

1

Italic

Font 6

'wght'

900

Heavy

Font 6

'ital'

1

Italic

Example 3: Family using non-variable fonts with weight
and italic variants, later extended to add width variants
Suppose the font family from example 2 is later extended with different width variants.
The new fonts in the family would include matching axis records reflecting three axes:
ﾉ

Axis tag

Axis name

Axis ordering

Expand table

'wdth'

Width

0

'wght'

Weight

1

'ital'

Italic

2

Newer versions of the fonts would also include the additional axis record. When newer
fonts co-exist with the original version of the earlier fonts, the ordering from the morecomplete axis records in the newer fonts is used.
To allow for situations in which one of the newer fonts co-exists with the older fonts,
which did not reference the width axis, the newer fonts should each include an axis
value table to describe the “Normal” width, which is inferred onto the earlier fonts.
ﾉ

Axis tag

Value

Name string

Flag

'wdth'

100

Normal

OLDER_SIBLING_FONT_ATTRIBUTE

Expand table
Other data

Example 4: A weight/width variable font
Consider a family comprised of a single variable font with weight and width variations.
This font would have axis records for the two variation axes:
ﾉ

Axis tag

Axis name

Axis ordering

'wght'

Weight

0

'wdth'

Width

1

Expand table

Suppose the variable font has 6 named instances that correspond to three different
weights for each of two widths. The style attributes table should include axis value tables
for at least those three weights and those two widths, but could also include tables for
other weight or width values. The font can include the following axis value tables:
ﾉ

Axis tag

Value

Name string

'wght'

300

Light

'wght'

400

Regular

Flag

Expand table

Other data
linkedValue = 600

ELIDABLE_AXIS_VALUE_NAME

linkedValue = 700

'wght'

600

Semibold

'wght'

700

Bold

'wght'

900

Black

'wdth'

62.5

Extra-Condensed

'wdth'

75

Condensed

'wdth'

100

Normal

'wdth'

125

Expanded

'wdth'

150

Extra-Expanded

ELIDABLE_AXIS_VALUE_NAME

Example 5: A family comprised of a non-italic variable
font plus an italic variable font
Consider a family comprised of a non-italic, weight/width variable font plus a
corresponding italic, weight/width variable font. Each font would have axis records for
three axes:
ﾉ

Axis tag

Axis name

Axis ordering

'wght'

Weight

0

'wdth'

Width

1

'ital'

Italic

2

Expand table

In addition to axis value tables for various weight or width values, the first font would
also include an axis value table to reflect the non-italic attribute:
ﾉ

Expand table

Axis tag

Value

Name string

Flag

Other data

'ital'

0

Normal

ELIDABLE_AXIS_VALUE_NAME

linkedValue = 1

The second font would include an axis value table to reflect the italic attribute, in
addition to the axis value tables for various weight and width values:
ﾉ

Expand table

Axis tag

Value

Name string

'ital'

1

Italic

Flag

Other data

The pattern in this example can be applied to other cases involving a family with style
variations implemented using a combination of font variation mechanisms plus static,
non-variation designs. The axis records in each font would span both variation and nonvariation axes. Axis value tables in each font would include multiple values for variation
axes defined in the 'fvar' table, plus single tables for the relevant attribute values of
other axes.

Example 6: A variable font with non-analytic subfamily
names associated with multiple axis values
Consider a variable font that uses several custom axes, 'TRM1', 'TRM2', 'STK1', 'STK2',
and also the registered 'wght' axis. Suppose that this font has named instances “Florid”
and “Jagged” that involve particular combinations of values for the custom axes; and
additional named instances that correspond to those two named instances but with
other 'wght' values: “Florid Bold”, “Florid Semibold”, etc. The font would have axis value
tables for 'wght' values, with data such as the following:
ﾉ

Expand table

Axis tag

Value

Name string

Flag

Other data

'wght'

400

Regular

ELIDABLE_AXIS_VALUE_NAME

linkedValue = 700

'wght'

700

Bold

'wght'

900

Heavy

The font would also have format 4 axis value tables corresponding to “Florid” and
“Jagged”, with data such as the following:
ﾉ

Name string

AxisValue records

Florid

'TRM1' = 250
'TRM2' = 1000
'STK1' = 550
'STK2' = 0

Jagged

'TRM1' = 900
'TRM2' = 450

Expand table

'STK1' = 0
'STK2' = 310

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

SVG — The SVG (Scalable Vector
Graphics) Table
Article • 05/30/2024

This table contains SVG descriptions for some or all of the glyphs in the font.

Introduction
OpenType provides various formats for color fonts, one of which is the SVG table. The
SVG table provides the benefits of supporting scalable color graphics using the Scalable
Vector Graphics markup language, a vector graphics file format that is widely used on
the Web and that provides rich graphics capabilities, such as gradients.
Compared to the other color formats, the SVG table also provides certain other benefits:
SVG allows for raster artwork as well as vectors, and also allows for combining
raster and vector elements in a color glyph. The other formats allow for one or the
other, but not both.
The SVG description for a color glyph is a complete, integrated piece of artwork;
no additional glyphs are required for the SVG description. In the COLR table,
however, a color glyph may require components that have separate glyph IDs. The
conservation of 16-bit glyph IDs when using the SVG table, in comparison with the
COLR table, may be beneficial for fonts that support a large number of characters.
There are certain trade-offs, however. File sizes are often larger when using the SVG
table than for the other color formats. Also, glyph outlines used in the COLR table can
be variable (in a variable font) and can also be hinted, whereas these capabilities are not
supported with the SVG table.
SVG was developed for use in environments that allow for a rich set of functionality,
including leveraging the full functionality of Cascading Style Sheets for styling, and
programmatic manipulation of graphics objects using the SVG Document Object Model.
Adoption of SVG for use in OpenType does not entail wholesale incorporation of all SVG
capabilities. Text-rendering engines typically have more stringent security, performance
and architectural requirements than general-purpose SVG engines. For this reason,
when used within OpenType fonts, the expressiveness of the language is limited and
simplified to be appropriate for environments in which font processing and text layout
occurs.

The SVG table is optional, and may be used in OpenType fonts with TrueType, CFF or
CFF2 outlines. For every SVG glyph description, there must be a corresponding TrueType,
CFF or CFF2 glyph description in the font.

SVG table formats
The SVG table has a header and an SVGDocumentList subtable.
SVG Header
ﾉ

Expand table

Type

Name

Description

uint16

version

Table version (starting at 0). Set to 0.

Offset32

svgDocumentListOffset

Offset to the SVGDocumentList, from the start of the SVG
table. Must be non-zero.

uint32

reserved

Set to 0.

The SVG document list provides a set of SVG documents, each of which defines one or
more glyph descriptions.
SVGDocumentList:
ﾉ

Expand table

Type

Name

Description

uint16

numEntries

Number of SVGDocumentRecords. Must
be non-zero.

SVGDocumentRecord

documentRecords[numEntries]

Array of SVGDocumentRecords.

Each SVG document record specifies a range of glyph IDs (from startGlyphID to
endGlyphID, inclusive), and the location of its associated SVG document in the SVG
table.
SVGDocumentRecord:
ﾉ

Type

Name

Description

uint16

startGlyphID

The first glyph ID for the range covered by this record.

Expand table

Type

Name

Description

uint16

endGlyphID

The last glyph ID for the range covered by this record.

Offset32

svgDocOffset

Offset from the beginning of the SVGDocumentList to an SVG
document. Must be non-zero.

uint32

svgDocLength

Length of the SVG document data. Must be non-zero.

Records must be sorted in increasing startGlyphID order. For any given record, the
startGlyphID must be less than or equal to the endGlyphID of that record, and also must
be greater than the endGlyphID of any previous record.
Note: Two or more records can point to the same SVG document. In this way, a
single SVG document can provide glyph descriptions for discontinuous glyph ID
ranges. See Example 1.

SVG documents
SVG specification
The SVG markup language used in the SVG table is defined in the Scalable Vector
Graphics (SVG) 1.1 (Second Edition) specification at http://www.w3.org/TR/SVG11

. Any

SVG features beyond those in the SVG 1.1 specification are not supported, unless
explicitly indicated otherwise.
Previous versions of this specification allowed use of context-fill and other context-*
property values, which are defined in the draft SVG 2

specification. Use of these

properties is deprecated: conforming implementations may support these properties,
but support is not required or recommended, and use of these properties in fonts is
strongly discouraged.

Document encoding and format
SVG documents within an OpenType SVG table may either be plain text or gzipencoded, and applications that support the SVG table must support both.
The gzip format is defined in RFC 1952, “GZIP file format specification version 4.3”,
available at http://www.ietf.org/rfc/rfc1952.txt

. Within a gzip-encoded SVG document,

the deflate compression method (defined in RFC 1951, available at
http://www.ietf.org/rfc/rfc1951.txt

) must be used. Thus, the first three bytes of the

gzip-encoded document header must be 0x1F, 0x8B, 0x08.

Whether compressed or plain-text transfer encoding is used, the svgDocLength field of
the SVG document record specifies the length of the encoded data, not the decoded
document.
The character encoding of the (uncompressed) SVG document must be UTF-8.
While SVG 1.1 is defined as an XML application, some SVG implementations for the Web
use an “HTML dialect”. The “HTML dialect” differs from the XML-based definition in
various ways, including being case-insensitive (XML is case-sensitive), and not requiring
an xmlns attribute on the SVG root element. Applications that support the OpenType
SVG table must support the XML-based definition for SVG 1.1. Applications may use
SVG-parsing libraries that also support the “HTML dialect”. However, SVG documents
within OpenType fonts must always conform to the XML-based definition.
While SVG 1.1 requires conforming interpreters to support XML namespace constructs,
applications that support the OpenType SVG table are not required to have full support
for XML namespaces. The root element of each SVG document must declare SVG as the
default namespace:
<svg version="1.1" xmlns="http://www.w3.org/2000/svg">

If the XLink href attribute is used, the root must also declare “xlink” as a namespace in
the root element:
<svg version="1.1" xmlns="http://www.w3.org/2000/svg"
xmlns:xlink="http://www.w3.org/1999/xlink">

No other XLink attributes or other mechanisms may be used anywhere in the document.
Also, no other namespace declarations should be made in any element.

SVG capability requirements and restrictions
Most SVG 1.1 capabilities are supported in OpenType, and should be supported in all
OpenType applications that support the SVG table. Some SVG 1.1 capabilities are not
required and may be optionally supported in applications. Certain other capabilities are
not supported in OpenType and must not be used in SVG documents within OpenType
fonts.
The following capabilities are restricted from use in OpenType and must not be used in
conforming fonts. If use of associated elements is encountered within a font,
conforming applications must ignore and not render those elements.

<text>, <font>, and associated elements
<foreignObject> elements
<switch> elements
<script> elements
<a> elements
<view> elements
XSL processing
Use of relative units em, ex
Use of SVG data within <image> elements
Use of color profiles (the <icccolor> data type, the <color-profile> element, the
color-profile property, or the CSS @color-profile rule)
Use of the contentStyleType attribute
Use of CSS2 system color keywords
SVG documents may include <desc>, <metadata> or <title> elements, but these are
ignored by implementations.
Support for the following capabilities is not required in conforming implementations,
though some applications may support them. Font developers should evaluate support
for these capabilities in the target environments in which their fonts will be used before
using them in fonts. To ensure interoperability across the broadest range of
environments, use of these capabilities should be avoided.
Internal CSS stylesheets (expressed using the <style> element)
CSS inline styles (expressed using the style attribute)
CSS variables (custom properties) — but see further qualifications below
CSS media queries, calc() or animations
SVG animations
SVG child elements
<filter> elements and associated attributes, including enableBackground
<pattern> elements
<mask> elements
<marker> elements
<symbol> elements
Use of XML entities
Use of image data within <image> elements in formats other than JPEG or PNG
Interactivity capabilities (event attributes, zoomAndPan attributes, the cursor
property, or <cursor> elements)
Note: In fonts intended for broad distribution, use of XML presentation atttributes
for styling is recommended over CSS styling as that will have the widest support
across implementations.

Note: Use of media queries to react to environment changes within a glyph
description is not recommended, even when fonts are used in applications that
provide CSS media query support. Instead, a higher-level presentation framework
should handle environment changes. The higher-level framework can interact with
options implemented within the font using OpenType mechanisms such as glyph
substitution, or selection of color palettes.
While supporting the use of CSS variables is optional, it is strongly recommended that
all implementations support the CSS var() function

and color variables derived from

colors defined in the CPAL table. Fonts should not define any variables within an SVG
document; var() should only be used in attributes or properties that accept a color value,
and should only occur as the first item in the value. See Color and Color Palettes below
for more information.
While support for patterns and masks is not required, all conforming implementations
must support gradients (<linearGradient> and <radialGradient> elements), clipping
paths and opacity properties.
Conforming implementations must support all other capabilities of SVG 1.1 that are not
listed above as restricted or as optional and best avoided for broad interoperability.

Color and color palettes
In SVG 1.1, color values can be specified in various ways. For some of these, special
considerations apply when used in the SVG table. Also, OpenType provides a mechanism
for alternate, user-selectable color palettes that can be used within SVG glyph
descriptions.

Colors
Implementations must support numerical RGB specifications; for example, “#ffbb00”, or
“rgb(255,187,0)”. Implementations must also support all of the recognized color
keywords

supported in SVG 1.1. However, CSS2 system color keywords

are not

supported and must not be used.
Some implementations may use graphics engines that happen to support RGBA
specifications using the rgba() function. This is not supported in OpenType, however,
and rgba() specifications must not be used in conforming fonts. Note that SVG 1.1
provides opacity properties that can achieve the same effects.

Implementations must also support the “currentColor” keyword. The initial value must
be set by the text-layout engine or application environment. This can be set in whatever
way is considered most appropriate for the application. In general, it is recommended
that this be set to the text foreground color applied to a given run of text.
Note: Within an SVG document, the value of “currentColor” for any element is the
current color property value for that element. If a color property is set explicitly on
an element, it will reset the “currentColor” value for that element and its children.
Doing so will override the value set by the host environment. In SVG documents
within the SVG table, there is no scenario in which it would be necessary to set a
color property value since any effects can be achieved in other ways. Setting a color
property value should be avoided.

Color palettes
Implementations can optionally support color palettes defined in the CPAL table. The
CPAL table allows the font designer to define one or more palettes, each containing a
number of colors. All palettes defined in the font have the same number of colors, which
are referenced by base-zero index. Within an SVG document in the SVG table, colors in a
CPAL palette are referenced as implementation-defined CSS variables (custom
properties), using the var() function.
Support for the CPAL table and palettes in implementations is strongly recommended.
Implementations that support palettes must support the CSS var() function

for

purposes of referencing palette entries as custom properties. Fonts should only use
custom properties and the var() function to reference CPAL palette entries. Fonts should
not define any variables within an SVG document. The var() function should only be
used in attributes or properties that accept a color value, and should only occur as the
first item in the value.
Note: Even if an implementation does not support CPAL palettes, it is strongly
recommended that the var() function be supported, and that the implementation is
able to apply a fallback value specified as a second var() argument if the first
argument (the color variable) is not supported. This will allow fonts intended for
wide distribution to include use of the CPAL table but to be able to specify fallback
colors in case CPAL palettes are not supported in some applications.
The text-layout engine or application defines a custom property for each palette entry
and assigns color values to each one. Custom color properties should only be defined
for fonts that include a CPAL table. In general, the values of the custom properties
should be set using palette entries from the CPAL table, though applications can assign

values derived by other means, such as user input. When assigning values from CPAL
palette entries, the first palette should normally be used by default. If the font has
palettes marked with the USABLE_WITH_LIGHT_BACKGROUND or
USABLE_WITH_DARK_BACKGROUND flag, however, one of these palettes can be used as
the default instead.
However the values are assigned, the number of custom properties defined must be
numPaletteEntries, as specified in the CPAL table header. The custom-property names
must be of the form “--color<num>”, where <num> is a non-zero-padded decimal
number in the range [0, numPaletteEntries-1]. For example, “--color0”, “--color1”, and so
on.
The following illustrates how a color variable might be used in an SVG glyph description:
<path fill="var(--color0, yellow)" d="..."/>

In implementations that do support color variables and palettes, the color value
assigned to the variable will be applied. If an implementation does not support color
variables and palettes, however, the var() function should still be supported. In that way,
the color variable will be ignored, but the fallback color value, yellow, will be applied.
Palette entries in the CPAL table are specified as BGRA values. (CPAL alpha values are in
the range 0 to 255, where 0 is fully transparent and 255 is fully opaque.) Note that SVG
1.1 supports RGB color values, but not RGBA/BGRA color values. As noted above, use of
rgba() color values within SVG documents in the SVG table is not supported and must
not be used in conforming fonts. Alpha values in CPAL entries are supported, however.
When a CPAL color entry is applied to a fill or stroke property of a shape element, to the
stop-color of a gradient stop element, or to the flood-color property of an feFlood filter
element, then the alpha value from that palette entry must be converted to a value in
the range [0.0 – 1.0] and multiplied into the corresponding fill-opacity, stroke-opacity,
stop-opacity or flood-opacity property of the same element. If an implementation
supports feDiffuseLighting or feSpecularLighting filters and a palette entry is applied to
the lighting-color property, then the alpha value is ignored. When the alpha value is
applied in this way to an opacity property of an element, it is the original opacity
property value that is inherited by child elements, not the computed result of applying
the alpha value to the opacity property. The alpha value is inherited as a component of
the color-related property (fill, stroke, etc.), however.

Glyph Identifiers

As noted above, each SVG document defines one or more glyph descriptions. For each
glyph ID in the glyph ID range of a document record within the SVG document list, the
associated SVG document must contain an element with ID “glyph<glyphID>”, where
<glyphID> is the glyph ID expressed as a non-zero-padded decimal value. This element
functions as the SVG glyph description for the given glyph ID.
For example, suppose a font with 100 glyphs (glyph IDs 0 – 99) has SVG glyph
definitions only for its last 5 glyphs. Suppose also that the last SVG glyph definition has
its own SVG document, but that the other four glyphs are defined in a single SVG
document (to take advantage of shared graphical elements, for instance). There will be
two document records: the first, with glyph ID range [95, 98]; and the second, with glyph
ID range [99, 99]. The SVG document referenced by the first record will contain elements
with IDs “glyph95”, “glyph96”, “glyph97”, and “glyph98”. The SVG document referenced
by the second record will contain an element with ID “glyph99”.
Glyph identifiers may appear deep within an SVG element hierarchy, but SVG itself does
not define how partial SVG documents are to be rendered. Thus, font engines shall
render an element designated in this way as the glyph description for a given glyph ID
according to SVG’s <use> tag behavior, as though the given element and its content
were specified in a <defs> tag and then referenced as the graphic content of an SVG
document. For example, consider the following SVG document, which defines two
glyphs:
<svg version="1.1" xmlns="http://www.w3.org/2000/svg">
<defs>...</defs>
<g id="glyph13">...</g>
<g id="glyph14">...</g>
</svg>

Note: The <g> element

in SVG is a container for grouping of elements, not a

“glyph” element.
When a font engine renders glyph 14, the result shall be the same as rendering the
following SVG document:
<svg version="1.1" xmlns="http://www.w3.org/2000/svg"
xmlns:xlink="http://www.w3.org/1999/xlink">
<defs>
<defs>...</defs>
<g id="glyph14">...</g>
</defs>
<use xlink:href="#glyph14" />
</svg>

Glyph semantics and text layout processing
An SVG glyph description in the SVG table is an alternate to the corresponding glyph
description with the same glyph ID in the 'glyf', 'CFF ' or CFF2 table. The SVG glyph
description must provide a depiction of the same abstract glyph as the corresponding
TrueType/CFF/CFF2 glyph description.
When SVG glyph descriptions are used, text layout is done in the same manner, using
the 'cmap', 'hmtx', GSUB and other tables. This results in an array of final glyph IDs
arranged at particular x,y positions on a surface (along with applicable scale/rotation
matrices). After this layout processing is done, available SVG descriptions are used in
rendering, instead of the TrueType/CFF/CFF2 descriptions. For each glyph ID in the final
glyph array, if an SVG glyph description is available for that glyph ID, then it is rendered
using an SVG engine; otherwise, the TrueType, CFF or CFF2 glyph description is
rendered. Glyph advance widths or heights are the same for SVG glyphs as for
TrueType/CFF/CFF2 glyphs, though there may be small differences in glyph ink
bounding boxes. Because advances are the same, switching between SVG and non-SVG
rendering should not require re-layout of lines unless the line layout depends on
bounding boxes.

Coordinate systems and glyph metrics
The default SVG coordinate system is vertically mirrored in comparison to the
TrueType/CFF/CFF2 design grid: the positive y-axis points downward, rather than usual
convention for OpenType of the positive y-axis pointing upward. In other respects, the
default coordinate system of an SVG document corresponds to the TrueType/CFF/CFF2
design grid: the default units for the SVG document are equivalent to font design units;
the SVG origin (0,0) is aligned with the origin in the TrueType/CFF/CFF2 design grid; and
y = 0 is the default horizontal baseline used for text layout.
The size of the initial viewport for the SVG document is the em square: height and width
both equal to head.unitsPerEm. If a viewBox attribute is specified on the <svg> element
with width or height values different from the unitsPerEm value, this will have the effect
of a scale transformation on the SVG “user” coordinate system. Similarly, if height or
width attributes are specified on the <svg> element, this will also have the effect of a
scale transformation on the coordinate system.
Although the initial viewport size is the em square, the viewport must not be clipped.
The <svg> element is assumed to have a clip property value of auto, and an overflow
property value of visible. A font should not specify clip or overflow properties on the

<svg> element. If clip or overflow properties are specified on the <svg> element with
any other values, they must be ignored.
Note: Because SVG uses a y-down coordinate system, then by default, glyphs will
often be drawn in the +x -y quadrant of the SVG coordinate system. (See Example
2.) In many other environments, however, graphic elements may need to be in the
+x +y quadrant to be visible. Font development tools are expected to provide an
appropriate transfer between a design environment and the representation within
the font’s SVG table. In Example 3, a viewBox attribute is used to shift the viewport
up. In Example 4, a translate transform is used on container elements to shift the
graphic elements that comprise the glyph descriptions.
Glyph advance widths are specified in the 'hmtx' table; advance heights are specified in
the 'vmtx' table. Note that, if SVG or CSS animations are supported, glyph advances
must not be affected by animations.
As with CFF glyphs, no explicit glyph bounding boxes are recorded. Note that left side
bearing values in the 'hmtx' table, top side bearings in the 'vmtx' table, and bit 1 in the
flags field of the 'head' table are not used for SVG glyph descriptions. The “ink”
bounding box of the rendered SVG glyph should be used if a bounding box is desired;
this box may be different for animated versus static renderings of the glyph.
Glyph advances and positions can be adjusted by data in the GPOS or 'kern' tables. Note
that data in the GPOS and 'kern' table use the y-up coordinate system, as with TrueType
or CFF glyph descriptions. When applied to SVG glyph descriptions, applications must
handle the translation between the y-up coordinate system and the y-down coordinates
used for the SVG glyph descriptions.

Animations
Some implementations may support use of animations—either SVG animation or CSS
animation. Note that support for animation is optional and is not recommended in fonts
intended for wide distribution.
Applications that support animations may, in some cases, require a static rendering for
glyphs that include animations. This may be needed, for example, when printing. Note
that a static rendering is obtained by ignoring and not running any animations in the
SVG document, not by allowing animations to run and capturing the initial frame at time
= 0.
Note that glyph advance widths and advance heights are defined in the 'hmtx' and
'vmtx' tables, and cannot be animated. A glyph’s bounding box may change during

animation, but should remain within the glyph advance width/height and the font’s
default line metrics to avoid collision with other text elements.

SVG glyph examples
The SVG code in these examples is presented exactly as could be used in the SVG
documents of an OpenType font with SVG glyph descriptions. The code is not optimized
for brevity.

Example 1: SVG table header and document list
This example shows an SVG table header and document list.
In the SVG Document List, multiple SVG Document Records can point to the same SVG
document. In this way, a single SVG document can provide glyph descriptions for a
discontinuous range of glyph IDs. This example shows multiple records in the Document
List pointing to the same SVG document.
Example 1:
ﾉ

Hex Data

Source

Comments

SVGHeader
0000

version

Table version = 0

0000000A

svgDocumentListOffset

Offset to document list

00000000

reserved
SVGDocumentList

0005

numEntries

Five documentRecord entries, index 0 to 4

documentRecords[0]

Document record for glyph ID range [1, 1]

0001

startGlyphID

0001

endGlyphID

0000003E

svgDocOffset

Offset to SVG document for glyph 1

0000019F

svgDocLength

Length of SVG document for glyph 1

documentRecords[1]

Document record for glyph ID range [2, 2]

Expand table

Hex Data

Source

Comments

0002

startGlyphID

0002

endGlyphID

000001DD

svgDocOffset

Offset to SVG document for glyph 2. The same SVG
document is also used for glyphs 13 and 14.

000002FF

svgDocLength

Length of SVG document for glyph 2 — length of the
entire SVG document, covering glyphs 2, 13 and 14.

documentRecords[2]

Document record for glyph ID range [3, 12]

0003

startGlyphID

000C

endGlyphID

000004DC

svgDocOffset

Offset to SVG document for glyphs 3 to 12

000006F4

svgDocLength

Length of SVG document for glyphs 3 to 12

documentRecords[3]

Document record for glyph ID range [13, 14]

000D

startGlyphID

000E

endGlyphID

000001DD

svgDocOffset

Offset to SVG document for glyphs 2, 13, 14. Offset is the
same as for documentRecords[1].

000002FF

svgDocLength

Length of SVG document for glyphs 2, 13, 14. Length is the
same as for documentRecords[1].

documentRecords[4]

Document record for glyph ID range [15, 19]

000F

startGlyphID

0013

endGlyphID

00000BD0

svgDocOffset

Offset to SVG document for glyphs 15 to 19

00000376

svgDocLength

Length of SVG document for glyphs 15 to 19

Example 4 illustrates an SVG document with glyph descriptions for the discontinuous
ranges [2, 2], [13, 14].

Example 2: Glyph specified directly in expected position
In this example, the letter “i” is drawn directly in the +x -y quadrant of the SVG
coordinate system, upright, with its baseline on the x axis. Note that the y attribute of

the <rect> elements specifies the top edge, with the height of the rectangle below that.
Example 2:

<svg id="glyph7" version="1.1" xmlns="http://www.w3.org/2000/svg">
<defs>
<linearGradient id="grad" x1="0%" y1="0%" x2="0%" y2="100%">
<stop offset="0%" stop-color="darkblue" stop-opacity="1" />
<stop offset="100%" stop-color="#00aab3" stop-opacity="1" />
</linearGradient>
</defs>
<rect x="100" y="-430" width="200" height="430" fill="url(#grad)" />
<rect x="100" y="-635" width="200" height="135" fill="darkblue" />
</svg>

The following image shows the visual result:

Example 3: Glyph shifted up with viewBox
When designing in an SVG illustration application, it may be most natural to draw
objects in the +x +y quadrant of the SVG coordinate system. In this example, the glyph
description of the letter “i” is specified with upright orientation in the +x +y quadrant as
though the baseline were at y=1000 in the SVG coordinate system. A viewBox in the
<svg> element is then used to shift the viewport down by 1000 units so that the actual
baseline aligns with the design’s baseline.
Note: When using a viewBox attribute on the <svg> element, it is important to
specify unitsPerEm for width and height values to avoid a scaling effect. See

Coordinate Systems and Glyph Metrics for more information.
Example 3:

<svg id="glyph7" version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0
1000 1000 1000">
<defs>
<linearGradient id="grad" x1="0%" y1="0%" x2="0%" y2="100%">
<stop offset="0%" stop-color="darkblue" stop-opacity="1" />
<stop offset="100%" stop-color="#00aab3" stop-opacity="1" />
</linearGradient>
</defs>
<rect x="100" y="570" width="200" height="430" fill="url(#grad)" />
<rect x="100" y="365" width="200" height="135" fill="darkblue" />
</svg>

The visual result is the same as that shown for Example 2.

Example 4: Common elements shared across glyphs in
same SVG doc
In this example, the base of the letter “i” is specified as a component within the <defs>
element so that it can be re-used across three glyphs. This shared component is
referenced using the identifier “i-base”. In glyph2, the component is used alone to
comprise the “dotless i”. In glyph13, a dot is added on top. In glyph14, an acute accent
is added on top.
This example also illustrates the use of a translate transform to shift elements drawn in
the +x +y quadrant of the SVG coordinate system so that they appear in the +x -y
quadrant, above the baseline.
Example 4:

<svg version="1.1" xmlns="http://www.w3.org/2000/svg"
xmlns:xlink="http://www.w3.org/1999/xlink">
<defs>
<linearGradient id="grad" x1="0%" y1="0%" x2="0%" y2="100%">
<stop offset="0%" stop-color="darkblue" stop-opacity="1" />
<stop offset="100%" stop-color="#00aab3" stop-opacity="1" />
</linearGradient>
<g id="i-base">
<rect x="100" y="570" width="200" height="430" fill="url(#grad)" />
</g>

</defs>
<g id="glyph2" transform="translate(0,-1000)">
<use xlink:href="#i-base" />
</g>
<g id="glyph13" transform="translate(0,-1000)">
<use xlink:href="#i-base" />
<rect x="100" y="365" width="200" height="135" fill="darkblue" />
</g>
<g id="glyph14" transform="translate(0,-1000)">
<use xlink:href="#i-base" />
<polygon fill="darkblue" points="120,500 280,500 435,342 208,342"/>
</g>
</svg>

The following image shows the visual results for glyph IDs 2, 13, and 14, from left to
right.

Example 5: Specifying currentColor in glyphs
This example uses the same glyph description for “i” as in Example 2 with one
modification: the “darkblue” color value for the dot of the “i” is replaced with the
“currentColor” keyword. The application sets the color value for currentColor, typically
with the text foreground color.
Example 5:

<svg id="glyph7" version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0
1000 1000 1000">
<defs>
<linearGradient id="grad" x1="0%" y1="0%" x2="0%" y2="100%">
<stop offset="0%" stop-color="darkblue" stop-opacity="1" />
<stop offset="100%" stop-color="#00aab3" stop-opacity="1" />
</linearGradient>

</defs>
<rect x="100" y="570" width="200" height="430" fill="url(#grad)" />
<rect x="100" y="365" width="200" height="135" fill="currentColor" />
</svg>

The following image illustrates visual results with currentColor set to two different color
values by the application: black (left), and red (right).

Example 6: Specifying color palette variables in glyphs
This example uses the same glyph description for “i” as in Example 2, but with a
modification: the stop colors of the linear gradient are specified using color variables -color0 and --color1.
The font in this example includes a CPAL table. The value for the color variables is set by
the application, typically using CPAL entries. The CPAL table assumed in this example has
two palettes, each with two entries, with BGRA color values as follows:
palette 0: {8B0000FF, B3AA00FF}
palette 1: {800080FF, D670DAFF}
(SVG equivalents for colors in palette 0 would be {darkblue, #00aab3}. SVG equivalents
for colors in palette 1 would be {purple, orchid}.)
In each of the var() invocations used to reference the color variables, a second
parameter for a fallback color value has been specified. The values match the values
used in palette 0. These fallback values will be used if the application does not support
the CPAL table.

Example 6:

<svg id="glyph7" version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0
1000 1000 1000">
<defs>
<linearGradient id="grad" x1="0%" y1="0%" x2="0%" y2="100%">
<stop offset="0%" stop-color="var(--color0,darkblue)" stop-opacity="1"
/>
<stop offset="100%" stop-color="var(--color1,#00aab3)" stopopacity="1" />
</linearGradient>
</defs>
<rect x="100" y="570" width="200" height="430" fill="url(#grad)" />
<rect x="100" y="365" width="200" height="135" fill="darkblue" />
</svg>

The following images show the visual results in three situations, from left to right:

The first case, on left, shows the result when the values of the color variables have been
set using palette 0 from the CPAL table. The second case, in the middle, shows the result
when values have been set using palette 1.
The third case, on the right, shows a result in which the application has set the values of
the color variables using a custom palette with user-specified colors:
--color0: red
--color1: orange
Note that, in all three cases, the dot of the “i” is still dark blue, since this is hard coded in
the glyph description and not controlled by a color variable.

If the application has not set values for --color0 and --color1 (because it does not
support the CPAL table, for example), then the fallback values provided in the var()
functions (darkblue and #00aab3, respectively) are used. Note that these are in fact the
same colors as in the first (default) CPAL color palette, which means the glyph will
render as in the first case shown above.

Example 7: Embedding a PNG in an SVG glyph
In this example, PNG data is embedded within an <image> element.
A typical use case for embedding PNG data is detailed artwork in a lettering font.
Example 7:

<svg id="glyph2" version="1.1" xmlns="http://www.w3.org/2000/svg"
xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 1000 1000 1000">
<image x="100" y="365" width="200" height="635"
xlink:href="data:image/png;base64,
iVBORw0KGgoAAAANSUhEUgAAAMgAAAJ7CAYAAACmmd5sAAAFZklEQVR42u3XsQ3D
MBAEQUpw9ypahrMPGGwiwcFMCQQW9zzWuu4FbJ2eAAQCAgGBgEBAICAQEAgIBAQC
CAQEAgIBgYBAQCAgEBAICAQEAggEBAICAYGAQEAgIBAQCAgEEAgIBAQCAgGBgEBA
ICAQEAgIBBAICAQEAgIBgYBAQCAgEBAIIBAQCAgEBAICAYGAQEAgIBAQCCAQEAgI
BAQCAgGBgEBAICAQQCAgEBAICAQEAgIBgYBAQCAgEEAgIBAQCAgEBAICAYGAQEAg
IBBPAAIBgYBAQCAgEBAICAQEAgIBBAICAYGAQEAgIBAQCAgEBAICAQQCAgGBgEBA
ICAQEAgIBAQCCAQEAgIBgYBAQCAgEBAICAQEAggEBAICAYGAQEAgIBAQCAgEAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAA4DHHWtftGWDv80sE2Ds9AQgEBAL+IPBuIAoBJxYIBAQCPukgEHBigUBAIOAP
AlgQiAtiQsCCgEDAJx0sCFgQsCAgEHBigQUB5oKYELAgIBDwSQcLAhYELAgIBJxY
YEEACwItEIWAEwucWGBBwIKABQGBgBMLLAhYEMCCQFwQEwJOLHBigQUBCwICAScW
WBCwIGBBAIFAPbHcWGBBwCcdLAgIBJxYYEHAgoAFAYEA88RyY4EFAZ90sCAgEBAI
+IOAQMCJBQIBBALxD+ITAj7p4MQCgYBAwB8EBAJOLBAICATwB4EYiELAiQUCAYGA
TzoIBJxYIBAQCPiDABYE4oKYELAgIBDwSQcLAhYELAgIBJxYYEGAuSAmBCwICAR8
0sGCgAUBCwICAScWWBDAgkALRCHgxAInFlgQsCBgQUAg4MQCCwIWBLAgEBfEhIAT
C5xYYEHAgoBAwIkFFgQsCFgQQCBQTyw3FlgQ8EkHCwICAScWWBCwIGBBQCDAPLHc
WGBBwCcdLAgIBAQC/iAgEHBigUAAgUD8g/iEgE86OLFAICAQ8AcBgYATCwQCAgH8
QSAGohBwYoFAQCDgkw4CAScWCAQEAv4ggAWBuCAmBCwICAR80sGCgAUBCwICAScW
WBBgLogJAQsCAgGfdLAgYEHAgoBAwIkFFgSwINACUQg4scCJBRYELAhYEBAIOLHA
goAFASwIxAUxIeDEAicWWBCwICAQcGKBBQELAhYEEAjUE8uNBRYEfNLBgoBAwIkF
FgQsCFgQEAgwTyw3FlgQ8EkHCwICAYGAPwgIBJxYIBBAIBD/ID4h4JMOTiwQCAgE
/EFAIODEAoGAQAB/EIiBKAScWCAQEAj4pINAwIkFAgGBgD8IYEEgLogJAQsCAgGf
dLAgYEHAgoBAwIkFFgSYC2JCwIKAQMAnHSwIWBCwICAQcGKBBQEsCLRAFAJOLHBi
gQUBCwIWBAQCTiywIGBBAAsCcUFMCDixwIkFFgQsCAgEnFhgQcCCgAUBBAL1xHJj
gQUBn3SwICAQcGKBBQELAhYEBALME8uNBRYEfNLBgoBAQCDgDwICAScWCAQQCMQ/
iE8I+KSDEwsEAgIBfxAQCDixQCAgEMAfBGIgCgEnFggEBAI+6SAQcGKBQEAg4A8C
WBCIC2JCwIKAQMAnHSwIWBCwICAQcGKBBQHmgpgQsCAgEPBJBwsCFgQsCAgEnFhg
QQALAi0QhYATC5xYYEHAgoAFAYGAEwssCFgQwIJAXBATAk4scGKBBQELAgIBJxZY
ELAgYEEAgUA9sdxYYEHAJx0sCAgEnFhgQcCCgAUBgQDzxHJjgQUBn3SwICAQEAj4
g4BAwIkFAgEEAvEP4hMCPungxAKBgEDgH3wBrUwJtCBGuc0AAAAASUVORK5CYII=

"/>
</svg>

The following image shows the visual result:

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

VDMX — Vertical Device Metrics
Article • 02/14/2024

The VDMX table can be used in fonts with TrueType outlines. Under Windows, the
usWinAscent and usWinDescent values from the OS/2 table will be used to determine
the maximum black height for a font at any given size. Windows calls this distance the
Font Height. Because TrueType instructions can lead to Font Heights that differ from the
actual scaled and rounded values, basing the Font Height strictly on the yMax and yMin
can result in “lost pixels.” Windows will clip any pixels that extend above the yMax or
below the yMin. In order to avoid grid fitting the entire font to determine the correct
height, the VDMX table has been defined.
The VDMX table consists of a header followed by groupings of VDMX records.
VdmxHeader
ﾉ

Expand table

Type

Name

Description

uint16

version

Version number (0 or 1).

uint16

numRecs

Number of VDMX groups present

uint16

numRatios

Number of aspect ratio groupings

RatioRange

ratRange[numRatios]

Ratio record array.

Offset16

vdmxGroupOffsets[numRatios]

Offsets from start of this table to the VDMXGroup
table for a corresponding RatioRange record.

RatioRange record
ﾉ

Type

Name

Description

uint8

bCharSet

Character set (see below).

uint8

xRatio

Value to use for x-Ratio

uint8

yStartRatio

Starting y-Ratio value.

uint8

yEndRatio

Ending y-Ratio value.

Ratios are set up as follows:

Expand table

ﾉ

For a 1:1 aspect ratio

Expand table

Ratios.xRatio = 1;
Ratios.yStartRatio = 1;
Ratios.yEndRatio = 1;

For 1:1 through 2:1 ratio

Ratios.xRatio = 2;
Ratios.yStartRatio = 1;
Ratios.yEndRatio = 2;

For 1.33:1 ratio

Ratios.xRatio = 4;
Ratios.yStartRatio = 3;
Ratios.yEndRatio = 3;

For all aspect ratios

Ratio.xRatio = 0;
Ratio.yStartRatio = 0;
Ratio.yEndRatio = 0;

All values set to zero signal the default grouping to use; if present, this must be the last
Ratio group in the table. Ratios of 2:2 are the same as 1:1.
Aspect ratios are matched against the target device by normalizing the entire ratio
range record based on the current X resolution and performing a range check of Y
resolutions for each record after normalization. Once a match is found, the search stops.
If the 0,0,0 group is encountered during the search, it is used (therefore if this group is
not at the end of the ratio groupings, no group that follows it will be used). If there is
not a match and there is no 0,0,0 record, then there is no VDMX data for that aspect
ratio.
Range checks are conceptually performed as follows:

(deviceXRatio == Ratio.xRatio) && (deviceYRatio >= Ratio.yStartRatio) &&
(deviceYRatio <= Ratio.yEndRatio)

Each ratio grouping refers to a specific VDMX record group; there must be at least 1
VDMX group in the table.
The bCharSet value is used to denote cases where the VDMX group was computed
based on a subset of the glyphs present in the font file. The semantics of bCharSet is
different based on the version of the VDMX table. It is recommended that VDMX
version 1 be used. The currently defined values for character set are:
Character Set Values, Version 0

ﾉ

Expand table

Value

Description

0

No subset; the VDMX group applies to all glyphs in the font. This is used for symbol or
dingbat fonts.

1

Windows ANSI subset; the VDMX group was computed using only the glyphs required to
complete the Windows ANSI character set. Windows will ignore any VDMX entries that
are not for the ANSI subset (i.e. ANSI_CHARSET).

Character Set Values, Version 1
ﾉ

Expand table

Value

Description

0

No subset; the VDMX group applies to all glyphs in the font. If adding new character sets
to existing font, add this flag and the groups necessary to support it. This should only be
used in conjunction with ANSI_CHARSET.

1

No subset; the VDMX group applies to all glyphs in the font. Used when creating a new
font for Windows. No need to support SYMBOL_CHARSET.

VDMX groups immediately follow the table header. Each set of records (there need only
be one set) has the following layout:
VDMXGroup table

Type

Name

Description

uint16

recs

Number of height records in this group

uint8

startsz

Starting yPelHeight

uint8

endsz

Ending yPelHeight

vTable

entry[recs]

The VDMX records

ﾉ

Expand table

ﾉ

Expand table

vTable record

Type

Name

Description

uint16

yPelHeight

yPelHeight to which values apply.

int16

yMax

Maximum value (in pels) for this yPelHeight.

int16

yMin

Minimum value (in pels) for this yPelHeight.

This table must appear in sorted order (sorted by yPelHeight), but need not be
continuous. It should have an entry for every pel height where the yMax and yMin do
not scale linearly, where linearly scaled heights are defined as:
Hinted yMax and yMin are identical to scaled/rounded yMax and yMin.
It is assumed that once yPelHeight reaches 255, all heights will be linear, or at least close
enough to linear that it no longer matters. Please note that while the Ratios structure
can only support ppem sizes up to 255, the vTable structure can support much larger pel
heights (up to 65535). The choice of int16 and uint16 for the vTable record is dictated by
the requirement that yMax and yMin be signed values (and 127 to -128 is too small a
range) and the desire to word-align the vTable elements.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

vhea — Vertical Header Table
Article • 05/31/2024

Overview
The vertical header table contains information needed for vertical layout of Chinese,
Japanese, Korean (CJK) and other ideographic scripts. In vertical layout, these scripts are
written either top to bottom or bottom to top. This table contains information that is
general to the font as a whole. Information that pertains to specific glyphs is given in the
vertical metrics ('vmtx') table. The formats of these tables are similar to those for
horizontal metrics, 'hhea' and 'hmtx'.
Data in the vertical header table must be consistent with data that appears in the
vertical metrics table. The advance height and top sidebearing values in the vertical
metrics table must correspond with the maximum advance height and minimum bottom
sidebearing values in the vertical header table.
See the section OpenType CJK Font Guidelines for more information about constructing
CJK (Chinese, Japanese, and Korean) fonts.

Table formats
There are two versions of the 'vhea' table, 1.0 and 1.1. The difference between version
1.0 and version 1.1 is the name and definition of the following fields:
ascender becomes vertTypoAscender
descender becomes vertTypoDescender
lineGap becomes vertTypoLineGap
Version 1.0 of the vertical header table format is as follows:
VheaHeader, version 1.0
ﾉ

Expand table

Type

Name

Description

Version16Dot16

version

Version number of the vertical header table; 0x00010000
for version 1.0

FWORD

ascent

Distance in font design units from the centerline to the
previous line’s descent.

Type

Name

Description

FWORD

descent

Distance in font design units from the centerline to the
next line’s ascent.

FWORD

lineGap

Reserved; set to 0

UFWORD

advanceHeightMax

The maximum advance height measurement in font
design units found in the font. This value must be
consistent with the entries in the vertical metrics table.

FWORD

FWORD

minTop

The minimum top sidebearing measurement found in the

SideBearing

font, in font design units. This value must be consistent
with the entries in the vertical metrics table.

minBottom

The minimum bottom sidebearing measurement found in

SideBearing

the font, in font design units. This value must be
consistent with the entries in the vertical metrics table.

FWORD

yMaxExtent

Defined as yMaxExtent = max(tsb + (yMax - yMin)).

int16

caretSlopeRise

The value of the caretSlopeRise field divided by the value
of the caretSlopeRun Field determines the slope of the
caret. A value of 0 for the rise and a value of 1 for the run
specifies a horizontal caret. A value of 1 for the rise and a
value of 0 for the run specifies a vertical caret.
Intermediate values are desirable for fonts whose glyphs
are oblique or italic. For a vertical font, a horizontal caret
is best.

int16

caretSlopeRun

See the caretSlopeRise field. Value=1 for nonslanted
vertical fonts.

int16

caretOffset

The amount by which the highlight on a slanted glyph
needs to be shifted away from the glyph in order to
produce the best appearance. Set value equal to 0 for
nonslanted fonts.

int16

reserved

Set to 0.

int16

reserved

Set to 0.

int16

reserved

Set to 0.

int16

reserved

Set to 0.

int16

metricDataFormat

Set to 0.

uint16

numOf

Number of advance heights in the vertical metrics table.

LongVerMetrics

Version 1.1 of the vertical header table format is as follows:

VheaHeader, version 1.1
ﾉ

Expand table

Type

Name

Description

Version16Dot16

version

Version number of the vertical header table; 0x00011000
for version 1.1

FWORD

vertTypoAscender

The vertical typographic ascender for this font. It is the
distance in font design units from the vertical center
baseline to the right edge of the design space for CJK /
ideographic glyphs (or “ideographic em box”).
It is usually set to (head.unitsPerEm)/2. For example, a
font with an em of 1000 design units will set this field to
500. See the Baseline tags section of the OpenType
Layout Tag Registry for a description of the ideographic
em-box.

FWORD

vertTypoDescender

The vertical typographic descender for this font. It is the
distance in font design units from the vertical center
baseline to the left edge of the design space for CJK /
ideographic glyphs.
It is usually set to -(head.unitsPerEm/2). For example, a
font with an em of 1000 design units will set this field to
-500.

FWORD

vertTypoLineGap

The vertical typographic gap for this font. An application
can determine the recommended line spacing for single
spaced vertical text for an OpenType font by the
following expression: ideo embox width +
vhea.vertTypoLineGap.

UFWORD

advanceHeightMax

The maximum advance height measurement in font
design units found in the font. This value must be
consistent with the entries in the vertical metrics table.

FWORD

minTop
SideBearing

The minimum top sidebearing measurement found in the
font, in font design units. This value must be consistent
with the entries in the vertical metrics table.

FWORD

minBottom
SideBearing

The minimum bottom sidebearing measurement found in
the font, in font design units. This value must be
consistent with the entries in the vertical metrics table.

FWORD

yMaxExtent

Defined as yMaxExtent = max(tsb + (yMax - yMin)).

int16

caretSlopeRise

The value of the caretSlopeRise field divided by the value
of the caretSlopeRun Field determines the slope of the

Type

Name

Description
caret. A value of 0 for the rise and a value of 1 for the run
specifies a horizontal caret. A value of 1 for the rise and a
value of 0 for the run specifies a vertical caret.
Intermediate values are desirable for fonts whose glyphs
are oblique or italic. For a vertical font, a horizontal caret
is best.

int16

caretSlopeRun

See the caretSlopeRise field. Value=1 for nonslanted
vertical fonts.

int16

caretOffset

The amount by which the highlight on a slanted glyph
needs to be shifted away from the glyph in order to
produce the best appearance. Set value equal to 0 for
nonslanted fonts.

int16

reserved

Set to 0.

int16

reserved

Set to 0.

int16

reserved

Set to 0.

int16

reserved

Set to 0.

int16

metricDataFormat

Set to 0.

uint16

numOf
LongVerMetrics

Number of advance heights in the vertical metrics table.

'vhea' table and OpenType Font Variations
In a variable font, various font-metric values within the 'vhea' table may need to be
adjusted for different variation instances. Variation data for 'vhea' entries can be
provided in the metrics variations (MVAR) table. Different 'vhea' entries are associated
with particular variation data in the MVAR table using value tags, as follows:
ﾉ

Expand table

'vhea' entry

Tag

ascent, vertTypoAscender

'vasc'

caretOffset

'vcof'

caretSlopeRun

'vcrn'

caretSlopeRise

'vcrs'

'vhea' entry

Tag

descent, vertTypoDescender

'vdsc'

lineGap, vertTypoLineGap

'vlgp'

For general information on OpenType Font Variations, see the chapter, OpenType Font
Variations Overview.

Vertical header table example
ﾉ

Expand table

Offset/length

Value

Name

Comment

0/4

0x00011000

version

Version number of the vertical header
table is 1.1.

4/2

1024

vertTypoAscender

Half the em-square height.

6/2

-1024

vertTypoDescender

Minus half the em-square height.

8/2

0

vertTypoLineGap

Typographic line gap is 0 font design
units.

10/2

2079

advanceHeightMax

The maximum advance height
measurement found in the font is 2079
font design units.

12/2

-342

minTopSideBearing

The minimum top sidebearing
measurement found in the font is -342
font design units.

14/2

-333

minBottomSideBearing

The minimum bottom sidebearing
measurement found in the font is -333
font design units.

16/2

2036

yMaxExtent

max(tsb + (yMax - yMin)) = 2036.

18/2

0

caretSlopeRise

The caret slope rise of 0 and a caret
slope run of 1 indicate a horizontal caret
for a vertical font.

20/2

1

caretSlopeRun

The caret slope rise of 0 and a caret
slope run of 1 indicate a horizontal caret
for a vertical font.

22/2

0

caretOffset

Value set to 0 for nonslanted fonts.

Offset/length

Value

Name

Comment

24/4

0

reserved

Set to 0.

26/2

0

reserved

Set to 0.

28/2

0

reserved

Set to 0.

30/2

0

reserved

Set to 0.

32/2

0

metricDataFormat

Set to 0.

34/2

258

numOfLongVerMetrics

Number of advance heights in the
vertical metrics table is 258.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

vmtx — Vertical Metrics Table
Article • 05/31/2024

Overview
The vertical metrics table allows you to specify the vertical spacing for each glyph in a
vertical font. This table consists of either one or two arrays that contain metric
information (the advance heights and top sidebearings) for the vertical layout of each of
the glyphs in the font. The vertical metrics coordinate system is shown below.

OpenType™ vertical fonts require both a vertical header table ('vhea') and the vertical
metrics table. The vertical header table contains information that is general to the font
as a whole. The vertical metrics table contains information that pertains to specific
glyphs. The formats of these tables are similar to those for horizontal metrics, 'hhea' and
'hmtx'.
See the section OpenType CJK Font Guidelines for more information about constructing
CJK (Chinese, Japanese, and Korean) fonts.
Vertical origin and advance height
The y coordinate of a glyph’s vertical origin is specified as the sum of the glyph’s top side
bearing (recorded in the 'vmtx' table) and the top (i.e. maximum y) of the glyph’s
bounding box.
OpenType fonts that use TrueType outlines contain glyph bounding box information in
the Glyph Data ('glyf') table. Fonts that use CFF outlines do not contain glyph bounding
box information, and so for these fonts the top of the glyph’s bounding box can only be
calculated from the CharString data in the 'CFF ' or CFF2 table. The optional Vertical
Origin (VORG) table can be used in fonts that use CFF glyph data to record the y
coordinate of glyphs’ vertical origins directly, thus obviating the need to calculate
bounding boxes as an intermediate step. This improves accuracy and efficiency for
applications.

The x coordinate of a glyph’s vertical origin is not specified in the 'vmtx' table. Vertical
writing implementations may make use of the baseline values in the Baseline (BASE)
table, if present, in order to align the glyphs in the x direction as appropriate to the
desired vertical baseline.
The advance height of a glyph starts from the y coordinate of the glyph’s vertical origin
and advances downwards. Its endpoint is at the y coordinate of the vertical origin of the
next glyph in the run, by default. Metric-adjustment OpenType layout features such as
Vertical Kerning ('vkrn') could modify the vertical advances in a manner similar to
kerning in horizontal mode.

Table formats
The overall structure of the vertical metrics table consists of two arrays shown below: the
vMetrics array followed by an array of top side bearings. The top side bearing is
measured relative to the top of the origin of glyphs, for vertical composition of
ideographic glyphs.
This table does not have a header, but does require that the number of glyphs included
in the two arrays equals the total number of glyphs in the font.
The number of entries in the vMetrics array is determined by the value of the
numOfLongVerMetrics field of the vertical header table.
The vMetrics array contains two values for each entry. These are the advance height and
the top sidebearing for each glyph included in the array.
In monospaced fonts, such as Courier or Kanji, all glyphs have the same advance height.
If the font is monospaced, only one entry need be in the first array, but that one entry is
required.
The format of an entry in the vertical metrics array is given below.
ﾉ

Expand table

Type

Name

Description

UFWORD

advanceHeight

The advance height of the glyph, in font design units.

FWORD

topSideBearing

The top sidebearing of the glyph, in font design units.

The second array is optional and generally is used for a run of monospaced glyphs in
the font. Only one such run is allowed per font, and it must be located at the end of the
font. This array contains the top sidebearings of glyphs not represented in the first array,

and all the glyphs in this array must have the same advance height as the last entry in
the vMetrics array. All entries in this array are therefore monospaced.
The number of entries in this array is calculated by subtracting the value of
numOfLongVerMetrics from the number of glyphs in the font. The sum of glyphs
represented in the first array plus the glyphs represented in the second array therefore
equals the number of glyphs in the font. The format of the top sidebearing array is given
below.
ﾉ

Expand table

Type

Name

Description

FWORD

topSideBearing[]

The top sidebearing of the glyph, in font design units.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

VORG — Vertical Origin Table
Article • 05/31/2024

This optional table specifies the y coordinate of the vertical origin of every glyph in the
font.
This table may only be used in CFF or CFF2 OpenType fonts. If present in OpenType
fonts containing TrueType outline data, it must be ignored: the Vertical Metrics ('vmtx')
and Glyph Data ('glyf') tables provide all the information necessary to accurately
calculate the y coordinate of a glyph’s vertical origin. See the “Vertical Origin and
Advance Height” section in the 'vmtx' table specification for more details.
The 'vmtx' and Vertical Header ('vhea') tables continue to be required for all OpenType
fonts that support vertical writing. Advance heights must continue to be obtained from
the 'vmtx' table; that is the only place they are stored.
If a VORG table is present in a CFF or CFF2 OpenType font, the application may choose
to obtain the y coordinate of a glyph’s vertical origin either:
1. directly from the VORG table, or
2. by first calculating the top of the glyph’s bounding box from the CFF or CFF2
CharString data and then adding to it the glyph’s top side bearing from the 'vmtx'
table.
The former method offers the advantage of increased accuracy and efficiency, since
bounding box results calculated from the CFF or CFF2 CharString can differ depending
on the rounding decisions and data types of the bounding box algorithm. The latter
method provides compatibility for applications that are either unaware of or choose not
to support the VORG.
Thus, the VORG table doesn’t add any new font metric values per se; it simply improves
accuracy and efficiency for applications, since the intermediate step of calculating
bounding boxes from the CFF or CFF2 CharString is rendered unnecessary.
See OpenType CJK Font Guidelines in the Recommendations chapter for more
information about constructing CJK (Chinese, Japanese, and Korean) fonts.

Vertical Origin table format
The VORG table is structured as follows:
VerticalOrigin table

ﾉ

Expand table

Type

Name

Description

uint16

majorVersion

Major version—set to 1.

uint16

minorVersion

Minor version—set to 0.

int16

defaultVertOriginY

The y coordinate of a glyph’s
vertical origin, in the font’s
design coordinate system, to
be used if no entry is present
for the glyph in the
vertOriginYMetrics array.

uint16

numVertOriginYMetrics

Number of elements in the
vertOriginYMetrics array.

VertOriginYMetrics

vertOriginYMetrics[numVertOriginYMetrics]

Array of VertOriginYMetrics
records, sorted by glyph ID.

The VertOriginYMetrics record has the following format:
VertOriginYMetrics record
ﾉ

Expand table

Type

Name

Description

uint16

glyphIndex

Glyph index.

int16

vertOriginY

Y coordinate, in the font’s design coordinate system, of the glyph’s vertical
origin.

This array must be sorted by increasing glyphIndex, and must not have more than one
element with the same glyphIndex. In a size-optimized implementation, glyphs whose
vertical origin’s y coordinate equals defaultVertOriginY will not have an entry in this
array.
If all glyphs in a font share the same defaultVertOriginY value, the length of the VORG
table will be 8 bytes in a size-optimized implementation, since the vertOriginYMetrics
array will be absent.
Typically, only the full-width Latin glyphs in an East Asian font will have entries in the
vertOriginYMetrics array. Glyphs rotated for vertical writing, as used in the Vertical
Alternates and Rotation ('vrt2') feature, for example, can take advantage of the default
value if they are designed appropriately.

In the following example of a complete VORG table for a 1000-unit-em font, every glyph
in the font is specified as having a vertOriginY of 880 except for glyphs with glyph
indices 10, 12, and 13:

majorVersion
=1
minorVersion
=0
defaultVertOriginY
=880
numVertOriginYMetrics=3
--- vertOriginYMetrics[index]=(glyphIndex,vertOriginY)
[0]=(10,889)
[1]=(12,861)
[2]=(13,849)

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

VVAR — Vertical Metrics Variations
Table
Article • 05/30/2024

The VVAR table is used in variable fonts to provide variations for vertical glyph metric
values. This can be used to provide variation data for advance heights in the 'vmtx'
table. In fonts with TrueType outlines, it can also be used to provide variation data for
top and bottom side bearings obtained from the 'vmtx' table and glyph bounding
boxes. In addition, it can also be used in fonts that have CFF2 outlines to provide
vertical-origin variation data.
For a general overview of OpenType Font Variations and terminology related to
variations, see the chapter, OpenType Font Variations Overview.
In a font with TrueType outlines, the rasterizer will generate “phantom” points that
represent left, right, top and bottom side bearings. (See the chapter Instructing TrueType
Glyphs for more background on phantom points.) In a TrueType variable font, the glyph
variations ('gvar') table will include variation data for the phantom points of each glyph,
allowing glyph metrics to be interpolated for different variation instances as part of
deriving the interpolated glyph outlines. For this reason, the VVAR table is not required
in variable fonts that have TrueType outlines. For text-layout operations that require
glyph metrics but not actual glyph outlines, however, there can be significant
performance benefits by being able to obtain adjusted glyph metrics for an instance
without needing to interpolate glyph outlines. For this reason, it is recommended that a
VVAR table be included in variable fonts that have TrueType outlines and that support
vertical layout.
The CFF2 rasterizer does not generate phantom points as in the TrueType rasterizer. For
this reason, a VVAR table is required to handle any variation in vertical glyph metrics in a
variable font with CFF 2 outlines.
The format and processing of the VVAR table is analogous to the horizontal metrics
variations (HVAR) table.

Related and Co-Requisite Tables
The VVAR table is used only in variable fonts that support vertical layout. It must be
used in combination with a vertical metrics ('vmtx') table, and also in combination with a
font variations ('fvar') table, and other required or optional tables used in variable fonts.

See Variation Data Tables and Miscellaneous Requirements in the OpenType Font
Variations Overview chapter for general information.
For variable fonts that have TrueType outlines and that support vertical layout, the VVAR
table is optional but recommended. For variable fonts that have CFF2 outlines and that
support vertical layout, the VVAR table is required if there is any variation in glyph
advance heights across the variation space.
Note: The VDMX table is not used in variable fonts.

Table Formats
The vertical metrics variations table has the following format.
Vertical metrics variations table:
ﾉ

Expand table

Type

Name

Description

uint16

majorVersion

Major version number of the vertical metrics
variations table — set to 1.

uint16

minorVersion

Minor version number of the vertical metrics
variations table — set to 0.

Offset32

itemVariationStoreOffset

Offset in bytes from the start of this table to the item
variation store table.

Offset32

advanceHeightMappingOffset

Offset in bytes from the start of this table to the deltaset index mapping for advance heights (may be
NULL).

Offset32

tsbMappingOffset

Offset in bytes from the start of this table to the deltaset index mapping for top side bearings (may be
NULL).

Offset32

bsbMappingOffset

Offset in bytes from the start of this table to the deltaset index mapping for bottom side bearings (may be
NULL).

Offset32

vOrgMappingOffset

Offset in bytes from the start of this table to the deltaset index mapping for Y coordinates of vertical origins
(may be NULL).

The item variation store table is documented in the chapter, OpenType Font Variations
Common Table Formats.

Mapping subtables are represented using a DeltaSetIndexMap table; see Associating
Target Items to Variation Data in the Common Table Formats chapter for the definition
of this table. In the VVAR table, only format 0 of the DeltaSetIndexMap is used. Mapping
subtables are optional. If a given mapping subtable is not provided, the offset is set to
NULL.
Variation data for advance heights is required. A delta-set index mapping subtable for
advance heights can be provided, but is optional. If a mapping table is not provided,
glyph indices are used as implicit delta-set indices, as in the HVAR table.
Variation data for side bearings are optional. If included, mapping subtables are
required to provide the delta-set index for each glyph.
Mappings and variation data for vertical origins are not used in fonts with TrueType
outlines, but can be included in variable fonts with CFF 2 outlines if there is variability in
the Y coordinates of glyph vertical origins, the default values of which are recorded in
the VORG table. A mapping subtable is required for vertical-origin variation data.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

OpenType Layout Tag Registry
Article • 05/31/2024

OpenType Layout tags are 4-byte character strings that identify the scripts, language
systems, features and baselines in an OpenType font. The registry establishes
conventions for naming and using these tags. Registered tags have a specific meaning
and convey precise information to developers and text-processing clients of OpenType
Layout. Font developers are encouraged to use registered tags to assure compatibility
and ease of use across fonts, applications, and operating systems. Additional tags may
be added to this registry over time. Vendors wishing to register new tags should contact
Microsoft.
The following sections contain sample sets of commonly used tags for scripts, language
systems, and baselines.
OpenType Layout tag registry for:
Script tags
Language tags
Feature tags
Baseline tags

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

Script Tags
Article • 05/31/2024

Script tags generally correspond to a Unicode script. However, the associations between
them are not always one-to-one, and the OpenType tags are not guaranteed to be the
same as Unicode Script property-value aliases or ISO 15924 script IDs. Since the
development of OpenType predates the ISO 15924 or Unicode Script property, the rules
for script tags defined in this document are not always the same as rules for ISO 15924
script IDs. The OpenType script tags can also correlate with a particular OpenType
Layout implementation, with the result that more than one script tag may be registered
for a given Unicode script (e.g. 'deva' and 'dev2').
All tags are four-character strings composed of a limited set of ASCII characters; for
details regarding the Tag data type, see Data Types. By convention, registered script tags
use four lowercase letters.
Use and processing of script tags in Script Records is described in the Script List Table
and Script Record section of the OpenType Layout Common Table Formats chapter.
ﾉ

Script

Script
Tag

Adlam

'adlm'

Ahom

'ahom'

Anatolian Hieroglyphs

'hluw'

Arabic

'arab'

Armenian

'armn'

Avestan

'avst'

Balinese

'bali'

Bamum

'bamu'

Bassa Vah

'bass'

Batak

'batk'

Bangla

'beng'

Bangla v.2

'bng2'

Remarks

Expand table

Bhaiksuki

'bhks'

Bopomofo

'bopo'

Brahmi

'brah'

Braille

'brai'

Buginese

'bugi'

Buhid

'buhd'

Byzantine Music

'byzm'

Canadian Syllabics

'cans'

Carian

'cari'

Caucasian Albanian

'aghb'

Chakma

'cakm'

Cham

'cham'

Cherokee

'cher'

Chorasmian

'chrs'

CJK Ideographic

'hani'

Coptic

'copt'

Cypriot Syllabary

'cprt'

Cypro-Minoan

'cpmn'

Cyrillic

'cyrl'

Default

DFLT

Deseret

'dsrt'

Devanagari

'deva'

Devanagari v.2

'dev2'

Dives Akuru

'diak'

Dogra

'dogr'

Duployan

'dupl'

Egyptian Hieroglyphs

'egyp'

Elbasan

'elba'

Elymaic

'elym'

Ethiopic

'ethi'

Garay

'gara'

Georgian

'geor'

Glagolitic

'glag'

Gothic

'goth'

Grantha

'gran'

Greek

'grek'

Gujarati

'gujr'

Gujarati v.2

'gjr2'

Gunjala Gondi

'gong'

Gurmukhi

'guru'

Gurmukhi v.2

'gur2'

Gurung Khema

'gukh'

Hangul

'hang'

Hangul Jamo

'jamo'

Use of this tag is not recommended. Fonts
supporting Unicode conjoining jamo characters
should use 'hang' instead.

Hanifi Rohingya

'rohg'

Hanunoo

'hano'

Hatran

'hatr'

Hebrew

'hebr'

Hiragana

'kana'

Imperial Aramaic

'armi'

Inscriptional Pahlavi

'phli'

Inscriptional Parthian

'prti'

Javanese

'java'

Kaithi

'kthi'

Kannada

'knda'

Kannada v.2

'knd2'

Katakana

'kana'

Kawi

'kawi'

Kayah Li

'kali'

Kharosthi

'khar'

Khitan Small Script

'kits'

Khmer

'khmr'

Khojki

'khoj'

Khudawadi

'sind'

Kirat Rai

'krai'

Lao

'lao '

Latin

'latn'

Lepcha

'lepc'

Limbu

'limb'

Linear A

'lina'

Linear B

'linb'

Lisu (Fraser)

'lisu'

Lycian

'lyci'

Lydian

'lydi'

Mahajani

'mahj'

Makasar

'maka'

Malayalam

'mlym'

Malayalam v.2

'mlm2'

Mandaic, Mandaean

'mand'

Manichaean

'mani'

Marchen

'marc'

Masaram Gondi

'gonm'

Mathematical text layout

'math'

This script tag is intended for use by math layout
engines for features related to math layout—see
OpenType Layout tags used with the MATH Table for
more details.

Medefaidrin (Oberi Okaime,

'medf'

Oberi Ɔkaimɛ)
Meitei Mayek (Meithei, Meetei)

'mtei'

Mende Kikakui

'mend'

Meroitic Cursive

'merc'

Meroitic Hieroglyphs

'mero'

Miao

'plrd'

Modi

'modi'

Mongolian

'mong'

Mro

'mroo'

Multani

'mult'

Musical Symbols

'musc'

Myanmar

'mymr'

Use of this tag is not recommended. Fonts
supporting Unicode encoding of Myanmar script
should use 'mym2' instead.

Myanmar v.2

'mym2'

Nabataean

'nbat'

Nag Mundari

'nagm'

Nandinagari

'nand'

Newa

'newa'

New Tai Lue

'talu'

N'Ko

'nko '

Nüshu

'nshu'

Nyiakeng Puachue Hmong

'hmnp'

Odia

'orya'

Odia v.2

'ory2'

Ogham

'ogam'

Ol Chiki

'olck'

Ol Onal

'onao'

Old Italic

'ital'

Old Hungarian

'hung'

Old North Arabian

'narb'

Old Permic

'perm'

Old Persian Cuneiform

'xpeo'

Old Sogdian

'sogo'

Old South Arabian

'sarb'

Old Turkic, Orkhon Runic

'orkh'

Old Uyghur

'ougr'

Osage

'osge'

Osmanya

'osma'

Pahawh Hmong

'hmng'

Palmyrene

'palm'

Pau Cin Hau

'pauc'

Phags-pa

'phag'

Phoenician

'phnx'

Psalter Pahlavi

'phlp'

Rejang

'rjng'

Runic

'runr'

Samaritan

'samr'

Saurashtra

'saur'

Sharada

'shrd'

Shavian

'shaw'

Siddham

'sidd'

Sign Writing

'sgnw'

Sinhala

'sinh'

Sogdian

'sogd'

Sora Sompeng

'sora'

Soyombo

'soyo'

Sumero-Akkadian Cuneiform

'xsux'

Sundanese

'sund'

Sunuwar

'sunu'

Syloti Nagri

'sylo'

Syriac

'syrc'

Tagalog

'tglg'

Tagbanwa

'tagb'

Tai Le

'tale'

Tai Tham (Lanna)

'lana'

Tai Viet

'tavt'

Takri

'takr'

Tamil

'taml'

Tamil v.2

'tml2'

Tangsa

'tnsa'

Tangut

'tang'

Telugu

'telu'

Telugu v.2

'tel2'

Thaana

'thaa'

Thai

'thai'

Tibetan

'tibt'

Tifinagh

'tfng'

Tirhuta

'tirh'

Todhri

'todr'

Toto

'toto'

Tulu-Tigalari

'tutg'

Ugaritic Cuneiform

'ugar'

Vai

'vai '

Vithkuqi

'vith'

Wancho

'wcho'

Warang Citi

'wara'

Yezidi

'yezi'

Yi

'yi '

Zanabazar Square (Zanabazarin
Dörböljin Useg, Xewtee

'zanb'

For this tag value, NO-BREAK SPACE characters are
used in this table rather than SPACE to ensure that
two space characters are displayed. The actual tag
byte sequence is 0x79 0x69 0x20 0x20.

Dörböljin Bicig, Horizontal
Square Script)

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

Language System Tags
Article • 12/05/2024

Language system tags identify the language systems supported in OpenType Layout
tables. What is meant by a “language system” in this context is a set of typographic
conventions for how text in a given script should be presented. Such conventions may
be associated with particular languages, with particular genres of usage, with different
publications, and other such factors. For example, particular glyph variants for certain
characters may be required for particular languages, or for phonetic transcription or
mathematical notation.
In principle, a given set of conventions may be shared across multiple scenarios. For
instance, two different languages (perhaps unrelated) may happen to follow the same
conventions. Language system tags can be registered on a perceived-need basis,
however. As a result, there is no guarantee that each tag represents a distinct and
unique set of conventions. Tags can, however, be registered with the intent of
representing conventions that apply to multiple languages. In such cases, the
documented description for the tag should reflect that intent.
It should also be noted that there may be more than one set of typographic conventions
that apply to a given language.
Therefore, in several respects, language system tags do not correspond in a one-to-one
manner with languages. Even so, many registered tags are intended to represent
typographic conventions for a particular language. For cases in which a correlation exists
between a tag and one or more languages, the language identities are documented
here by reference to the ISO 639 standard for language identifiers.
Note: The ISO 639 standard defines different identifier sets. Set 3 includes identifiers
for all known languages; Set 2 also includes identifiers for certain collections of
languages. Entities from ISO 639 that are referenced here can include any of the
individual languages covered in Set 3, or any of the collections covered in Set 2.
Note: The ISO 639 data for a given language system can include identifiers that are
equivalent or narrower in scope. For example, when a language system corresponds
to an ISO 639 collection, the ISO 639 identifiers for individual languages within that
collection may also be listed. On the other hand, if a language system corresponds
to an ISO 639 individual language identifier, ISO 639 collection identifiers are not
also listed. In some cases, an individual language identifier may be listed for
multiple language system tags.

If information is available to an application declaring the language of text content, then
the application may make use of that to select a default language system tag to be
applied when displaying that text. In some applications, however, it could be preferable
to give users control over the choice of language system tag to be used. Depending on
the application scenario, such control may be given to content authors, to content
readers, or to both.
All tags are four-character strings composed of a limited set of ASCII characters; for
details regarding the Tag data type, see Data Types. By convention, registered language
system tags use three or four capital letters (0x41 to 0x5A).
Note: The tags 'dflt' and 'DFLT', as language system tags, are permanently reserved
and are not used in OpenType fonts. Within the structure of GPOS and GSUB tables,
data is organized by Script tables, and each Script table has an offset to a default
language system (LangSys) table. These structures do not involve use of any
language system tag. Some font development tools may use 'dflt' or 'DFLT' as a
means to indicate data that should get compiled into a default LangSys table. That
is a tool-specific convention, and it is the responsibility of font tool developers to
compile data into appropriate structures with the font file. An OpenType font should
never include language system records (LangSysRecord) with the 'dflt' or 'DFLT' tag.
Requests to register additional language system tags can be submitted using the
feedback mechanism at the bottom of this page or at
https://github.com/MicrosoftDocs/typography-issues/issues

.

In the following table, entries marked with an asterisk (“*”) have been added to the
registry since the current OpenType version was published.
ﾉ

Expand table

Language system

Language
system tag

Corresponding ISO 639 IDs or other information

Eastern Abenaki

'AAQ '

aaq

Abaza

'ABA '

abq

Abkhazian

'ABK '

abk

Acholi

'ACH '

ach

Achi

'ACR '

acr

Cypriot Arabic

'ACY '

acy

Adyghe

'ADY '

ady

Afrikaans

'AFK '

afr

Afar

'AFR '

aar

Agaw

'AGW '

ahg

Aiton

'AIO '

aio

Akan

'AKA '

aka, fat, twi

Batak Angkola

'AKB '

akb

Alsatian

'ALS '

gsw

Altai

'ALT '

atv, alt

Amharic

'AMH '

amh

Anglo-Saxon

'ANG '

ang

Phonetic

APPH

Cf. BCP 47 variant subtag “fonnapa” (see

transcription—

https://www.iana.org/assignments/lang-subtags-

Americanist
conventions

templates/fonnapa.txt

)

Arabic

'ARA '

ara

Aragonese

'ARG '

arg

Aari

'ARI '

aiw

Rakhine

'ARK '

mhv, rmz, rki

Assamese

'ASM '

asm

Asturian

'AST '

ast

Athapaskan
languages

'ATH '

aht, apa, apk, apj, apl, apm, apw, ath, bea, sek, bcr, caf, chp,
clc, coq, crx, ctc, den, dgr, gce, gwi, haa, hoi, hup, ing, kkz,
koy, ktw, kuu, mvb, nav, qwt, scs, srs, taa, tau, tcb, tce, tfn,
tgx, tht, tol, ttm, tuu, txc, wlk, xup, xsl

Gros Ventre

'ATS '

ats

Avatime

'AVN '

avn

Avar

'AVR '

ava

Awadhi

'AWA '

awa

(Atsina)

Aymara

'AYM '

aym

Torki

'AZB '

azb

Azerbaijani

'AZE '

aze

Badaga

'BAD '

bfq

Banda

BAD0

bad, bbp, bfl, bjo, bpd, bqk, gox, kuw, liy, lna, lnl, mnh, nue,
nuu, tor, yaj, zmz

Baghelkhandi

'BAG '

bfy

Balkar

'BAL '

krc

Balinese

'BAN '

ban

Bavarian

'BAR '

bar

Baulé

'BAU '

bci

Batak Toba

'BBC '

bbc

Berber

'BBR '

auj, ber, cnu, gha, gho, grr, jbe, jbn, kab, mzb, oua, rif, sds,
shi, shy, siz, sjs, swn, taq, tez, thv, thz, tia, tjo, tmh, ttq, tzm,
zen, zgh

Bench

'BCH '

bcq

Bible Cree

'BCR '

Emberá-Baudó

'BDC '

bdc

Bandjalang

'BDY '

bdy

Belarusian

'BEL '

bel

Bemba

'BEM '

bem

Bangla

'BEN '

ben

Haryanvi

'BGC '

bgc

Bagri

'BGQ '

bgq

Bulgarian

'BGR '

bul

Bhili

'BHI '

bhi, bhb

Bhojpuri

'BHO '

bho

Bikol

'BIK '

bik, bhk, bcl, bto, cts, bln, fbl, lbl, rbl, ubl

Bilen

'BIL '

byn

Bislama

'BIS '

bis

Kanauji

'BJJ '

bjj

Blackfoot

'BKF '

bla

Baluchi

'BLI '

bal

Pa’o Karen

'BLK '

blk

Balante

'BLN '

bjt, ble

Balti

'BLT '

bft

Bambara

'BMB '

bam

Bamileke

'BML '

bai, bbj, bko, byv, fmp, jgo, nla, nnh, nnz, nwe, xmg, ybb

Bosnian

'BOS '

bos

Bishnupriya
Manipuri

'BPY '

bpy

Breton

'BRE '

bre

Brahui

'BRH '

brh

Braj Bhasha

'BRI '

bra

Burmese

'BRM '

mya

Bodo

'BRX '

brx

Bashkir

'BSH '

bak

Burushaski

'BSK '

bsk

Batak Dairi

'BTD '

btd

Beti

'BTI '

btb, beb, bum, bxp, eto, ewo, mct

Batak languages

'BTK '

akb, bbc, btd, btk, btm, bts, btx, btz

Batak Mandailing

'BTM '

btm

Batak Simalungun

'BTS '

bts

Batak Karo

'BTX '

btx

(Bamanankan)

(Pakpak)

Batak Alas-Kluet

'BTZ '

btz

Bugis

'BUG '

bug

Medumba

'BYV '

byv

Kaqchikel

'CAK '

cak

Catalan

'CAT '

cat

Cayuga

'CAY '

cay

Chimila

'CBG '

cbg

Zamboanga
Chavacano

'CBK '

cbk

Chinantec

CCHN

cco, chj, chq, chz, cle, cnl, cnt, cpa, csa, cso, cte, ctl, cuc, cvn

Cebuano

'CEB '

ceb

Chiga

'CGG '

cgg

Chamorro

'CHA '

cha

Chechen

'CHE '

che

Chaha Gurage

'CHG '

sgw

Chattisgarhi

'CHH '

hne

Chichewa (Chewa,
Nyanja)

'CHI '

nya

Chukchi

'CHK '

ckt

Chuukese

CHK0

chk

Choctaw

'CHO '

cho

Chipewyan

'CHP '

chp

Cherokee

'CHR '

chr

Chuvash

'CHU '

chv

Cheyenne

'CHY '

chy

Western Cham

'CJA '

cja

Eastern Cham

'CJM '

cjm

Emberá-Chamí

'CMI '

cmi

Comorian

'CMR '

swb, wlc, wni, zdj

Comox

'COO '

coo

Coptic

'COP '

cop

Cornish

'COR '

cor

Corsican

'COS '

cos

Creoles

'CPP '

abs, acf, afs, aig, aoa, bah, bew, bis, bjs, bpl, bpq, brc, bxo,
bzj, bzk, cbk, ccl, ccm, chn, cks, cpe, cpf, cpi, cpp, cri, crp, crs,
dcr, dep, djk, fab, fng, fpe, gac, gcf, gcl, gcr, gib, goq, gpe,
gul, gyn, hat, hca, hmo, hwc, icr, idb, ihb, jam, jvd, kcn, kea,
kmv, kri, kww, lir, lou, lrt, max, mbf, mcm, mfe, mfp, mkn,
mod, msi, mud, mzs, nag, nef, ngm, njt, onx, oor, pap, pcm,
pea, pey, pga, pih, pis, pln, pml, pmy, pov, pre, rcf, rop, scf,
sci, skw, srm, srn, sta, svc, tas, tch, tcs, tgh, tmg, tpi, trf, tvy,
uln, vic, vkp, wes, xmm, ycr

Cree

'CRE '

cre

Carrier

'CRR '

crx, caf

Crimean Tatar

'CRT '

crh

Kashubian

'CSB '

csb

Church Slavonic

'CSL '

chu

Czech

'CSY '

ces

Chittagonian

'CTG '

ctg

Emberá-Catío

'CTO '

cto

Wayanad Chetti

'CTT '

ctt

San Blas Kuna

'CUK '

cuk

Dagbani

'DAG '

dag

Danish

'DAN '

dan

Dargwa

'DAR '

dar

Dayi

'DAX '

dax

Woods Cree

'DCR '

cwd

German

'DEU '

deu

Dogri (individual
language)

'DGO '

dgo

Dogri
(macrolanguage)

'DGR '

doi

Dhangu

'DHG '

dhg

Divehi (Dhivehi,

'DHV '

div

Maldivian)

(deprecated)

Dimli

'DIQ '

diq

Divehi (Dhivehi,
Maldivian)

'DIV '

div

Zarma

'DJR '

dje

Djambarrpuyngu

DJR0

djr

Dangme

'DNG '

ada

Dan

'DNJ '

dnj

Dinka

'DNK '

din

Dari

'DRI '

prs

Dhuwal

'DUJ '

duj, dwu, dwy

Dungan

'DUN '

dng

Dzongkha

'DZN '

dzo

Ebira

'EBI '

igb

Eastern Cree

'ECR '

crj, crl

Edo

'EDO '

bin

Efik

'EFI '

efi

Greek

'ELL '

ell

Eastern
Maninkakan

'EMK '

emk

Northern Emberá

'EMP '

emp

English

'ENG '

eng

Erzya

'ERZ '

myv

Spanish

'ESP '

spa

Central Yupik

'ESU '

esu

Estonian

'ETI '

est

Basque

'EUQ '

eus

Evenki

'EVK '

evn

Even

'EVN '

eve

Ewe

'EWE '

ewe

French Antillean

'FAN '

acf

Fang

FAN0

fan

Persian

'FAR '

fas

Fanti

'FAT '

fat

Finnish

'FIN '

fin

Fijian

'FJI '

fij

Dutch (Flemish)

'FLE '

vls

Fe’fe’

'FMP '

fmp

Forest Enets

'FNE '

enf

Fon

'FON '

fon

Faroese

'FOS '

fao

French

'FRA '

fra

Cajun French

'FRC '

frc

Frisian

'FRI '

fry

Friulian

'FRL '

fur

Arpitan

'FRP '

frp

Futa

'FTA '

fuf

Fulah

'FUL '

ful

Nigerian Fulfulde

'FUV '

fuv

Ga

'GAD '

gaa

Scottish Gaelic

'GAE '

gla

Gagauz

'GAG '

gag

Galician

'GAL '

glg

Garshuni

'GAR '

Garhwali

'GAW '

gbm

Geez

'GEZ '

gez

Githabul

'GIH '

gih

Gilyak

'GIL '

niv

Kiribati
(Gilbertese)

GIL0

gil

Kpelle (Guinea)

'GKP '

gkp

Gilaki

'GLK '

glk

Gumuz

'GMZ '

guk

Gumatj

'GNN '

gnn

Gogo

'GOG '

gog

Gondi

'GON '

gon

Greenlandic

'GRN '

kal

Garo

'GRO '

grt

Guarani

'GUA '

grn

Wayuu

'GUC '

guc

Gupapuyngu

'GUF '

guf

Gujarati

'GUJ '

guj

Gusii

'GUZ '

guz

Haitian (Haitian
Creole)

'HAI '

hat

Haida

'HAI0'

hai, hax, hdn

Halam (Falam
Chin)

'HAL '

cfm

Harauti

'HAR '

hoj

Hausa

'HAU '

hau

Hawaiian

'HAW '

haw

Haya

'HAY '

hay

Hazaragi

'HAZ '

haz

Hammer-Banna

'HBN '

amf

Heiltsuk

'HEI '

hei

Herero

'HER '

her

Hiligaynon

'HIL '

hil

Hindi

'HIN '

hin

High Mari

'HMA '

mrj

A-Hmao

'HMD '

hmd

Hmong

'HMN '

hmn

Hiri Motu

'HMO '

hmo

Hmong Shuat

'HMZ '

hmz

Hindko

'HND '

hno, hnd

Ho

'HO '

hoc

Harari

'HRI '

har

Croatian

'HRV '

hrv

Hungarian

'HUN '

hun

Halkomelem

'HUR '

hur

Armenian

'HYE '

hye, hyw

Armenian East

HYE0

hye

Iban

'IBA '

iba

Ibibio

'IBB '

ibb

Igbo

'IBO '

ibo

Ido

'IDO '

ido

Ijo languages

'IJO '

iby, ijc, ije, ijn, ijo, ijs, nkx, okd, okr, orr

Interlingue

'ILE '

ile

Ilokano

'ILO '

ilo

Interlingua

'INA '

ina

Indonesian

'IND '

ind

Ingush

'ING '

inh

Inuktitut

'INU '

iku

Nunavik Inuktitut

'INUK'

ike, iku

Inupiat

'IPK '

ipk

Phonetic
transcription—IPA

IPPH

Cf. BCP 47 variant subtag “fonipa” (see
https://www.iana.org/assignments/lang-subtags-

conventions

templates/fonipa.txt

Irish

'IRI '

gle

Irish Traditional

'IRT '

ghc, gle

Irula

'IRU '

iru

Icelandic

'ISL '

isl

Inari Sami

'ISM '

smn

Italian

'ITA '

ita

Hebrew

'IWR '

heb

Jamaican Creole

'JAM '

jam

Japanese

'JAN '

jpn

Javanese

'JAV '

jav

Lojban

'JBO '

jbo

Krymchak

'JCT '

jct

Judeo-Tat

'JDT '

jdt

Yiddish

'JII '

yid

Ladino

'JUD '

lad

Jula

'JUL '

dyu

)

Kabardian

'KAB '

kbd

Kabyle

KAB0

kab

Kachchi

'KAC '

kfr

Kalenjin

'KAL '

kln

Kannada

'KAN '

kan

Karachay

'KAR '

krc

Georgian

'KAT '

kat

Kawi (Old
Javanese)

'KAW '

kaw

Kazakh

'KAZ '

kaz

Kadiwéu

'KBC '

kbc

Makonde

'KDE '

kde

Kabuverdianu
(Crioulo)

'KEA '

kea

Kebena

'KEB '

ktb

Kekchi

'KEK '

kek

Khutsuri Georgian

'KGE '

kat

Kube

'KGF '

kgf

Khakass

'KHA '

kjh

Khanty-Kazim

'KHK '

kca

Khmer

'KHM '

khm

Khanty-Shurishkar

'KHS '

kca

Khamti Shan

'KHT '

kht

Khanty-Vakhi

'KHV '

kca

Khowar

'KHW '

khw

Kikuyu (Gikuyu)

'KIK '

kik

Kirghiz (Kyrgyz)

'KIR '

kir

Kisii

'KIS '

kqs, kss

Kirmanjki

'KIU '

kiu

Southern Kiwai

'KJD '

kjd

Khinalug

'KJJ '

kjj

Eastern Pwo Karen

'KJP '

kjp

Bumthangkha

'KJZ '

kjz

Kokni

'KKN '

kex

Kalmyk

'KLM '

xal

Kamba

'KMB '

kam

Kâte

'KMG '

kmg

Kumaoni

'KMN '

kfy

Komo

'KMO '

kmw

Komso

'KMS '

kxc

Khorasani Turkic

'KMZ '

kmz

Kanuri

'KNR '

kau

Kodagu

'KOD '

kfa

Korean Old

'KOH '

kor, okm

Konkani

'KOK '

kok

Komi

'KOM '

kom

Kikongo

'KON '

ktu

Kongo

KON0

kon

Komi-Permyak

'KOP '

koi

Korean

'KOR '

kor

Kosraean

'KOS '

kos

Komi-Zyrian

'KOZ '

kpv

Kpelle

'KPL '

kpe

Krio

'KRI '

kri

Karakalpak

'KRK '

kaa

Hangul

Karelian

'KRL '

krl

Karaim

'KRM '

kdr

Karen

'KRN '

blk, bwe, eky, ghk, jkm, jkp, kar, kjp, kjt, ksw, kvl, kvq, kvt, kvu,
kvy, kxf, kxk, kyu, pdu, pwo, pww, wea

Koorete

'KRT '

kqy

Kashmiri

'KSH '

kas

Ripuarian

KSH0

ksh

Khasi

'KSI '

kha

Kildin Sami

'KSM '

sjd

Khamyang

'KSU '

ksu

S’gaw Karen

'KSW '

ksw

Kuanyama

'KUA '

kua

Kui

'KUI '

kxu

Kulvi

'KUL '

kfx

Kumyk

'KUM '

kum

Kurdish

'KUR '

kur

Kurukh

'KUU '

kru

Kuy

'KUY '

kdt

Geba Karen

'KVQ '

kvq

Kwakʼwala

'KWK '

kwk

Koryak

'KYK '

kpy

Western Kayah

'KYU '

kyu

Ladin

'LAD '

lld

Lahuli

'LAH '

bfu

Lak

'LAK '

lbe

Lambani

'LAM '

lmn

Lao

'LAO '

lao

Latin

'LAT '

lat

Laz

'LAZ '

lzz

L-Cree

'LCR '

crm

Ladakhi

'LDK '

lbj

Lelemi

'LEF '

lef

Lezgi

'LEZ '

lez

Ligurian

'LIJ '

lij

Limburgish

'LIM '

lim

Lingala

'LIN '

lin

Lisu

'LIS '

lis

Liv

'LIV '

liv

Lampung

'LJP '

ljp

Laki

'LKI '

lki

Low Mari

'LMA '

mhr

Limbu

'LMB '

lif

Lombard

'LMO '

lmo

Lomwe

'LMW '

ngl

Loma

'LOM '

lom

Lipo

'LPO '

lpo

Luri

'LRC '

lrc, luz, bqi, zum

Lower Sorbian

'LSB '

dsb

Lule Sami

'LSM '

smj

Lithuanian

'LTH '

lit

Luxembourgish

'LTZ '

ltz

Luba-Lulua

'LUA '

lua

Luba-Katanga

'LUB '

lub

Ganda

'LUG '

lug

Luyia

'LUH '

luy

Luo

'LUO '

luo

Lushootseed

'LUT '

lut

Latvian

'LVI '

lav

Madura

'MAD '

mad

Magahi

'MAG '

mag

Marshallese

'MAH '

mah

Majang

'MAJ '

mpe

Makhuwa

'MAK '

vmw

Malayalam

'MAL '

mal

Mam

'MAM '

mam

Mansi

'MAN '

mns

Mapudungun

'MAP '

arn

Marathi

'MAR '

mar

Marwari

'MAW '

mwr, dhd, rwr, mve, wry, mtr, swv

Mbundu

'MBN '

kmb

Mbo

'MBO '

mbo

Manchu

'MCH '

mnc

Moose Cree

'MCR '

crm

Mende

'MDE '

men

Mandar

'MDR '

mdr

Me’en

'MEN '

mym

Meru

'MER '

mer

Mano

'MEV '

mev

Pattani Malay

'MFA '

mfa

Morisyen

'MFE '

mfe

Minangkabau

'MIN '

min

Mizo

'MIZ '

lus

Macedonian

'MKD '

mkd

Makasar

'MKR '

mak

Kituba

'MKW '

mkw

Male

'MLE '

mdy

Malagasy

'MLG '

mlg

Malinke

'MLN '

mlq

Malayalam
Reformed

'MLR '

mal

Malay

'MLY '

msa

Mandinka

'MND '

mnk

Mongolian

'MNG '

mon

Manipuri

'MNI '

mni

Maninka

'MNK '

man, mnk, myq, mku, msc, emk, mwk, mlq

Manx

'MNX '

glv

Mohawk

'MOH '

moh

Moksha

'MOK '

mdf

Moldavian

'MOL '

mol

Mon

'MON '

mnw

Thailand Mon

'MONT'

mnw
See https://www.unicode.org/L2/L2020/20163-arakanesemon.pdf

Moroccan

'MOR '

Mossi

'MOS '

mos

Maori

'MRI '

mri

Maithili

'MTH '

mai

Maltese

'MTS '

mlt

Mundari

'MUN '

unr

Muscogee

'MUS '

mus

Mirandese

'MWL '

mwl

Hmong Daw

'MWW '

mww

Mayan

'MYN '

acr, agu, caa, cac, cak, chf, ckz, cob, ctu, emy, hus, itz, ixl, jac,
kek, kjb, knj, lac, mam, mhc, mop, myn, poc, poh, quc, qum,
quv, toj, ttc, tzh, tzj, tzo, usp, yua

Mazanderani

'MZN '

mzn

Naga-Assamese

'NAG '

nag

Nahuatl

'NAH '

azd, azn, azz, nah, naz, nch, nci, ncj, ncl, ncx, ngu, nhc, nhe,
nhg, nhi, nhk, nhm, nhn, nhp, nhq, nht, nhv, nhw, nhx, nhy,
nhz, nlv, npl, nsu, nuz

Nanai

'NAN '

gld

Neapolitan

'NAP '

nap

Naskapi

'NAS '

nsk

Nauruan

'NAU '

nau

Navajo

'NAV '

nav

N-Cree

'NCR '

csw

Ndebele

'NDB '

nbl, nde

Ndau

'NDC '

ndc

Ndonga

'NDG '

ndo

Low Saxon

'NDS '

nds

Nepali

'NEP '

nep

Newari

'NEW '

new

Ngbaka

'NGA '

nga

Nagari

'NGR '

Norway House

'NHC '

csw

Nisi

'NIS '

dap, njz, tgj

Niuean

'NIU '

niu

Nyankole

'NKL '

nyn

Cree

N’Ko

'NKO '

nqo

Dutch

'NLD '

nld

Nimadi

'NOE '

noe

Nogai

'NOG '

nog

Numanggang

'NOP '

nop

Norwegian

'NOR '

nob

Novial

'NOV '

nov

Northern Sami

'NSM '

sme

Northern Sotho

'NSO '

nso

Northern Tai

'NTA '

nod

Esperanto

'NTO '

epo

Nuu-chah-nulth

'NUK '

nuk

Nyamwezi

'NYM '

nym

Norwegian

'NYN '

nno

Mbembe Tigon

'NZA '

nza

Occitan

'OCI '

oci

Oji-Cree

'OCR '

ojs

Ojibway

'OJB '

oji

Oneida

'ONE '

one

Onondaga

'ONO '

ono

Odia

'ORI '

ori

Oromo

'ORO '

orm

Ossetian

'OSS '

oss

Palestinian
Aramaic

'PAA '

sam

Pangasinan

'PAG '

pag

Nynorsk (Nynorsk,
Norwegian)

Pali

'PAL '

pli

Pampangan

'PAM '

pam

Punjabi

'PAN '

pan

Palpa

'PAP '

plp

Papiamentu

PAP0

pap

Pashto

'PAS '

pus

Palauan

'PAU '

pau

Bouyei

'PCC '

pcc

Picard

'PCD '

pcd

Pennsylvania

'PDC '

pdc

Polytonic Greek

'PGR '

ell

Phake

'PHK '

phk

Norfolk

'PIH '

pih

Filipino

'PIL '

fil

Palaung

'PLG '

pce, rbb, pll

Pilagá

'PLG0'

plg

Polish

'PLK '

pol

Piemontese

'PMS '

pms

Western Panjabi

'PNB '

pnb

Pocomchi

'POH '

poh

Pohnpeian

'PON '

pon

Provençal / Old

'PRO '

pro

Portuguese

'PTG '

por

Western Pwo
Karen

'PWO '

pwo

Chin

'QIN '

bgr, biu, cek, cey, cfm, cbl, cka, ckn, clj, clt, cmr, cnb, cnh, cnk,
cnw, csh, csj, csv, csy, ctd, cth, czt, dao, gnb, hlt, hmr, hra, lus,

German

Provençal

mrh, mwq, pck, pkh, pub, ral, rtc, sch, sez, shl, smt, tcp, tcz,
vap, weu, zom, zyp
K’iche’

'QUC '

quc

Quechua (Bolivia)

'QUH '

quh

Quechua

'QUZ '

quz

Quechua

'QVI '

qvi

Quechua (Peru)

'QWH '

qwh

Rajasthani

'RAJ '

raj

Rarotongan

'RAR '

rar

Russian Buriat

'RBU '

bxr

R-Cree

'RCR '

atj

Rejang

'REJ '

rej

Riang

'RIA '

ria

Rohingya

'RHG '

rhg

Tarifit

'RIF '

rif

Ritarungo

'RIT '

rit

Arakwal

'RKW '

rkw

Romansh

'RMS '

roh

Vlax Romani

'RMY '

rmy

Romanian

'ROM '

ron

Romany

'ROY '

rom

Rusyn

'RSY '

rue

Rotuman

'RTM '

rtm

Kinyarwanda

'RUA '

kin

Rundi

'RUN '

run

Aromanian

'RUP '

rup

Russian

'RUS '

rus

(Ecuador)

Sadri

'SAD '

sck

Sanskrit

'SAN '

san

Sasak

'SAS '

sas

Santali

'SAT '

sat

Sayisi

'SAY '

chp

Sicilian

'SCN '

scn

Scots

'SCO '

sco

North Slavey

'SCS '

scs

Seneca

'SEE '

see

Sekota

'SEK '

xan

Selkup

'SEL '

sel

Small Flowery
Miao

'SFM '

sfm

Old Irish

'SGA '

mga, sga

Sango

'SGO '

sag

Samogitian

'SGS '

sgs

Tachelhit

'SHI '

shi

Shan

'SHN '

shn

Sibe

'SIB '

sjo

Sidamo

'SID '

sid

Silte Gurage

'SIG '

xst, stv, wle

Epena

'SJA '

sja

Pite Sami

'SJE '

sje

Ume Sami

'SJU '

sju

Skolt Sami

'SKS '

sms

Slovak

'SKY '

slk

Slavey

'SLA '

den, scs, xsl

Slovenian

'SLV '

slv

Somali

'SML '

som

Samoan

'SMO '

smo

Sena

'SNA '

seh

Shona

SNA0

sna

Sindhi

'SND '

snd

Sinhala (Sinhalese)

'SNH '

sin

Soninke

'SNK '

snk

Sodo Gurage

'SOG '

gru

Songe

'SOP '

sop

Southern Sotho

'SOT '

sot

Albanian

'SQI '

sqi

Serbian

'SRB '

cnr, srp

Sardinian

'SRD '

srd

Saraiki

'SRK '

skr

Serer

'SRR '

srr

South Slavey

'SSL '

xsl

Southern Sami

'SSM '

sma

Straits Salish

'STR '

str

Saterland Frisian

'STQ '

stq

Sukuma

'SUK '

suk

Sundanese

'SUN '

sun

Suri

'SUR '

suq

Svan

'SVA '

sva

Swedish

'SVE '

swe

Swadaya Aramaic

'SWA '

aii

Swahili

'SWK '

swa

Swati

'SWZ '

ssw

Sutu

'SXT '

ngo, xnj, xnq

Upper Saxon

'SXU '

sxu

Sylheti

'SYL '

syl

Syriac

'SYR '

aii, amw, cld, syc, syr, tru

Syriac, Estrangela
script-variant

SYRE

syc, syr

SYRJ

syc, syr

SYRN

syc, syr

Silesian

'SZL '

szl

Tabasaran

'TAB '

tab

Tajiki

'TAJ '

tgk

Tamil

'TAM '

tam

Tamasheq

'TAQ '

taq
See also 'TMH '

Tatar

'TAT '

tat

Tobo

'TBV '

tbv

TH-Cree

'TCR '

cwd

Emberá-Tadó

'TDC '

tdc

Dehong Dai

'TDD '

tdd

Telugu

'TEL '

tel

Tetum

'TET '

tet

Tagalog

'TGL '

tgl

Tongan

'TGN '

ton

Tigre

'TGR '

tig

(equivalent to ISO
15924 'Syre')
Syriac, Western
script-variant
(equivalent to ISO
15924 'Syrj')
Syriac, Eastern
script-variant
(equivalent to ISO
15924 'Syrn')

Tigrinya

'TGY '

tir

Thai

'THA '

tha

Tahitian

'THT '

tah

Thompson

'THP '

thp

Tahaggart
Tamahaq

'THV '

thv
See also 'TMH '

Tayart Tamajeq

'THZ '

thz
See also 'TMH '

Tibetan

'TIB '

bod

Tiv

'TIV '

tiv

Tai Laing

'TJL '

tjl

Turkmen

'TKM '

tuk

Tlingit

'TLI '

tli

Tamashek

'TMH '

taq, thv, thz, tmh, ttq
See also 'TAQ ', 'THV ', 'THZ ', 'TTQ '

Talysh

'TLY '

tly

Temne

'TMN '

tem

Tswana

'TNA '

tsn

Tundra Enets

'TNE '

enh

Tonga

'TNG '

toi

Todo

'TOD '

xal

Toma

TOD0

tod

Tok Pisin

'TPI '

tpi

Turkish

'TRK '

tur

Tsonga

'TSG '

tso

Tshangla

'TSJ '

tsj

Tawallammat
Tamajaq

'TTQ '

ttq
See also 'TMH '

Turoyo Aramaic

'TUA '

tru

Tulu

'TUL '

tcy

Tumbuka

'TUM '

tum

Tuscarora

'TUS '

tus

Tuvin

'TUV '

tyv

Tuvalu

'TVL '

tvl

Twi

'TWI '

twi

Tày

'TYZ '

tyz

Tamazight

'TZM '

tzm

Tzotzil

'TZO '

tzo

Udi

'UDI '

udi

Udmurt

'UDM '

udm

Ukrainian

'UKR '

ukr

Umbundu

'UMB '

umb

Uralic Phonetic

'UPPH'

Cf. BCP 47 variant subtag “fonupa” (see

Alphabet

https://www.iana.org/assignments/lang-subtagstemplates/fonupa.txt )

Urdu

'URD '

urd

Upper Sorbian

'USB '

hsb

Uyghur

'UYG '

uig

Uzbek

'UZB '

uzb

Venetian

'VEC '

vec

Venda

'VEN '

ven

Vietnamese

'VIT '

vie

Volapük

'VOL '

vol

Võro

'VRO '

vro

Wa

'WA '

wbm

Wagdi

'WAG '

wbr

Waray-Waray

'WAR '

war

Wakhi

'WBL '

wbl

Waci Gbe

'WCI '

wci

West-Cree

'WCR '

crk

Wendat

'WDT '

wdt

Welsh

'WEL '

cym

Wolof

'WLF '

wol

Walloon

'WLN '

wln

Mewati

'WTM '

wtm

Wyandot

'WYN '

wyn

Lü

'XBD '

khb

Xhosa

'XHS '

xho

Minjangbal

'XJB '

xjb

Khengkha

'XKF '

xkf

Soga

'XOG '

xog

Kpelle (Liberia)

'XPE '

xpe

Bette Kuruma

'XUB '

xub

Jennu Kuruma

'XUJ '

xuj

Sakha

'YAK '

sah

Yao

'YAO '

yao

Yapese

'YAP '

yap

Yoruba

'YBA '

yor

Y-Cree

'YCR '

crj, crk, crl

Gepo

'YGP '

ygp

Yi Classic

'YIC '

Yi Modern

'YIM '

iii

Aluo

'YNA '

yna

HavasupaiWalapai-Yavapai

'YUF '

yuf

Wuding-Luquan Yi

'YWQ '

ywq

Zealandic

'ZEA '

zea

Standard
Moroccan

'ZGH '

zgh

Zhuang

'ZHA '

zha

Chinese,

'ZHH '

zho

Chinese, Phonetic

'ZHP '

zho

Chinese,

'ZHS '

zho

'ZHT '

zho

'ZHTM'

zho

Zande

'ZND '

zne

Zulu

'ZUL '

zul

Zazaki

'ZZA '

zza

Tamazight

Traditional, Hong
Kong SAR

Simplified
Chinese,
Traditional
Chinese,
Traditional, Macao
SAR

Feature Tags
Article • 05/31/2024

Features provide information about how to use the glyphs in a font to layout text for a
script or language. For example, an Arabic font might have a feature for substituting
initial glyph forms, and a Kanji font might have a feature for positioning glyphs
vertically. All OpenType Layout features define data for glyph substitution, glyph
positioning, or both.
Each OpenType Layout feature has a feature tag that identifies its typographic function
and effects. By examining a feature’s tag, a text-processing client can determine what a
feature does and decide whether to utilize it during text layout.
All tags are four-character strings composed of a limited set of ASCII characters; for
details regarding the Tag data type, see Data Types. By convention, registered feature
tags use four lowercase letters. For instance, the 'mark' feature is used in managing the
placement of diacritical marks, and the 'swsh' feature is used to select alternate swash
glyphs.
The tag space of tags consisting of four uppercase letters (A-Z) with no punctuation,
spaces, or numbers, is reserved as a vendor space. Font vendors may use such tags to
identify private features. For example, the feature tag PKRN might designate a private
feature used to kern punctuation marks. Interoperability of private features is not
guaranteed.
A feature definition might not provide all the information required to properly
implement glyph substitution or positioning actions. In many cases, a text-processing
client may need to supply additional data. For example, the function of the 'init' feature
is to provide initial glyph forms. Nothing in the feature’s lookup tables indicates when or
where to apply this feature during text processing. To correctly use the 'init' feature in
Arabic text, in which initial glyph forms appear at the beginning of connected letter
groups determined by character-joining properties, text-processing clients must be able
to identify the glyphs to which the feature should be applied, based on character
context and joining properties. In all cases, the text-processing client is responsible for
applying, combining, and arbitrating among features and rendering the result.
The feature descriptions provided can include details regarding suggested lookup types
that can be used to implement a feature. Some feature descriptions include featurespecific details regarding how text-layout software is expected to interact with the
feature. General information on processing of lookup tables is provided in the 'GPOS',
'GSUB' and OpenType Layout Common Table Formats chapters. Information provided in

feature descriptions regarding lookups and lookup types is provided only as
recommendations or suggestions; the set of lookups used to implement a feature may
vary across platforms, applications, fonts, and font developers.

Registered features
Features listed alphabetically
Feature descriptions and implementations

How to register features
Microsoft encourages font developers to use “registered” feature tags when
implementing registered features. However, font developers also may define and
register their own features.
Microsoft welcomes nominations for new features and feature tags to register. To qualify
for registration, a feature must have a single function that is clearly identified by its tag.
The function of the feature should be defined at the lowest useful level and must be
distinctly different from the functions of currently registered features. When font
developers register feature tags and functions with Microsoft, they do not have to
supply implementation details.
Microsoft reserves the right to officially assign feature tags in the Microsoft Tag Registry.
Although Microsoft has reserved the feature and feature tag definitions listed in this
registry, Microsoft fonts do not necessarily contain all of the features.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

Registered Features: Descriptions and
Implementations (a – e)
Article • 07/06/2024

a-e|f-j|k-o|p-t|u-z

Tag: 'aalt'
Friendly name: Access All Alternates
Registered by: Adobe
Function: This feature makes all variations of a selected character accessible. This serves
several purposes: An application might not support the feature by which the desired
glyph would normally be accessed; the user could need a glyph outside the context
supported by the normal substitution, or the user might not know what feature
produces the desired glyph.
Example: A user inputs the P in Poetica and is presented with a choice of the four
standard capital forms, the eight swash capital forms, the initial capital form and the
small capital form.
Recommended implementation: A GSUB type 3 lookup subtable should normally be
used. The type 3 formats arrange glyphs into groupings of related glyphs. For example,
the default glyph for a Unicode character and the associated set of alternate glyphs for
that character. The default glyph can be included in the set of alternates, in which case it
should be the first alternate.
A GSUB type 1 lookup subtable could also be used if a default glyph has only one
alternate. A lookup could combine type 3 and type 1 subtables. Other lookup subtable
types are not recommended.
Ligature glyphs should not be included as alternates of the glyph for any ligature
component. For example, an fi ligature glyph should not be included as an alternate for
f. Ligature glyphs can be included in an alternate set if they are variants of another
ligature glyph, however.
If different fonts within a typographic family have the same alternates, the ordering of
glyphs within the alternate sets should match across these fonts so that corresponding
alternates will be selected when switching between fonts in the family.

Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria. The application determines
the glyph ID for the default form of a given character (default glyph from the 'cmap'
table with no features applied). It then checks to see whether the glyph ID is found in
the coverage table of an 'aalt' lookup. If so, the application retrieves the alternate glyphs
mapped in the alternate substitution lookup and selects one.
UI suggestion: The application should indicate to the user which glyphs in the user’s
document have alternative forms (i.e., which are in the coverage table for 'aalt'), and
provide some means for the user to select an alternate glyph. An application could
display the forms sequentially in context, or present a palette showing all the forms at
once, or give the user a choice between these approaches. The application may assume
that the first glyph in a set is the preferred form, so the font developer should order
them accordingly. When only one alternate exists, this feature could toggle directly
between the alternate and default forms.
Script/language sensitivity: None.
Feature interaction: This feature may be used in combination with other features.

Tag: 'abvf'
Friendly name: Above-base Forms
Registered by: Microsoft
Function: Substitutes the above-base form of a vowel. In particular, this feature is used
for certain “split” vowels in Khmer or other Brahmi-derived scripts if the character has
separate components that appear before and above a consonant, but the Unicode
character for the vowel does not have a decomposition into separate characters for the
two components.
Example: In Khmer script, U+17BE KHMER VOWEL SIGN OE needs to be split into a prebase form and an above-base form. The above-base form of OE would be substituted to
form the correct piece of the vowel that is displayed above the base consonant.
Recommended implementation: This feature is used to map the default glyph for OE to a
glyph for the above-base component (GSUB lookup type 1).
Application interface: In recommended usage, this feature triggers substitutions required
for correct display of Khmer script. It should be applied in the appropriate contexts, as
determined by script-specific processing requirements. In particular, in a cluster in which

the applicable split vowel is used, the application must insert the pre-base glyph into
the correct location and then apply the above-base form feature to the split vowel.
UI suggestion: Control of the feature should not generally be exposed to the user.
Script/language sensitivity: Used for Khmer script. May also be used for other Brahmiderived scripts.
Feature interaction: This feature overrides the results of all other features.

Tag: 'abvm'
Friendly name: Above-base Mark Positioning
Registered by: Microsoft
Function: Positions marks above base glyphs.
Example: In complex scripts like Devanagari (Indic), the Anuswar needs to be positioned
above the base glyph. This base glyph can be a base consonant or conjunct. The base
glyph and the presence/absence of other marks above the base glyph decides the
location of the Anuswar, so that they do not overlap one another.
Recommended implementation: A lookup table for the 'abvm' feature provides
positioning information (x,y) to enable mark positioning (GPOS lookup type 4, 5).
Application interface: In recommended usage, this feature triggers positioning of mark
glyphs required for correct display of certain scripts. It should be applied in the
appropriate contexts, as determined by script-specific processing requirements.
UI suggestion: Control of the feature should not generally be exposed to the user.
Script/language sensitivity: Used for Indic or other Brahmi-derived scripts.
Feature interaction: Can be used to position default marks; or those that have been
selected from a number of alternates based on contextual requirement using a feature
like 'abvs'.

Tag: 'abvs'
Friendly name: Above-base Substitutions
Registered by: Microsoft
Function: Substitutes a ligature for a base glyph and mark that’s above it.

Example: In complex scripts like Kannada (Indic), the vowel sign for the vowel I which a
mark, is positioned above base consonants. This mark combines with the consonant Ga
to form a ligature.
Recommended implementation: The 'abvs' feature is used to map consonant vowel
sequences to corresponding ligature glyphs (GSUB lookup type 4).
Application interface: In recommended usage, this feature triggers substitutions required
for correct display of certain scripts. It should be applied in the appropriate contexts, as
determined by script-specific processing requirements.
UI suggestion: Control of the feature should not generally be exposed to the user.
Script/language sensitivity: Used for Indic or other Brahmi-derived scripts.
Feature interaction: None.

Tag: 'afrc'
Friendly name: Alternative Fractions
Registered by: Microsoft
Function: Replaces figures separated by a slash with an alternative form.
Example: The user enters 3/4 in a recipe and get the three-quarters nut fraction.
Recommended implementation: Sequences of glyphs for figures (digits) separated by a
slash (U+002F) or fraction slash (U+2044) are mapped to a corresponding ligature glyph
for the fraction (GSUB lookup type 4).
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria. The application applies the
feature to a complete sequence of figures separated by slash (U+002F) or fraction slash
(U+2044).
UI suggestion: This feature should be off by default.
Script/language sensitivity: None.
Feature interaction: This feature overrides the results of all other features.

Tag: 'akhn'
Friendly name: Akhand

Registered by: Microsoft
Function: Preferentially substitutes default glyphs for a sequence of characters with a
ligature. This substitution is done irrespective of any characters that may precede or
follow the sequence.
Example: In Devanagari script, the form Kssa is considered an Akhand character
(meaning unbreakable), and the sequence Ka, Halant, Ssa should always produce the
ligature Kssa, irrespective of characters that precede/follow the above given sequence.
Recommended implementation: This feature is used to map sequences that form
Akhands to the corresponding ligature glyph (GSUB lookup type 4).
Application interface: In recommended usage, this feature triggers substitutions required
for correct display of certain scripts. It should be applied in the appropriate contexts, as
determined by script-specific processing requirements.
UI suggestion: Control of the feature should not generally be exposed to the user.
Script/language sensitivity: Used for Indic or other Brahmi-derived scripts.
Feature interaction: This feature is used in conjunction with certain other features to
derive required forms of Indic scripts. The application is expected to process this feature
and certain other features in an appropriate order to obtain the correct set of basic
forms: 'nukt', 'akhn', 'rphf', 'rkrf', 'pref', 'blwf', 'half', 'pstf', 'cjct'. Other discretionary
features for optional typographic effects may also be applied. Lookups for such
discretionary features should be processed after lookups for this feature have been
processed.

Tag: 'apkn'
Friendly name: Kerning for Alternate Proportional Widths.
Registerd by: Adobe/Microsoft
Function: Applies kerning adjustments to glyphs that have fixed advance widths by
default but have been adjusted to proportional widths by application of the 'palt'
feature.
Example: A user activates proportional metrics ('palt') in Japanese text, which results in
some glyphs that had fixed advance widths by default now having proportional widths.
By activating the 'apkn' feature as well, those glyphs are then kerned with other glyphs.
For instance, the glyphs for U+30A2 “ア” and U+30CE “ノ” have full-width advances by

default; the 'palt' feature adjusts these glyphs to have a narrower, proportional width;
the 'apkn' feature then shifts these glyphs closer together in the combination “アノ”.
Recommended implementation: The font kerns Kanji, Kana, Latin, punctuation, or other
glyphs that have fixed-width metrics by default if those glyphs are also adjusted to
proportional widths by the 'palt' feature.
Primarily intended for use in the GPOS table. Positioning adjustments can be
implemented using GPOS pair-adjustment (type 2) lookups. Single-adjustment and pairadjustment lookups have simple additive effect, therefore relative ordering of lookups
for this feature and type 1 or type 2 lookups for 'palt' or other similar features
implemented using GPOS type 1 or type 2 lookups is not crucial.
For glyphs that have fixed widths by default but that can have metrics adjusted by the
'palt' feature, it is strongly recommended that those glyphs not be kerned with other
glyphs using the 'kern' feature; these should only be kerned by application of this
feature.
UI suggestion: This feature should be off by default. If the font used for a text run
implements the 'palt' feature, activation on that text run should be possible only if the
'palt' feature has been activated on that run. If 'palt' has been activated for a run, then
this feature may be automatically activated, but the UI should also provide a way for a
user optionally to deactivate the feature while 'palt' is still activated.
Script/language sensitivity: Intended primarily for CJK fonts but can be used in fonts for
any script that have fixed advance widths by default.
Feature interaction: Should only be implemented in fonts that also implement the 'palt'
feature, which this feature is intended to complement. This feature should only be
activated on a text run if 'palt' has been activated, but activation when that feature has
been applied is optional and should be under user control. If activated on a run and
later the 'palt' feature is deactivated for that run, then this feature should also be
deactivated, as the kerning adjustments applied by this feature would not be
appropriate for glyphs with fixed-width metrics.
In the recommended implementation for this feature, it acts only on characters that
have fixed-width glyphs by default but that acquire proportional widths by application
of the 'palt' feature. As a result, it can be deactivated on any text run that does not have
'palt' activated without any need to scan lookup tables to determine which glyphs do or
do not require deactivation.

Tag: 'blwf'

Friendly name: Below-base Forms
Registered by: Microsoft
Function: Substitutes the below-base form of a consonant in conjuncts.
Example: In complex scripts like Odia (Indic), the consonant Va has a below-base form
that is used to generate conjuncts. Given a sequence Gha, Virama (Halant), Va; the
below-base form of Va would be substituted to form the conjunct GhVa.
Recommended implementation: This feature is used to map a virama (halant) plus
consonant sequence to the glyph for the below base form of the consonant (GSUB
lookup type 4).
Application interface: In recommended usage, this feature triggers substitutions required
for correct display of certain scripts. It should be applied in the appropriate contexts, as
determined by script-specific processing requirements.
UI suggestion: Control of the feature should not generally be exposed to the user.
Script/language sensitivity: Used for many Indic or other Brahmi-derived scripts.
Feature interaction: This feature is used in conjunction with certain other features to
derive required forms of Indic and Indic-related scripts. For Indic scripts, the application
is expected to process this feature and certain other features in an appropriate order to
obtain the correct set of basic forms: 'nukt', 'akhn', 'rphf', 'rkrf', 'pref', 'blwf', 'half', 'pstf',
'cjct'. Other discretionary features for optional typographic effects may also be applied.
Lookups for such discretionary features should be processed after lookups for this
feature have been processed.

Tag: 'blwm'
Friendly name: Below-base Mark Positioning
Registered by: Microsoft
Function: Positions marks below base glyphs.
Example: In complex scripts like Gujarati (Indic), the vowel sign U needs to be positioned
below base consonant/conjuncts that form the base glyph. This position can vary
depending on the base glyph, as well as the presence/absence of other marks below the
base glyph.
Recommended implementation: A lookup table for the 'blwm' feature provides
positioning information (x,y) to enable mark positioning (GPOS lookup type 4, 5).

Application interface: In recommended usage, this feature triggers positioning of mark
glyphs required for correct display of certain scripts. It should be applied in the
appropriate contexts, as determined by script-specific processing requirements.
UI suggestion: Control of the feature should not generally be exposed to the user.
Script/language sensitivity: Used for Indic or other Brahmi-derived scripts.
Feature interaction: Can be used to position default marks; or those that have been
selected from a number of alternates based on contextual requirement using a feature
like 'blws'.

Tag: 'blws'
Friendly name: Below-base Substitutions
Registered by: Microsoft
Function: Produces ligatures that comprise of base glyph and below-base forms.
Example: In the Malayalam script (Indic), the conjunct Kla, requires a ligature which is
formed using the base glyph Ka and the below-base form of consonant La. This feature
can also be used to substitute ligatures formed using base glyphs and below base
matras in Indic scripts.
Recommended implementation: The 'blws' feature is used to map consonant conjunct
sequences or consonant vowel sequences to corresponding ligature glyphs (GSUB
lookup type 4).
Application interface: In recommended usage, this feature triggers substitutions required
for correct display of certain scripts. It should be applied in the appropriate contexts, as
determined by script-specific processing requirements.
UI suggestion: Control of the feature should not generally be exposed to the user.
Script/language sensitivity: Used for Indic or other Brahmi-derived scripts.
Feature interaction: This feature overrides the results of all other features.

Tag: 'calt'
Friendly name: Contextual Alternates
Registered by: Adobe

Function: In specified situations, replaces default glyphs with alternate forms which
provide better joining behavior. Used in script typefaces which are designed to have
some or all of their glyphs join.
Example: In Caflisch Script, o is replaced by o.alt2 when followed by an ascending
letterform.
Recommended implementation: A lookup table for the 'calt' feature specifies the context
in which each substitution occurs, and maps one or more default glyphs to replacement
glyphs (GSUB lookup type 6).
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria.
UI suggestion: This feature should be active by default.
Script/language sensitivity: Can be used with scripts that have optional, cursive styles.
Feature interaction: This feature may be used in combination with other substitution
(GSUB) features, whose results it may override.

Tag: 'case'
Friendly name: Case-sensitive Forms
Registered by: Adobe
Function: Shifts various punctuation marks up to a position that works better with allcapital sequences or sets of lining figures; also changes oldstyle figures to lining figures.
By default, glyphs in a text face are designed to work with lowercase characters. Some
characters should be shifted vertically to fit the higher visual center of all-capital or
lining text. Also, lining figures are the same height (or close to it) as capitals, and fit
much better with all-capital text.
Example: The user selects a block of text and applies this feature. The dashes, bracketing
characters, guillemet quotes and the like shift up to match the capitals, and oldstyle
figures change to lining figures.
Recommended implementation: The font may implement this change by substituting
different glyphs (GSUB lookup type 1) or by repositioning the original glyphs (GPOS
lookup type 1, xPlacement and yPlacement).
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria.

UI suggestion: It would be good to apply this feature (or turn it off) automatically when
the user changes case on a sequence of more than one character. Applications could
also detect words consisting only of capitals, and apply this feature based on user
preference settings.
Script/language sensitivity: Applies only to European scripts; particularly prominent in
Spanish-language setting.
Feature interaction: This feature overrides the results of other features affecting the
figures (e.g. 'onum' and 'tnum').

Tag: 'ccmp'
Friendly name: Glyph Composition / Decomposition
Registered by: Microsoft
Function: To minimize the number of glyph alternates, it is sometimes desirable to
decompose the default glyph for a character into two or more glyphs. Additionally, it
may be preferable to compose default glyphs for two or more characters into a single
glyph for better glyph processing. This feature permits such
composition/decomposition. The feature should be processed as the first feature
processed, and should be processed only when it is called.
Example: In Syriac, the character 0x0732 is a combining mark that has a dot above AND
a dot below the base character. To avoid multiple glyph variants to fit all base glyphs,
the default glyph for the character is decomposed into two glyphs: a dot above and a
dot below. These two glyphs can then be correctly placed using GPOS. In Arabic it might
be preferred to combine the shadda with fatha (0x0651, 0x064E) into a ligature before
processing shapes. This allows the font vendor to do special handling of the mark
combination when doing further processing without requiring larger contextual rules.
Recommended implementation: Glyphs for multiple characters are mapped to a single
glyph (GSUB lookup type 4), or the glyph for a character is mapped to a sequence of
glyphs (GSUB lookup type 2).
Application interface: This feature should always be applied.
UI suggestion: Control of the feature should not generally be exposed to the user.
Script/language sensitivity: None.
Feature interaction: This feature needs to be implemented prior to any other feature.

Tag: 'cfar'
Friendly name: Conjunct Form After Ro
Registered by: Microsoft
Function: Substitutes alternate below-base or post-base forms in Khmer script when
occurring after conjoined Ro (“Coeng Ra”).
In Khmer script, the conjoined form of Ro is reordered to the left of the base consonant.
It wraps under the base consonant, however, and so can interact typographically with
below-base or post-base conjoined consonant and vowel forms. After the application
has reordered the glyph for the conjoined Ro, it is no longer in the immediate context of
glyphs for below-base or post-base forms. The application can detect this and apply this
feature over the range for the below-base and post-base conjoining forms, triggering
lookups to substitute alternate below-base or post-base forms as may be needed.
Example: In the Khmer script, Coeng Ro is denoted by a pre-base conjoining form, and
Coeng Yo is denoted by a post-base conjoining form, but in both cases part of the form
wraps under the base. The consonant cluster TRYo is denoted with an alternate form of
Coeng Ya that descends lower so that it does not collide below the base with the Coeng
Ro.
Recommended implementation: A GSUB type 1 lookup substitutes a below-base or postbase conjoining form by an alternate form.
Application interface: In recommended usage, this feature triggers substitutions that are
required for correct display of Khmer script. It should be applied in the appropriate
contexts, as determined by script-specific processing requirements. In particular, the
application is expected to apply this feature if a syllable contains a Coeng Ra followed
by other conjoining consonants or vowels.
UI suggestion: Control of the feature should not generally be exposed to the user.
Script/language sensitivity: Used for Khmer script.
Feature interaction: This feature is used in conjunction with certain other features to
derive required forms of Khmer script. Other discretionary features for optional
typographic effects may also be applied. Lookups for such discretionary features should
be processed after lookups for this feature have been processed.

Tag: 'chws'

Friendly name: Contextual Half-width Spacing
Registered by: Adobe/W3C
Function: Contextually re-spaces glyphs that have full-em widths by default, fitting them
onto half-em horizontal widths to approximate more sophisticated text layout, such as
what is described in Requirements for Japanese Text Layout (JLREQ)

or similar CJK

text-layout specifications that expect half-width forms of characters whose default
glyphs are full-width. This feature differs from 'halt' in that the re-spacing is contextual.
This feature may be invoked to get better fit for punctuation or symbol glyphs without
disrupting the monospaced alignment, such as for UIs or terminal apps.
(In JLREQ, see, in particular, 3.1.4 Positioning of Consecutive Opening Brackets, Closing
Brackets, Commas, Full Stops and Middle Dots

, and B. Spacing between Characters

See also Requirements for Chinese Text Layout (CLREQ)
Layout (KLREQ)

.

, Requirements for Hangul Text

.)

Example: When FULLWIDTH RIGHT PARENTHESIS (U+FF09; “）”) is followed by
IDEOGRAPHIC COMMA (U+3001; “、”), the former is re-spaced to remove half-em of
width between them.
Recommended implementation: The font specifies positioning adjustments for pairs of
glyphs (GPOS lookup type 2 or 8, xPlacement, xAdvance, yPlacement, and yAdvance).
Pairs can be defined using left and right classes of glyphs or using specific glyph IDs.
Additional adjustments may be provided for larger sequences of glyphs (e.g., triplets,
quadruplets, etc.) and ordered to take precedence over pair kern adjustments of
particular combinations.
When using a GPOS type 2 lookup for this feature, it is recommended that no
positioning adjustment be applied to the second glyph in a pair. (That is, that
valueFormat2 should be set to 0.) As a result, the next glyph pair to be processed after
the lookup has been applied to this pair will start at the second glyph. In this way, every
glyph in a sequence can undergo positioning adjustment as the first glyph in a pair.
Otherwise, if positioning of the second glyph is adjusted, then the next glyph pair to be
processed will begin with the glyph following the second glyph. That will result in
spacing adjustment happening only for every other pair of glyphs.
Application interface: If a layout engine supports advanced layout for CJK text as
described in CLREQ

, JLREQ

or KLREQ

, this feature should not be used. Otherwise,

this feature should always be supported for horizontal layout of CJK text.
UI suggestion: This feature should not be used in combination with a layout engine that
independently provides advanced layout as described in CLREQ

, JLREQ

or KLREQ

.

For applications that provide such advanced layout, it may be appropriate not to expose

control of this feature to users. In applications that do not support such advanced
layout, this feature should be enabled by default for horizontal layout of CJK text. See
below for details on important feature interactions.
Script/language sensitivity: Used mostly in CJKV fonts.
Feature interaction: This feature is mutually exclusive to all other horizontal glyph-width
features ('fwid', 'halt', 'hwid', 'palt', 'pkna', 'pwid', 'qwid', 'twid', 'pnum', 'tnum'), which
should be turned off when this feature is applied. When applied to a text run, the 'apkn'
and 'kern' features should be disabled for that run. See also 'vchw'.

Tag: 'cjct'
Friendly name: Conjunct Forms
Registered by: Microsoft
Function: Produces conjunct forms of consonants in Indic scripts. This is similar to the
Akhands feature, but is applied at a different sequential point in the process of shaping
an Indic syllable.
Indic scripts are associated with conjoining-consonant behaviors, such as the use of
“half” forms. Some consonants might not have half forms and not exhibit conjoining
behavior when combined with certain consonants, yet may conjoin as ligature forms
with other consonants. Whether a given pair of consonants conjoins may impact other
shaping behaviors for a syllable, such as where a reordering vowel mark or reph is
placed. The Conjunct Forms feature can be used at a point in the shaping process
immediately before final reordering such that the application can determine whether a
reordering vowel or reph is placed in relation to the consonants.
More generally, the Akhands feature and Conjunct Forms feature can be used at two
points in the shaping of an Indic syllable, together with other features such as Half
Forms and Below Forms applied in between, providing the font developer with flexibility
in how the shapes for Indic syllables are derived from the default glyphs for the
character sequence.
Example: In Hindi (Devanagari script), the consonant cluster DGa is denoted with a
conjunct ligature form.
Recommended implementation: A glyph for a consonant conjunct form is mapped from
a sequence of two or more glyphs for consonants separated by virama (halant) (e.g., C H
C, or C H C H C, etc.); or from sequences of glyphs involving simpler consonant

conjuncts or conjoining consonant forms resulting from earlier substitutions from
default consonant + virama + consonant (+ etc.) sequences (GSUB lookup type 4).
Application interface: In recommended usage, this feature triggers substitutions that are
required for correct display of the given script. It should be applied in the appropriate
contexts, as determined by script-specific processing requirements.
UI suggestion: Control of the feature should not generally be exposed to the user.
Script/language sensitivity: Used for Devanagari and other Indic or Brahmi-derived
scripts.
Feature interaction: This feature is used in conjunction with certain other features to
derive required forms of Indic scripts. The application is expected to process this feature
and certain other features in an appropriate order to obtain the correct set of basic
forms: 'nukt', 'akhn', 'rphf', 'rkrf', 'pref', 'blwf', 'half', 'pstf', 'cjct'. Other discretionary
features for optional typographic effects may also be applied. Lookups for such
discretionary features should be processed after lookups for this feature have been
processed.

Tag: 'clig'
Friendly name: Contextual Ligatures
Registered by: Adobe
Function: Replaces a sequence of glyphs with a single glyph which is preferred for
typographic purposes. Unlike other ligature features, 'clig' specifies the context in which
the ligature is recommended. This capability is important in some script designs and for
swash ligatures.
Example: The glyph for ft replaces the sequence f t in Bickham Script, except when
preceded by an ascending letter.
Recommended implementation: A lookup table for the 'clig' feature maps sequences of
glyphs to corresponding ligatures in a chained context (GSUB lookup type 8). Ligatures
with more components need to be stored ahead of those with fewer components in
order to be found. The set of contextual ligatures will vary by design and script.
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria. When processing lookups,
context before or after the glyph sequence to which the feature is applied should be
considered.

UI suggestion: This feature should be active by default.
Script/language sensitivity: None.
Feature interaction: This feature may be used in combination with other substitution
(GSUB) features, whose results it may override. See also 'dlig'.

Tag: 'cpct'
Friendly name: Centered CJK Punctuation
Registered by: Adobe
Function: Centers specific punctuation marks for those fonts that do not include
centered and non-centered forms.
Example: The user may invoke this feature in a Chinese font to get centered punctuation
in case it is desired. Examples include U+3001 and U+3002, including their vertical
variants, specifically U+FE11 and U+FE12, respectively.
Recommended implementation: The font specifies X- and Y-axis adjustments for a small
number of full-width glyphs (GPOS lookup type 1, xPlacement, xAdvance, yPlacement
and yAdvance).
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria.
UI suggestion: This feature should be off by default.
Script/language sensitivity: Used primarily in Chinese fonts.
Feature interaction: This feature is mutually exclusive to all other glyph-width features
(e.g. 'tnum', 'fwid', 'hwid', 'halt', 'palt', 'twid'), which should be turned off when it is
applied.

Tag: 'cpsp'
Friendly name: Capital Spacing
Registered by: Adobe
Function: Globally adjusts inter-glyph spacing for all-capital text. Most typefaces contain
capitals and lowercase characters, and the capitals are positioned to work with the

lowercase. When capitals are used for words, they need more space between them for
legibility and esthetics. This feature would not apply to monospaced designs.
Example: The user sets a title in all caps, and the Capital Spacing feature opens the
spacing.
Recommended implementation: A lookup table for the 'cpsp' feature stores alternate
advance widths for the capital letters covered, generally increasing them by a uniform
percentage (GPOS lookup type 1, xPlacement and xAdvance).
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria. The application may rely on
the user to apply this feature (e.g., by selecting text for a change to all-caps) or apply its
own heuristics for recognizing words consisting of capitals.
UI suggestion: This feature should be on by default. Applications may want to allow the
user to override the percentage of adjustment to fit individual tastes and functions.
Script/language sensitivity: Should not be used in connecting scripts (e.g. most Arabic).
Feature interaction: May be used in combination with any other feature. Note that
positioning adjustment effects of this and other features, such as 'kern', can be additive.

Tag: 'cswh'
Friendly name: Contextual Swash
Registered by: Adobe
Function: This feature replaces default character glyphs with corresponding swash
glyphs in a specified context. More than one swash alternate may be provided for a
given character.
Example: The user sets the word “HOLIDAY” in Poetica with this feature active, and is
presented with a choice of three alternate forms appropriate for an initial H and one
alternate appropriate for a medial L.
Recommended implementation: A lookup table for the 'cswh' feature maps GIDs for
default forms to those for one or more corresponding swash forms in a chained context
(GSUB lookup type 8). If more than one contextual alternate is provided, the nested
substitution lookup can be implemented using alternate substitution (GSUB lookup type
3). If several styles of swash are present across the font, the set of forms for each
character should be ordered consistently.

Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria. If the font is implemented
using an alternate substitution lookup, the application should provide a means for the
user to select the one desired.
UI suggestion: This feature should be inactive by default. When implemented in the font
using an alternate substitution lookup (GSUB type 3), an application could display the
forms sequentially in context, or present a palette showing all the forms at once, or give
the user a choice between these approaches. The application may assume that the first
glyph in a set is the preferred form, so the font developer should order them
accordingly.
Script/language sensitivity: Not used for ideographic scripts.
Feature interaction: This feature may be used in combination with other substitution
(GSUB) features, whose results it may override. See also 'swsh' and 'init'.

Tag: 'curs'
Friendly name: Cursive Positioning
Registered by: Microsoft
Function: This feature is used to position adjacent glyphs for cursive connections.
Example: In Arabic, the Meem followed by a Reh are cursively positioned by overlapping
the exit point of the Meem on the entry point of the Reh.
Recommended implementation: Lookup tables for the 'curs' feature provide entry and
exit points (x,y) for glyphs to be cursively positioned (GPOS lookup type 3).
Application interface: In recommended usage, this feature triggers positioning
adjustments that are required for correct display of fonts that implement cursive joining
behavior. It should always be applied.
UI suggestion: Control of this feature should not normally be exposed to the user.
Script/language sensitivity: Used primarily for Arabic and other cursively connecting
scripts, and also any other scripts for which cursive styles can optionally be used.
Feature interaction: None.

Tag: 'cv01' – 'cv99'

Friendly name: Character Variant 1 – Character Variant 99
Registered by: Microsoft
Function: A font may have stylistic-variant glyphs for one or more characters where the
variations for one character are not systematically related to those for other characters.
Or, a variation may exist for a character and its casing pair or related pre-composed
characters, but not be applicable to other unrelated characters. In some usage scenarios,
it may be necessary to provide the application with control over glyph variations for
different Unicode characters individually.
The function of these features is similar to the function of the Stylistic Alternates feature
('salt') and the Stylistic Set features (see 'ss01' – 'ss20'). Whereas the Stylistic Set features
assume recurring stylistic variations that apply to a broad set of Unicode characters,
however, these features are intended for scenarios in which particular characters have
variations not applicable to a broad set of characters. The Stylistic Alternates feature
provides access to glyph variants but does not allow an application to control these on a
character-by-character basis; the Character Variant features provide the greater
granularity of control.
The function of these features is also related to that of the Localized Forms ('locl')
feature, in that particular variations for a character may be preferred for particular
languages. In practice, though, it might not be feasible to associate particular glyph
variants with particular language systems for all the relevant languages; for example, the
requirements of particular languages might not be known when a font is being
developed.
The distinction between these features and the Stylistic set features is most easily
understood in terms of variants applying to a single character versus variants applying
across a range of characters. In practice, if a variant applies to a character in a bicameral
script, then the casing-pair character might have the same variant. Also, Unicode
includes pre-composed characters for certain base + mark combinations, hence a single
abstract character could be incorporated into a number of Unicode characters.
Therefore, a variant for a particular abstract character could be applicable to several
related Unicode characters. The Character Variant features can be used for sets of
related characters in these cases. The key distinction between such use and the intended
use for Stylistic Set features is that a Character Variant feature should apply only to one
character or a set of characters closely related in this way, while Stylistic Set features are
intended for broader sets of characters.
Recommended implementation: A 'cvXX' lookup table maps the GID for the default form
of a character to the GIDs for stylistic alternates of that character. Each 'cvXX' feature
uses alternate substitutions (GSUB lookup type 3). (If there is only one variant for a

character, a single-substitution lookup, type 1, can also be used.) A given 'cvXX' feature
acts on a single glyph or on multiple glyphs for closely related characters that have
corresponding variants. Within each 'cvXX' feature, the number of variants should be
identical for all glyphs, and the ordering of glyphs in lookup arrays should correspond
such that the nth variants of all glyphs are corresponding variants.
The featureParamsOffset field of the Feature Table of these GSUB features may be set to
0, or to an offset to a Feature Parameters table. The Feature Parameters table for this
feature is structured as follows:
ﾉ

Expand table

Type

Name

Description

uint16

format

Format number is set to 0.

uint16

featUiLabelNameId

The 'name' table name ID that specifies a string (or strings,
for multiple languages) for a user-interface label for this
feature. (May be NULL.)

uint16

featUiTooltipTextNameId

The 'name' table name ID that specifies a string (or strings,
for multiple languages) that an application can use for
tooltip text for this feature. (May be NULL.)

uint16

sampleTextNameId

The 'name' table name ID that specifies sample text that
illustrates the effect of this feature. (May be NULL.)

uint16

numNamedParameters

Number of named parameters. (May be zero.)

uint16

firstParamUiLabelNameId

The first 'name' table name ID used to specify strings for
user-interface labels for the feature parameters. (Must be
zero if numParameters is zero.)

uint16

charCount

The count of characters for which this feature provides glyph
variants. (May be zero.)

uint24

character[charCount]

The Unicode Scalar Value of the characters for which this
feature provides glyph variants.

If a font supports two or more character variant features, use of Feature Parameters
tables should be consistent across all of these features.
The name ID provided by featUiLabelNameId is intended to provide a user-interface
string for the feature; for example, “Capital-eng variants”. If set to NULL, no 'name' table
string is used for the feature name.
The name ID provided by featUiTooltipTextNameId is intended to provide a userinterface string that provides a brief description of the feature that applications can use

in popup “tooltip” help windows (e.g. “Select glyph variants for capital eng.”). If set to
NULL, no 'name' table string is used for the feature “tooltip” help text.
The name ID provided by sampleTextNameId is intended to provide a string that can be
used in a user-interface to illustrate the effect of the feature. If multiple characters are
affected by the feature or if the feature affects a combining mark, it might not be
evident to an application what string to use to present an illustrative sample; a 'name'
table string can be provided for that purpose.
If numNamedParameters is non-zero, then firstParamUiLabelNameId and
numNamedParameters specify a sequence of consecutive name IDs in the 'name' table.
These are used to provide user-interface strings for individual variants. The range of
name IDs start at firstParamUiLabelNameId and end at firstParamUiLabelNameId +
numNamedParameters - 1. Each of these name IDs corresponds to a feature parameter
value used to select a particular GID from the array of GIDs returned by a type 3
substitution lookup; the relation between parameter values and name IDs is: name ID =
parameter + firstParamUiLabelNameId - 1. The value of numNamedParameters should
not exceed the number of alternate glyphs in lookups associated with the feature.
However, the number of GIDs in the returned array for a GSUB type 3 lookup should not
be assumed to be equal to numNamedParameters: numNamedParameters should not
be more than the number of GIDs in the array, but it may be less. If
numNamedParameters is zero, then no 'name' table strings are associated with feature
parameters.
The values of featUiLabelNameId, featUiTooltipTextNameId and
firstParamUiLabelNameId are expected to be in the font-specific name ID range (256–
32767), though that is not a requirement in this Feature Parameters specification. The
value of firstParamUiLabelNameId + numNamedParameters - 1 should not exceed
32767.
The user-interface label for the feature, for “tooltip” help text, or for feature parameters
can be provided in multiple languages. English strings for each should be included as a
fallback. A sample-text string likely would not need to be localized, though different
sample-text strings for different UI languages can be used. If only one sample-text string
is provided, applications may use it with any UI language.
The charCount field and character array are used to identify the Unicode characters for
which this feature provides glyph variants. Applications can use this information in
presenting user interface or for other purposes. Content of the character list is at the
discretion of the font developer — the list may be exhaustive, representative, or empty
— and does not affect the operation of the feature. If a font developer chooses not to

include such information, charCount may be set to zero, in which case no character array
can be included.
It is left to the discretion of application developers to determine whether or how to use
the data provided in the feature parameters table or associated strings in the 'name'
table.
Since the strings provided using this feature parameter table will be used in application
user interface, length is an important consideration. Strings should be as short as
possible. It is recommended that the length of the feature or feature-parameter names
be 25 characters or less, and that the length of “tooltip” help text be 250 characters or
less.
Application interface: Discretionary features: can be applied to glyph runs based on
document markup, user control or other application criteria. The application is
responsible for counting and enumerating the number of features in the font with tag
names of the format 'cv01' to 'cv99', and for presenting the user with an appropriate
selection mechanism. The application is also responsible for interpreting any feature
parameter tables (if the application developer wishes to use that data) and presenting
referenced strings in a user interface. If the font is implemented using an alternate
substitution lookup, the application may use an index parameter as an index into the
array of mapped glyph IDs.
UI suggestion: This feature should be off by default. An application can display glyph
variants for a given character as a glyph palette in the user interface. If a Feature
Parameters table is provided, the feature UI label or the named parameter UI labels (if
provided) can be presented in the application user interface; or the sample-text string (if
provided) can be presented in the application user interface.
Script/language sensitivity: None.
Feature interaction: This feature may be used in combination with other substitution
(GSUB) features, whose results it may override. Note that after a 'cvXX' feature has been
applied, the user may wish to apply other typographic features, e.g. 'smcp'; font
developers are responsible for ordering substitution lookups to obtain desired user
experience. If it is to be used in conjunction with a complex script that requires
obligatory substitution of ligatures or contextual forms, this feature should be applied
before features for obligatory script behaviors.

Tag: 'c2pc'
Friendly name: Petite Capitals From Capitals

Registered by: Tiro Typeworks / Emigre
Function: This feature turns capital characters into petite capitals. It is generally used for
words which would otherwise be set in all caps, such as acronyms, but which are desired
in petite-cap form to avoid disrupting the flow of text. See the 'pcap' feature description
for notes on the relationship of caps, smallcaps and petite caps.
Example: The user types UNICEF or NASA, applies 'c2pc' and gets petite cap text.
Recommended implementation: A lookup table for the 'c2pc' feature maps capital glyphs
to the corresponding petite cap forms (GSUB lookup type 1).
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria. Applications may use this
feature in an implementation to support petite-cap formatting applied to text with
language-specific case-mapping logic. See 'pcap' and 'smcp' for additional information.
UI suggestion: This feature should be off by default.
Script/language sensitivity: Used for bicameral scripts (i.e. those with case differences),
such as Latin, Greek, Cyrillic, and Armenian.
Feature interaction: This feature may be used in combination with other substitution
(GSUB) features, whose results it may override. Also see 'pcap'.

Tag: 'c2sc'
Friendly name: Small Capitals From Capitals
Registered by: Adobe
Function: This feature turns capital characters into small capitals. It is generally used for
words which would otherwise be set in all caps, such as acronyms, but which are desired
in small-cap form to avoid disrupting the flow of text.
Example: The user types UNICEF or SCUBA, applies 'c2sc' and gets small cap text.
Recommended implementation: A lookup table for the 'c2sc' feature maps capital glyphs
to the corresponding small-cap forms (GSUB lookup type 1).
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria. Applications may use this
feature in an implementation to support small-cap formatting applied to text with
language-specific case-mapping logic. See 'smcp' for additional information.

UI suggestion: This feature should be off by default.
Script/language sensitivity: Used for bicameral scripts (i.e. those with case differences),
such as Latin, Greek, Cyrillic, and Armenian.
Feature interaction: This feature may be used in combination with other substitution
(GSUB) features, whose results it may override. Also see 'smcp'.

Tag: 'dist'
Friendly name: Distances
Registered by: Microsoft
Function: Provides a means to control distance between glyphs.
This feature should only be used for required positioning adjustments, not as an
alternate kerning feature. For spacing adjustments that can be controlled by the user,
the 'kern' feature should be used.
Example: In Telugu script, adjust the placement of subjoined consonant forms to avoid
collision with other glyphs.
Recommended implementation: The font provides distances by which a glyph needs to
move towards or away from another glyph (GPOS lookup type 1, type 2, or contextual
lookups that reference nested type 1 or type 2 lookups).
Application interface: In recommended usage, this feature triggers positioning
adjustments that are required for correct display of the given script. It should be applied
in the appropriate contexts, as determined by script-specific processing requirements.
UI suggestion: Control of the feature should not generally be exposed to the user.
Script/language sensitivity: Used for Indic or other Brahmi-derived scripts.
Feature interaction: This and other certain other features, such as 'kern', are typically
implemented using single or pair adjustment positioning lookups. Note that positioning
adjustment effects of this and other features can be additive. The glyphs affected by the
'dist' and 'kern' features should be distinct unless it is intended that their effects can be
combined.

Tag: 'dlig'
Friendly name: Discretionary Ligatures

Registered by: Adobe
Function: Replaces a sequence of glyphs with a single glyph which is preferred for
typographic purposes. This feature covers those ligatures which may be used for special
effect, at the user’s preference.
Example: The glyph for ct replaces the sequence of glyphs c t, or U+322E (Kanji ligature
for “Friday”) replaces the sequence U+91D1 U+66DC U+65E5.
Recommended implementation: A lookup table for the 'dlig' feature maps sequences of
glyphs to corresponding ligatures (GSUB lookup type 4). Ligatures with more
components need to be stored ahead of those with fewer components in order to be
found. The set of discretionary ligatures will vary by design and script.
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria.
UI suggestion: This feature should be off by default.
Script/language sensitivity: None.
Feature interaction: This feature may be used in combination with other substitution
(GSUB) features, whose results it may override. See also 'clig'.

Tag: 'dnom'
Friendly name: Denominators
Registered by: Adobe
Function: Replaces selected figures which follow a slash with denominator figures.
Example: In the string 11/17 selected by the user, the application turns the 17 into
denominators when the user applies the fraction feature ('frac').
Recommended implementation: Glyphs for figures (digits) and related characters
(grouping or decimal separators) are mapped to corresponding denominator glyphs in
the font (GSUB lookup type 1).
Application interface: In recommended usage, this feature is applied automatically as
part of the application’s implementation for the 'frac' feature. See the 'frac' for details.
UI suggestion: In recommended usage, this feature is applied to sequences automatically
by applications when the 'frac' feature is used, and direct user control is not required.

Script/language sensitivity: None.
Feature interaction: This feature supports implementation of the 'frac' feature. It may be
used in combination with other substitution (GSUB) features, whose results it may
override.

Tag: 'dtls'
Friendly name: Dotless Forms
Registered by: Microsoft
Function: This feature provides dotless forms for Math Alphanumeric characters, such as
U+1D422 MATHEMATICAL BOLD SMALL I, U+1D423 MATHEMATICAL BOLD SMALL J,
U+1D456 U+MATHEMATICAL ITALIC SMALL I, U+1D457 MATHEMATICAL ITALIC SMALL
J, and so on. The dotless forms are to be used as base forms for placing mathematical
accents over them.
Example: When adding a tilde to an i, the dotless form is substituted before attaching
the tilde accent on top of it.
Recommended implementation: Single substitution (GSUB lookup type 1), for glyphs of
all dotted characters.
Application interface: In recommended usage, this feature is used to trigger substitutions
that are required for correct display of math formulas. It should be applied to individual
glyphs in appropriate contexts under the control of a math layout handler. See the
'MATH' table chapter for additional information.
UI suggestion: Control of the feature should not generally be exposed to the user.
Script/language sensitivity: Used for math formula layout.
Feature interaction: None.

Tag: 'expt'
Friendly name: Expert Forms
Registered by: Adobe
Function: Like the JIS78 Forms feature, this feature replaces standard forms in Japanese
fonts with corresponding forms preferred by typographers. Although most of the JIS78

substitutions are included, the expert substitution goes on to handle many more
characters.
Example: The user would invoke this feature to replace kanji character U+5516 with
U+555E.
Recommended implementation: A lookup table for the 'expt' feature maps many default
(JIS90) GIDs to corresponding alternates (GSUB lookup type 1).
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria. Note that the effect of this
feature is effectively equivalent to a change of character code. Besides the original
character code, the application should store the character code for the new glyph.
UI suggestion: Applications may choose to have this feature active or inactive by default,
depending on their target markets.
Script/language sensitivity: Applies only to Japanese.
Feature interaction: This feature is mutually exclusive to most other features, which
should be turned off when it’s applied. Exceptions include the 'palt', 'vpal', 'vert' and
'vrt2' features, which may be used in addition.

Registered Features: Descriptions and
Implementations (f – j)
Article • 05/31/2024

a-e|f-j|k-o|p-t|u-z

Tag: 'falt'
Friendly name: Final Glyph on Line Alternates
Registered by: Microsoft
Function: Replaces line final glyphs with alternate forms specifically designed for this
purpose (they would have less or more advance width as might be needed), to help
justification of text.
Example: In the Arabic script, providing alternate forms for line final glyphs would result
in better justification. E.g., replacing a long tailed Yeh-with-tail with one that has a
slightly longer or shorter tail.
Recommended implementation: A lookup table for the 'falt' feature maps line final glyphs
(in isolated or final forms) to their corresponding alternate forms (GSUB lookup type 1).
This feature can be implemented in conjunction with justification extension or shrinkage
modifications in a JSTF table.
Application interface: In recommended usage, this feature is applied to final glyphs of
lines when text is justified, as determined by a justification algorithm or direct user
control. The feature can affect the length of lines, which should be taken into
consideration by line-breaking and justification algorithms.
UI suggestion: This feature could be made active or inactive by default, at the user’s
preference.
Script/language sensitivity: Can be used in any cursive script.
Feature interaction: Would need to be applied last, only after all other features have
been applied to the run.

Tag: 'fin2'
Friendly name: Terminal Forms #2

Registered by: Microsoft
Function: Used to replace the Alaph glyph at the end of Syriac words with its appropriate
form, when the preceding base character cannot be joined to, and that preceding base
character is not a Dalath, Rish, or dotless Dalath-Rish.
This feature is used only for the Syriac script alaph character.
Example: When an Alaph is preceded by a He, the Alaph would be replaced by an
appropriate form.
Recommended implementation: A lookup table for the 'fin2' feature maps default
alphabetic forms to corresponding final forms (GSUB lookup type 1).
Application interface: In recommended usage, this feature triggers substitutions required
for correct layout of Syriac text. The application should always apply the feature to the
Alaph glyph when the preceding base character is non-joining and is a character other
than Dalath, Rish, or dotless Dalath-Rish.
UI suggestion: Control of the feature should not generally be exposed to the user.
Script/language sensitivity: Used only with the Syriac script.
Feature interaction: This feature may be used in combination with other substitution
(GSUB) features, whose results it may override. See also 'init' and 'fina'.

Tag: 'fin3'
Friendly name: Terminal Forms #3
Registered by: Microsoft
Function: Used to replace Alaph glyphs at the end of Syriac words when the preceding
base character is a Dalath, Rish, or dotless Dalath-Rish.
This feature is used only for the Syriac script alaph character.
Example: When an Alaph is preceded by a Dalath, the Alaph would be replaced by an
appropriate form.
Recommended implementation: A lookup table for the 'fin3' feature maps default
alphabetic forms to corresponding final forms (GSUB lookup type 5).
Application interface: In recommended usage, this feature triggers substitutions required
for correct layout of Syriac text. The application should always apply the feature to the

Alaph glyph when at the end of Syriac words if the preceding base character is Dalath,
Rish, or dotless Dalath-Rish.
UI suggestion: Control of the feature should not generally be exposed to the user.
Script/language sensitivity: Used only with the Syriac script.
Feature interaction: This feature may be used in combination with other substitution
(GSUB) features, whose results it may override. See also 'init' and 'fina'.

Tag: 'fina'
Note: This feature description was significantly revised in 2016.
Friendly name: Terminal Forms
Registered by: Microsoft/Adobe
Function: Replaces glyphs for characters that have applicable joining properties with an
alternate form when occurring in a final context. This applies to characters that have one
of the following Unicode Joining_Type property values:
Right_Joining, if the characters are from a right-to-left script.
Left_Joining, if the characters are from a left-to-right script.
Dual_Joining.
Unicode Joining_Type property values are obtained from the Unicode Character
Database

(UCD). Specifically, Joining_Type property values are documented in the

UCD file, ArabicShaping.txt, the current version of which is available at
http://www.unicode.org/Public/UCD/latest/ucd/ArabicShaping.txt

.

Example: In an Arabic-script font, the application would apply the 'fina' feature to the
letter ARABIC LETTER WAW (U+0648 “‫ )”و‬when it follows a left-joining character, thereby
replacing the default “‫ ”و‬glyph with its right-joining, final form.
Recommended implementation: The 'fina' feature is used to map default forms to
corresponding single-joining, final forms. This will usually be implemented using a single
substitution (type 1) GSUB lookup, though contextual substitution GSUB lookups (types
5, 6 or 8) could also be appropriate.
Application interface: In recommended usage, this feature triggers substitutions that are
required for correct display of cursively-connecting scripts. It should be applied in the
appropriate contexts, as determined by script-specific processing requirements. The
application is responsible for parsing character strings and identifying which of the

joining-related features — initial forms ('init'), medial forms ('medi'), terminal forms
('fina'), and isolated forms ('isol') — to apply to which glyphs, based on character
Joining_Type properties. Additional factors, such as the presence of control characters,
should also be considered.
UI suggestion: Control of the feature should not generally be exposed to the user.
Script/language sensitivity: Can be used in any script with joining behavior — that is, the
scripts for which Joining_Type properties are given explicitly in ArabicShaping.txt.
Feature interaction: This feature may be used in combination with other substitution
(GSUB) features, whose results it may override. See also 'init', 'isol' and 'medi'.

Tag: 'flac'
Friendly name: Flattened Accent Forms
Registered by: Microsoft
Function: This feature provides flattened forms of accents to be used in math formulas
over high-rise bases such as capitals. This feature should only change the shape of the
accent and should not move it in the vertical or horizontal direction. Moving of the
accents is done by the math layout engine. Accents are flattened by the Math engine if
their base is higher than the flattenedAccentBaseHeight value in the
MATH.MathConstants table.
Example: Depending on the font parameters, a lowercase a with tilde may used in
default form and an uppercase A with tilde may use the flattened form
Recommended implementation: Single substitution, replacing ascent glyph with its
flattened form. See the MATH table specification for details.
Application interface: In recommended usage, this feature is used to trigger substitutions
that are required for correct display of math formulas. It should be applied to individual
glyphs in the appropriate contexts, as determined by math layout handler. See the
'MATH' table chapter for additional information.
UI suggestion: Control of the feature should not generally be exposed to the user.
Script/language sensitivity: Used for math formula layout.
Feature interaction: None.

Tag: 'frac'

Friendly name: Fractions
Registered by: Microsoft/Adobe
Function: Replaces figures (digits) separated by a slash (U+002F or U+2044) with
“common” (diagonal) fractions.
Example: The user enters 3/4 and gets the three-quarters fraction.
Recommended implementation: Glyphs for figures (digits) separated by a slash are
mapped to variant forms (GSUB lookup type 1, or contextual substitutions that reference
type 1 lookups), or sequences of such glyphs are mapped to ligature fraction glyphs
(GSUB lookup type 4).
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria.
An application may automatically apply the feature over certain text sequences, such as
sequences of one or more digits followed by fraction slash (U+2044) followed by one or
more digits. An application may also automatically apply the 'numr' feature to a
sequence preceding a slash, and the 'dnom' feature to a sequence following a slash,
either based on analysis of the text sequence or as a corollary to application of the 'frac'
feature over a sequence.
UI suggestion: This feature should be off by default.
Script/language sensitivity: None.
Feature interaction: Applications may use this feature in conjunction with the 'numr' and
'dnom' features. It may be used in combination with other substitution (GSUB) features,
whose results it may override.

Tag: 'fwid'
Friendly name: Full Widths
Registered by: Adobe
Function: Replaces glyphs set on other widths with glyphs set on full (usually em) widths.
In a CJKV font, this may include “lower ASCII” Latin characters and various symbols. In a
European font, this feature replaces proportionally-spaced glyphs with fixed-width
glyphs, which are generally set on widths of 0.6 em.
Example: The user may invoke this feature in a Japanese font to get full, fixed-width
Latin glyphs instead of the corresponding proportionally-spaced versions.

Recommended implementation: The font may substitute alternate glyphs with full
advance widths (GSUB lookup type 1), or it may specify alternate, full-width metrics for
the proportional glyphs (GPOS lookup type 1, xPlacement and xAdvance).
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria.
UI suggestion: This feature should be off by default. See below for details on important
feature interactions.
Script/language sensitivity: Can be used for any script which can use fixed-width forms.
Feature interaction: This feature is mutually exclusive to all other horizontal glyph-width
features ('chws', 'halt', 'hwid', 'palt', 'pkna', 'pwid', 'qwid', 'twid', 'pnum', 'tnum'), which
should be turned off when it’s applied. When applied to a text run, the 'apkn' and 'kern'
features should be disabled for that run.

Tag: 'half'
Friendly name: Half Forms
Registered by: Microsoft
Function: Produces the half forms of consonants in Indic scripts.
Example: In Hindi (Devanagari script), the conjunct KKa is denoted with a half form of Ka
followed by the full form of Ka.
Recommended implementation: A lookup table for the 'half' feature maps the sequence
of a consonant followed by a virama (halant) to its half form (GSUB lookup type 4).
Application interface: In recommended usage, this feature triggers substitutions required
for correct display of certain scripts. It should be applied in the appropriate contexts, as
determined by script-specific processing requirements.
UI suggestion: Control of the feature should not generally be exposed to the user.
Script/language sensitivity: Used for Devanagari and other Indic or Brahmi-derived
scripts that have pre-base consonant half forms.
Feature interaction: This feature is used in conjunction with certain other features to
derive required forms of Indic scripts. The application is expected to process this feature
and certain other features in an appropriate order to obtain the correct set of basic
forms: 'nukt', 'akhn', 'rphf', 'rkrf', 'pref', 'blwf', 'half', 'pstf', 'cjct'. Other discretionary
features for optional typographic effects may also be applied. Lookups for such

discretionary features should be processed after lookups for this feature have been
processed.

Tag: 'haln'
Friendly name: Halant Forms
Registered by: Microsoft
Function: Produces the halant forms of consonants in Indic scripts (that is, precomposed
glyphs for consonant with the overt halant).
Example: In Sanskrit (Devanagari script), syllable final consonants are frequently required
in their halant form.
Recommended implementation: A lookup table for the 'haln' feature maps the sequence
of a consonant followed by a virama (halant) to its halant form (GSUB lookup type 4).
Application interface: In recommended usage, this feature triggers substitutions required
for correct display of certain scripts. It should be applied in the appropriate contexts, as
determined by script-specific processing requirements.
UI suggestion: Control of the feature should not generally be exposed to the user.
Script/language sensitivity: Used for Indic or other Brahmi-derived scripts.
Feature interaction: This feature overrides the results of all other features.

Tag: 'halt'
Friendly name: Alternate Half Widths
Registered by: Adobe
Function: Re-spaces glyphs that have full-width metrics by default, fitting them onto
fixed, half-em widths to approximate more sophisticated text layout, such as what is
described in Requirements for Japanese Text Layout (JLREQ)

or similar CJKV text-

layout specifications that expect half-width forms of characters whose default glyphs are
full-width. This feature differs from 'hwid' in that it is not used to substitute new glyphs.
It also differs from 'chws' in that adjustments are not contextual.
(In JLREQ, see, in particular, 3.1.4 Positioning of Consecutive Opening Brackets, Closing
Brackets, Commas, Full Stops and Middle Dots

, and B. Spacing between Characters

.

See also Requirements for Chinese Text Layout (CLREQ)
Layout (KLREQ)

, Requirements for Hangul Text

.)

Example: The user invokes this feature in a CJKV font to get better fit for punctuation or
symbol glyphs without disrupting the fixed-width alignment.
Recommended implementation: The font specifies alternate, half-width metrics for fullwidth glyphs (GPOS lookup type 1, xPlacement, xAdvance, yPlacement and yAdvance).
Application interface: If a layout engine supports advanced layout for CJKV text as
described in CLREQ

, JLREQ

or KLREQ

, this feature should not be used. Otherwise,

this feature should be enabled in horizontal layout to all CJKV text or selectively to
particular characters that require special treatment in CJKV text layout, such as brackets,
punctuation, and quotation marks.
UI suggestion: This feature should not be used in combination with a layout engine that
independently provides advanced layout as described in CLREQ

, JLREQ

or KLREQ

.

For applications that provide such advanced layout, it could be appropriate not to
expose control of this feature to users. In applications that do not support such
advanced layout, this feature should be enabled by default for horizontal layout of CJK
text. See below for details on important feature interactions.
Script/language sensitivity: Used only in CJKV fonts.
Feature interaction: This feature is mutually exclusive to all other horizontal glyph-width
features ('chws', 'fwid', 'hwid', 'palt', 'pkna', 'pwid', 'qwid', 'twid', 'pnum', 'tnum'), which
should be turned off when this feature is applied. When applied to a text run, the 'apkn'
and 'kern' features should be disabled. See also 'vhal'.

Tag: 'hist'
Friendly name: Historical Forms
Registered by: Microsoft/Adobe
Function: Some letterforms were in common use in the past, but appear anachronistic
today. The best-known example is the long form of s; others would include the old
Fraktur k. Some fonts include the historical forms as alternates, so they can be used for a
“period” effect. This feature replaces the default (current) forms with the historical
alternates. While some ligatures are also used for historical effect, this feature deals only
with single characters. (For historic ligatures, see the 'hlig' feature.)
Example: The user applies this feature in Adobe Jenson to get the archaic forms of M, Q
and Z.

Recommended implementation: A lookup table for the 'hist' feature maps default forms
to corresponding historical forms (GSUB lookup type 1).
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria.
UI suggestion: This feature should be off by default.
Script/language sensitivity: None.
Feature interaction: This feature may be used in combination with other substitution
(GSUB) features, whose results it may override.

Tag: 'hkna'
Friendly name: Horizontal Kana Alternates
Registered by: Adobe
Function: Replaces standard kana with forms that have been specially designed for only
horizontal writing. This is a typographic optimization for improved fit and more even
color. Also see 'vkna'.
The 'hkna' and 'vkna' features are intended for use in fonts designed for both horizontal
and vertical layout. The font can have alternate glyphs for kana characters designed
specifically for horizontal layout, or specifically for vertical layout. These two features can
be used to select the variant glyphs for each layout direction. These features do not
affect glyph advance widths.
Example: Standard full-width kana (hiragana and katakana) are replaced by forms that
are designed for horizontal use.
Recommended implementation: A lookup table for the 'hkna' feature maps the standard
full-width forms to the corresponding special horizontal forms (GSUB lookup type 1).
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria.
UI suggestion: This feature should be off by default.
Script/language sensitivity: Used only in fonts that support kana (hiragana and katakana).
Feature interaction: This feature may be used with the 'kern' feature. Since it is for
horizontal use, features applying to vertical behaviors (e.g. 'vkna', 'vert', 'vrt2' or 'vkrn')
do not apply.

Tag: 'hlig'
Friendly name: Historical Ligatures
Registered by: Microsoft
Function: Some ligatures were in common use in the past, but appear anachronistic
today. Some fonts include the historical forms as alternates, so they can be used for a
“period” effect. This feature replaces the default (current) forms with the historical
alternates.
Example: The user applies this feature using Palatino Linotype, and historic ligatures are
formed for all long s forms, including: long s+t, long s+b, long s+h, long s+k, and
several others.
Recommended implementation: Sequences of glyphs for certain character combinations
are mapped to corresponding historical ligature glyphs (GSUB lookup type 4).
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria.
UI suggestion: This feature should be off by default.
Script/language sensitivity: None.
Feature interaction: This feature overrides the results of all other features.

Tag: 'hngl' (DEPRECATED)
Friendly name: Hangul
Registered by: Adobe
Function: Replaces hanja (Chinese-style) Korean characters with the corresponding
hangul (syllabic) characters. This effectively reverses the standard input method, in which
hangul are entered and replaced by hanja. Many of these substitutions are one-to-one
(GSUB lookup type 1), but hanja substitution often requires the user to choose from
several possible hangul characters (GSUB lookup type 3).
Example: The user may activate this feature to get the glyph for U+AC00 from U+4F3D.
Recommended implementation: Glyphs for hanja characters are mapped to
corresponding glyphs for Hangul syllables (GSUB lookup type 1); or default glyphs for
hanja characters are mapped to two or more corresponding alternate glyphs for Hangul
syllables (GSUB lookup type 3). As in any one-from-many substitution, alternates should

be ordered consistently across a family, so that those alternates can work correctly when
switching between family members.
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria. If the font is implemented
using an alternate substitution lookup, the application should provide a means for the
user to select the one desired. Note that the effect of this feature is effectively
equivalent to a change of character codes. Besides the original character codes (when
entered as hanja), the application should store the character codes for the new glyphs.
UI suggestion: This feature should be inactive by default. The application can note the
user’s choice when selecting from multiple hangul glyphs and offer it as a default the
next time the source hanja character is encountered. In the absence of such prior
information, the application may assume that the first hangul in a set is the preferred
form, so the font developer should order them accordingly.
Script/language sensitivity: Korean only.
Feature interaction: This feature is mutually exclusive to most other features, which
should be turned off when it’s applied. Exceptions include the 'palt', 'vert' and 'vrt2'
features, which may be used in addition.

Tag: 'hojo'
Friendly name: Hojo Kanji Forms (JIS X 0212-1990 Kanji Forms)
Registered by: Adobe
Function: The JIS X 0212-1990 (aka, “Hojo Kanji”) and JIS X 0213:2004 character sets
overlap significantly. In some cases their prototypical glyphs differ. When building fonts
that support both JIS X 0212-1990 and JIS X 0213:2004 (such as those supporting the
Adobe-Japan 1-6 character collection), it is recommended that JIS X 0213:2004 forms be
preferred as the encoded form. The 'hojo' feature is used to access the JIS X 0212-1990
glyphs for the cases when the JIS X 0213:2004 form is encoded.

Example: The glyph

is replaced by the glyph

.

Recommended implementation: One-for-one substitution of JIS X 0213:2004 glyphs by
the corresponding JIS X 0212-1990 glyph (GSUB lookup type 1).

Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria.
UI suggestion: This feature should be off by default.
Script/language sensitivity: Used only with Kanji characters in Japanese.
Feature interaction: This feature is mutually exclusive to 'jp78', 'jp83', 'jp90', 'nlck' and
similar features. It can be combined with the 'palt', 'vpal', 'vert' and 'vrt2' features.

Tag: 'hwid'
Friendly name: Half Widths
Registered by: Adobe
Function: Replaces glyphs with proportional widths, or with fixed widths other than half
an em, with glyphs on half-em (en) widths. Many CJKV fonts have alternate glyphs set
on multiple widths; this feature selects the half-em variants. There are various contexts
in which this is the preferred behavior, including compatibility with older desktop
documents.
Example: The user may replace a proportional Latin glyph with the same character set on
a half-em width.
Recommended implementation: The font substitutes alternate glyphs designed to be set
on half-em widths (GSUB lookup type 1), or it specifies alternate metrics for the original
glyphs (GPOS lookup type 1, xPlacement and xAdvance), adjusting their spacing to fit in
half-em widths.
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria.
UI suggestion: This feature should be off by default. See below for details on important
feature interactions.
Script/language sensitivity: Generally used only in CJKV fonts.
Feature interaction: This feature is mutually exclusive to all other horizontal glyph-width
features ('chws', 'fwid', 'halt', 'palt', 'pkna', 'pwid', 'qwid', 'twid', 'pnum', 'tnum'), which
should be turned off when it’s applied. When applied to a text run, the 'apkn' and 'kern'
features should be disabled for that run.

Tag: 'init'

Note: This feature description was significantly revised in 2016.
Friendly name: Initial Forms
Registered by: Microsoft/Adobe
Function: Replaces glyphs for characters that have applicable joining properties with an
alternate form when occurring in an initial context. This applies to characters that have
one of the following Unicode Joining_Type property values:
Right_Joining, if the characters are from a left-to-right script.
Left_Joining, if the characters are from a right-to-left script.
Dual_Joining.
Unicode Joining_Type property values are obtained from the Unicode Character
Database

(UCD). Specifically, Joining_Type property values are documented in the

UCD file, ArabicShaping.txt, the current version of which is available at
http://www.unicode.org/Public/UCD/latest/ucd/ArabicShaping.txt

.

Example: In an Arabic-script font, the application would apply the 'init' feature to the
letter ARABIC LETTER SEEN (U+0633 “‫ )”س‬when it precedes a right-joining character,
thereby replacing the default “‫ ”س‬glyph with its left-joining, initial form.
Recommended implementation: The 'init' feature is used to map default forms to
corresponding single-joining, inital forms. This will usually be implemented using a
single substitution (type 1) GSUB lookup, though contextual substitution GSUB lookups
(types 5, 6 or 8) could also be appropriate.
Application interface: In recommended usage, this feature triggers substitutions that are
required for correct display of cursively-connecting scripts. It should be applied in the
appropriate contexts, as determined by script-specific processing requirements. The
application is responsible for parsing character strings and identifying which of the
joining-related features — initial forms ('init'), medial forms ('medi'), terminal forms
('fina'), and isolated forms ('isol') — to apply to which glyphs, based on character
Joining_Type properties. Additional factors, such as the presence of control characters,
should also be considered.
UI suggestion: Control of the feature should not generally be exposed to the user.
Script/language sensitivity: Can be used in any script with joining behavior — that is, the
scripts for which Joining_Type properties are given explicitly in ArabicShaping.txt.
Feature interaction: This feature may be used in combination with other substitution
(GSUB) features, whose results it may override. See also 'fina', 'isol' and 'medi'.

Tag: 'isol'
Note: This feature description was significantly revised in 2016.
Friendly name: Isolated Forms
Registered by: Microsoft
Function: Replaces glyphs for characters that have applicable joining properties with an
alternate form when occurring in a isolate (non-joining) context. This applies to
characters that have one of the following Unicode Joining_Type property values:
Right_Joining.
Left_Joining.
Dual_Joining.
Non_Joining, if the characters are from a script with joining behavior.
Unicode Joining_Type property values are obtained from the Unicode Character
Database

(UCD). Specifically, Joining_Type property values are documented in the

UCD file, ArabicShaping.txt, the current version of which is available at
http://www.unicode.org/Public/UCD/latest/ucd/ArabicShaping.txt

. Scripts that have

joining behavior are those scripts with character properties given explicitly in
ArabicShaping.txt.
Note that, in many fonts that support the relevant scripts, this feature might not be
implemented since the default forms of the relevant characters are the isolated forms. In
some fonts, this feature may involve contextual substitution based on the specific,
isolated context.
Example: In an Arabic-script font, the application would apply the 'isol' feature to the
letter ARABIC LETTER HEH (U+0647 “‫ )”ه‬when not adjacent to any joining character,
thereby potentially replacing the default “‫ ”ه‬glyph with a special, isolated form (likely, a
contextual and language-specific substitution, substituting one isolated form for
another).
Recommended implementation: The 'isol' feature is used to map default forms to
alternate non-joining, isolate forms. This will usually be implemented using a single
substitution (type 1) GSUB lookup or, often, a contextual substitution GSUB lookup
(types 5, 6 or 8).
Application interface: In recommended usage, this feature triggers substitutions that are
required for correct display of cursively-connecting scripts. It should be applied in the
appropriate contexts, as determined by script-specific processing requirements. The
application is responsible for parsing character strings and identifying which of the

joining-related features — initial forms ('init'), medial forms ('medi'), terminal forms
('fina'), and isolated forms ('isol') — to apply to which glyphs, based on character
Joining_Type properties. Additional factors, such as the presence of control characters,
should also be considered.
UI suggestion: Control of the feature should not generally be exposed to the user.
Script/language sensitivity: Can be used in any script with joining behavior — that is, the
scripts for which Joining_Type properties are given explicitly in ArabicShaping.txt.
Feature interaction: This feature may be used in combination with other substitution
(GSUB) features, whose results it may override. See also 'fina', 'init' and 'medi'.

Tag: 'ital'
Friendly name: Italics
Registered by: Adobe
Function: Some fonts (such as Adobe’s Pro Japanese fonts) will have both Roman and
Italic forms of some characters in a single font. This feature replaces the Roman glyphs
with the corresponding Italic glyphs.
Example: The user would apply this feature to replace B with B.
Recommended implementation: A lookup table for the 'ital' feature maps the Roman
forms in a font to the corresponding Italic forms (GSUB lookup type 1).
Application interface: This feature is applied automatically by the application based on
italic formatting indicated in document markup, user control or other means.
UI suggestion: When a user selects text and applies an Italic style, an application should
check for this feature and use it if present.
Script/language sensitivity: Used mostly for Latin, particularly in fonts designed primarily
for CJKV or other scripts that do not normally use italics.
Feature interaction: This feature may be used in combination with other substitution
(GSUB) features, whose results it may override. In CJKV fonts it should activate the 'kern'
feature (which would typically be on in other scripts).

Tag: 'jalt'
Friendly name: Justification Alternates

Registered by: Microsoft
Function: Improves justification of text by replacing glyphs with alternate forms
specifically designed for this purpose (they would have less or more advance width as
need may be).
Example: In the Arabic script, providing alternate forms for line final glyphs would result
in better justification and reduce the use of tatweels (Kashidas). eg. replacing a Swash
Kaf with an alternate form.
Recommended implementation: A lookup table for the 'jalt' feature maps the initial,
medial, final or isolated forms to their corresponding alternate forms (GSUB lookup type
1).
This feature can be implemented in conjunction with justification extension or shrinkage
modifications in a JSTF table.
Application interface: In recommended usage, this feature is applied to glyphs in justified
text, as determined by a justification algorithm or direct user control. The feature may
affect the length of lines, which should be taken into consideration by line-breaking and
justification algorithms.
UI suggestion: This feature could be made active or inactive by default, at the user’s
preference.
Script/language sensitivity: Can be used in any cursive script.
Feature interaction: If the font contains 'init', 'medi', 'fina', 'isol' features, these need to
be called prior to calling this feature.

Tag: 'jp78'
Friendly name: JIS78 Forms
Registered by: Adobe
Function: This feature replaces default (JIS90) Japanese glyphs with the corresponding
forms from the JIS C 6226-1978 (JIS78) specification.
Example: The user would invoke this feature to replace the default glyph for kanji
character U+5516 with the glyph for U+555E.
Recommended implementation: When JIS90 glyphs correspond to JIS78 forms, a lookup
table for the 'jp78' feature maps each of those glyphs to their alternates. While many of
these substitutions are one-to-one (GSUB lookup type 1), others require a selection

from a set (GSUB lookup type 3). The manufacturer may choose to build two tables (one
for each lookup type) or only one which uses lookup type 3 for all substitutions.
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria. If the font is implemented
using an alternate substitution lookup, the application should provide a means for the
user to select the one desired. The application may assume that the first glyph in a set is
the preferred form, so the font developer should order them accordingly. Note that the
effect of this feature is effectively equivalent to a change of character code. Besides the
original character code, the application should store the character code for the new
glyph.
UI suggestion: This feature should be off by default.
Script/language sensitivity: Used only for Japanese.
Feature interaction: This feature is mutually exclusive to most other features, which
should be turned off when it’s applied. Exceptions include the 'palt', 'vpal', 'vert' and
'vrt2' features, which may be used in addition.

Tag: 'jp83'
Friendly name: JIS83 Forms
Registered by: Adobe
Function: This feature replaces default (JIS90) Japanese glyphs with the corresponding
forms from the JIS X 0208-1983 (JIS83) specification.
Example: Because of the Han unification in Unicode, there are no JIS83 glyphs which
have distinct Unicode values, so the substitution cannot be described specifically.
Recommended implementation: When JIS90 glyphs correspond to JIS83 forms, a lookup
table for the 'jp83' feature maps each of those glyphs to their alternates (GSUB lookup
type 1).
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria. If the font is implemented
using an alternate substitution lookup, the application should provide a means for the
user to select the one desired.
UI suggestion: This feature should be off by default.
Script/language sensitivity: Used only for Japanese.

Feature interaction: This feature is mutually exclusive to most other features, which
should be turned off when it’s applied. Exceptions include the 'palt', 'vpal', 'vert' and
'vrt2' features, which may be used in addition.

Tag: 'jp90'
Friendly name: JIS90 Forms
Registered by: Adobe
Function: This feature replaces Japanese glyphs from the JIS78 or JIS83 specifications
with the corresponding forms from the JIS X 0208-1990 (JIS90) specification.
Example: The user would invoke this feature to replace the glyph for kanji character
U+555E with the glyph for U+5516.
Recommended implementation: A lookup table for 'jp90' feature maps each JIS78 and
JIS83 form in a font to JIS90 forms (GSUB lookup type 1). The application stores a record
of any simplified forms which resulted from substitutions (the 'jp78' or 'jp83' features);
for such forms, applying the 'jp90' feature undoes the previous substitution. When there
is no record of a substitution, the application uses the 'jp90' table to get back to the
default form.
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria. Note that the effect of this
feature is effectively equivalent to a change of character code. Besides the original
character code, the application should store the character code for the new glyph.
UI suggestion: This feature should be off by default.
Script/language sensitivity: Used only for Japanese.
Feature interaction: This feature is mutually exclusive to most other features, which
should be turned off when it’s applied. Exceptions include the 'palt', 'vpal', 'vert' and
'vrt2' features, which may be used in addition.

Tag: 'jp04'
Friendly name: JIS2004 Forms
Registered by: Adobe
Function: The National Language Council (NLC) of Japan has defined new glyph shapes
for a number of JIS characters, which were incorporated into JIS X 0213:2004 as new

prototypical forms. The 'jp04' feature is a subset of the 'nlck' feature, and is used to
access these prototypical glyphs in a manner that maintains the integrity of JIS X
0213:2004.

Example: The glyph

is replaced by the glyph

.

Recommended implementation: One-for-one substitution of non-JIS X 0213:2004 glyphs
by the corresponding JIS X 0213:2004 glyph (GSUB lookup type 1).
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria.
UI suggestion: This feature should be off by default.
Script/language sensitivity: Used only for Japanese.
Feature interaction: This feature is mutually exclusive to 'jp78', 'jp83', 'jp90', 'nlck' and
similar features. It can be combined with the 'palt', 'vpal', 'vert' and 'vrt2' features.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

Registered Features: Descriptions and
Implementations (k – o)
Article • 05/31/2024

a-e|f-j|k-o|p-t|u-z

Tag: 'kern'
Friendly name: Kerning
Registered by: Microsoft/Adobe
Function: In horizontal text layout, used to adjust the amount of space between specific
glyph combinations to provide optically consistent spacing between glyphs.
Although a well-designed typeface has consistent inter-glyph spacing overall, some
glyph combinations require adjustment for improved legibility. Besides standard
adjustment in the horizontal direction, this feature can provide “cross-stream” kerning in
the Y text direction, make adjustments to glyph placement independent of the advance
adjustment, and can supply size-dependent kerning data via device tables. Note that
lookups for this feature can apply to runs of more than two glyphs.
This feature is not intended for use in vertical text layout. See the 'vkrn' feature for
vertical kerning.
This feature should only be used for intended spacing adjustments that can be
overridden by the user. For required spacing adjustments not under user control, as
might be needed for certain scripts, the 'dist' feature should be used.
Example: The o is shifted closer to the T in the combination “To.”
Recommended implementation: The font adjusts metrics for pairs of glyphs (GPOS
lookup type 2 or 8, xPlacement, xAdvance, yPlacement and yAdvance). These can be
stored as one or more tables matching left and right classes, or as individual pairs.
Additional adjustments may be provided for longer sequences of glyphs (e.g., triplets,
quadruplets, etc.) and ordered to take precedence over pair kern adjustments of
particular combinations.
A font should not apply kerning adjustments to fixed-width glyphs unless other features
can be applied that adjust glyph metrics to be proportional. In new fonts, kerning of
glyphs with default fixed-width metrics that have been adjusted to have proportional

widths should be implemented using the 'apkn' feature rather than this feature. See
below for more details.
When using a GPOS type 2 lookup for this feature, it is recommended that no
positioning adjustment be applied to the second glyph in a pair. (That is, that
valueFormat2 should be set to 0.) As a result, the next glyph pair to be processed after
the lookup has been applied to this pair will start at the second glyph. In this way, every
glyph in a sequence can undergo positioning adjustment as the first glyph in a pair.
Otherwise, if positioning of the second glyph is adjusted, then the next glyph pair to be
processed will begin with the glyph following the second glyph. That will result in
kerning adjustment happening only for every other pair of glyphs.
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria.
UI suggestion: In most horizontal text layout, this feature should be active by default—
see below for important exceptions. Applications may allow users to add further
manually specified adjustments to suit specific needs and tastes. This feature should be
optional: when activated by default for a text run, it should be possible for users to
disable it for that run.
An exception to default activation can apply for CJK text. If a text run is formatted with a
font that implements the 'palt' feature, this feature should not be activated by default to
glyphs covered by 'palt' lookups unless the 'palt' feature has been activated. (Glyphs
covered by 'palt' lookups will have fixed-width metrics by default, and the kerning
adjustments applied by this feature would be inappropriate for glyphs with fixed-width
metrics.) An application can scan the coverage tables of 'palt' lookups to determine
glyphs to be excluded from default activation. Alternately, an application can use the
East Asian Width property, defined in Unicode Standard Annex #11, East Asian Width ,
to determine characters likely to have fixed-width glyphs by default. Specifically,
Unicode characters with East_Asian_Width property values Wide or Fullwidth may be
assumed to have default fixed-width metrics in fonts that implement 'palt', and
therefore excluded from default activation of the 'kern' feature.
In new fonts, however, glyphs that are fixed width by default but are made proportional
by application of 'palt' should have their kerning implemented using the 'apkn' feature
rather than the 'kern' feature. If a font implements both the 'palt' and 'apkn' features,
then the 'kern' feature can be applied by default to all horizontal text. But if a font
implements 'palt' but not 'apkn', then one of the techniques described in the previous
paragraph should be used to condition default application of 'kern'.
If a font implements 'kern' but does not implement 'palt', then 'kern' should be applied
by default to all horizontal text using that font. See below for other important feature

interactions.
Script/language sensitivity: None.
Feature interaction: The 'kern' feature should not be used in combination with features
that result in fixed-width metrics ('chws', 'fwid', 'halt', 'hwid', 'qwid', 'twid', 'tnum'). If any
of those features are activated on a text run, this feature should be disabled for that run.
This feature may be used in combination with the 'pkna' and 'pwid' features, which
substitute alternate proportional-width glyphs for fixed-width glyphs. When those
features are activated on a text run, this feature may be activated for that run, either by
default or by user preference.
This feature may also be used in combination with the 'palt' feature, which adjusts glyph
metrics to be proportional. See details above regarding interaction between this feature
and 'palt'. Also see recommendations above regarding use of the 'apkn' feature in fonts.
If kerning is activated by default as a result of activation of any of the above features
that result in proportional widths, users should still have the option to disable this while
the proportional-width feature is still active.

Tag: 'lfbd'
Friendly name: Left Bounds
Registered by: Adobe
Function: Aligns glyphs by their apparent left extents at the left ends of horizontal lines
of text, replacing the default behavior of aligning glyphs by their origins.
Example: Succeeding lines beginning with T, D and W would shift to the left by varying
amounts when the text is left-justified and this feature is applied.
Recommended implementation: Values for affected glyphs describe the amount by which
the placement and advance width should be altered (GPOS lookup type 1).
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria. In recommended usage, the
application applies this feature to characters at the left end of a horizontal line when
paragraphs are left or left and right justified.
UI suggestion: This feature should be inactive by default. Applications may expose to
users direct control of this feature and also the Right Bounds feature ('rtbd'), or may
automatically activate the feature based on other paragraph layout settings.

Script/language sensitivity: None.
Feature interaction: Should not be applied to glyphs which use fixed-width features (e.g.
'fwid', 'halt', 'hwid', 'qwid' and 'twid') or vertical features (e.g. 'vert', 'vrt2', 'vpal', 'valt' and
'vhal').

Tag: 'liga'
Friendly name: Standard Ligatures
Registered by: Microsoft/Adobe
Function: Replaces a sequence of glyphs with a single glyph which is preferred for
typographic purposes. This feature covers the ligatures which the
designer/manufacturer judges should be used in normal conditions.
Example: The glyph for ffl replaces the sequence of glyphs f f l.
Recommended implementation: A lookup table for the 'liga' feature maps sequences of
glyphs to corresponding ligatures (GSUB lookup type 4). Ligatures with more
components need to be stored ahead of those with fewer components in order to be
found. The set of standard ligatures will vary by design and script.
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria.
UI suggestion: This feature serves a critical function in some contexts and should be
active by default.
Script/language sensitivity: None.
Feature interaction: This feature may be used in combination with other substitution
(GSUB) features, whose results it may override.

Tag: 'ljmo'
Friendly name: Leading Jamo Forms
Registered by: Microsoft
Function: Substitutes the form for a Hangul leading consonant jamo used in a jamo
cluster.

Example: In Hangul script, the jamo cluster is composed of three parts: leading
consonant, vowel, and trailing consonant. When a leading jamo is found, an alternate
leading jamo form is substituted.
Recommended implementation: The default glyph for a leading jamo is mapped into an
alternate form required for conjoining in a syllable (GSUB lookup type 1, or a contextual
substitution referencing a type 1 lookup).
Application interface: In recommended usage, this feature triggers substitutions required
for correct layout of certain scripts. It should be applied in the appropriate contexts, as
determined by script-specific processing requirements.
UI suggestion: Control of the feature should not generally be exposed to the user.
Script/language sensitivity: Used for Hangul script, particularly when Unicode conjoining
jamo characters are used.
Feature interaction: This feature overrides the results of all other features.

Tag: 'lnum'
Friendly name: Lining Figures
Registered by: Adobe (Modified by Adobe, this is the newer description)
Function: This feature changes selected non-lining figures (digits) to lining figures.
Example: The user invokes this feature in order to get lining figures, which fit better with
all-capital text. Various characters designed to be used with figures may also be covered
by this feature. In cases where lining figures are the default form, this feature would
undo previous substitutions.
Recommended implementation: Glyphs for figures (digits) or other characters used in
numbers (grouping or decimal separators) are mapped to corresponding lining forms
(GSUB lookup type 1). If the default figures are non-lining, they too are mapped to the
corresponding lining form.
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria.
UI suggestion: This feature should be inactive by default. Users can switch between the
lining and oldstyle sets by turning this feature on or off. Note that this feature is distinct
from the figure width features ('pnum' and 'tnum'). When the user invokes this feature,
the application could inquire whether a change in width is also desired.

Script/language sensitivity: None.
Feature interaction: This feature is mutually exclusive to the Oldstyle Figures feature
('onum').

Tag: 'locl'
Friendly name: Localized Forms
Registered by: Tiro Typeworks/Adobe
Function: Many scripts used to write multiple languages over wide geographical areas
have developed localized variant forms of specific letters, which are used by individual
literary communities. For example, several letters in the Bulgarian and Serbian alphabets
have forms distinct from their Russian counterparts and from each other. In some cases,
the localized form differs only subtly from the script “norm”, in others the forms are
radically distinct. This feature enables localized forms of glyphs to be substituted for
default forms.
Example: The user applies this feature to text to enable localized Bulgarian forms of
Cyrillic letters; alternatively, the feature might enable localized Russian forms in a
Bulgarian manufactured font in which the Bulgarian forms are the default characters.
Recommended implementation: For a given Unicode value, the font contains glyphs for
two or more locales. A lookup table for the 'locl' feature maps GIDs for default forms to
GIDs for corresponding localized alternatives. These are one-to-one substitutions (GSUB
lookup type 1). Different language systems can have different implementations for this
feature, with lookups that provide appropriate substitutions for each language system.
Application interface: In recommended usage, this feature triggers substitutions or
positioning adjustments to provide the most appropriate typography for the language
of content. This feature should always be applied. Language tagging or similar metadata
indicating the language of the text should be used to select the most appropriate
language system table within the font’s GPOS or GSUB table.
UI suggestion: Control of the feature should not generally be exposed to the user
directly. Control over language-specific typography should be provided by language
settings or by providing the user ability to choose between the alternative language
systems supported in the font’s GPOS or GSUB tables.
Script/language sensitivity: None.
Feature interaction: This feature can be used in combination with any other feature.

Tag: 'ltra'
Friendly name: Left-to-right Alternates
Registered by: Adobe
Function: This feature applies glyphic variants (other than mirrored forms) appropriate
for left-to-right text (for mirrored forms, see 'ltrm').
Recommended implementation: These are required to be glyph substitutions, and it is
recommended that they be one-to-one (GSUB lookup type 1).
Application interface: See section “Left-to-right and right-to-left text” on the Advanced
Typographic Extensions page.
UI suggestion: Control of this feature should not generally be exposed to the user.
Script/language sensitivity: Left-to-right runs of text.
Feature interaction: This feature is to be applied simultaneously with other pre-shaping
features such as 'ccmp' and 'locl'.

Tag: 'ltrm'
Friendly name: Left-to-right Mirrored Forms
Registered by: Adobe
Function: This feature applies mirrored forms appropriate for left-to-right text. (For leftto-right glyph alternates, see 'ltra').
Example: The Old South Arabian script is a case of a strong right-to-left script that can
have lines laid out left-to-right, in which case some glyphs would need to be mirrored
with the 'ltrm' feature.
Recommended implementation: These are required to be glyph substitutions, and it is
recommended that they be one-to-one (GSUB lookup type 1).
Application interface: See section “Left-to-right and right-to-left text” on the Advanced
Typographic Extensions page.
UI suggestion: Control of this feature should not generally be exposed to the user.
Script/language sensitivity: Left-to-right runs of text; also see Example above.

Feature interaction: This feature is to be applied simultaneously with other pre-shaping
features such as 'ccmp' and 'locl'.

Tag: 'mark'
Friendly name: Mark Positioning
Registered by: Microsoft
Function: Positions mark glyphs with respect to base glyphs.
Example: In the Arabic script, positioning the Hamza above the Yeh.
Recommended implementation: This feature can be implemented as a mark-to-base
attachment lookup (GPOS LookupType = 4) or a mark-to-ligature attachment lookup
(GPOS LookupType = 5).
Application interface: In recommended usage, this feature triggers positioning of mark
glyphs required for correct layout. It should always be applied.
UI suggestion: Control of this feature should not generally be exposed to the user.
Script/language sensitivity: None.
Feature interaction: None.

Tag: 'med2'
Friendly name: Medial Forms #2
Registered by: Microsoft
Function: Used to replace Alaph glyphs in the middle of Syriac words when the
preceding base character can be joined to. This feature is used only for the Syriac script
Alaph character.
Example: When an Alaph is preceded by a Heth, the Alaph would be replaced by an
appropriate form.
Recommended implementation: Default alphabetic forms are mapped to corresponding
medial forms (GSUB lookup type 1).
Application interface: In recommended usage, this feature triggers substitutions required
for correct layout of Syriac text. The application should always apply the feature to the
Alaph glyph when the preceding base character is a joining character.

UI suggestion: Control of the feature should not generally be exposed to the user.
Script/language sensitivity: Used only with the Syriac script.
Feature interaction: This feature may be used in combination with other substitution
(GSUB) features, whose results it may override. See also 'init' and 'fina'.

Tag: 'medi'
Note: This feature description was significantly revised in 2016.
Friendly name: Medial Forms
Registered by: Microsoft/Adobe
Function: Replaces glyphs for characters that have applicable joining properties with an
alternate form when occurring in a medial context. This applies to characters that have
the Unicode Joining_Type property value Dual_Joining.
Unicode Joining_Type property values are obtained from the Unicode Character
Database

(UCD). Specifically, Joining_Type property values are documented in the

UCD file, ArabicShaping.txt, the current version of which is available at
http://www.unicode.org/Public/UCD/latest/ucd/ArabicShaping.txt

.

Example: In an Arabic-script font, the application would apply the 'medi' feature to the
letter ARABIC LETTER QAF (U+0642 “‫ )”ق‬when it follows a left-joining character and
precedes a right-joining character, thereby replacing the default “‫ ”ق‬glyph with its dualjoining, medial form.
Recommended implementation: The 'medi' feature is used to map default forms to
corresponding dual-joining, medial forms. This will usually be implemented using a
single substitution (type 1) GSUB lookup, though contextual substitution GSUB lookups
(types 5, 6 or 8) could also be appropriate.
Application interface: In recommended usage, this feature triggers substitutions that are
required for correct display of cursively-connecting scripts. It should be applied in the
appropriate contexts, as determined by script-specific processing requirements. The
application is responsible for parsing character strings and identifying which of the
joining-related features — initial forms ('init'), medial forms ('medi'), terminal forms
('fina'), and isolated forms ('isol') — to apply to which glyphs, based on character
Joining_Type properties. Additional factors, such as the presence of control characters,
should also be considered.
UI suggestion: Control of the feature should not generally be exposed to the user.

Script/language sensitivity: Can be used in any script with joining behavior — that is, the
scripts for which Joining_Type properties are given explicitly in ArabicShaping.txt.
Feature interaction: This feature may be used in combination with other substitution
(GSUB) features, whose results it may override. See also 'fina', 'init' and 'isol'.

Tag: 'mgrk'
Friendly name: Mathematical Greek
Registered by: Adobe
Function: Replaces standard typographic forms of Greek glyphs with corresponding
forms commonly used in mathematical notation (which are a subset of the Greek
alphabet).
Example: The user applies this feature to U+03A3 (Sigma), and gets the glyph for
U+2211 (summation).
Recommended implementation: A lookup table for the 'mgrk' feature maps Greek glyphs
to the corresponding forms used for mathematics (GSUB lookup type 1).
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria. Note that the effect of this
feature is effectively equivalent to a change of character codes. Besides the original
character codes, the application should store the character codes for the new glyphs.
UI suggestion: This feature should be off by default in most applications. Math-oriented
applications may activate this feature by default.
Script/language sensitivity: Used with Greek characters.
Feature interaction: This feature may be used in combination with other substitution
(GSUB) features, whose results it may override.

Tag: 'mkmk'
Friendly name: Mark to Mark Positioning
Registered by: Microsoft
Function: Positions marks with respect to other marks. Required in various non-Latin
scripts like Arabic.

Example: In Arabic, the ligaturised mark Ha with Hamza above it can also be obtained by
positioning these marks relative to one another.
Recommended implementation: This feature can be implemented as a mark-to-mark
Attachment lookup (GPOS lookup type 6).
Application interface: In recommended usage, this feature triggers positioning of mark
glyphs required for correct layout. It should always be applied.
UI suggestion: Control of this feature should not generally be exposed to the user.
Script/language sensitivity: None.
Feature interaction: None.

Tag: 'mset'
Friendly name: Mark Positioning via Substitution
Registered by: Microsoft
Function: Positions Arabic combining marks in fonts for Windows 95 using glyph
substitution.
This feature is not recommended for use in new fonts.
Example: In Arabic, the Hamza is positioned differently when placed above a Yeh Barree
as compared to the Alef.
Recommended implementation: In contrast to the 'mark' feature, 'mset' uses glyph
substitution to position marks on base glyphs. It replaces a default mark glyph with a
correctly positioned mark glyph. The font designer specifies the position of the mark
when describing the mark’s contour in the font file.
Microsoft’s Arabic fonts for Windows 95 used a contextual substitution lookup (GSUB
lookup type 5) to implement this feature.
Application interface: When using legacy fonts that implement this feature, the feature
triggers substitutions that are required for correct display and should be applied to the
entire text run.
UI suggestion: Control of this feature should not generally be exposed to the user.
Script/language sensitivity: Used only in legacy Arabic fonts.

Feature interaction: This feature may be used in combination with other substitution
(GSUB) features, whose results it may override.

Tag: 'nalt'
Friendly name: Alternate Annotation Forms
Registered by: Adobe
Function: Replaces default glyphs with various notational forms (e.g., glyphs placed in
open or solid circles, squares, parentheses, diamonds, or rounded boxes). In some cases,
an annotation form could already be present, but the user might want a different one.
Example: The user invokes this feature to get the glyph of U+3200 (the circled form of
“ga”) from U+3131 (hangul “ga”).
Recommended implementation: A lookup table for the 'nalt' feature maps GIDs for
various standard forms to one or more corresponding annotation forms. While many of
these substitutions are one-to-one (GSUB lookup type 1), others require a selection
from a set (GSUB lookup type 3). A font developer can choose to build two tables (one
for each lookup type) or only one which uses lookup type 3 for all substitutions. If more
than one form is present, the set of forms for each character should be ordered
consistently, both within the font and across the family.
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria. If implemented in a font
using an alternate substitution lookup, the application selects one of the alternative
glyphs based on user choice or other criteria.
UI suggestion: This feature should be inactive by default. When implemented in the font
using an alternate substitution lookup, the application should provide a means for the
user to select the desired form from the alternative glyphs mapped in the lookup. It can
note the position of the selected form in a set of alternates and offer the glyph at that
position as the default selection the next time this feature is invoked. In the absence of
such prior information, the application may assume that the first glyph in a set is the
preferred form, so the font developer should order them accordingly.
Script/language sensitivity: Used mostly in CJKV fonts, but can also be used for European
scripts.
Feature interaction: This feature is mutually exclusive to most other features, which
should be turned off when it’s applied. Exceptions include the 'vert' and 'vrt2' features,
which may be used in addition.

Tag: 'nlck'
Friendly name: NLC Kanji Forms
Registered by: Adobe Systems Inc.
Function: The National Language Council (NLC) of Japan has defined new glyph shapes
for a number of JIS characters in 2000. The 'nlck' feature is used to access those glyphs.

Example: The glyph

is replaced by the glyph

.

Recommended implementation: One-for-one substitution of non-NLC glyphs by the
corresponding NLC glyph (GSUB lookup type 1).
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria.
UI suggestion: This feature should be off by default.
Script/language sensitivity: Used only for Kanji characters in Japanese.
Feature interaction: This feature is mutually exclusive to the 'jp78', 'jp83', 'jp90' and
similar features. It can be combined with the 'palt', 'vpal', 'vert' and 'vrt2' features.

Tag: 'nukt'
Friendly name: Nukta Forms
Registered by: Microsoft
Function: Produces nukta forms in Indic scripts.
Example: In Hindi (Devanagari script), a consonant when combined with a nukta gives its
nukta form.
Recommended implementation: A lookup table for the 'nukt' feature maps the sequence
of a consonant followed by a nukta to the consonant’s nukta form (GSUB lookup type
4).
Application interface: In recommended usage, this feature triggers substitutions that are
required for correct display of the given script. It should be applied in the appropriate
contexts, as determined by script-specific processing requirements.

UI suggestion: Control of the feature should not generally be exposed to the user.
Script/language sensitivity: Used for Indic or other Brahmi-derived scripts.
Feature interaction: This feature is used in conjunction with certain other features to
derive required forms of Indic scripts. The application is expected to process this feature
and certain other features in an appropriate order to obtain the correct set of basic
forms: 'nukt', 'akhn', 'rphf', 'rkrf', 'pref', 'blwf', 'half', 'pstf', 'cjct'. Other discretionary
features for optional typographic effects may also be applied. Lookups for such
discretionary features should be processed after lookups for this feature have been
processed.

Tag: 'numr'
Friendly name: Numerators
Registered by: Adobe
Function: Replaces selected figures (digits) which precede a slash with numerator figures,
and replaces the typographic slash with the fraction slash.
Example: When the fraction feature ('frac') is applied to the string 11/17, the application
applies this feature to the initial portion of the string to turn the 11 into numerators, and
the slash into a fraction slash.
Recommended implementation: Glyphs for figures (digits) or other characters used in
numbers (grouping or decimal separators) are mapped to corresponding numerator
glyphs; and the glyph for slash (U+002F) is mapped to a fraction slash (glyph for
U+2044). Substitutions are one-to-one (GSUB lookup type 1).
Application interface: In recommended usage, this feature is applied automatically as
part of the application’s implementation for the 'frac' feature. See the 'frac' for details.
UI suggestion: In recommended usage, this feature is applied to sequences automatically
by applications when the 'frac' feature is used, and direct user control is not required.
Script/language sensitivity: None.
Feature interaction: This feature supports application implementation for the 'frac'
feature. It may be used in combination with other substitution (GSUB) features, whose
results it may override.

Tag: 'onum'

Friendly name: Oldstyle Figures
Registered by: Microsoft/Adobe
Function: This feature changes selected figures from the default or lining style to
oldstyle form.
Example: The user invokes this feature to get oldstyle figures, which fit better into the
flow of normal upper- and lowercase text. Various characters designed to be used with
figures may also have oldstyle versions.
Recommended implementation: Glyphs for figures (digits) or other characters used in
numbers (grouping or decimal separators) are mapped to corresponding oldstyle forms
(GSUB lookup type 1). If the default figures are non-lining, they too are mapped to the
corresponding oldstyle form.
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria.
UI suggestion: This feature should be inactive by default. Users can switch between the
default and oldstyle figure sets by turning this feature on or off. This feature is separate
from the figure-width features 'pnum' and 'tnum'. When the user changes figure style,
the application could query whether a change in width is also desired.
Script/language sensitivity: None.
Feature interaction: This feature overrides the results of the Lining Figures feature
('lnum').

Tag: 'opbd' (DEPRECATED)
Friendly name: Optical Bounds
Registered by: Adobe
Function: Aligns glyphs by their apparent left or right extents in horizontal setting, or
apparent top or bottom extents in vertical setting, replacing the default behavior of
aligning glyphs by their origins. Another name for this behavior would be visual
justification. The optical edge of a given glyph is only indirectly related to its advance
width or bounding box; this feature provides a means for getting true visual alignment.
Example: Succeeding lines beginning with T, D and W would shift to the left by varying
amounts when the text is left-justified and this feature is applied. Succeeding lines

ending with r, h and y would likewise shift to the right by differing degrees when the
text is right-justified and this feature is applied.
Recommended implementation: Positioning adjustments (GPOS lookup type 1) are
implemented in separate lookups associated with features for left, right, top and bottom
line positions.
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria. The application
implementation for this feature should make use of the 'lfbd' and 'rtbd' features: the
'lfbd' feature should be applied automatically to glyphs at the left end of a horizontal
line; the 'rtbd' feature should be applied automatically to glyphs at the right end of a
horizontal line. It affects the line length, which should be taken into consideration by
line-breaking and justification algorithms.
UI suggestion: This feature should be active by default.
Script/language sensitivity: None.
Feature interaction: Should not be applied to glyphs which use fixed-width features (e.g.
'fwid', 'halt', 'hwid', 'qwid' and 'twid') or vertical features (e.g. 'vert', 'vrt2', 'vpal', 'valt' and
'vhal'). Uses 'lfbd' and 'rtbd' features.

Tag: 'ordn'
Friendly name: Ordinals
Registered by: Adobe
Function: Replaces default alphabetic glyphs with the corresponding ordinal forms for
use after figures. One exception to the follows-a-figure rule is the numero character
(U+2116), which is actually a ligature substitution, but is best accessed through this
feature.
Example: The user applies this feature to turn 2.o into 2.o (abbreviation for secundo).
Recommended implementation: Glyphs for various lowercase letters are mapped to
corresponding ordinal forms using a chained-context substitution (GSUB lookup type 6);
and the sequence of default glyphs for “No” are mapped to a numero ligature glyph
(GSUB lookup type 4).
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria. When processing lookups,
context before or after the glyph sequence to which the feature is applied should be

considered. Note that the effect of this feature could be effectively equivalent to a
change of character codes. Besides the original character codes, the application should
store the character codes for the new glyph.
UI suggestion: This feature should be off by default.
Script/language sensitivity: Used mostly for Latin script.
Feature interaction: This feature may be used in combination with other substitution
(GSUB) features, whose results it may override.

Tag: 'ornm'
Friendly name: Ornaments
Registered by: Adobe
Function: This is a dual-function feature, which uses two input methods to give the user
access to ornament glyphs (e.g. fleurons, dingbats and border elements) in the font.
One method replaces the bullet character with a selection from the full set of available
ornaments; the other replaces specific “lower ASCII” characters with ornaments assigned
to them. The first approach supports the general or browsing user; the second supports
the power user.
Example: The user inputs “qwwwwwwwwwe” to form the top of a flourished box in
Adobe Caslon, or inputs the bullet character, then chooses the thistle dingbat.
Recommended implementation: All ornament glyphs are mapped from the default glyph
of the bullet character (U+2022) as alternates (GSUB lookup type 3); or ornament glyphs
are mapped from the default glyph of corresponding alphanumeric characters (GSUB
lookup type 1). A font developer can choose to build two tables (one for each lookup
type) or only one which uses lookup type 3 for all substitutions. As in any alternate
substitution lookup, alternates present in more than one face should be ordered
consistently across a family, so that those alternates can work correctly when switching
between family members.
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria. When this feature is
invoked, the application must note whether the selected text is the bullet character
(U+2022) or alphanumeric characters. In the first case, it retrieves the glyphs mapped
from the bullet glyph, and gives the user a means to select from among them. In the
second case, a substitution is applied directly.

UI suggestion: This feature should be inactive by default. When implemented in the font
using an alternate substitution lookup (the bullet case), an application could display the
forms sequentially in context, or present a palette showing all the forms at once, or give
the user a choice between these approaches. Once the user has selected a specific
ornament, that one should be the default selection the next time the bullet is typed. In
the absence of such prior information, the application may assume that the first
ornament in a set is the preferred form, so the font developer should order them
accordingly.
Script/language sensitivity: None.
Feature interaction: This feature is mutually exclusive to all other substitution (GSUB)
features, which should be turned off when it’s applied.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

Registered Features: Descriptions and
Implementations (p – t)
Article • 05/31/2024

a-e|f-j|k-o|p-t|u-z

Tag: 'palt'
Friendly name: Proportional Alternate Widths
Registered by: Adobe
Function: Re-spaces glyphs designed to be set on full-em widths, fitting them onto
individual (more or less proportional) horizontal widths. This differs from 'pwid' in that it
does not substitute new glyphs (GPOS, not GSUB). The user might prefer the fixed-width
form, or could simply want to ensure that the glyph is well-fit and not rotated in vertical
setting (Latin forms designed for proportional spacing would be rotated).
Example: The user invokes this feature in a Japanese font to get Latin, Kanji, Kana or
Symbol glyphs with the full-width design but individual metrics.
Recommended implementation: The font specifies alternate metrics for the full-width
glyphs (GPOS lookup type 1).
If a font supports this feature and also supports kerning, it is recommended that kerning
for glyphs affected by this feature be implemented using the 'apkn' feature and not the
'kern' feature. (The 'kern' feature should still be used for glyphs that have proportional
widths by default.) See the 'apkn' feature for more information.
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria.
UI suggestion: This feature should be off by default. See below for details regarding
important interactions with other features.
Script/language sensitivity: Used mostly in CJKV fonts.
Feature interaction: This feature is mutually exclusive to other horizontal glyph-width
features ('chws', 'fwid', 'halt', 'hwid', 'pwid', 'qwid' and 'twid'), which should be turned off
when it’s applied.

This feature may be used in combination with the 'apkn' or 'kern' features. If this feature
is activated for a text run, then kerning features can be activated for that run, either by
default or by user preference. However, if this feature is not activated, then the 'apkn'
and 'kern' features should not be activated for glyphs covered by the lookups for this
feature, as the kerning adjustments applied by those features would be inappropriate
for glyphs with fixed-width metrics.
See also 'vpal'.

Tag: 'pcap'
Friendly name: Petite Capitals
Registered by: Tiro Typeworks / Emigre
Function: Some fonts contain an additional size of capital letters, shorter than the
regular smallcaps and whimsically referred to as petite caps. Such forms are most likely
to be found in designs with a small lowercase x-height, where they better harmonize
with lowercase text than the taller smallcaps (for examples of petite caps, see the Emigre
type families Mrs Eaves and Filosofia). This feature turns glyphs for lowercase characters
into petite capitals. Forms related to petite capitals, such as specially designed figures,
may be included.

Note: Some languages written with bicameral scripts have special case-mapping
behaviors for certain characters. Care is needed by font and application developers
to handle these cases correctly. See the 'smcp' feature for more information.
Example: The user applies the feature to lowercase or mixed case text and gets petite
cap text or text with regular uppercase and petite caps. Note that some designers might
extend the petite cap lookups to include uppercase-to-smallcap substitutions, creating a
shifting hierarchy of uppercase forms.
Recommended implementation: A lookup table for the 'pcap' feature maps lowercase
glyphs to the corresponding petite cap forms (GSUB lookup type 1).
Correct handling of case mapping for some languages could require exceptions to be
handled using separate language systems. Also, some applications could handle
language-specific case mappings by mapping the lowercase characters to appropriate
uppercase characters in a temporary buffer and then applying the 'c2pc' feature. Fonts

that implement 'pcap' should also implement the 'c2pc' feature. See the 'smcp' feature
for more information.
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria.
For best handling of language-specific case mapping behaviors, applications can
implement petite-cap formatting by mapping lowercase characters to uppercase in a
temporary buffer and then applying the 'c2pc' feature. See the 'smcp' feature for more
information.
UI suggestion: This feature should be off by default.
Script/language sensitivity: Applies only to scripts with both upper- and lowercase forms
(e.g. Latin, Cyrillic, Greek).
Feature interaction: This feature may be used in combination with other substitution
(GSUB) features, whose results it may override.

Tag: 'pkna'
Friendly name: Proportional Kana
Registered by: Adobe
Function: Replaces kana and kana-related glyphs set on uniform widths (half or fullwidth) with proportional glyphs.
Example: The user invokes this feature in a Japanese font to get a proportional kana
glyph instead of a corresponding half-width or full-width kana glyph.
Recommended implementation: The font contains alternate kana and kana-related
glyphs designed to be set on proportional widths (GSUB lookup type 1).
If a kerning feature is also implemented, the fixed-width glyphs covered by this feature
should not be kerned; only the proportional glyphs substituted by this feature should be
kerned.
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria.
UI suggestion: This feature should be off by default. See below for details on important
feature interactions.
Script/language sensitivity: Generally used only in Japanese fonts.

Feature interaction: This feature is mutually exclusive to all other horizontal glyph-width
features ('chws', 'fwid', 'halt', 'hwid', 'palt', 'pwid', 'qwid', 'twid'), which should be turned
off when it’s applied.
This feature may be used in combination with the 'kern' feature. When this feature is
activated on a text run, the 'kern' feature can be activated for that run, either by default
or by user preference. (If kerning is activated by default, users should still have the
option to disable it while this feature is still active.) With the recommended
implementation for this feature (using GSUB, not GPOS), the default, fixed-width glyphs
are not kerned. Therefore, if this feature is not activated for a text run but the 'kern' is
activated, there should not be any unintended kerning effects for those characters. An
application could still deactivate the 'kern' feature when this feature is not activated,
however.

Tag: 'pnum'
Friendly name: Proportional Figures
Registered by: Microsoft/Adobe
Function: Replaces figure glyphs set on uniform (tabular) widths with corresponding
glyphs set on glyph-specific (proportional) widths. Tabular widths will generally, but not
always, be the default. This feature would not be used in monospaced designs.
Example: The user applies this feature to get even spacing for lining figures used as
dates in an all-cap headline.
Recommended implementation: In order to simplify associated kerning and get the best
glyph design for a given width, this feature should use new glyphs for the figures, rather
than only adjusting the fit of the tabular glyphs (although some might be simple copies);
i.e., not a GPOS feature. A lookup table for the 'pnum' feature maps tabular versions of
lining and/or oldstyle figures to corresponding proportional glyphs (GSUB lookup type
1).
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria.
UI suggestion: This feature should be off by default. The application could query the user
about this feature when the user changes figure style ('onum' or 'lnum').
Script/language sensitivity: None.
Feature interaction: This feature overrides the results of the Tabular Figures feature
('tnum').

Tag: 'pref'
Friendly name: Pre-base Forms
Registered by: Microsoft
Function: Substitutes the pre-base form of a consonant.
In some scripts of south or southeast Asia, such as Khmer, the conjoined form of certain
consonants is always denoted as a pre-base form. In the case of some scripts of south
India, variations in writing conventions exist such that a conjoined Ra consonant can be
written as a pre-base form, or as a below-base or post-base form. Fonts can be
designed to support one or another convention. If a font is designed to support a
writing convention in which conjoined Ra is a pre-base form, the Pre-Base Forms feature
would be used.
Example: In the Khmer script, the consonant Ra has a pre-base subscript form called
Coeng Ra. When the sequence of Coeng followed by Ra occurs, its pre-base form is
substituted.
Recommended implementation: A lookup table for the 'pref' feature maps the sequence
required to convert a consonant into its pre-base form (GSUB lookup type 4).
Application interface: In recommended usage, this feature triggers substitutions required
for correct layout of certain scripts. It should be applied in the appropriate contexts, as
determined by script-specific processing requirements. The effect of lookups associated
with this feature may be used by the application to control subsequent reordering of
conjoined consonant glyphs, as determined by script-specific processing requirements.
UI suggestion: Control of the feature should not generally be exposed to the user.
Script/language sensitivity: Used for Khmer, Myanmar (Burmese) and other Brahmiderived scripts that could display a pre-base form of Ra.
Feature interaction: This feature is used in conjunction with certain other features to
derive required forms of certain Indic and southeast Asian scripts. The application is
expected to process this feature and certain other features in an appropriate order to
obtain the correct set of basic forms for the given script. For Indic scripts, the following
features should be applied in order: 'nukt', 'akhn', 'rphf', 'rkrf', 'pref', 'blwf', 'half', 'pstf',
'cjct'. Other discretionary features for optional typographic effects may also be applied.
Lookups for such discretionary features should be processed after lookups for this
feature have been processed.

Tag: 'pres'
Friendly name: Pre-base Substitutions
Registered by: Microsoft
Function: Produces the pre-base forms of conjuncts in Indic scripts. It can also be used
to substitute the appropriate glyph variant for pre-base vowel signs.
Example: In the Gujarati (Indic) script, the doubling of consonant Ka requires the first Ka
to be substituted by its pre-base form. This in turn ligates with the second Ka. Applying
this feature would result in the ligature version of the doubled Ka.
Recommended implementation: A lookup table for the 'pres' feature maps a sequence of
consonants separated by the virama (halant), to the ligated conjunct form (GSUB lookup
type 4). In the case of pre-base matra substitution, the appropriate matra can be
substituted using contextual substitution (GSUB lookup type 5).
Application interface: In recommended usage, this feature triggers substitutions required
for correct display of certain scripts. It should be applied in the appropriate contexts, as
determined by script-specific processing requirements.
UI suggestion: Control of the feature should not generally be exposed to the user.
Script/language sensitivity: Used for Indic or other Brahmi-derived scripts.
Feature interaction: This feature overrides the results of all other features.

Tag: 'pstf'
Friendly name: Post-base Forms
Registered by: Microsoft
Function: Substitutes the post-base form of a consonant.
Example: In the Gurmukhi (Indic) script, the consonant Ya has a post base form. When
the Ya is used as the second consonant in conjunct formation, its post-base form is
substituted.
Recommended implementation: A lookup table for the 'pstf' feature maps the sequence
required to convert a consonant into its post-base form (GSUB lookup type 4).
Application interface: In recommended usage, this feature triggers substitutions required
for correct display of certain scripts. It should be applied in the appropriate contexts, as

determined by script-specific processing requirements.
UI suggestion: Control of the feature should not generally be exposed to the user.
Script/language sensitivity: Used for scripts of south and southeast Asia that have postbase forms for consonants; e.g., Gurmukhi, Malayalam, Khmer.
Feature interaction: This feature is used in conjunction with certain other features to
derive required forms of Indic and other related scripts. The application is expected to
process this feature and certain other features in an appropriate order to obtain the
correct set of basic forms for the given script. For Indic scripts, the following features
should be applied in order: 'nukt', 'akhn', 'rphf', 'rkrf', 'pref', 'blwf', 'half', 'pstf', 'cjct'.
Other discretionary features for optional typographic effects may also be applied.
Lookups for such discretionary features should be processed after lookups for this
feature have been processed.

Tag: 'psts'
Friendly name: Post-base Substitutions
Registered by: Microsoft
Function: Substitutes a sequence of a base glyph and post-base glyph, with its ligature
form.
Example: In the Malayalam (Indic) script, the consonant Va has a post base form. When
the Va is doubled to form a conjunct VVa; the first Va (the base) and the post base form
that follows it are substituted with a ligature.
Recommended implementation: A lookup table for the 'psts' feature maps identified
conjunct formation sequences to corresponding ligatures (GSUB lookup type 4).
Application interface: In recommended usage, this feature triggers substitutions required
for correct display of certain scripts. It should be applied in the appropriate contexts, as
determined by script-specific processing requirements.
UI suggestion: Control of the feature should not generally be exposed to the user.
Script/language sensitivity: Used for Indic or other Brahmi-derived scripts.
Feature interaction: This feature overrides the results of all other features.

Tag: 'pwid'

Friendly name: Proportional Widths
Registered by: Adobe
Function: Replaces glyphs set on uniform widths (typically full or half-em) with
proportionally spaced glyphs. The proportional variants are often used for the Latin
characters in CJKV fonts, but may also be used for Kana in Japanese fonts.
Example: The user invokes this feature in a Japanese font to get a proportionally spaced
glyph instead of a corresponding half-width Roman glyph or a full-width Kana glyph.
Recommended implementation: The font substitutes alternate glyphs designed to be set
on proportional widths (GSUB lookup type 1).
If a kerning feature is also implemented, the fixed-width glyphs covered by this feature
should not be kerned; only the proportional glyphs substituted by this feature should be
kerned.
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria.
UI suggestion: Applications may have this feature active or inactive by default depending
on their markets. See below for details on important feature interactions.
Script/language sensitivity: Although used mostly in CJKV fonts, this feature could be
applied in European scripts.
Feature interaction: This feature is mutually exclusive to all other horizontal glyph-width
features ('chws', 'fwid', 'halt', 'hwid', 'palt', 'pkna', 'qwid', 'twid', 'pnum', 'tnum'), which
should be turned off when it’s applied.
This feature may be used in combination with the 'kern' feature. When this feature is
activated on a text run, the 'kern' feature can be activated for that run, either by default
or by user preference. (If kerning is activated by default, users should still have the
option to disable it while this feature is still active.) With the recommended
implementation for this feature (using GSUB, not GPOS), the default, fixed-width glyphs
are not kerned. Therefore, if this feature is not activated for a text run but the 'kern' is
activated, there should not be any unintended kerning effects for those characters. An
application could still deactivate the 'kern' feature when this feature is not activated,
however.

Tag: 'qwid'
Friendly name: Quarter Widths

Registered by: Adobe
Function: Replaces glyphs on other widths with glyphs set on widths of one quarter of
an em (half an en). The characters involved are normally figures and some forms of
punctuation.
Example: The user applies 'qwid' to place a four-digit figure in a single slot in a column
of vertical text.
Recommended implementation: The font substitutes alternate glyphs designed to be set
on quarter-em widths (GSUB lookup type 1), or it specifies alternate metrics for the
original glyphs (GPOS lookup type 1), adjusting their spacing to fit in quarter-em widths.
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria.
UI suggestion: This feature should be off by default. See below for details on important
feature interactions.
Script/language sensitivity: Generally used only in CJKV fonts.
Feature interaction: This feature is mutually exclusive to all other horizontal glyph-width
features ('chws', 'fwid', 'halt', 'hwid', 'palt', 'pkna', 'pwid', 'twid''pnum', 'tnum'), which
should be turned off when it’s applied. When applied to a text run, the 'apkn' and 'kern'
features should be disabled for that run.

Tag: 'rand'
Friendly name: Randomize
Registered by: Adobe
Function: In order to emulate the irregularity and variety of handwritten text, this feature
allows multiple alternate forms to be used.
Example: The user applies this feature in FF Kosmic to get three forms of f in one word.
Recommended implementation: A lookup table for the 'rand' feature maps GIDs for
default glyphs to one or more GIDs for corresponding alternates (GSUB lookup type 3).
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria. The feature is designed to
be used with an alternate substitution lookup that provides a selection of alternate
glyphs for a given character. The application selects one of these either by a pseudo-

random algorithm, or by noting the sequence of IDs returned, storing that sequence,
and stepping through that set as the corresponding character code is invoked.
UI suggestion: When supported by the font, the feature should be enabled by default. In
recommended usage, the application selects a glyph alternate automatically and does
not need to present the alternates for the user to make a selection.
Script/language sensitivity: None.
Feature interaction: This feature may be used in combination with other substitution
(GSUB) features, whose results it may override.

Tag: 'rclt'
Friendly name: Required Contextual Alternates
Registered by: Microsoft
Function: In specified situations, replaces default glyphs with alternate forms which
provide for better joining behavior or other glyph relationships. Especially important in
script typefaces which are designed to have some or all of their glyphs join, but
applicable also to other glyph variants to improve spacing. This feature is similar to 'calt',
but with the difference that it should not be possible to turn off 'rclt' substitutions: they
are considered essential to correct layout of the font.
Example: In an Arabic calligraphic font, the 'rclt' feature is used to contextually substitute
variant forms of letters sin and yeh providing for a correct join between these two letters
that differs from the default join of either letter to other letters.
Recommended implementation: A lookup table for the 'rclt' feature specifies the context
in which each substitution occurs, and maps one or more default glyphs to replacement
glyphs (GSUB lookup type 6).
Application interface: In recommended usage, this feature triggers substitutions required
for correct display of certain scripts. It should be applied in the appropriate contexts, as
determined by script-specific processing requirements. When processing lookups,
context before or after the glyph sequence to which the feature is applied should be
considered.
UI suggestion: Control of this feature should not generally be exposed to the user.
Script/language sensitivity: May be used for any script, but is especially important for
many styles of Arabic.

Feature interaction: This feature may be used in combination with other substitution
(GSUB) features, whose results it may override. For complex scripts, lookups for this
feature should be ordered and processed after basic script and language shaping
features.

Tag: 'rkrf'
Friendly name: Rakar Forms
Registered by: Microsoft
Function: Produces conjoined forms for consonants with rakar in Devanagari and
Gujarati scripts.
In Devanagari and Gujarati scripts, consonant clusters involving Ra following another
consonant are denoted by conjoining an alternate form of Ra to the preceding
consonant. Depending on the particular syllable, the preceding consonant could be
denoted in its full form or as a half form. Because of interactions involving other
behaviors of these scripts, a font implementation might need to process substitution
lookups for rakar forms and half forms in a particular order to derive the appropriate
display for various sequences.
Example: In Hindi (Devanagari script), the conjunct KRa is denoted with a conjunct
ligature form.
Recommended implementation: A lookup table for the 'rkrf' feature maps the sequence
of a consonant (the nominal form only) followed by a virama (halant) followed by Ra
(the nominal form) to the corresponding conjoined form (GSUB lookup type 4).
Application interface: In recommended usage, this feature triggers substitutions required
for correct display of certain scripts. It should be applied in the appropriate contexts, as
determined by script-specific processing requirements. This feature should be processed
before the Half Forms feature; a half form for a given consonant-Ra combination can be
derived by subsequent application of the Half Forms feature. This sequential ordering
allows for correct display results.
UI suggestion: Control of the feature should not generally be exposed to the user.
Script/language sensitivity: Used for Devanagari, Gujarati, and other Brahmi-derived
scripts.
Feature interaction: This feature is used in conjunction with certain other features to
derive required forms of Indic scripts. The application is expected to process this feature
and certain other features in an appropriate order to obtain the correct set of basic

forms: 'nukt', 'akhn', 'rphf', 'rkrf', 'pref', 'blwf', 'half', 'pstf', 'cjct'. Other discretionary
features for optional typographic effects may also be applied. Lookups for such
discretionary features should be processed after lookups for this feature have been
processed.

Tag: 'rlig'
Friendly name: Required Ligatures
Registered by: Microsoft
Function: Replaces a sequence of glyphs with a single glyph which is preferred for
typographic purposes. This feature is used for ligatures that are required for correct
display of a script.
Example: The Arabic character lam followed by alef will always form a ligated lam-alef
form. This ligated form is a requirement of the script’s shaping. The same happens with
the Syriac script.
Recommended implementation: Glyph sequences are mapped to a single, ligature glyph
(GSUB lookup type 4). Note that, if multiple sequences have the same initial subsequence, substitutions for longer sequences should be stored ahead of those for
shorter sequences.
Application interface: In recommended usage, this feature triggers substitutions required
for correct display of certain scripts. It should be applied in the appropriate contexts, as
determined by script-specific processing requirements.
UI suggestion: Control of this feature should not generally be exposed to the user.
Script/language sensitivity: Used for Arabic and Syriac. May also be used for other
scripts.
Feature interaction: This feature may be used in combination with other substitution
(GSUB) features, whose results it may override. See also 'liga'.

Tag: 'rphf'
Friendly name: Reph Form
Registered by: Microsoft
Function: Substitutes the reph form for a consonant and halant sequence.

Example: In the Devanagari (Indic) script, the consonant Ra possesses a reph form. When
the Ra is a syllable initial consonant and is followed by the virama, it is repositioned after
the post base vowel sign within the syllable, and also substituted with a mark that sits
above the base glyph.
Recommended implementation: A 'rphf' lookup table maps the sequence of default form
of Ra and virama to the reph glyph (GSUB lookup type 4).
Application interface: In recommended usage, this feature triggers substitutions required
for correct display of certain scripts. It should be applied in the appropriate contexts, as
determined by script-specific processing requirements.
UI suggestion: Control of the feature should not generally be exposed to the user.
Script/language sensitivity: Used for Indic or other Brahmi-derived scripts.
Feature interaction: This feature is used in conjunction with certain other features to
derive required forms of Indic scripts. The application is expected to process this feature
and certain other features in an appropriate order to obtain the correct set of basic
forms: 'nukt', 'akhn', 'rphf', 'rkrf', 'pref', 'blwf', 'half', 'pstf', 'cjct'. Other discretionary
features for optional typographic effects may also be applied. Lookups for such
discretionary features should be processed after lookups for this feature have been
processed.

Tag: 'rtbd'
Friendly name: Right Bounds
Registered by: Adobe
Function: Aligns glyphs by their apparent right extents at the right ends of horizontal
lines of text, replacing the default behavior of aligning glyphs by their origins.
Example: Succeeding lines ending with r, h and y would shift to the right by differing
degrees when the text is right-justified and this feature is applied.
Recommended implementation: Values for affected glyphs describe the amount by which
the placement and advance width should be altered (GPOS lookup type 1).
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria. In recommended usage, the
application applies this feature to characters at the right end of a horizontal line when
paragraphs are right or left and right justified.

UI suggestion: This feature should be inactive by default. Applications may expose to
users direct control of this feature and also the Left Bounds feature ('lfbd'), or may
automatically activate the feature based on other paragraph layout settings.
Script/language sensitivity: None.
Feature interaction: Should not be applied to text runs to which fixed-width features
(e.g., 'fwid', 'halt', 'hwid', 'qwid' and 'twid') or vertical features (e.g., 'vert', 'vrt2', 'vpal',
'valt' and 'vhal') have been applied.

Tag: 'rtla'
Friendly name: Right-to-left Alternates
Registered by: Adobe
Function: This feature applies glyphic variants (other than mirrored forms) appropriate
for right-to-left text. (For mirrored forms, see 'rtlm'.)
Recommended implementation: These are required to be glyph substitutions, and it is
recommended that they be one-to-one (GSUB lookup type 1).
Application interface: See section “Left-to-right and right-to-left text” on the Advanced
Typographic Extensions page.
UI suggestion: Control of this feature should not generally be exposed to the user.
Script/language sensitivity: Right-to-left runs of text.
Feature interaction: This feature is to be applied simultaneously with other pre-shaping
features such as 'ccmp' and 'locl'.

Tag: 'rtlm'
Friendly name: Right-to-left Mirrored Forms
Registered by: Adobe
Function: This feature applies mirrored forms appropriate for right-to-left text other than
for those characters that would be covered by the character-level mirroring step
performed by an OpenType layout engine. (For right-to-left glyph alternates, see 'rtla'.)
Example: The 'rtlm' feature replaces the glyph for U+2232, CLOCKWISE CONTOUR
INTEGRAL, with one in which the integral sign is mirrored but the circular arrow has

retained its direction.
Recommended implementation: These are required to be glyph substitutions, and it is
recommended that they be one-to-one (GSUB lookup type 1).
Application interface: See section “Left-to-right and right-to-left text” on the Advanced
Typographic Extensions page.
UI suggestion: Control of this feature should not generally be exposed to the user.
Script/language sensitivity: Right-to-left runs of text.
Feature interaction: This feature is to be applied simultaneously with other pre-shaping
features such as 'ccmp' and 'locl'.

Tag: 'ruby'
Friendly name: Ruby Notation Forms
Registered by: Adobe
Function: Japanese typesetting often uses smaller kana glyphs, generally in
superscripted form, to clarify the meaning of kanji that might be unfamiliar to the
reader. These are called “ruby”, from the old typesetting term for four-point-sized type.
This feature identifies glyphs in the font which have been designed for this use,
substituting them for the default designs.
Example: The user applies this feature to the kana character U+3042, to get the ruby
form for annotation.
Recommended implementation: The font contains alternate glyphs for all kana characters
which are enabled for ruby notation. A lookup table for the 'ruby' feature maps GIDs for
default forms to GIDs for corresponding ruby alternates. These are one-to-one
substitutions (GSUB lookup type 1).
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria. After associated lookups
are applied, applications may re-size or scale glyphs or perform other positioning or
layout adjustments based on other parameters.
UI suggestion: This feature should be inactive by default. Applications may offer the user
an opportunity to specify the degree of scaling and baseline shift.
Script/language sensitivity: Used for Japanese.

Feature interaction: This feature overrides the results of any other feature for the
affected characters.

Tag: 'rvrn'
Friendly name: Required Variation Alternates
Registered by: Microsoft
Function: This feature is used in fonts that support OpenType Font Variations in order to
select alternate glyphs for particular variation instances. (For background on OpenType
Font Variations, see OpenType Font Variations Overview.)
When a variable font is used, all of the interpolated variants of a given glyph ID have
exactly the same contours and points. It is possible to use glyph variation mechanisms
to make significant outline changes, such as reducing strokes in heavy-weight or
narrow-width variants, but this approach can be difficult to implement and might not
produce desired results for all variation instances. Instead, better results for these
scenarios might be achieved by substitution to a different glyph ID. The specific
substitutions applied would be conditioned by the particular variation instance that is
selected by the user. This conditional behavior is implemented using the required
variation alternates feature in conjunction with a FeatureVariations table within the
GSUB table.
Example: A variable font supports weight variations ranging from thin to black. The
default glyph for the dollar sign has two vertical strokes running through the full extent
of the glyph. In the bold variation instance, the default glyph is substituted to an
alternate glyph that has only one vertical stroke. In the black variation instance, the
default glyph is substituted to an alternate glyph that has only single vertical bars at the
top and bottom extremities, with no vertical bars in the two counters in between.
Recommended implementation: The feature is used to activate single substitution (GSUB
type 1) lookups, and is always used in conjunction with a FeatureVariations table.
Typically, a Feature table referenced in a FeatureRecord with the 'rvrn' tag will have
LookupCount set to 0; in this way, the default variation instance does not have any
glyph substitution applied but, rather, uses default glyphs. Alternate glyphs for particular
variation instances are obtained by adding a substitution of the feature table to an
alternate feature table within a FeatureVariations table. Different alternate feature tables
can be selected using condition sets that specify particular variation-axis value ranges.
One or more Condition tables are used to determine variation-axis value ranges for
which an alternate feature table (and associated lookups) is selected. The axis values

used to trigger a condition should normally be midway between values used for named
instances. This will avoid any possibility of inconsistent behavior in different applications
when using named instances that might arise due to small discrepancies in processing
the numeric values.
The default language system for the DFLT script can reference a feature record for this
feature with a feature table that will be substituted for particular variation instances to
use lookups that apply default, language-independent glyph substitutions; this feature
record should be the first feature record for this feature. Some applications may choose
to process this feature without processing other features or the script/language system
hierarchy; for this purpose, they should choose the first feature record for this feature to
obtain the most suitable substitutions for language-independent results.
Application interface: Application of the 'rvrn' feature is mandatory in implementations
that support OpenType Font Variations whenever a variable font is in use. The feature
should be processed in any layout process that supports use of variations, even if other
OpenType Layout processing is not supported.
The feature is applied only during the process of deriving final glyph IDs (GSUB); it is not
used for glyph positioning (GPOS). It should be processed early in GSUB processing,
before application of the localized forms feature or features related to shaping of
complex scripts or discretionary typographic effects.
Processing of the 'rvrn' feature also requires processing of the FeatureVariations table.
ConditionSet tables are scanned for a ConditionSet matching the current variation
instance, and then a corresponding FeatureTableSubstitution table is used to locate an
alternate feature table. For complete details on processing a FeatureVariations table, see
OpenType Layout Common Table Formats.
When an applicable feature table is located, only single substitution (GSUB type 1)
lookups are processed; any other lookup types are ignored. For any glyph IDs in the
coverage table, the application passes the glyph ID to the lookup, and gets back the
new glyph ID.
UI suggestion: The 'rvrn' feature is mandatory: it should be active by default and not
directly exposed to user control.
Script/language sensitivity: None.
Feature interaction: The feature should be processed early after initial character-to-glyph
mapping, before application of the localized forms ('locl') feature, any features related to
shaping of complex scripts, or any discretionary features.

Tag: 'salt'
Friendly name: Stylistic Alternates
Registered by: Adobe
Function: Many fonts contain alternate glyph designs for a purely esthetic effect; these
don’t always fit into a clear category like swash or historical. As in the case of swash
glyphs, there could be more than one alternate form. This feature replaces the default
forms with the stylistic alternates.
Example: The user applies this feature to Industria to get the alternate form of g.
Recommended implementation: A lookup table for the 'salt' feature maps GIDs for
default forms to one or more GIDs for corresponding stylistic alternatives. While many
of these substitutions are one-to-one (GSUB lookup type 1), others require a selection
from a set (GSUB lookup type 3). A font developer can choose to build two tables (one
for each lookup type) or only one which uses lookup type 3 for all substitutions. As in
any one-from-many substitution, alternates present in more than one face should be
ordered consistently across a family, so that those alternates can work correctly when
switching between family members.
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria. If implemented in a font
using an alternate substitution lookup, the application selects one of the alternative
glyphs based on user choice or other criteria.
UI suggestion: This feature should be inactive by default. When implemented in the font
using an alternate substitution lookup, an application could display the forms
sequentially in context, or present a palette showing all the forms at once, or give the
user a choice between these approaches. The application may assume that the first
glyph in a set is the preferred form, so the font developer should order them
accordingly.
Script/language sensitivity: None.
Feature interaction: This feature may be used in combination with other substitution
(GSUB) features, whose results it may override.

Tag: 'sinf'
Friendly name: Scientific Inferiors

Registered by: Microsoft/Adobe
Function: Replaces lining or oldstyle figures (digits) with inferior figures (smaller glyphs
which sit lower than the standard baseline, primarily for chemical or mathematical
notation). May also replace glyphs for lowercase characters with alphabetic inferiors.
Example: The application can use this feature to automatically access the inferior figures
(more legible than scaled figures).
Recommended implementation: Glyphs for figures (digits) are mapped to corresponding
inferior forms (GSUB lookup type 1).
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria.
UI suggestion: This feature should be off by default.
Script/language sensitivity: None.
Feature interaction: This feature may be used in combination with other substitution
(GSUB) features, whose results it may override.

Tag: 'size'
Note: Use of this feature has been superseded by the STAT table. See “Families with
Optical Size Variants” in the Recommendations section for more information.
Friendly name: Optical size
Registered by: Adobe
Function: This feature stores two kinds of information about the optical size of the font:
design size (the point size for which the font is optimized) and size range (the range of
point sizes which the font can serve well), as well as other information which helps
applications use the size range. The design size is useful for determining proper tracking
behavior. The size range is useful in families which have fonts covering several ranges.
Additional values serve to identify the set of fonts which share related size ranges, and
to identify their shared name. Note that sizes refer to nominal final output size and are
independent of viewing magnification or resolution.
Example: The 'size' information in Bell Centennial is [60 0 0 0 0]. This tells an application
that the font’s design size is six points, so larger sizes might need proportionate
reduction in default inter-glyph spacing. The 'size' information in Minion Pro Semibold
Condensed Subhead is [180 3 257 139 240]. These values tell an application that:

The font’s design size is 18 points;
This font is part of a subfamily of fonts that differ only by the size range which
each covers, and which share the arbitrary identifier number 3;
ID 257 in the 'name' table is the suggested menu name for this subfamily. In this
case, the string at name ID 257 is Semibold Condensed;
This font is the recommended choice from sizes greater than 13.9-point up
through 24-points.
Required implementation:
The Feature table of this GPOS feature must not reference any lookups; its
featureParamsOffset field records an offset from the beginning of the Feature table to
an array of five uint16 values. The size feature must be implemented in all fonts in any
family which uses the feature. In this usage, a family is a set of fonts which share a
Typographic Family name (name ID 16), or Font Family name (name ID 1) if the
Typographic Family name is absent.
The first value represents the design size in 720/inch units (decipoints). The design
size entry must be non-zero. When there is a design size but no recommended
size range, the rest of the array must consist of zeros.
The second value has no independent meaning but serves as an identifier that
associates fonts in a subfamily. All fonts which share a Typographic or Font Family
name and which differ only by size range shall have the same subfamily value, and
no fonts which differ in weight or style shall have the same subfamily value. If this
value is zero, the remaining fields in the array shall be ignored.
The third value enables applications to use a single name for the subfamily
identified by the second value. If the preceding value is non-zero, this value must
be set in the range 256 – 32767 (inclusive). It records the value of a field in the
'name' table, which must contain English-language strings encoded in Windows
Unicode and Macintosh Roman, and may contain additional strings localized to
other scripts and languages. Each of these strings is the name an application
should use, in combination with the family name, to represent the subfamily in a
menu. Applications will choose the appropriate version based on their selection
criteria.
The fourth and fifth values represent the small end of the recommended usage
range (exclusive) and the large end of the recommended usage range (inclusive),
stored in 720/inch units (decipoints). Ranges must not overlap and should
generally be contiguous.

Application interface: When the user specifies a size, the application checks for a 'size'
feature in the active font. If none is found, the application follows its default behavior. If
one is found, the application follows the specified offset to retrieve the five values.
Design size: Applications which offer size-based tracking have a pre-defined curve
which they can apply. By default, this curve should be set to produce no
adjustment at the font’s design size (first value in the array, in decipoints).
Size ranges: If the second value in the 'size' array is non-zero, the font has a
recommended size range. When any such font is selected by the user, the
application builds a list of all fonts with this subfamily value and the same
Typographic Family name, and notes the size range in the current font.
Applications might want to cache the subfamily list at this point. If the specified
size falls in the current font’s range, the application uses the current font. If not,
the application checks the other ranges in the subfamily, and if the specified size
falls in one of them, uses that font. If the specified size is not in any range present,
the font with the range closest to the specified value is used. If the specified size
falls exactly between two ranges, the range with the larger values is used. Since
adding or removing fonts from a subfamily could cause reflow, applications should
note which fonts are used for which text.
UI suggestion: This feature should be active by default. Applications can present the
tracking curve to the user for adjustments via a GUI. At start-up, and when fonts are
added or removed, applications might want to build a list of fonts with such ranges and
display the filtered subfamily names in their font selection UI, with each filtered name
representing the full set of related sizes. Applications could also present a setting which
allows the user to select non-default sizes (for example, in the case where final output is
intended for on-screen viewing, a smaller optical size will produce better results). In such
a case, the font-selection UI should present the unfiltered names. Applications should
notify the user if fonts are removed or added from a subfamily with size ranges, and
query about desired behavior.
Script/language sensitivity: None.
Feature interaction: None.

Tag: 'smcp'
Friendly name: Small Capitals
Registered by: Microsoft/Adobe

Function: This feature turns glyphs for lowercase characters into small capitals. It is
generally used for display lines set in Large & small caps, such as titles. Forms related to
small capitals, such as oldstyle figures, may be included.
Note: Some languages written with bicameral scripts have special case-mapping
behaviors for certain characters. Care is needed by font and application developers
to handle these cases correctly. See section “5.18 Case Mappings” of The Unicode
Standard

for more information.

Example: The user applies this feature to text with mixed capitals and lowercase and gets
mixed capitals and small cap glyphs.
Recommended implementation: Glyphs for lowercase characters are mapped to the
corresponding small-cap forms (GSUB lookup type 1).
Correct handling of case mapping for some languages could require exceptions to be
handled using separate language systems. For example, correct handling of Turkish
dotted and undotted i could be implemented using a 'TRK ' language system, with
appropriate mappings directly in a lookup for the 'smcp' feature or in concert with the
'locl' feature. Also, some applications might handle language-specific case mappings by
mapping the lowercase characters to appropriate uppercase characters in a temporary
buffer and then applying the 'c2sc' feature. Fonts that implement 'smcp' should also
implement the 'c2sc' feature.
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria.
For best handling of language-specific case mapping behaviors, applications can
implement small-cap formatting by mapping lowercase characters to uppercase in a
temporary buffer and then applying the 'c2sc' feature. The uppercase mapping can
make use of Unicode special-casing data in the Unicode Character Database
(SpecialCasing.txt

). Lookups for 'smcp' should still be applied to characters that do not

have an uppercase mapping, or if a font does not support some uppercased characters
using the 'c2sc' feature.
UI suggestion: This feature should be off by default.
Script/language sensitivity: Used for bicameral scripts (i.e. those with case differences),
such as Latin, Greek, Cyrillic, and Armenian.
Feature interaction: This feature may be used in combination with other substitution
(GSUB) features, whose results it may override. Also see 'c2sc'.

Tag: 'smpl'
Friendly name: Simplified Forms
Registered by: Adobe
Function: Replaces “traditional” Chinese or Japanese forms with the corresponding
“simplified” forms.
Example: The user gets the glyph for U+53F0 when this feature is applied to U+6AAF,
U+81FA, or U+98B1.
Recommended implementation: A lookup table for the 'smpl' feature maps each
traditional form in a font to a corresponding simplified form (GSUB lookup type 1). Note
that more than one traditional form could map to a single simplified form.
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria. Note that the effect of this
feature is effectively equivalent to a change of character codes. Besides the original
character codes, the application should store the character codes for the new glyphs.
UI suggestion: This feature should be off by default, but could be made the default by a
user preference setting.
Script/language sensitivity: Used only for Chinese and Japanese.
Feature interaction: This feature is mutually exclusive to most other features, which
should be turned off when it’s applied. Exceptions include the 'palt', 'vert' and 'vrt2'
features, which may be used in addition. The 'trad' and 'tnam' features are mutually
exclusive to and override the results of 'smpl'.

Tag: 'ss01' - 'ss20'
Friendly name: Stylistic Set 1 - Stylistic Set 20
Registered by: Tiro Typeworks
Function: Selects typographic alternatives for a set of glyphs.
Instead of, or in addition to, stylistic alternatives of individual glyphs (see the 'salt'
feature), some fonts can contain sets of stylistic variant glyphs corresponding to
portions of the character set, e.g., multiple variants for lowercase letters in a Latin font.
Glyphs in stylistic sets could be designed to harmonize visually, to interact in particular
ways, or otherwise work together. Examples of fonts including stylistic sets are Zapfino

Linotype and Adobe’s Poetica. Individual features numbered sequentially with the tag
name convention 'ss01', 'ss02', 'ss03'… 'ss20' provide a mechanism for glyphs in these
sets to be associated via GSUB lookup indices to default forms and to each other, and
for users to select from available stylistic sets.
Use of the stylistic set features is not limited to substitutions in the GSUB table. For
example, a stylistic set feature could be used to provide alternate mark positioning or
alternate kerning for certain glyphs.
Recommended implementation: An 'ssXX' lookup table maps GIDs for default forms to
GIDs for corresponding stylistic alternatives in each set. Each 'ssXX' feature uses one-toone (GSUB lookup type 1) substitutions. Font developers can choose to map only from
default forms to variants for each stylistic set, or could choose to map between all
stylistic sets in each feature, depending on intended user experience. For example,
feature 'ss03' might contain lookups mapping variant glyphs from 'ss01' and 'ss02' to
corresponding variants in 'ss03', in addition to mapping from default forms.
The featureParamsOffset field of the Feature Table of these features may be set to 0, or
to an offset to a Feature Parameters table comprising two successive uint16 values, as
follows:
Version (set to 0): This corresponds to a “minor” version number. Additional data
may be added to the end of this Feature Parameters table in the future.
uiLabelNameID: The 'name' table name ID that specifies a string (or strings, for
multiple languages) for a user-interface label for this feature. The value of
uiLabelNameId is expected to be in the font-specific name ID range (256 – 32767),
though that is not a requirement in this Feature Parameters specification. The userinterface label for the feature can be provided in multiple languages. An English
string should be included as a fallback. The string should be kept to a minimal
length to fit comfortably with different application interfaces.
Application interface: Discretionary features: can be applied to glyph runs based on
document markup, user control or other application criteria.
UI suggestion: These features should be off by default. This set of features are not
mutually exclusive, hence it should be possible to activate any combination of them.
Note that the application is responsible for counting and enumerating the number of
features in the font with tag names of the format 'ss01' to 'ss20', and for presenting the
user with an appropriate selection mechanism.
Script/language sensitivity: None.

Feature interaction: These features may be used in combination with other substitution
(GSUB) or positioning (GPOS) features, whose results they may override. Also, this set of
features are not mutually exclusive. For instance, different stylistic set features could
affect different subsets of glyphs. Also, they could have complementary effects that
combine (for example, deep descenders and swash terminals). Note that after an 'ssXX'
feature has been applied, the user might wish to apply glyph-specific features, e.g. 'salt',
to individual glyphs in the resulting layout; font developers are responsible for ordering
substitution lookups to obtain desired user experience.

Tag: 'ssty'
Friendly name: Math Script-style Alternates
Registered by: Microsoft
Function: This feature provides glyph variants adjusted to be more suitable for use in
subscripts and superscripts within math formulas. The script style forms should not be
scaled or moved in the font; scaling and moving them is done by the math layout
engine. Instead, the 'ssty' feature should provide glyph forms that result in shapes that
look good as superscripts and subscripts when scaled and positioned by the Math
engine. When designing the script forms, the font developer may assume that the
scriptPercentScaleDown and scriptScriptPercentScaleDown values in the
MATH.MathConstants table will be the scaling factors used by the Math engine.
This feature can have a parameter indicating the script level: 1 for simple subscripts and
superscripts, 2 for second level subscripts and superscripts (that is, scripts on scripts),
and so on. (Currently, only the first two alternates are used). For glyphs that are not
covered by this feature, the original glyph is used in subscripts and superscripts.
Example: In the formula

, the glyph for the letter b will be substituted with a script

level 1 variant, and the glyph for the letter c will be substituted with a script level 2
variant.
Recommended implementation: Alternate substitution (GSUB lookup type 3), with
parameter 1 or 2 corresponding to subscript or superscript level, as described above. If
there are no second-level alternates defined in the font, single substitution can also be
used. Glyphs that don’t have script alternates can be omitted from lookups for this
feature. See the MATH table specification for details.
Application interface: In recommended usage, this feature is used to trigger substitutions
that are required for correct display of math formula. It should be applied to individual
glyphs in appropriate contexts under the control of a math layout handler. If

implemented in a font using an alternate substitution lookup, the first or second
alternate glyph should be selected depending on the nesting level within the math
formula. See the 'MATH' table chapter for additional information.
UI suggestion: Control of the feature should not generally be exposed to the user.
Script/language sensitivity: Used for math formula layout.
Feature interaction: None.

Tag: 'stch'
Friendly name: Stretching Glyph Decomposition
Registered by: Microsoft
Function: Unicode characters that enclose other characters, such as the Syriac
Abbreviation Mark (U+070F), need to be able to stretch in order to dynamically adapt to
the width of the enclosed text. This feature defines a decomposition set consisting of an
odd number of glyphs that can be used to dynamically generate the stretching glyph.
The odd numbered glyphs in the decomposition are fixed reference points that are
distributed evenly from the start to the end of the enclosed text. The even numbered
glyphs may be repeated as necessary in the text presentation to fill the space between
the fixed glyphs. The first and last glyphs may either be simple glyphs with width at the
baseline, or mark glyphs. All other decomposition glyphs should have width but must be
defined as mark glyphs.
Example: In Syriac, the character 0x070F is a control character that is rendered as a line
above an abbreviation in Syriac script. The line should have a circle at each end and at
the mid point. The decomposition sequence for this character should consist of a circle
at the start of a line, a connecting line, a circle on a line for the mid point, a second
connecting line, and a circle at the end of the line. The connecting lines will repeat in
order to fill the space between the circle glyphs.
Recommended implementation: The default glyph for a character that requires stretching
is mapped to a sequence comprised of an odd number of corresponding glyphs (GSUB
lookup type 2).
Application interface: For characters that require stretching, such as Syriac abbreviation
mark (U+070F), the 'stch' feature is applied. If the default glyph for the character is in
the coverage of an associated lookup subtable, the mapped glyph sequence is retrieved.
The last glyph of the substitute sequence is reordered to the end of the sequence of
glyphs to be enclosed or encompassed. The remaining glyphs from the substitution

sequence are inserted before the sequence of glyphs to be enclosed. Odd-numbered
glyphs in the substitution sequence are positioned so as to be distributed evenly over
the width of text being enclosed. Even-numbered glyphs are repeated so that the
spaces between the odd-numbered glyphs are filled.
UI suggestion: Control of this feature should not generally be exposed to the user.
Script/language sensitivity: None
Feature interaction: None

Tag: 'subs'
Friendly name: Subscript
Registered by: Microsoft/Adobe
Function: The 'subs' feature is used to present subscript forms.
Recommended implementation: First, a single or contextual substitution lookup
implements the subscript glyph (GSUB lookup type 1). Then, if the glyph needs
repositioning, a single adjustment, pair adjustment, or contextual adjustment
positioning lookup is used to modify its position (GPOS lookup type 1 or type 2, or a
contextual lookup that references a type 1 or type 2 lookup).
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria. Note that, for some
Unicode characters, the effect of this feature is effectively equivalent to a change of
character codes. In such cases, besides the original character codes, the application
should store the character code for the new glyph.
UI suggestion: This feature should be off by default.
Script/language sensitivity: None.
Feature interaction: This feature may be used in combination with other substitution
(GSUB) features, whose results it may override.

Tag: 'sups'
Friendly name: Superscript
Registered by: Microsoft/Adobe

Function: Replaces lining or oldstyle figures with superior figures (primarily for footnote
indication), and replaces lowercase letters with superior letters (primarily for abbreviated
French titles).
Example: The application can use this feature to automatically access the superior
figures (more legible than scaled figures) for footnotes, or the user can apply it to “Mssr”
to get the classic form.
Recommended implementation: A lookup table for the 'sups' feature maps figures and
lowercase letters to the corresponding superior forms (GSUB lookup type 1).
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria. Note that, for some
Unicode characters, the effect of this feature is effectively equivalent to a change of
character codes. In such cases, besides the original character codes, the application
should store the character code for the new glyph.
UI suggestion: This feature should be off by default.
Script/language sensitivity: None.
Feature interaction: This feature may be used in combination with other substitution
(GSUB) features, whose results it may override.

Tag: 'swsh'
Friendly name: Swash
Registered by: Microsoft/Adobe
Function: This feature replaces default character glyphs with corresponding swash
glyphs. More than one swash alternate may be provided for a given character.
Example: The user inputs the ampersand character when setting text with Poetica with
this feature active and is presented with a choice of the 63 ampersand forms in that
face.
Recommended implementation: A lookup table for the 'swsh' feature maps GIDs for
default forms to those for one or more corresponding swash forms. While many of these
substitutions are one-to-one (GSUB lookup type 1), others require a selection from a set
(GSUB lookup type 3). A font developer can choose to build two tables (one for each
lookup type) or only one which uses lookup type 3 for all substitutions. If several styles
of swash are present across the font, the set of forms for each character should be
ordered consistently.

Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria. If implemented in a font
using an alternate substitution lookup, the application selects one of the alternative
glyphs based on user choice or other criteria.
UI suggestion: This feature should be inactive by default. When implemented in the font
using an alternate substitution lookup, an application could display the alternate forms
sequentially in context, or present a palette showing all the forms at once, or give the
user a choice between these approaches. The application may assume that the first
glyph in a set is the preferred form, so the font developer should order them
accordingly.
Script/language sensitivity: Not used for ideographic scripts.
Feature interaction: This feature may be used in combination with other substitution
(GSUB) features, whose results it may override.

Tag: 'titl'
Friendly name: Titling
Registered by: Adobe
Function: This feature replaces the default glyphs with corresponding forms designed
specifically for titling. These may be all-capital or larger on the body and adjusted for
viewing at larger sizes.
Example: The user applies this feature in Adobe Garamond to get the titling caps.
Recommended implementation: A lookup table for the 'titl' feature maps default forms to
corresponding titling forms (GSUB lookup type 1).
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria.
UI suggestion: This feature should be off by default.
Script/language sensitivity: None.
Feature interaction: This feature may be used in combination with other substitution
(GSUB) features, whose results it may override.

Tag: 'tjmo'

Friendly name: Trailing Jamo Forms
Registered by: Microsoft
Function: Substitutes the form for a Hangul trailing consonant jamo used in a jamo
cluster.
Example: In Hangul script, the jamo cluster is composed of three parts: leading
consonant, vowel, and trailing consonant. When a trailing jamo is found, an alternate
trailing jamo form is substituted as required for that cluster.
Recommended implementation: The default glyph for a trailing jamo is mapped into an
alternate form required for conjoining in a syllable (GSUB lookup type 1, or a contextual
substitution referencing a type 1 lookup).
Application interface: In recommended usage, this feature triggers substitutions required
for correct layout of Hangul script. It should be applied in the appropriate contexts, as
determined by script-specific processing requirements.
UI suggestion: Control of this feature should not generally be exposed to the user.
Script/language sensitivity: Used for Hangul script, particularly when Unicode conjoining
jamo characters are used.
Feature interaction: This feature overrides the results of all other features.

Tag: 'tnam'
Friendly name: Traditional Name Forms
Registered by: Adobe
Function: Replaces “simplified” Japanese kanji forms with the corresponding “traditional”
forms. This is equivalent to the Traditional Forms feature, but explicitly limited to the
traditional forms considered proper for use in personal names (as many as 205 glyphs in
some fonts).
Example: The user applies this feature to U+4E9C and gets the glyph for U+4E9E.
Recommended implementation: A lookup table for the 'tnam' feature maps simplified
forms in a font to corresponding traditional forms which can be used in personal names
(GSUB lookup type 1). The application stores a record of any simplified forms which
resulted from substitutions (the 'smpl' feature); for such forms, applying the 'tnam'
feature undoes the previous substitution.

Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria. Note that the effect of this
feature is effectively equivalent to a change of character codes. Besides the original
character code, the application should store the character code for the new glyph.
UI suggestion: This feature should be off by default.
Script/language sensitivity: Used only for Japanese.
Feature interaction: Characters affected by this feature could include some characters
also affected by the Proportional Alternate Widths feature ('palt'). The 'trad' and 'tnam'
features are mutually exclusive to and override the results of 'smpl'.

Tag: 'tnum'
Friendly name: Tabular Figures
Registered by: Adobe
Function: Replaces figure glyphs set on proportional widths with corresponding glyphs
set on uniform (tabular) widths. Tabular widths will generally, but not always, be the
default. This feature would not be used in monospaced designs.
Example: The user applies this feature to get oldstyle figures that align vertically in a
column.
Recommended implementation: In order to simplify associated kerning and get the best
glyph design for a given width, this feature should use new glyphs for the figures, rather
than only adjusting the fit of the proportional glyphs (although some might be simple
copies); i.e., not a GPOS feature. A lookup table for the 'tnum' feature maps proportional
versions of lining or oldstyle figures to corresponding tabular glyphs (GSUB lookup type
1).
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria.
UI suggestion: This feature should be off by default. The application could query the user
about this feature when the user changes figure style ('onum' or 'lnum').
Script/language sensitivity: None.
Feature interaction: This feature overrides the results of the Proportional Figures feature
('pnum').

Tag: 'trad'
Friendly name: Traditional Forms
Registered by: Adobe
Function: Replaces 'simplified' Chinese hanzi or Japanese kanji forms with the
corresponding 'traditional' forms.
Example: The user inputs U+53F0 and is offered a choice of glyphs corresponding to
characters U+6AAF, U+81FA, or U+98B1.
Recommended implementation: A lookup table for the 'trad' feature maps each
simplified form in a font to one or more traditional forms. While many of these
substitutions are one-to-one (GSUB lookup type 1), others require a selection from a set
(GSUB lookup type 3). A font developer can choose to build two tables (one for each
lookup type) or only one which uses lookup type 3 for all substitutions. As in any onefrom-many substitution, alternates present in more than one face should be ordered
consistently across a family, so that those alternates can work correctly when switching
between family members.
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria. If implemented in a font
using an alternate substitution lookup, the application selects one of the alternative
glyphs based on user choice or other criteria. The application stores a record of any
simplified forms which resulted from substitutions (the 'smpl' feature); for such forms,
applying the 'trad' feature undoes the previous substitution. Note that the effect of this
feature is effectively equivalent to a change of character codes. Besides the original
character code, the application should store the character code for the new glyph.
UI suggestion: This feature should be inactive by default. If there’s no record of a
conversion from traditional to simplified, the user should be offered a set of possibilities
from which to select. The application can note the user’s choice and offer it as a default
the next time the source simplified character is encountered. In the absence of such
prior information, the application may assume that the first glyph in a set is the
preferred form, so the font developer should order them accordingly.
Script/language sensitivity: Used only for Chinese and Japanese.
Feature interaction: Characters affected by this feature could include some characters
also affected by the Proportional Alternate Widths feature ('palt'). The 'trad' and 'tnam'
features are mutually exclusive to and override the results of 'smpl'.

Tag: 'twid'
Friendly name: Third Widths
Registered by: Adobe
Function: Replaces glyphs on other widths with glyphs set on widths of one third of an
em. The characters involved are normally figures and some forms of punctuation.
Example: The user applies 'twid' to place a three-digit figure in a single slot in a column
of vertical text.
Recommended implementation: The font substitutes alternate glyphs designed to be set
on third-em widths (GSUB lookup type 1), or it specifies alternate metrics for the original
glyphs (GPOS lookup type 1), adjusting their spacing to fit in third-em widths.
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria.
UI suggestion: This feature should be off by default. See below for details on important
feature interactions.
Script/language sensitivity: Generally used only in CJKV fonts.
Feature interaction: This feature is mutually exclusive to all other horizontal glyph-width
features ('chws, 'fwid', 'halt', 'hwid', 'palt', 'pkna', 'pwid', 'qwid', 'pnum', 'tnum'), which
should be turned off when it’s applied. When applied to a text run, the 'apkn' 'kern'
features should be disabled for that run.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

Registered Features: Descriptions and
Implementations (u – z)
Article • 05/31/2024

a-e|f-j|k-o|p-t|u-z
>

Tag: 'unic'
Friendly name: Unicase
Registered by: Tiro Typeworks / Emigre
Function: This feature maps uppercase and lowercase letters to a mixed set of lowercase
and small capital forms, resulting in a single case alphabet. (For an example of unicase,
see the Emigre type family Filosofia.) The letters substituted can vary from font to font,
as appropriate to the design. If aligning to the x-height, smallcap glyphs can be
substituted, or specially designed unicase forms might be used. Substitutions might also
include specially designed figures.
Example: The user enters text as uppercase, lowercase or mixed case, and gets unicase
text.

Recommended implementation: Uppercase and lowercase glyphs are mapped to
corresponding unicase forms (GSUB lookup type 1).
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria.
UI suggestion: This feature should be off by default.
Script/language sensitivity: Used for bicameral scripts (i.e. those with case differences),
such as Latin, Greek, Cyrillic, and Armenian.
Feature interaction: This feature may be used in combination with other substitution
(GSUB) features, whose results it may override.

Tag: 'valt'

Friendly name: Alternate Vertical Metrics
Registered by: Adobe
Function: Repositions glyphs to visually center them within full-height metrics, for use in
vertical setting. Applies to full-width Latin, Greek, or Cyrillic glyphs, which are typically
included in East Asian fonts, and whose glyphs are aligned on a common horizontal
baseline and not rotated relative to the page or text frame.
Example: Applying this feature would shift a Roman h down, or y up, from their default
full-width positions.
Recommended implementation: The font specifies alternate metrics for the original
glyphs (GPOS lookup type 1, yPlacement).
Note that same functionality can be accomplished by setting glyph vertical origins
through the use of appropriate topSideBearing values in the 'vmtx' table and (only for
fonts with CFF or CFF2 outlines) corresponding vertOriginY values in the VORG table.
This method is recommended as it provides the desired spacing for vertical layout by
default. Fonts that include 'vmtx' or VORG tables should not implement this feature.
Application interface: Should be applied to runs of characters for applicable scripts in
vertical text layout.
UI suggestion: This feature should be active by default in vertical-setting contexts.
Script/language sensitivity: Used for scripts with vertical writing modes.
Feature interaction: This feature is mutually exclusive to all other glyph-height features
(e.g., 'vhal' and 'vpal'), which should be turned off when it’s applied. When applied to a
run of text, the 'vapk' and 'vkrn' features should be disabled for that run.

Tag: 'vapk'
Friendly name: Kerning for Alternate Proportional Vertical Metrics
Registered by: Adobe/Microsoft
Function: In vertical text layout, applies kerning adjustments to glyphs that have fixed
advance heights by default but have been adjusted to proportional heights by
application of the 'vpal' feature.
Example: A user activates proportional vertical metrics ('vpal') in Japanese text, which
results in some glyphs that have fixed advance heights by default now having

proportional heights. By activating the 'vapk' feature as well, those glyphs are then
vertically kerned with other glyphs.
Recommended implementation: The font vertically kerns Kanji, Kana, Latin, punctuation,
or other glyphs that have fixed-height metrics by default if those glyphs are also
adjusted to proportional heights by the 'vpal' feature.
Primarily intended for use in the GPOS table. Positioning adjustments can be
implemented using GPOS pair-adjustment (type 2) lookups. Single-adjustment and pairadjustment lookups have simple additive effect, therefore relative ordering of lookups
for this feature and type 1 or type 2 lookups for 'vpal' or other similar features
implemented using GPOS type 1 or type 2 lookups is not crucial.
For glyphs that have fixed heights by default but that can have metrics adjusted by the
'vpal' feature, it is strongly recommended that those glyphs not be kerned with other
glyphs using the 'vkrn' feature; these should only be kerned by application of this
feature.
UI suggestion: This feature should be off by default. If the font used for a text run
implements the 'vpal' feature, activation on that text run should be possible only if the
'vpal' feature has been activated on that run. If 'vpal' has been activated for a run, then
this feature may be automatically activated, but the UI should also provide a way for a
user optionally to deactivate the feature while 'vpal' is still activated.
Script/language sensitivity: Intended primarily for CJK fonts.
Feature interaction: Should only be implemented in fonts that also implement the 'vpal'
feature, which this feature is intended to complement. This feature should only be
activated on a text run if 'vpal' has been activated, but activation when that feature has
been applied is optional, and may be under user control. If activated on a run and later
the 'vpal' feature is deactivated for that run, then this feature should also be deactivated,
as the kerning adjustments applied by this feature would not be appropriate for glyphs
with fixed-height metrics.
In the recommended implementation for this feature, it acts only on characters that
have fixed-height glyphs by default but that acquire proportional heights by application
of the 'vpal' feature. As a result, it can be deactivated on any text run that does not 'vpal'
activated without any need to scan lookup tables to determine which glyphs do or do
not require deactivation.

Tag: 'vatu'
Friendly name: Vattu Variants

Registered by: Microsoft
Function: In an Indic consonant conjunct, substitutes a ligature glyph for a base
consonant and a following vattu (below-base) form of a conjoining consonant, or for a
half form of a consonant and a following vattu form.
Example: In the Devanagari script, the consonant Ra takes a vattu form, when it is not
the syllable initial consonant in a conjunct. This vattu form ligates with the base
consonant as well as half forms of consonants.
Recommended implementation: A lookup table for the 'vatu' feature maps consonant
and vattu form combinations to their respective ligatures (GSUB lookup type 4).
Lookups associated with the Vattu Variants feature apply to glyphs derived using the
Below-base Forms feature and (for half-form plus vattu ligatures) the Half Forms
features. The Below-base Forms feature should be used to derive the nominal vattu
form of a consonant; the Vattu Variants feature should only be used to substitute the
nominal vattu form and a base consonant or half form with a ligature glyph. If the Rakar
Forms feature is used, the Vattu Variants feature is not required.
Application interface: In recommended usage, this feature triggers substitutions required
for correct layout of certain scripts. It should be applied in the appropriate contexts, as
determined by script-specific processing requirements.
UI suggestion: Control of the feature should not generally be exposed to the user.
Script/language sensitivity: Used for Devanagari and other Indic or Brahmi-derived
scripts.
Feature interaction: This feature may be used in conjunction with certain other features
— 'nukt', 'akhn', 'rphf', 'rkrf', 'pref', 'blwf', 'half', 'pstf', 'cjct' — to derive required forms of
Indic scripts. For Indic script implementations that use the Vattu Variants feature, the
application is expected to process this and the other features in an appropriate order to
obtain the correct basic forms. Other discretionary features for optional typographic
effects may also be applied. Lookups for such discretionary features should be
processed after lookups for this feature have been processed.

Tag: 'vchw'
Friendly name: Vertical Contextual Half-width Spacing
Registered by: Adobe/W3C

Function: Contextually re-spaces glyphs that have full-em heights by default, fitting
them onto half-width vertical heights to approximate more sophisticated text layout,
such as what is described in Requirements for Japanese Text Layout (JLREQ)

or similar

CJK text-layout specifications that expect half-width forms of characters whose default
glyphs are full-width. This differs from 'vhal' in that the re-spacing is contextual. This
feature can be invoked to get better fit for punctuation or symbol glyphs without
disrupting the monospaced alignment.
(In JLREQ, see, in particular, 3.1.4 Positioning of Consecutive Opening Brackets, Closing
Brackets, Commas, Full Stops and Middle Dots

, and B. Spacing between Characters

See also Requirements for Chinese Text Layout (CLREQ)
Layout (KLREQ)

.

, Requirements for Hangul Text

.)

Example: When PRESENTATION FORM FOR VERTICAL RIGHT PARENTHESIS (U+FE36;
“︶”, vertical form of FULLWIDTH RIGHT PARENTHESIS U+FF09; “)” is followed by
PRESENTATION FORM FOR VERTICAL IDEOGRAPHIC COMMA (U+FE11; “︑”, vertical
form of IDEOGRAPHIC COMMA U+3001; “、”), the former is re-spaced to remove halfem of height between them.
Recommended implementation: The font specifies positioning adjustments for pairs of
glyphs (GPOS lookup type 2 or 8, xPlacement, xAdvance, yPlacement, and yAdvance).
These can be stored as one or more tables matching left and right classes, or as
individual pairs. Additional adjustments may be provided for longer sequences of glyphs
(e.g., triplets, quadruplets, etc.) and ordered to take precedence over pair kern
adjustments of particular combinations.
When using a GPOS type 2 lookup for this feature, it is recommended that no
positioning adjustment be applied to the second glyph in a pair. (That is, that
valueFormat2 be set to 0.) As a result, the next glyph pair to be processed after the
lookup has been applied to this pair will start at the second glyph. In this way, every
glyph in a sequence can undergo positioning adjustment as the first glyph in a pair.
Otherwise, if positioning of the second glyph is adjusted, then the next glyph pair to be
processed will begin with the glyph following the second glyph. That will result in
spacing adjustment happening only for every other pair of glyphs.
Application interface: If a layout engine supports advanced layout for CJK text as
described in CLREQ

, JLREQ

or KLREQ

, this feature should not be used. Otherwise,

this feature should always be applied in vertical layout of CJK text.
UI suggestion: This feature should not be used in combination with a layout engine that
independently provides advanced layout as described in CLREQ

, JLREQ

or KLREQ

For applications that provide such advanced layout, it might be appropriate not to

.

expose control of this feature to users. In applications that do not support such
advanced layout, this feature should be enabled by default for vertical layout of CJK text.
Script/language sensitivity: Used mostly in CJKV fonts.
Feature interaction: This feature is mutually exclusive to all other glyph-height features
(e.g., 'valt', 'vhal', 'vpal'), which should be turned off when this feature is applied. When
applied to a run of text, the 'vapk' and 'vkrn' features should be disabled for that run.
See also 'chws'.

Tag: 'vert'
Friendly name: Vertical Alternates
Registered by: Microsoft/Adobe
Function: Transforms default glyphs into glyphs that are appropriate for upright
presentation in vertical writing mode. While the glyphs for most characters in East Asian
writing systems remain upright when set in vertical writing mode, some must be
transformed — usually by rotation, shifting, or different component ordering — for
vertical writing mode.
Example: In vertical writing mode, the opening parenthesis (U+FF08) is replaced by the
rotated form (U+FE35).
In vertical writing mode, the glyph for HIRAGANA LETTER SMALL A (U+3041 “ぁ”) is
transformed into a glyph that is shifted up and to the right, which is properly positioned
for upright presentation in vertical writing mode.
In vertical writing mode, the glyph for SQUARE MAIKURO (U+3343 “㍃”), whose
component katakana characters are ordered from left to right, then top to bottom (like
horizontal writing mode), is transformed into a glyph whose component katakana
characters are ordered from top to bottom then right to left (like vertical writing mode
line progression).
Recommended implementation: The font includes versions of the glyphs covered by this
feature that differ in some visual way from the default glyphs, such as by rotation,
shifting, or different component ordering. The 'vert' feature maps the default glyphs to
the corresponding, alternate glyphs for vertical writing mode using a single substitution
(GSUB type 1) lookup.
Application interface: Should be applied to runs of characters for applicable scripts in
vertical text layout.

UI suggestion: This feature should be active by default in vertical writing mode.
Script/language sensitivity: Used for scripts with vertical writing modes.
Feature interaction: The 'vert' and 'vrtr' features are intended to be used in conjunction:
'vert' for glyphs to be presented upright in vertical writing, and 'vrtr' for glyphs intended
to be presented sideways. Since they should never be activated simultaneously for a
given glyph, there should be no interaction between the two features. These features
are intended for layout engines that graphically rotate glyphs for sideways runs in
vertical writing mode, such as those conforming to Unicode Technical Report #50:
Unicode Vertical Text Layout

.

Note that layout engines that instead depend on the font to supply pre-rotated glyphs
for all sideways glyphs should use the 'vrt2' feature in lieu of 'vert' and 'vrtr'. Because
'vrt2' supplies pre-rotated glyphs, the 'vert' feature should never be used with 'vrt2', but
it may be used in addition to any other feature.

Tag: 'vhal'
Friendly name: Alternate Vertical Half Metrics
Registered by: Adobe
Function: Re-spaces glyphs that have full-em heights by default, fitting them onto halfem heights. This differs from 'valt', which repositions a glyph but does not affect its
advance.
Example: The user invokes this feature in a CJKV font to get better fit for punctuation or
symbol glyphs without disrupting the monospaced alignment.
Recommended implementation: The font specifies alternate metrics for the full-height
glyphs (GPOS lookup type 1, xPlacement, xAdvance, yPlacement and yAdvance).
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria.
UI suggestion: In general, this feature should be off by default. Different behavior should
be used, however, in applications that conform to Requirements for Japanese Text
Layout (JLREQ)

or similar CJK text-layout specifications that expect half-width forms of

characters whose default glyphs are full-width. Such implementations should turn this
feature on by default, or should selectively apply this feature to particular characters
that require special treatment for CJK text-layout purposes, such as brackets,
punctuation, and quotation marks.

Script/language sensitivity: Used only in CJKV fonts.
Feature interaction: This feature is mutually exclusive to all other glyph-height features
(e.g., 'valt' and 'vpal'), which should be turned off when this feature is applied. When
applied to a run of text, the 'vapk' and 'vkrn' features should be deactivated for that run.
See also 'halt'.

Tag: 'vjmo'
Friendly name: Vowel Jamo Forms
Registered by: Microsoft
Function: Substitutes the form for a Hangul vowel jamo used in a jamo cluster.
Example: In Hangul script, the jamo cluster is composed of three parts: leading
consonant, vowel, and trailing consonant. When a vowel jamo is found, an alternate
vowel jamo form is substituted.
Recommended implementation: The default glyph for a vowel jamo is mapped into an
alternate form required for conjoining in a syllable (GSUB lookup type 1, or a contextual
substitution that references a type 1 lookup).
Application interface: In recommended usage, this feature triggers substitutions required
for correct layout of certain scripts. It should be applied in the appropriate contexts, as
determined by script-specific processing requirements.
UI suggestion: Control of the feature should not generally be exposed to the user.
Script/language sensitivity: Used for Hangul script, particularly when Unicode conjoining
jamo characters are used.
Feature interaction: This feature overrides the results of all other features.

Tag: 'vkna'
Friendly name: Vertical Kana Alternates
Registered by: Adobe
Function: Replaces standard kana with forms that have been specially designed for only
vertical writing. This is a typographic optimization for improved fit and more even color.
Also see 'hkna'.

The 'hkna' and 'vkna' features are intended for use in fonts designed for both horizontal
and vertical layout. The font can have alternate glyphs for kana characters designed
specifically for horizontal layout, or specifically for vertical layout. These two features can
be used to select the variant glyphs for each layout direction. These features do not
affect glyph advance widths.
Example: Standard full-width kana (hiragana and katakana) are replaced by forms that
are designed for vertical use.
Recommended implementation: A lookup table for the 'vkna' feature maps the standard
full-width kana forms to the corresponding special vertical forms (GSUB lookup type 1).
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria.
UI suggestion: This feature should be off by default.
Script/language sensitivity: Used only for Hiragana and Katakana.
Feature interaction: Since this feature is only for vertical use, features applying to
horizontal behaviors (e.g. 'kern') do not apply.

Tag: 'vkrn'
Friendly name: Vertical Kerning
Registered by: Adobe
Function: In vertical text layout, used to adjust the amount of space between specific
glyph combinations to provide optically consistent spacing between glyphs.
Although a well-designed typeface has consistent inter-glyph spacing overall, some
glyph combinations require adjustment for improved legibility. Besides standard
adjustment in the vertical direction, this feature can provide “cross-stream” kerning in
the X text direction, make adjustments to glyph placement independent of the advance
adjustment, and can supply size-dependent kerning data via device tables. Note that
lookups for this feature can apply to runs of more than two glyphs.
This feature should only be used for spacing adjustments that can be overridden by the
user. It is not intended for use in horizontal text layout. See the 'kern' feature for
horizontal kerning.
Example: When the katakana character U+30B9 or U+30D8 is followed by U+30C8 in a
vertical setting, U+30C8 is shifted up to fit more evenly.

Recommended implementation: The font stores adjustments for pairs of glyphs (GPOS
lookup type 2 or 8). These can be stored as one or more tables matching left and right
classes, or as individual pairs. Additional adjustments may be provided for longer
sequences of glyphs (e.g., triplets, quadruplets, etc.) and ordered to take precedence
over pair kern adjustments of particular combinations.
A font should not apply kerning adjustments to fixed-height glyphs unless other
features can be applied that adjust vertical glyph metrics to be proportional. In new
fonts, kerning of glyphs with default fixed-height metrics that have been adjusted to
have proportional widths should be implemented using the 'vapk' feature rather than
this feature. See below for more details.
When using a GPOS type 2 lookup for this feature, it is recommended that no
positioning adjustment be applied to the second glyph in a pair. (That is, that
valueFormat2 should be set to 0.) As a result, the next glyph pair to be processed after
the lookup has been applied to this pair will start at the second glyph. In this way, every
glyph in a sequence can undergo positioning adjustment as the first glyph in a pair.
Otherwise, if positioning of the second glyph is adjusted, then the next glyph pair to be
processed will begin with the glyph following the second glyph. That will result in
kerning adjustment happening only for every other pair of glyphs.
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria.
UI suggestion: In most vertical text layout, this feature should be active by default—see
below for important exceptions. Applications may allow users to add further manuallyspecified adjustments to suit specific needs and tastes. This feature should be optional:
when activated by default for a text run, it should be possible for users to disable it for
that run.
An exception to default activation can apply for CJK text. If a text run is formatted with a
font that implements the 'vpal' feature, this feature should not be activated by default to
glyphs covered by 'vpal' lookups unless the 'vpal' feature has been activated. (Glyphs
covered by 'vpal' lookups will have fixed-height metrics by default, and the kerning
adjustments applied by this feature would be inappropriate for glyphs with fixed-height
metrics.) An application can scan the coverage tables of 'vpal' lookups to determine
glyphs to be excluded from default activation. Alternately, an application can use the
East Asian Width property, defined in Unicode Standard Annex #11, East Asian Width ,
to determine characters likely to have glyphs with fixed widths and heights by default.
Specifically, Unicode characters with East_Asian_Width property values Wide or Fullwidth
may be assumed to have default fixed-height metrics in fonts that implement 'vpal', and
therefore excluded from default activation of the 'vkrn' feature.

In new fonts, however, glyphs that are fixed height by default but are made proportional
by application of 'vpal' should have their kerning implemented using the 'vapk' feature
rather than the 'vkrn' feature. If a font implements both the 'vpal' and 'vapk' features,
then the 'vkrn' feature can be applied by default to all vertical text. But if a font
implements 'vpal' but not 'vapk', then one of the techniques described in the previous
paragraph should be used to condition default application of 'vkrn'.
If a font implements 'vkrn' but does not implement 'vpal', then 'vkrn' should be applied
by default to all vertical text using that font. See below for other important feature
interactions.
Script/language sensitivity: None
Feature interaction: The 'vkrn' feature should not be used in combination with features
that result in fixed-height metrics ('valt', 'vchw', 'vhal'). If any of those features are
activated on a text run, this feature should be disabled for that run.
This feature may be used in combination with the 'vpal' feature, which adjusts vertical
glyph metrics to be proportional. See details above regarding interaction betwen this
feature and 'vpal'. Also see recommendations above regarding use of the 'vapk' feature
in fonts.
If vertical kerning is activated by default as a result of activation of any features that
result in proportional widths, users should still have the option to disable this while the
proportional-width feature is still active.

Tag: 'vpal'
Friendly name: Proportional Alternate Vertical Metrics
Registered by: Adobe
Function: Re-spaces glyphs that have full-em heights by default, fitting them onto
individual (more or less proportional) vertical heights. This differs from 'valt', which
repositions a glyph but does not affect its advance.
Example: The user invokes this feature in a Japanese font to get Latin, Kanji, Kana or
Symbol glyphs with the full-height design but individual metrics.
Recommended implementation: The font specifies alternate heights for the full-height
glyphs (GPOS lookup type 1, xPlacement, xAdvance, yPlacement and yAdvance).
If a font supports this feature and also supports kerning, it is recommended that kerning
for glyphs affected by this feature be implemented using the 'vapk' feature and not the

'vkrn' feature. (The 'vkrn' feature should still be used for glyphs that have proportional
widths by default.) See the 'vapk' feature for more information.
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria.
UI suggestion: This feature should be off by default. See below for details regarding
important interactions with other features.
Script/language sensitivity: Used mostly in CJKV fonts.
Feature interaction: This feature is mutually exclusive to all other glyph-height features
('valt', 'vchw', 'vhal'), which should be turned off when it’s applied.
This feature may be used in combination with the 'vapk' or 'vkrn' features. If this feature
is activated for a text run, then kerning features may be activated for that run, either by
default or by user preference. However, if this feature is not activated, then the 'vapk'
and 'vkrn' features should not be activated for glyphs covered by the lookups for this
feature, as the kerning adjustments applied by those features would be inappropriate
for glyphs with fixed-width metrics.
See also 'palt'.

Tag: 'vrt2'
Friendly name: Vertical Alternates and Rotation
Registered by: Adobe
Function: Replaces some fixed-width (half-width, third-width or quarter-width) or
proportional-width glyphs (mostly Latin or katakana) with forms suitable for vertical
writing (that is, rotated 90 degrees clockwise). Note that these are a superset of the
glyphs covered by the 'vert' feature.
Example: Proportional-width or half-width Latin and half-width katakana characters are
rotated 90 degrees clockwise for vertical writing.
Recommended implementation: The font includes rotated versions of the glyphs covered
by this feature. The 'vrt2' table maps the standard (horizontal) forms to the
corresponding vertical (rotated) forms (GSUB lookup type 1). This feature should be the
last substitution in the font.
Note that some implementations impose the following requirements for an OpenType
font with CFF outlines to be used for vertical writing: the 'vrt2' feature must be present

in the GSUB table, it must comprise a single type 1 (single substitution) lookup with
lookupFlag set to 0, and the lookup must have a single subtable. The predecessor
feature, 'vert', is ignored.
A rotated glyph must be designed such that its top side bearing and vertical advance as
recorded in the Vertical Metrics ('vmtx') table are identical to the left side bearing and
horizontal advance, respectively, of the corresponding upright glyph as recorded in the
Horizontal Metrics ('hmtx') table. The horizontal advance of the rotated glyph may be
set to any value, since the glyph is intended only for vertical writing use. The vendor can,
however, set it to head.unitsPerEm, to prevent overlap during font proofing tests, for
example.
Thus, proportional-width characters with rotated forms substituted by the 'vrt2' feature
will appear identically spaced in both vertical and horizontal writing. In order for kerning
to produce identical results as well, developers must ensure that lookups for the Vertical
Kerning ('vkrn') feature have kern values between the rotated glyphs that are the same
as kern values between their corresponding upright glyphs in lookups for the Kerning
('kern') feature.
Application interface: Discretionary feature: can be applied to glyph runs in vertical text
layout based on document markup, user control or other application criteria.
UI suggestion: This feature should be active by default when vertical writing mode is on,
although the user should be able to override it.
Script/language sensitivity: Used for scripts with vertical writing modes.
Feature interaction: Overrides the 'vert' (Vertical Writing) feature, which is a subset of this
one. May be used in addition to any other feature.

Tag: 'vrtr'
Friendly name: Vertical Alternates for Rotation
Registered by: Adobe/Microsoft/W3C
Function: Transforms default glyphs into glyphs that are appropriate for sideways
presentation in vertical writing mode. While the glyphs for most characters in East Asian
writing systems remain upright when set in vertical writing mode, glyphs for other
characters — such as those of other scripts or for particular Western-style punctuation
— are expected to be presented sideways in vertical writing.
Example: As a first example, the glyphs for FULLWIDTH LESS-THAN SIGN (U+FF1C “＜”)
and FULLWIDTH GREATER-THAN SIGN (U+FF1E “＞”) in a font with a non-square em-

box are transformed into glyphs whose aspect ratio differs from the default glyphs,
which are properly sized for sideways presentation in vertical writing mode. As a second
example, the glyph for LEFT SQUARE BRACKET (U+005B, “[”) in a brush-script font that
exhibits slightly rising horizontal strokes might use an obtuse angle for its upper-left
corner when in horizontal writing mode, but an alternate glyph with an acute angle for
that corner is supplied for vertical writing mode.
Recommended implementation: The font includes versions of the glyphs covered by this
feature that, when rotated 90 degrees clockwise by the layout engine for sideways
presentation in vertical writing, differ in some visual way from rotated versions of the
default glyphs, such as by shifting or shape. The 'vrtr' feature maps the default glyphs to
the corresponding to-be-rotated glyphs (GSUB lookup type 1).
Application interface: Should be applied to applicable characters in vertical text layout.
UI suggestion: This feature should always be active by default for sideways runs in
vertical writing mode.
Script/language sensitivity: Applies to any script when set in vertical writing mode.
Feature interaction: The 'vrtr' and 'vert' features are intended to be used in conjunction:
'vrtr' for glyphs intended to be presented sideways in vertical writing, and 'vert' for
glyphs to be presented upright. Since they should never be activated simultaneously for
a given glyph, there should be no interaction between the two features. These features
are intended for layout engines that graphically rotate glyphs for sideways runs in
vertical writing mode, such as those conforming to Unicode Technical Report #50:
Unicode Vertical Text Layout

.

Note that layout engines that instead depend on the font to supply pre-rotated glyphs
for all sideways glyphs should use the 'vrt2' feature in lieu of 'vrtr' and 'vert'. Because
'vrt2' supplies pre-rotated glyphs, the 'vrtr' feature should never be used with 'vrt2', but
it may be used in addition to any other feature.

Tag: 'zero'
Friendly name: Slashed Zero
Registered by: Adobe
Function: Some fonts contain both a default form of zero, and an alternative form which
uses a diagonal slash through the counter. Especially in condensed designs, it can be
difficult to distinguish between 0 and O (zero and capital O) in any situation where

capitals and lining figures might be arbitrarily mixed. This feature allows the user to
change from the default 0 to a slashed form.
Example: When setting labels, the user applies this feature to get the slashed 0.
Recommended implementation: A lookup table for the 'zero' feature maps the GIDs for
the lining forms of zero to corresponding slashed forms (GSUB lookup type 1).
Application interface: Discretionary feature: can be applied to glyph runs based on
document markup, user control or other application criteria.
UI suggestion: Optimally, the application would store this as a preference setting, and
the user could use the feature to toggle back and forth between the two forms. Most
applications will want the default setting to disable this feature.
Script/language sensitivity: Used only for 0.
Feature interaction: Applies only to lining figures, so is mutually exclusive to oldstyle
figure features (e.g. 'onum').

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

Baseline Tags
Article • 07/06/2024

Baseline tags are used in the BASE table to provide additional font metric values that
may apply to particular scripts or usage contexts.
Baseline tags can be used in the BASE table’s HorizAxis subtable for horizontal layout, or
in the VertAxis subtable for vertical layout. A given baseline tag has a specific meaning
for each layout direction. For example, the 'romn' baseline tag is used to specify the
horizontal baseline for Latin text in horizontal layout, and the vertical baseline for
rotated Latin text in vertical layout; the 'icfb' baseline tag is used to specify the bottom
edge of an “ideographic character face” region (described below) in horizontal layout,
and the left edge in vertical layout.
All tags are four-character strings composed of a limited set of ASCII characters; for
details regarding the Tag data type, see Data Types. By convention, registered baseline
tags use four lowercase letters.
Within this section, the notation <axis>.<baseline tag> is used to mean the given
baseline tag when used in the specified layout-direction axis table within the BASE table.
For example, HorizAxis.ideo means the 'ideo' baseline tag used in the HorizAxis
subtable of the BASE table.
The following table describes the registered baseline tags. Sections that follow provide
more details related to certain baseline tags.
ﾉ

Expand table

Baseline
tag

Baseline for HorizAxis

Baseline for VertAxis

'hang'

The hanging baseline. This is
the horizontal line from which
syllables seem to hang in

The hanging baseline, (which now appears vertical)
for Tibetan (or some other similar script) characters
rotated 90 degrees clockwise, for vertical writing

Tibetan and other similar
scripts.

mode.

Ideographic character face
bottom edge. (See Ideographic
Character Face below for

Ideographic character face left edge. (See
Ideographic Character Face below for usage.)

'icfb'

usage.)
'icft'

Ideographic character face top

Ideographic character face right edge. (See

edge. (See Ideographic

Ideographic Character Face below for usage.)

Character Face below for
usage.)
'ideo'

'idtp'

'math'

'romn'

Ideographic em-box bottom
edge. (See Ideographic em-

Ideographic em-box left edge. If this tag is present
in the VertAxis, the value must be set to 0. (See

box below for usage.)

Ideographic em-box below for usage.)

Ideographic em-box top edge.
(See Ideographic em-box

Ideographic em-box right edge. If this tag is present
in the VertAxis, the value is strongly recommended

below for usage.)

to be set to head.unitsPerEm. (See Ideographic embox below for usage.)

The baseline about which
characters in mathematical

The baseline about which characters in
mathematical formulas are centered when formulas

formulas are centered.

are rotated 90 degrees clockwise for vertical writing
mode.

The baseline used by

The alphabetic baseline for characters rotated 90

alphabetic scripts such as Latin,

degrees clockwise for vertical writing mode. (This

Cyrillic and Greek.

would not apply to alphabetic characters that
remain upright in vertical writing mode, since these
characters are not rotated.)

Ideographic em-box
Some applications use ideographic em-box metrics for layout of CJK text. A font’s
ideographic em-box is the rectangle that defines a standard escapement around the
full-width ideographic glyphs of the font, for both the horizontal and vertical writing
directions. It is usually a square, but may be non-square, as in the case of fonts used in
Japanese newspaper layout that have a vertically condensed design.
The left, right, top and bottom edges of the ideographic em-box are determined as
follows:
ideoEmboxLeft = 0
If HorizAxis.ideo is defined:
ideoEmboxBottom = HorizAxis.ideo
If HorizAxis.idtp is defined:
ideoEmboxTop = HorizAxis.idtp
Else:
ideoEmboxTop = HorizAxis.ideo + head.unitsPerEm

If VertAxis.idtp is defined:
ideoEmboxRight = VertAxis.idtp
Else:
ideoEmboxRight = head.unitsPerEm
If VertAxis.ideo is defined and is non-zero:
Warning: Bad VertAxis.ideo value
Else If this is a CJK font:
ideoEmboxBottom = OS/2.sTypoDescender
ideoEmboxTop = OS/2.sTypoAscender
ideoEmboxRight = head.unitsPerEm
Else:
ideoEmbox cannot be determined for this font
Determining whether a font is CJK (Chinese, Japanese, or Korean) or not, as in the
second-last “Else” clause above, can be done by checking the 'dlng' entry (if present) of
the 'meta' table, the CJK-related bits of the OS/2.ulUnicodeRange fields, or the
OS/2.ulCodePageRange fields.
Note that non-CJK fonts can specify a HorizAxis.ideo baseline; this can be used by
applications when aligning the font with an ideographic font used on the same line of
text, when alignment based on the ideographic em-box is used.
The ideographic em-box center baseline is defined as halfway between the ideographic
em-box top and bottom baselines in the horizontal axis, and halfway between the
ideographic em-box left and right baselines in the vertical axis. These center baselines
are calculated in whole font design units. The division used in the calculation must be
rounded to the unit nearest 0 if needed. Thus, for maximal precision of center baseline
placement, vendors should ensure that opposite edges of the ideographic em-box box
are an even number of design units apart.

Example

The values of the ideographic baseline tags for the Kozuka Mincho font family (designed
on a 1000-unit em) are:
HorizAxis.ideo = -120; HorizAxis.idtp = 880.
Since this describes a square ideographic em-box, it is sufficient to record only the
following:
HorizAxis.ideo = -120.
If HorizAxis.ideo is not present, then the following will be used for the ideographic embox bottom and top, since this is a CJK font:
OS/2.sTypoDescender = -120; OS/2.sTypoAscender = 880.

Compatibility notes
Most applications expect the width of full-width ideographs in a CJK font to be exactly
one em, thus it is strongly recommended that VertAxis.idtp, if present, be set to
head.unitsPerEm.
The OS/2.sTypoDescender and OS/2.sTypoAscender fields in a CJK font may specify
metrics different from the HorizAxis.ideo and HorizAxis.idtp values in the BASE table.
However, CJK font developers should be aware that some applications might not read
the BASE table at all but simply use the OS/2.sTypoDescender and OS/2.sTypoAscender
fields to describe the bottom and top edges of the ideographic em-box. If developers
want their fonts to work correctly with such applications, they should ensure that any
ideographic em-box values in the BASE table of their CJK fonts describe the same
bottom and top edges as the OS/2.sTypoDescender and OS/2.sTypoAscender fields.
Some legacy platforms or applications might not use OS/2 fields at all. Thus, CJK fonts
generally should have the same descender value recorded in hhea.descender,
OS/2.sTypoDescender, and HorizAxis.ideo (if present) fields, and the same ascender
value recorded in hhea.ascender, OS/2.sTypoAscender, and HorizAxis.idtp (if present)
fields.
See the section “OpenType CJK Font Guidelines” for more information about
constructing CJK fonts.

Ideographic character face

In addition to ideographic em-box metrics, some applications also use ideographic
character face metrics for layout of CJK documents. The ideographic character face (ICF)
specifies an average or approximate bounding box of the ideographic glyphs in a CJK
font. (This is different from the FontBBox operator in the PostScript programming
language, which is the bounding box of all glyphs in the font superimposed.) It can also
be used in a font that does not contain ideographs (for example, a kana-only font) to
indicate metrics for ideographs that would balance with other existing glyphs in the
font.
In Japanese, the term for ICF is heikin jizura.
ICF metrics are not typically used as a text baseline, though they can be used in this way.
Rather, ICF metrics allow an application to provide improved visual alignment of page
elements to text.
ICF metrics are often expressed in applications as a percentage that represents the ratio
of the length of an ICF box edge to the length of an ideographic em-box edge, and is
conceptualized as a square centered within the ideographic em-box. OpenType,
however, allows for finer specification of ICF metrics, with the left, bottom, right, and top
edges of the ICF box specified using VertAxis.icfb, HorizAxis.icfb, VertAxis.icft, and
HorizAxis.icft values, respectively. This provides font designers with the flexibility to
specify a non-square or non-centered ICF box.
Font designers should set the value of the ICF box edges based on how tight or loose
they want the font to appear when text is set with no tracking or kerning (beta gumi in
Japanese). Therefore, the left-over boundary of the ideographic em-box around the ICF
box is the default escapement of the font.
Applications can use the ICF box as an alignment tool, to ensure that glyphs touch the
edges of the text frame and that page objects are visually aligned to text edges. It is also
useful for aligning glyphs of different sizes on the same line. In Japanese traditional
paper-based workflow, the ICF box was often used for these purposes. It provides
optically aligned results that are superior to using the ideographic em-box.
HorizAxis.icfb is the minimum piece of information required in a CJK font to define the
ICF metrics. First, the ideographic em-box dimensions must be calculated as described
above. The ICF edges are then calculated in the following order:
If HorizAxis.icfb is defined:
icfBottom = HorizAxis.icfb
margin = HorizAxis.icfb - ideoEmboxBottom
If HorizAxis.icft is defined:

icfTop = HorizAxis.icft
Else:
icfTop = ideoEmboxTop - margin
If VertAxis.icfb is defined:
icfLeft = VertAxis.icfb
Else:
icfLeft = margin
If VertAxis.icft is defined:
icfRight = VertAxis.icft
Else:
icfRight = ideoEmboxRight - icfLeft
Else:
ICF cannot be determined for this font
For the last case above (i.e., fonts that don’t have ICF information in their BASE table), an
application may choose to apply a heuristic such as calculating the bounding box of
some or all of the ideographic and kana glyphs, and then averaging its margin with the
ideographic em-box.
The ICF center baseline is defined as halfway between the ICF top and bottom baselines
in the horizontal axis, and halfway between the ICF left and right baselines in the vertical
axis. These center baselines are defined in whole character units. The division used in the
calculation must round to the character unit nearest 0 if needed. Thus, for maximal
precision of center baseline placement, vendors should ensure that opposite edges of
the ICF box are an even number of character units apart.

Example

The values of the ICF baselines for the Extra Light and Heavy weights of the Kozuka
Mincho font family (designed on a 1000-unit em, with ideographic em-box as given in
the example in the previous section) are:
Kozuka Mincho Extra Light:
VertAxis.icfb = 41; HorizAxis.icfb = -79;
VertAxis.icft = 959; HorizAxis.icft = 839.
Since this describes a square ICF centered in a square ideographic em-box, it is
sufficient to record only the following:
HorizAxis.icfb = -79.
Kozuka Mincho Heavy:
VertAxis.icfb = 26; HorizAxis.icfb = -94;
VertAxis.icft = 974; HorizAxis.icft = 854.
It is sufficient to record only:
HorizAxis.icfb = -94.
It is strongly recommended that each of the edges of the ICF box be equidistant from
the corresponding edge of the ideographic em-box. Following this will result in more
predictable results in applications that use these values. That is, for fonts based on a
square ideographic em-box, the ICF box should be a centered square.
See the section “OpenType CJK Font Guidelines” for more information about
constructing CJK fonts.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

OpenType Design-Variation Axis Tag
Registry
Article • 05/29/2024

This registry defines design-variation axis tags for use in OpenType fonts. By providing
registered tags with well-defined semantics and associated numeric scales for variation,
this provides some degree of interoperability between different fonts from different
vendors, or between fonts and applications.
Design-variation axis tags are used within the 'fvar' table in variable fonts, and also
within the STAT table. Note that they are relevant for non-variable fonts as well as
variable fonts: even though a font might not be a variable font, it is still a design variant
within its font family. The STAT table allows applications to understand relationships of
font design variants within a given family, whether they are implemented as nonvariable fonts or as variation instances of a variable font.

Syntactic requirements for design-variation axis
tags
Design-variation axis tags are four-byte arrays that can equivalently be interpreted as a
string of four ASCII characters. (See Data Types for a general description of Tag values.)
Axis tags must begin with a letter (0x41 to 0x5A, 0x61 to 0x7A) and must use only
letters, digits (0x30 to 0x39) or space (0x20). Space characters must only occur as trailing
characters in tags that have fewer than four letters or digits.
Fonts may use tags defined in this registry, or may use foundry-defined tags. (Foundrydefined tags can also be referred to as “custom” or “private” tags.) Foundry-defined tags
must begin with an uppercase letter (0x41 to 0x5A), and must use only uppercase letters
or digits. Registered axis tags must not use that pattern, but can use any other valid
pattern. This ensures that foundry-defined tags and registered tags are never conflicting.

Documentation of registered axis tags
For every axis tag defined in this registry, certain information is required or
recommended:
The tag specification must include a US English name for the axis that may be used
as a display string in application user interfaces to refer to the axis, or as the basis
of localized display strings.

The tag specification must include a description of the intended meaning and
design-variation behavior for the axis.
The tag specification must include information regarding the numeric scale used
for the axis. This must include a specification of the range of values that are valid
for the axis. Depending on the nature of the axis, this may be a bounded or
unbounded range. It must also provide information regarding the semantic
interpretation for values, specifying either some objective measure or some
convention by which values can be interpreted.
Whenever appropriate, the tag specification should also indicate a numeric value
that is recommended or required (by definition of the scale) for that axis in a
“Regular” font.
Note: The “Regular” font in a font family often has a sub-family name that omits axis
qualifiers. For example, one foundry may create an optical-size font suited to 12
point size with “Text” included in the name as an indicator of the intended optical
size, but another foundry may create a similar font without any indicator for optical
size in the name. The choice for a recommended “Regular” axis value should be
made with this in mind.
Additional information may also be provided, such as suggestions for programmatic
selection of axis values that may be useful in applications.
The specification for the semantic interpretation of numeric values is required as a
means to provide some degree of interoperability between different fonts, between
fonts and software implementations, and between OpenType Font Variations and other
specifications, such as font-weight values in CSS.
Note that interoperability is assumed to be attained in varying degrees, depending on
the nature of an axis and the scale that it uses. For example, the scale for the Weight axis
provides a limited degree of interoperability. Two different fonts with a Weight axis
value of 700 (or “Bold”) may not result in the same amount of darkness or “color” when
applied to the same text; but in both cases, a user can expect these to be darker than
the “Regular” or “Semibold” fonts from each respective font family, and application
developers can produce results that will be predictable for users if they associate that
axis value with a particular state of a user-interface control or with a <strong> markup
tag.
In contrast to this, the scale for the Optical size axis is designed to provide a much
stronger degree of interoperability. For instance, two different fonts with an optical-size
value of 20 are assumed to be best suited to text set at 20 points, because the scale is
designed that way. If this axis had been defined with a different numeric scale, then an

application might not be able to assume that two fonts with the same optical-size value
are equally-well suited for a given context.
Not all axes will be equally amenable to a precise or objective measure. For example,
there is no objective scale for an amount of italicness. But an Italic axis can be defined
with a range from 0.0 to 1.0, representing whatever the font developer considers to be a
non-italic design and a fully italic design, and that is sufficient for applications to
associate those numeric variation values with off/on states of an Italic toggle in a user
interface to provide a meaningful and familiar experience. It also provides a useful basis
of comparison between different fonts, which may be important, for instance, in fontfallback implementations: if the requested font face had an Italic axis setting of 1 but a
font-fallback font must be used when displaying text, the application is able to select an
appropriate Italic axis setting in the fallback font.
If an axis is intended to interact with programmatic mechanisms that automatically
select axis values to provide some effect, then a more precise definition of the numeric
scale and its interpretation may be needed. It must be clear to application and platform
developers what independent variables should contribute as inputs for selection of axis
values, and how the numeric values of the axis scale can be derived from those inputs.
For variable font implementations that support a given axis, the “Regular” value will
often be a good choice for the default value of that axis in the 'fvar' variation axis
record. The default values set in the 'fvar' table, however, are implementation-specific,
and fonts are not required to use this “Regular” value as the axis default value.

Registered axis tags
The following design-variation axes and tags have been registered; the linked pages
provide the axis tag descriptions. These are listed in alphabetic order of the tags.
ﾉ

Axis tag

Name

'ital'

Italic

'opsz'

Optical Size

'slnt'

Slant

'wdth'

Width

'wght'

Weight

Expand table

How to register a design-variation axis tag
While font developers can always use foundry-defined axis tags however they might
choose, Microsoft encourages font developers to use registered axis tags when
implementing designs for which the registered axis is applicable. Microsoft welcomes
nominations for new design-variation axis tag registration.
Registration of an axis tag can be useful for two key purposes. One is to foster
conventionality and familiarity for a kind of design variation. For example, by defining
the 'opsz' tag for optical-size variation, to use for tailoring glyph outlines according to
the font size, different vendors can incorporate this kind of design variation into fonts,
and the variations in these various fonts can be presented to font users as the same kind
of variation. The more fonts that are implemented using an 'opsz' axis, the more familiar
designers and content authors will become with this kind of design variation. They will
benefit from greater consistency in experience when fonts use the same concepts than if
different fonts were using similar but different concepts.
Another key purpose for registration of axis tags is to facilitate interoperability between
different fonts or between fonts and applications. For example, by specifying a numeric
scale for the 'opsz' axis that corresponds to text size in points, this makes it possible for
applications to implement mechanisms for automatic selection of optical-size variation
that can work with any fonts that support variation in the 'opsz' axis.
The merits for adding a variation axis tag to the registry is primarily determined in
relation to these two key purposes: What is the likelihood that an axis of design
variation will be implemented in fonts from multiple vendors and found to be useful to
designers; and what is the likelihood that applications will implement mechanisms that
make use of an interoperable understanding of the axis.
To qualify for registration, a complete description of the axis must be provided,
including each of the categories of information listed above. If the axis is intended to
interact with mechanisms that select axis values programmatically, then the description
must include a clear specification for the numeric scale. There must be reasonable
indication of alignment with one or both of the two key purposes for registration
described above, and a reasonable indication that the axis will be implemented in fonts
from multiple vendors and supported in software platforms and applications. It is
recommended that the party proposing the new registration seek input from and get
consensus among multiple font and software vendors regarding the definition of the
proposed axis and its merits.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

Registered Design-Variation Axis Tag:
'ital'
Article • 12/09/2021

Axis definition
Tag: 'ital'
Name: Italic
Description: Used to vary between non-italic and italic.
Valid numeric range: Values must be in the range 0 to 1.
Scale interpretation: A value of 0 can be interpreted as “Roman” (non-italic); a value of 1
can be interpreted as (fully) italic.
Recommended or required “Regular” value: 0 is required.

Additional information
The Italic axis has long been treated as a kind of design variation within a font family.
The 'ital' axis tag is used within a STAT table of italic fonts to provide a complete
characterization of a font in relation to its family within the STAT table. The Italic axis can
be used as a variation axis within a variable font, though this is not expected to be
common.
The Italic axis is distinct from the Slant axis ('slnt'). Fonts may use one or the other,
depending on the nature of the design, but should rarely use both. While an italic
design often incorporates some slant in the design, use of the Italic axis does not
require use of the Slant axis. An italic font should not be characterized in the STAT table
as being italic and also having some slant, unless the font family includes multiple italic
designs with different amounts of slant.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:

can also create and review
issues and pull requests. For
more information, see our
contributor guide.

 Open a documentation issue
 Provide product feedback

Registered Design-Variation Axis Tag:
'opsz'
Article • 05/29/2024

Axis definition
Tag: 'opsz'
Name: Optical Size
Description: Used to vary design to suit different text sizes.
Valid numeric range: Values must be strictly greater than zero.
Scale interpretation: Values can be interpreted as text size, in typographic points, as
defined in the OpenType specification: a physical unit equal to 1/72 of a standard
physical inch.
Recommended or required “Regular” value: A value in the range 10 to 16 is
recommended for typical text settings.
Suggested programmatic interactions: Applications may choose to select an optical-size
variant automatically based on the displayed text size.

Additional information
The Optical size axis can be used as a variation axis within a variable font. It can also be
used within a STAT table in non-variable fonts within a family that has optical-size
variants to provide a complete characterization of a font in relation to its family within
the STAT table. In the STAT table of a non-variable font, a format 2 axis value table is
recommended to characterize the range of text sizes for which the optical-size variant is
intended.
Typical font implementation of optical size design variants involves adapting glyph
proportions, stem weights, and details to be appropriate to specific sizes of displayed
text. These adaptations may be both functional and aesthetic, ensuring legibility at
smaller sizes and refinement of fine details and overall width at larger sizes. The nature
of the adaptations may depend on aspects of the individual typeface design, the
characters or scripts involved, targeted devices on which the font may be displayed, and
known or intended distance from which text will be viewed.

Type designers may develop size-specific design variations based on print or screen
rendering, typically evaluating the design of these variations at a reading distance of 14
to 16 inches, or 35 to 40 cm. This can be used as a basis for determining appropriate
optical size variants for different distances. For example, if the design of a given optical
size variant is appropriate for 12-point text viewed from a reading distance of 15 inches,
it should also be appropriate for 24 point text viewed from a reading distance of 30
inches.
The scale for the Optical size axis is text size in points. For these purposes, the text size is
as determined by the document or application for its intended use; the actual physical
size on a display may be different due to platform or application scaling methods or
intended viewing distance.
The target of size-specific design is optical, i.e., tailored to what the reader is seeing. For
this reason, Optical size axis variant selection should be determined, so far as possible,
by as much information as available regarding displayed size of text as seen by the
reader. Factors to be taken into account should include the scaling of type on specific
platforms and the translation of document and platform units to 1/72 of a physical inch,
as well as typical reading distances for applications and devices. This may mean that a
nominally specified text size in a document could result in a different Optical size axis
variant selection on different platforms and devices, determined by the actual size of
text seen by the reader.
Note: User-perceived size is very dependent on viewing distance, not only physical
size on the display. For example, when viewing text on a large-screen TV, the
physical size on the display will be many times larger than the size perceived by the
user. In this case, selecting an Optical size variant based only on the physical size on
the display would likely result in reduced legibility for the user.
When translating between document units and the point (1/72 inch) scale for this axis,
care should be taken not to assume equivalences between units that may apply on
some platforms but not others.
In applications that automatically select an Optical size variant, this should normally be
done based on the text size with a default or “100%” zoom level, not on a combination
of text size and zoom level. Types of zoom that do not trigger re-layout of text should
not change Optical size variant selection, while content enlarging or diminishing
operations that change re-layout of text should make a new Optical size variant
selection based on the new displayed sized.
If the size of displayed text is smaller or greater than the minimum and maximum extent
of the axis range, Optical size axis variant selection should be clamped to the

appropriate minimum or maximum axis value, not reset to the default instance.
It is recommended that software provide means to override automatic Optical size
variant selection, as may be appropriate for particular platforms, intended use, known
viewing distance, or accessibility.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

Registered Design-Variation Axis Tag:
'slnt'
Article • 12/09/2021

Axis definition
Tag: 'slnt'
Name: Slant
Description: Used to vary between upright and slanted text.
Valid numeric range: Values must be greater than -90 and less than +90.
Scale interpretation: Values can be interpreted as the angle, in counter-clockwise
degrees, of oblique slant from whatever the designer considers to be upright for that
font design.
Recommended or required “Regular” value: 0 is required.

Additional information
The Slant axis can be used as a variation axis within a variable font. It can also be used
within a STAT table in non-variable, oblique fonts to provide a complete characterization
of a font in relation to its family within the STAT table.
The Slant axis is distinct from the Italic axis ('ital'). Fonts may use one or the other,
depending on the nature of the design, but should rarely use both. While an italic
design often incorporates some slant in the design, use of the Italic axis does not
require use of the Slant axis. An italic font should not be characterized in the STAT table
as being italic and also having some slant, unless the font family includes multiple italic
designs with different amounts of slant.
Note that the scale for the Slant axis is interpreted as the angle of slant in counterclockwise degrees from upright. This means that a typical, right-leaning oblique design
will have a negative slant value. This matches the scale used for the italicAngle field in
the 'post' table.
In a variable font that implements 'slnt' variations, the value in the italicAngle field of the
'post' table must match the default 'slnt' value specified in the 'fvar' table. For non-

default instances of a variable font, the 'slnt' axis value can be used as the
post.italicAngle value for the instance.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

Registered Design-Variation Axis Tag:
'wdth'
Article • 12/09/2021

Axis definition
Tag: 'wdth'
Name: Width
Description: Used to vary width of text from narrower to wider.
Valid numeric range: Values must be strictly greater than zero.
Scale interpretation: Values can be interpreted as a percentage of whatever the font
designer considers “normal width” for that font design.
Recommended or required “Regular” value: 100 is required.
Suggested programmatic interactions: Applications may choose to select a width variant
in a variable font automatically in order to fit a span of text into a target width.

Additional information
The Width axis has long been used in conjunction with face names such as “Condensed”
or “Extended”. Change in glyph width is typically the primary aspect of the design that
varies, though other secondary details such as stroke thickness may also be
encompassed in this variation.
The Width axis can be used as a variation axis within a variable font. It can also be used
within a STAT table in non-variable fonts within a family that has width variants to
provide a complete characterization of a font in relation to its family within the STAT
table.
The Width axis uses a scale that correlates with but is different from the scale used for
the usWidthClass field of the OS/2 table. The description of usWeightClass in the OS/2
table documentation provides a table of mappings from usWidthClass values to “% of
normal” values. Because usWidthClass is limited to nine integer values, it has much less
granularity than the Width axis.

When mapping from 'wdth' values to usWidthClass, interpolate fractional values
between the mapped values and then round, and clamp to the range 1 to 9.
In a variable font that implements 'wdth' variations, the value in the usWidthClass field
of the OS/2 table must correspond to the default 'wdth' value specified in the 'fvar'
table. For non-default instances of a variable font, the 'wdth' axis value can be used to
derive the OS/2.usWidthClass value for that instance.
Percentage of normal width is a comparitive scale that will depend on the specific items
being compared. The width of a line of text very much depends on the content of the
text. No specific reference string is specified here as the basis for comparisons; a font
designer can choose what they consider to be representative strings assigning a 'wdth'
value to a design variant. Ideally, the 'wdth' value should provide a good estimate for
most strings in the target languages of how the width of the string formatted with that
'wdth' variant compares to the width of the same string when formatted with the
“normal” variant.
When using a variable font, applications may choose to make small, automated 'wdth'
adjustments in order to fit a span of text to some target size. This might be done, for
instance, to fit headings within a column, or to improve paragraphy layout. The relative
change in 'wdth' value (ratio of the original 'wdth' to the adjusted 'wdth') may be used
as a first approximation of the adjustment needed. Since the relative change in width
may depend on the actual text content, however, this may not provide the exact
adjustment needed to obtain the desired width adjustment. The application will likely
need to refine the adjustment over multiple attempts.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

Registered Design-Variation Axis Tag:
'wght'
Article • 12/09/2021

Axis definition
Tag: 'wght'
Name: Weight
Description: Used to vary stroke thicknesses or other design details to give variation
from lighter to blacker.
Valid numeric range: Values must be in the range 1 to 1000.
Scale interpretation: Values can be interpreted in direct comparison to values for
usWeightClass in the OS/2 table, or the CSS font-weight property.
Recommended or required “Regular” value: 400 is required.

Additional information
The Weight axis has long been used in conjunction with face names such as “Regular”,
“Light” or “Bold”. Change in stroke thickness is typically the primary aspect of the design
that varies, though other secondary details such as glyph width or thick-thin contrast
may also be encompassed in this variation.
The Weight axis can be used as a variation axis within a variable font. It can also be used
within a STAT table in non-variable fonts within a family that has weight variants to
provide a complete characterization of a font in relation to its family within the STAT
table.
In a variable font that implements 'wght' variations, the value in the usWeightClass field
of the OS/2 table must match the default 'wght' value specified in the 'fvar' table. For
non-default instances of a variable font, the 'wght' axis value can be used as the
OS/2.usWeightClass value for the instance.

６ Collaborate with us on

OpenType specification feedback

GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

OpenType 1.9.1 errata
Article • 03/20/2025

This page documents errors in the OpenType specification that have technical
significance and could lead to incorrect implementations. The scope is limited to issues
in which the OpenType 1.9.1 specification as originally published implies technical
details that are contrary to the intended design. Corrections may include corrections to
incorrect values related to certain table fields, incorrect formulas for computing certain
values, or similar issues. Corrections will not include any changes to data structures. If
the textual change required for the correction is minor, the correction will be made in
the specification and also listed here. If larger textual changes are required, the issue
may be described here, but actual changes may be left to a future version. In either case,
the status will be indicated in the table below.
Certain minor, editorial errors such as mis-spelling of words with no technical impact
may on occasion be corrected silently, without notice or version update.
ﾉ

Expand table

Date

Page

Description

Status

9
October
2024

CFF2 —
Compact
Font Format
(CFF) Version
2

The description of StemSnapH and StemSnapV included
a statement suggesting that, if the values are blended in
a variable font and the derived instance values are not in
increasing order, then behavior is not defined. That is
incorrect: the values are still valid.

Corrected
in 1.9.1
(2024-109).

Similarly, the discussion of blended stem and end hints
included a statement suggesting that, if derived instance
values for stems are not in order, then behavior is not
defined. That is incorrect: the values are still valid, and
the bit flag operands for cntrmask and hintmask
operators reference stems in their encoded order.
6 July

OpenType™

In the description for the SequenceRuleSet table, the

Corrected

2024

Layout
Common

size for the seqRuleOffsets[] array incorrectly referred to
a field name “posRuleCount” instead of the

in 1.9.1
(2024-7-6).

Table Formats

“seqRuleCount” field.

19

JSTF —

The field name “gsubLookupIndices" in the JstfModList

Corrected

March
2025

Justification
Table

table is incorrect. In OpenType 1.9 and earlier, two
justification modification list tables were documented,
JstfGSUBModList and JstfGPOSModList, that were

in 1.9.1
(2025-319).

identical except for having distinct field names with
“GSUB” and “GPOS”. In working drafts for ISO/IEC

14496-22 Open Font Format, 5th Edition, the separate
tables were consolidated into the one JstfModList table.
When incorporating a corresponding change in
OpenType 1.9.1, revision of this field name was
overlooked: the field name in the consolidated table
should be “lookupIndices”.

Recommendations for OpenType Fonts
Article • 05/29/2024

This chapter outlines recommendations for creating OpenType fonts.

Mixing Outline Formats
Both Microsoft and Adobe recommend against mixing outline formats within a single
font. Choose the format that meets your feature requirements.

Filenames
OpenType fonts may have the extension .OTF, .TTF, .OTC or .TTC, depending on the type
of outlines in the font and the desired backwards compatibility.
A file containing a single font resource with TrueType outlines should have either
.OTF or .TTF extension. The choice between .OTF and .TTF may depend on the
desire for backward compatibility on older systems or with previous versions of the
font.
A file containing a single font resource with only CFF outline data (no TrueType
outlines) should have an .OTF extension.
A font collection file (one that contains multiple font resources) should have either
.OTC or .TTC as the extension, regardless of whether or not layout tables are
present in any of the font resources, and regardless of the kind of outline data
used. The .TTC extension may be used for font collection files containing font
resources that use CFF outline data if needed for backward compatibility with older
software that was not aware of the .OTC extension.
A variable font that uses OpenType Font Variations mechanisms and associated
tables should use the extensions .OTF, .TTF, .OTC or .TTC following the above
guidance. If there is a need to provide some indication wihtin a filename that the
file contains a variable font, a recommended convention is to append “VF” (with a
preceding delimiter character) at the end of the file name (before the extension) —
e.g., “Selawik-VF.ttf”.
In all cases, software must determine the kind of outlines present in a font not from the
filename extension but from the contents of the file.

Table Alignment

Some implementations do not assume that tables have four-byte aligned offsets, and
some do not validate table checksums. However, there are also implementations that do
validate table checksums and that calculate checksums assuming that tables have fourbyte aligned offsets with padded zeros. Also, having tables begin at four-byte aligned
offsets provides performance benefit when accessing tables, and minimizes potential for
erroneous checksum calculation. New fonts are required to align table offsets to
multiples of four bytes. However, new software implementations should allow for table
lengths that are not a multiple of four when calculating checksums, if checksums are
validated.

Glyph 0: the .notdef glyph
Glyph 0 must be assigned to a .notdef glyph. The .notdef glyph is very important for
providing the user feedback that a glyph is not found in the font. This glyph should not
be left without an outline as the user will only see what looks like a space if a glyph is
missing and not be aware of the active font’s limitation.
It is recommended that the shape of the .notdef glyph be either an empty rectangle, a
rectangle with a question mark inside of it, or a rectangle with an “X”. Creative shapes,
like swirls or other symbols, may not be recognized by users as indicating that a glyph is
missing from the font and is not being displayed at that location.

BASE Table
The BASE table allows for different scripts in the font to specify different values for the
same baseline tag. This situation could arise, for example, when a developer makes a
multi-script font by combining glyphs from multiple fonts that use different baseline
systems.
However, glyphs from different scripts in this font may not appear correctly aligned
relative to each other when used with applications that either don’t support the BASE
table or that support it but assume that a particular baseline will not vary across scripts.
Furthermore, it is not always possible to determine the script of every glyph in the font,

some “weakly-scripted” characters such as punctuation may be used in several scripts,
and some glyphs such as ornaments may not have a script at all.
Thus, it is strongly recommended that developers construct their fonts so that all scripts
in the BASE table record the same value for a particular baseline if they want their fonts
to work as expected in the above situations.
If baselines vary by script, it is strongly recommended that the vendor add a DFLT script
entry to the BASE table, which can be used if the script requested by the application is
not matched, or if the application does not or cannot determine the script.

'cmap' Table
New fonts should use Unicode encoding:
If the font supports only characters in the Unicode Basic Multilingual Plane
(U+0000 to U+FFFF): either platform 3, encoding 1; or platform 0, encoding 3. With
either encoding, use a format 4 subtable.
If the font supports any characters in a Unicode supplementary plane (U+10000 to
U+10FFFF): either platform 3, encoding 10; or platform 0, encoding 4. With either
encoding, use a format 12 subtable.
If the font supports Unicode variation sequences: platform 0, encoding 5, with a
format 14 subtable. This is in addition to a format 4 or format 12 subtable with
encodings as listed above.
If the font is designed as a font of last resort, using single glyphs for entire
Unicode character ranges: platform 0, encoding 6, with a format 13 subtable. A
last-resort font should not use any other encodings or subtable formats.
When creating a font to support Unicode supplementary-plane characters, a format 4
subtable can be included, as well as a format 12 subtable, to provide compatibility with
older applications might not support a format 12 subtable. This is not required,
however. If both are included, either subtable may be used in different contexts, and so
the glyph mappings for characters in the range U+0000 to U+FFFF should be identical.
The format 12 table should include all BMP and supplementary-plane characters
supported by the font. For each subtable, use the encodings indicated above.

'cvt ' Table
Should be defined only if required by font instructions.

'fpgm' Table
Should be defined only if required by TrueType font instructions.

'fvar' Table
The InstanceRecord postScriptNameID field may be required in some applications. For
the broadest application compatibility, variable fonts should include this field in all
instance records.

'glyf' Table
The 'glyf' table contains TrueType outline data, and can be optimized by Agfa MicroType
Compression. It is recommended that developers perform this optimization prior to
finalizing and adding a digital signature to the font. This is necessary for the creator’s
signature to remain valid in embedded OpenType fonts.

'hdmx' Table
This table improves the performance of OpenType fonts with TrueType outlines. This
table is not necessary at all unless instructions are used to control the “phantom points,”
and should be omitted if bits 2 and 4 of the flags field in the 'head' table are zero. (See
the 'head' table documentation in Chapter 2.) Microsoft recommends that this table be
included for fonts with one or more non-linearly scaled glyphs (i.e., bit 2 or 4 of the
'head' table flags field are set).
Device records should be defined for all sizes from 8 through 14 point, and even point
sizes from 16 through 24 point. However, the table requires pixel-per-em sizes, which
depend on the horizontal resolution of the output device. The records in 'hdmx' should
cover both 96 dpi devices (CGA, EGA, VGA) and 300 dpi devices (laser and ink jet
printers).
Thus, 'hdmx' should contain entries for the following pixel sizes (PPEM): 11, 12, 13, 15,
16, 17, 19, 21, 24, 27, 29, 32, 33, 37, 42, 46, 50, 54, 58, 67, 75, 83, 92, 100. These values
have been rounded to the nearest pixel. For instance, 12 points at 300 dpi would
measure 37.5 pixels, but this is rounded down to 37 for this list.
This will add approximately 9,600 bytes to the font file. However, there will be a
significant improvement in speed when an application requests advance widths covered
by these device records.

If the font includes an LTSH table, the 'hdmx' values are not needed above the linearity
threshold.

'head' Table
Although historical usage of the fontRevision value is varied, the recommended use of
the field is to set it as a Fixed 16.16 value, and to report it rounded and zero-padded to
three fractional decimal places. Examples: Decimal 1.5 is set as 0x00018000 and is
reported as “1.500”; decimal 1.001 is set as 0x00010041 and is reported as “1.001”. All
data required. If the font has been compressed with Agfa MicroType Compression, this
must be indicated in the flags field of the 'head' table.

'hhea' Table
All data required. It is suggested that monospaced fonts set numberOfHMetrics to three
(see 'hmtx').

'hmtx' Table
All data required. It is suggested that monospaced fonts have three entries in the
numberOfHMetrics field. OpenType fonts that include CFF data must set
numberOfHMetrics equal to the number of glyphs in the font and therefore cannot use
the “repeat last width” optimization normally available within the 'hmtx' table.

'kern' Table
Should contain a single kerning pair subtable (format 0). Windows will not support
format 2 (two-dimensional array of kern values by class); nor multiple tables (only the
first format 0 table found will be used) nor coverage bits 0 through 4 (i.e. assumes
horizontal data, kerning values, no cross stream, and override).
The OpenType specification allows fonts with CFF outlines to express their kerning in a
'kern' table. Many OpenType text layout engines support this. Windows GDI’s OpenType
CFF driver, however, ignores the 'kern' table in a CFF OT font when it prepares kerning
pairs to report via its pair kerning API.
When a 'kern' table and GPOS table are both present in a font, and an OpenType Layout
engine is requested to apply kerning to a run of text of a particular script and language
system: (a) If the number of 'kern' feature lookups in the resolved language system in
the GPOS table is zero, then the 'kern' table should be applied, followed by any

remaining GPOS features requested. (b) If the number of 'kern' feature lookups in the
resolved language system in the GPOS table is non-zero, then all GPOS lookups,
including the 'kern' lookups, should be applied in the usual way and the 'kern' table data
ignored.
If a 'kern' table present but no GPOS table is present in the font, then an OpenType
Layout engine should apply the 'kern' table to the text, regardless of the resolved
language system of the text.
If compatibility with legacy environments is not a concern, font vendors are encouraged
to record kerning in the GPOS table’s 'kern' feature and not in the 'kern' table.
OpenType Font Variations mechanisms do not include any way to represent variation of
data within a 'kern' table. Therefore, kerning in a variable should be implemented using
the GPOS table.

'loca' Table
Local offsets should be 16-bit aligned, in both the short and long formats of this table.
The actual ordering of the glyphs in the font can be optimized based on expected
utilization, with the most frequently used glyphs appearing at the beginning of the font
file. Additionally, glyphs that are often used together should be grouped together in the
file. The will help to minimize the amount of swapping required when the font is loaded
into memory.

LTSH Table
This table improves the performance of OpenType fonts with TrueType outlines. The
table should be used if bit 2 or 4 of flags in 'head' is set.

'maxp' Table
All data required for a font with TrueType outlines. Fonts with CFF or CFF2 data must
only fill the numGlyphs field.

'name' Table
Platform and encoding IDs in the 'name' table should be consistent with those in the
'cmap' table. If they are not, the font will not load in Windows. When building a Unicode
font for Windows, the platform ID should be 3 and the encoding ID should be 1. When

building a symbol font for Windows, the platform ID should be 3 and the encoding ID
should be 0, and the referenced string data must be encoded in UTF-16.
Names for the Macintosh platform (platform ID 1) were required on Apple platforms,
but are no longer required on modern platforms. Some legacy software, however, may
require names platform ID 1, encoding ID 0.
Each set of name records should appear for US English (language ID = 0x0409 for
Microsoft records, language ID = 0 for Macintosh records); additional language strings
for the Microsoft set of records (platform ID 3) may be added at the discretion of the
font vendor.
Remember that, despite references to “first” and “second,” the name record must be
stored in sorted order (by platform ID, encoding ID, language ID, name ID). The 'name'
table platform/encoding IDs must match the 'cmap' table platform/encoding IDs, which
is how Windows knows which name set to use.

Name strings
We recommend using name IDs 8–12, to identify manufacturer, designer, description,
URL of the vendor, and URL of the designer. URLs must contain the protocol of the site
for example, http:// or mailto: or ftp://. The OpenType font properties extension can
enumerate this information to the users.
The Subfamily string in the 'name' table should be used for variants of weight (ultra light
to extra black) and style (oblique/italic or not). So, for example, the full font name of
“Helvetica Narrow Italic” should be defined as Family name “Helvetica Narrow” and
Subfamily “Italic”. This is so that Windows can group the standard four weights of a font
in a reasonable fashion for non-typographically aware applications which only support
combinations of “bold” and “italic.”
The Full font name string usually contains a concatenation of strings 1 and 2. If the font
is “Regular” as indicated in string 2, then sometimes only the family name contained in
string 1 is used for the full font name. In many contexts, the full font name is what will
be exposed to users.
In variable fonts, the Typographic Family and Typographic Subfamily names (name IDs
16 and 17) are required. Applications that support OpenType Font Variations will
typically present to users the Typographic Family name along with the Typographic
Subfamily name or alternative subfamily names for named instances, as specified in the
font variations ('fvar') table. In some situations, a font vendor may want to make
available a variable font as well as some set of non-variable fonts corresponding to the
named instances of the variable font. In such situations, the vendor may want to have

distinct family names for the family implemented as a variable font and the family
implemented using several non-variable fonts. In that case, a suggested convention is to
append “VF” at the end of the variable-font family name. Note, however, that this will
result in distinct families, and content formatted with the one may not display as
intended in some contexts if only the other is available. For example, if a document is
formatted using the regular and bold instances of a variable font with family name
“Selawik VF” and then the document is viewed in a context in which only the nonvariable fonts Selawik Regular and Selawik Bold are available, the viewing application
will generally not be able to associate the non-variable fonts available to it with the
formatting declarations in the content.
OpenType fonts that include a name with name ID of 6 should include these two names
with name ID 6, and characteristics as follows:
1. Platform: 1 [Macintosh]; Platform-specific encoding: 0 [Roman]; Language: 0
[English].
2. Platform: 3 [Windows]; Platform-specific encoding: 1 [Unicode]; Language: 0x409
[English (American)].
Names with name ID 6 other than the above two, if present, may be ignored.
When translated to ASCII, these two name strings must be identical and restricted to the
printable ASCII subset, codes 33 through 126, except for the 10 characters: '[', ']', '(', ')',
'{', '}', '<', '>', '/', '%'. Some implementations have a 63-character length limit; however, a
127-character length limit is recommended.
The term “PostScript Name” here means a string identical to the two identical name ID 6
strings described above.
Depending on the particular font format that PostScript language font uses, the
invocation method for the PostScript font differs, and the semantics of the resulting
PostScript language font differ. The method used to invoke this font depends on the
presence of Name ID 20.
If a Name ID 20 is present in this font, then the default assumption should be that the
PostScript Name defined by name ID 6 should be used with the PostScript
'composefont' invocation. This PostScript Name is then the name of a PostScript
language CIDFont resource which corresponds to the glyphs of the OpenType font. This
name is valid to pass, with an appropriate PostScript language CMap reference, and an
instance name, to the PostScript language 'composefont' operator.
If no Name ID 20 is present in this font, then the default assumption should be that the
PostScript Name defined by name ID 6 should be used with the PostScript 'findfont'
invocation, for locating the font in the context of a PostScript interpreter. This PostScript

Name is then the name of a PostScript language Font resource which corresponds to
the glyphs of the OpenType font. This name is valid to pass to the PostScript language
'findfont' operator. This does not necessarily imply that the resulting font dictionary
accepts an /Encoding array, such as when the font referenced is a Type 0 PostScript font.
This specification applies only to data fork OpenType fonts. Macintosh resource-fork
TrueType and other Macintosh sfnt-wrapped fonts supply the PostScript font name to be
used with the 'findfont' invocation, in order to invoke the font in a PostScript interpreter,
in the FOND resource style-mapping table.
Developers may choose to ignore the default usage when appropriate. For example,
PostScript printers whose version is earlier than 2015 cannot process CID font resources
and a CJK OpenType/CFF-CID font can be downloaded only as a set of Type 1 PostScript
fonts. Legacy CJK TrueType fonts, which do not have a Name ID 20, may still be most
effectively downloaded as a CID font resource. Definition of the full set of situations in
which the defaults should not be followed is outside the scope of this document.
The value held in the name ID 20 string is interpreted as a PostScript font name that is
meant to be used with the 'findfont' invocation, in order to invoke the font in a
PostScript interpreter.
If the name ID 20 is present in a font, there must be one name ID 20 record for every
Macintosh platform 'cmap' subtable in that font. A particular name ID 20 record is
associated with the encoding specified by the matching 'cmap' subtable. A name ID 20
record is matched to a 'cmap' subtable when they have the same platform and
platform-specific encoding IDs, and corresponding language/version IDs. Name ID 20
records are meant to be used only with Macintosh 'cmap' subtables. The version field
for a 'cmap' subtable is one more than the language ID value for the corresponding
name ID 20 record, with the exception of the 'cmap' subtable version field 0. This
version field, meaning “not language-specific”, corresponds to the language ID value
0xFFFF, or decimal 65535, for the corresponding name ID 20 record.
When translated to ASCII, this name string must be restricted to the printable ASCII
subset, codes 33 through 126, except for the 10 characters: '[', ']', '(', ')', '{', '}', '<', '>', '/',
'%'.
This specification applies only to data fork OpenType fonts. Macintosh resource-fork
TrueType and other Macintosh sfnt-wrapped fonts supply the PostScript font name to be
used with the 'findfont' invocation, in order to invoke the font in a PostScript interpreter,
in the FOND resource style-mapping table.
A particular Name ID 20 string always corresponds to a particular Macintosh 'cmap'
subtable. However, some host OpenType/TTF fonts also contain a 'post' table, format 4,

which provides a mapping from glyph ID to encoding value, and also corresponds to a
particular Macintosh 'cmap' subtable. Unfortunately, the 'post' table format 4 contains
no provision for identifying which Macintosh 'cmap' subtable it matches, nor for
providing more than one mapping. Host fonts which contain a 'post' table format 4,
should also contain only a single Macintosh 'cmap' subtable, and a single Name ID 20
string. In the case where there is more than one Macintosh 'cmap' subtable and more
than one Name ID 20 string, there is no definition of which one matches the 'post' table
format 4.

'OS/2' table
PANOSE values
PANOSE values may improve the user’s experience for font selection in some
applications or font management utilities.
If the font is a symbol font, the first byte of the PANOSE value must be set to “Latin
Pictorial” (value = 5). The PANOSE evaluation document is on-line at
https://monotype.github.io/panose/

.

In a variable font that uses OpenType Font Variation mechanisms, there is no way to
represent different PANOSE values for different instances supported by the font. The
PANOSE values can be set based on the default instance.

sTypoAscender, sTypoDescender and sTypoLineGap
The sTypoAscender, sTypoDescender and sTypoLineGap fields are used to specify the
recommended default line spacing for single-spaced horizontal text. The baseline-tobaseline distance is calculated as follows:
OS/2.sTypoAscender - OS/2.sTypoDescender + OS/2.sTypoLineGap
sTypoAscender should be used to determine an optimal default offset from the top of a
text frame to the first baseline. Similarly, sTypoDescender should be used to determine
an offset from the last baseline to the bottom of the text frame.
It is often appropriate to set the sTypoAscender and sTypoDescender values such that
the distance (sTypoAscender - sTypoDescender) is equal to one em. This is not a
requirement, however, and may not be suitable in some situations. For example, if a font
is designed for a script that (in horizontal layout) requires greater vertical extent relative
to Latin script but also needs to support Latin script, and needs to have the visual size of
Latin glyphs be similar to other fonts when set at the same text size, then the

(sTypoAscender - sTypoDescender) distance for that font would likely need to be greater
than one em.
The sTypoLineGap value will often be set such that the default baseline-to-baseline
distance is approximately 120% of the em. For example, in the Minion Pro font family,
fonts are designed on a 1000 units-per-em grid, the (sTypoAscender - sTypoDescender)
distance is one em, and the sTypoLineGap value is set to 200.
In CJK (Chinese, Japanese, and Korean) fonts, it is permissible for the sTypoDescender
and sTypoAscender fields to specify metrics different from the HorizAxis.ideo and
HorizAxis.idtp baselines in the BASE table. However, some applications may not read the
BASE table at all but simply use the sTypoDescender and sTypoAscender fields to
describe the bottom and top edges of the ideographic em-box. If developers want their
fonts to work correctly with such applications, they should ensure that any ideographic
em-box values in the BASE table describe the same bottom and top edges as the
sTypoDescender and sTypoAscender fields. See OpenType CJK Font Guidelines and
Ideographic Em-Box for more details.

usLowerOpticalPointSize and usUpperOpticalPointSize
Use of the usLowerOpticalPointSize and usUpperOpticalPointSize fields has been
superseded by the STAT table. See Families with Optical Size Variants, below, for more
information.

'post' Table
OpenType fonts containing CFF outlines use only format 3.0 of the 'post' table. When
devising glyph names, font developers may wish to consider conventions provided in
the Adobe Glyph List Specification , which specifies glyph naming conventions for all
Unicode characters as well as for glyphs not directly encoded as Unicode characters,
such as ligatures or glyphic variants.
Some applications might not implicitly support standard Macintosh glyph names. Any
glyph names should be provided explicitly in the font.

'prep' Table
Should be defined only if required by the TrueType font instructions.

VDMX Table

This table improves the performance of OpenType fonts with TrueType outlines. It
should be present if hints cause the font to scale non-linearly. If not present, the font is
assumed to scale linearly. Clipping may occur if values in this table are absent and font
exceeds linear height.

General Recommendations
OpenType Font Collections
The process of building TTC files involves paying close attention to the issue of glyph
renumbering in a font and the side effects that can result in the 'cmap' table and
elsewhere. For fonts with TrueType outlines, the fonts to be merged must also have
compatible TrueType instructions — i.e. their pre-programs, function definitions, and
control values must not conflict.

Optimized Table Ordering
OpenType fonts with TrueType outlines are more efficient in the Windows operating
system when the tables are ordered as follows (from first to last):
'head', 'hhea', 'maxp', OS/2, 'hmtx', LTSH, VDMX, 'hdmx', 'cmap', 'fpgm', 'prep', 'cvt ',
'loca', 'glyf', 'kern', 'name', 'post', 'gasp', PCLT, DSIG
The initial loading of an OpenType font containing CFF data will be more efficiently
handled if the following sfnt table ordering is used within the body of the sfnt (listed
from first to last):
'head', 'hhea', 'maxp', OS/2, 'name', 'cmap', 'post', 'CFF ', (other tables, as convenient)

Non-Standard (Symbol) Fonts
Non-standard fonts such as Symbol or Wingdings(tm) have special requirements for
Microsoft platforms. These requirements affect the 'cmap', 'name' and OS/2 tables; the
requirements and recommendations for all other tables remain the same.
For the Macintosh, non-standard fonts can continue to use platform ID 1 (Macintosh)
and encoding ID 0 (Roman character set). The 'cmap' subtable should use format 0 and
follow the standard PostScript character encodings.
For non-standard fonts on Microsoft platforms, however, the 'cmap' and 'name' tables
must use platform ID 3 (Microsoft) and encoding ID 0 (Unicode, non-standard character

set). Remember that 'name' table encodings should agree with the 'cmap' table.
Additionally, the first byte of the PANOSE value in the OS/2 table must be set to ‘Latin
Pictorial’ (value = 5).
The 'cmap' subtable (platform 3, encoding 0) must use format 4. The character codes
should start at 0xF000, which is in the Private Use Area of Unicode. It is suggested to
derive the format 4 encodings by simply adding 0xF000 to the format 0 (Macintosh)
encodings.
Under Windows, only the first 224 characters of non-standard fonts will be accessible: a
space and up to 223 printing characters. It does not matter where in user space these
start, but 0xF020 is suggested. The usFirstCharIndex and usLastCharIndex values in the
OS/2 table would be set based on the actual minimum and maximum character indices
used.

Baseline to Baseline Distances
The OS/2 table fields sTypoAscender, sTypoDescender, and sTypoLineGap free
applications from Macintosh- or Windows-specific metrics which are constrained by
backward compatibility requirements. See above for recommendations regarding those
values. The following discussion pertains to the platform-specific metrics.
In early TrueType implementations on Windows and Macintosh platforms, different font
values were used for line height metrics:
Macintosh: the ascender, descender and lineGap values in the 'hhea' table.
Windows GDI: the usWinAscent and usWinDescent values in the OS/2 table.
In the GDI TEXTMETRIC structure, metric values for TrueType fonts were set as follows:
ﾉ

Expand table

GDI metric

OpenType metric

tmHeight

usWinAscent - usWinDescent

tmAscent

usWinAscent

tmDescent

usWinDescent

tmInternalLeading

usWinAscent + usWinDescent - unitsPerEm

tmExternalLeading

MAX(0, (hhea.ascender - hhea.descender + hhea.lineGap) - (usWinAscent +
usWinDescent))

In addition, the usWinAscent and usWinDescent values were used to set a clip rectangle:
in on-screen display, any portions of glyphs extending beyond these limits could be
clipped.
In addition to these early platform implementations, different applications and textlayout engines (including newer Windows and Macintosh platforms) can use different
logic to determine a default baseline-to-baseline distance using the various metric fields
in the 'hhea' or OS/2 tables. This has made it challenging for font developers to create
fonts with predictable behavior when used in a wide range of applications. The following
recommendations might be useful to increase likelihood of consistent behavior in
different applications:
Set sTypoAscender and sTypoDescender such that (sTypoAscender sTypoDescender) = unitsPerEm.
Set the USE_TYPO_METRICS flag (bit 7) in the fsSelection field of the OS/2 table.
Set hhea.ascender = sTypoAscender, hhea.descender = sTypoDescender, and
hhea.lineGap = sTypoLineGap.
Set usWinAscent and usWinDescent such that (usWinAscent + usWinDescent) =
(sTypoAscender - sTypoDescender + sTypoLineGap).
The following is alternative guidance that might also be useful:
Set the USE_TYPO_METRICS flag (bit 7) in the fsSelection field of the OS/2 table.
Set hhea.ascender = usWinAscent = sTypoAscender.
Set hhea.descender = -usWinDescent = sTypoDescender.
Set hhea.lineGap and sTypoLineGap to 0.
With either guidance, if the font requires applications to use a larger clipping rectangle,
then usWinAscent and usWinDescent values can be set to larger values, though different
behavior will be seen in applications that set line spacing using sTypo* values (as
recommended) versus applications that set line spacing using the usWin* values.

Style Bits
For backwards compatibility with previous versions of Windows, the macStyle bits in the
'head' table will be used to determine whether or not a font is regular, bold or italic (in
the absence of an OS/2 table). This is completely independent of the usWeightClass and
PANOSE information in the OS/2 table, the ItalicAngle in the 'post' table, and all other
related metrics. If the OS/2 table is present, then the fsSelection bits are used to
determine this information.

Drop-out Control
Drop-out control is needed if there is a difference in bitmaps with dropout control on
and off. Two cases where drop-out control is needed are when the font is rotated or
when the size of the font is at or below 8 ppem. Do not use SCANCTRL unless needed.
SCANCTRL or the drop-out control rasterizer should be avoided for Roman fonts above
8 points per em (ppem) when the font is not under rotation. SCANCTRL should not be
used for “stretched” fonts (e.g. fonts displayed at non-square aspect ratios, like that
found on an EGA).

Embedded Bitmaps
Three tables are used to embed bitmaps in OpenType fonts. They are the EBLC table for
embedded bitmap locators, the EBDT table for embedded bitmap data, and the EBSC
table for embedded bitmap scaling information. OpenType embedded bitmaps are also
called “sbits”.
The behavior of sbits within an OpenType font is essentially transparent to the
application: an application need not be aware whether the bitmap returned by the
rasterizer comes from an sbit or from a scan-converted outline.
The metrics in 'sbit' tables overrule the outline metrics at all sizes where sbits are
defined. Fonts with 'hdmx' tables should correct those tables with 'sbit' values.
“Sbit-only” fonts, that is fonts with embedded bitmaps but without outline data, are
permitted. Care must be taken to ensure that all required OpenType tables except 'glyf'
and 'loca' are present in such a font. Obviously, such fonts will only be able to return
glyphs and sizes for which sbits are defined.
1. These metrics are returned as part of the logical font data structure by the GDI
CreateLogFont() API.
2. These metrics are returned by the Apple Advanced Typography (AAT) GetFontInfo()
API.

OpenType CJK Font Guidelines
This section provides a checklist of links to various CJK-related sections of the OpenType
specification. Some items are requirements; others, recommendations:
1. The ideographic em-box of an OpenType font will be determined as described in
the section Ideographic Em-Box in the Baseline Tags section of the OpenType

Layout Tag Registry. Also see the description for OS/2.sTypoAscender and
OS/2.sTypoDescender, and the BASE table recommendation section above.
2. CJK font vendors can choose to provide the ideographic character face (ICF)
metrics, which applications can use for accurate text alignment. This is described in
the section Ideographic Character Face in the Baseline Tags section of the
OpenType Layout Tag Registry.
3. All OpenType fonts that are used for vertical writing must include a Vertical Header
('vhea') table and a Vertical Metrics ('vmtx') table. It is strongly recommended that
CFF OpenType fonts that are used for vertical writing include a Vertical Origin
(VORG) table.
4. If an OpenType font with CFF outlines is to be used for vertical layout, some legacy
platforms may require that a Vertical Rotation ('vrt2') feature be present in the
Glyph Substitution (GSUB) table. See the Feature Tags section of the OpenType
Layout Tag Registry for a description of and further requirements for this feature.
5. See the Feature Tags section of the OpenType Layout Tag Registry for descriptions
of currently registered OpenType layout features, such as Alternate Half Widths
('halt') and Traditional Forms ('trad'), that can be specified in the font.

Stroke Reduction in Variable Fonts
When designing a font family to support a number of variations, there may be cases in
which it is desirable to make significant, structural changes to particular glyphs for
certain variations. A common example is stroke reduction for heavier weights or
narrower widths, simplifying the structure of a glyph so that counters do not become
filled and disappear at smaller text sizes. Within a variable font, two techniques might be
used to implement a stroke-reduction effect:
Use a pair of slightly overlapping intermediate regions within the variation data for
a glyph in order to introduce deltas for particular contour points that result in the
desired structural change and that apply for only problem ranges on one or more
axes.
Use an OpenType Layout Required Variation Alternates feature in combination with
a FeatureVariations table within the GSUB table to perform a glyph substitution
when a variation instance is selected in some range along one or more axes.
While both techniques are possible, it should be noted that the first technique, using
overlapping intermediate-regions, can be tricky to implement and may result in
unexpected or undesired results if an instance is selected using arbitrary axis values in
the range over which the transition occurs. The second technique is recommended as it
will generally be easier to implement and maintain, and provides the font designer with
better control over behavior near the point of transition.

Families with Optical Size Variants
In families that have fonts for different optical sizes or in variable fonts that support the
optical size ('opsz') design axis, a STAT table with format 2 axis value tables should be
used to indicate text size ranges for which the different optical-size variants or variablefont named instances are recommended. This supersedes the use of the
usLowerOpticalPointSize and usUpperOpticalPointSize fields in the OS/2 table, and the
OpenType Layout 'size' feature.
When creating an axis value table to correspond to the font or named instance that is
intended for the largest text sizes, the upper text size limit should be, effectively, infinity.
To represent this in a format 2 axis value table, set the rangeMaxValue to 0x7FFFFFFF.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

TrueType Fundamentals
Article • 05/30/2024

OpenType supports the TrueType glyph outline format, in which a glyph outline is
described as second-order Bezier splines. When outlines are rasterized, TrueType
“hinting” instructions contained in a font can be used to refine the rasterized results. In
particular, the TrueType instruction set provides a powerful means of controlling glyph
outlines at all or specific sizes and resolutions.
This chapter introduces the basic concepts needed to create and instruct an OpenType
font that contains TrueType outline data. It begins with an overview of the steps involved
in taking a design from paper to the creation of a bitmap that can be sent to an output
device and follows with a closer look at each of the steps in the process.
This chapter includes an introduction to TrueType instructions and how they are
interpreted. Other chapters provide in-depth details:
Instructing TrueType Glyphs
The TrueType Instruction Set
Graphics State Summary
In the remainder of this chapter, “TrueType font” will be used to mean OpenType fonts
that have TrueType glyph outlines.

From design to font file
A TrueType font can originate as a new design drawn on paper or created on a
computer screen. TrueType fonts can also be obtained by converting fonts from other
formats. Whatever the case, it is necessary to create a TrueType font file that, among
other things, describes each glyph in the font as an outline in the TrueType format.

From Font File to Paper

This section describes the process that allows glyphs from a TrueType font file to be
displayed on raster devices.
First, the outline stored in the font file is scaled to the requested size. Once scaled, the
points that make up the outline are no longer recorded in the font units (FUnits) used to
describe the original outline, but have become device-specific pixel coordinates.
Next, the instructions associated with this glyph are carried out by the interpreter. The
result of carrying out the instructions is a grid-fitted outline for the requested glyph.
This outline is then scan-converted to produce a bitmap that can be rendered on the
target device.

1. Digitize outline with FUnit coordinates in TrueType font file
2. Scaler converts FUnits to pixel coordinates and scales outline to size requested by
application
3. Outline “sized” to new grid
4. Scaled outline with pixel coordinates
5. Interpreter executes instructions associated with glyph “B” and grid-fits
6. Grid-fitted outline
7. Grid-fitted outline
8. Scan converter decides which pixels to turn on
9. Bitmap is rendered on raster device

Digitizing a Design

This section describes the coordinate system used to establish the locations of the
points that define a glyph outline. It also documents the placement of glyphs with
respect to the coordinate axes.

Outlines
In a TrueType font, glyph shapes are described by their outlines. A glyph outline consists
of a series of contours. A simple glyph may have only one contour. More complex
glyphs can have two or more contours. Composite glyphs can be constructed by
combining two or more simpler glyphs. Certain control characters that have no visible
manifestation will map to the glyph with no contours.

Figure 1-1 Glyphs with one, two, three contours respectively
Contours are composed of straight lines and curves. Curves are defined by a series of
points that describe second-order Bezier-splines. The TrueType Bezier-­spline format uses
two types of points to define curves, those that are on the curve and those that are off
the curve. Any combination of off and on curve points is acceptable when defining a
curve. Straight lines are defined by two consecutive on curve points.

Figure 1-2 A glyph description consisting of a series of on and off curve points
The points that make up a curve must be numbered in consecutive order. It makes a
difference whether the order is increasing or decreasing in determining the fill pattern of
the shapes that make up the glyph. The direction of the curves has to be such that, if the
curve is followed in the direction of increasing point numbers, the black space (the filled
area) will always be to the right.

FUnits and the em square
In a TrueType font file point locations are described in font units, or FUnits. An FUnit is
the smallest measurable unit in the em square, an imaginary square that is used to size
and align glyphs. The dimensions of the em square typically are those of the full body
height of a font plus some extra spacing to prevent lines of text from colliding when
typeset without extra leading.

While in the days of metal type, glyphs could not extend beyond the em square, digital
typefaces are not so constrained. The em square may be made large enough to
completely contain all glyphs, including accented glyphs. Or, if it proves convenient,
portions of glyphs may extend outside the em square. TrueType fonts can handle either
approach, so the choice is that of the font manufacturer.

Figure 1-3 A character that extends outside of the em square
The em square defines a two-dimensional coordinate grid whose x-axis describes
movement in a horizontal direction and whose y-axis describes movement in a vertical
direction. This is discussed in more detail in the following section.

FUnits and the grid
A key decision in digitizing a font is determining the resolution at which the points that
make up glyph outlines will be described. The points represent locations in a grid whose
smallest addressable unit is known as an FUnit or font Unit. The grid is a twodimensional coordinate system whose x-axis describes movement in a horizontal
direction and whose y-axis describes movement in a vertical direction. The grid origin
has the coordinates (0,0). The grid is not an infinite plane. Each point must be within the
range -16384 and +16383 FUnits. Depending upon the resolution chosen, the range of
addressable grid locations will be smaller.

The choice of the granularity of the coordinate grid—that is, number of units per em
(upem)—is made by the font manufacturer. Outline scaling will be fastest if units per em
is chosen to be a power of 2, such as 2048.

Figure 1-4 The coordinate system
Note: The number of units per em is always the same in both x and y directions.
The origin of the em square need not have any consistent relationship to the glyph
outlines. In practice, however, applications depend upon the existence of some
convention for the placement of glyphs for a given font. For Roman fonts, which are
intended to be laid out horizontally, a y-coordinate value of 0 typically is assumed to
correspond to the baseline of the font; this is indicated explicitly in a font using bit 0 of
the flags field of the font’s 'head' table. No particular meaning is assigned to an x-­‐
coordinate of 0 but manufacturers may improve the performance of applications by
choosing a standard meaning for the x o
­ rigin.
As a general term, left side bearing refers to the relationship along the x-axis between
the initial pen position and the leftmost extreme outline point. The left side bearing point
is a virtual outline point (see “Phantom points”) that corresponds to the initial pen
position. The 'hmtx' table provides a left side bearing value for each glyph that provides
the x-coordinate difference between the left side bearing point and the leftmost
extreme outline point. This allows an application to determine the x-axis relationship of
the em square origin and the pen position. To improve performance, bit 1 of the flags
field of the 'head' table can be set to indicate that the left side bearing point is at x = 0
for all glyphs, though this is not required.
For example, you might place a glyph so that its aesthetic center is at the x-­coordinate
value of 0. That is, a set of glyphs so designed when placed in a column such that their
x-­coordinate values of 0 are coincident will appear to be nicely centered. This option

would be used for Kanji or any fonts that are typeset vertically. Another alternative is to
place each glyph so that its leftmost extreme outline point has an x-value equal to the
left side bearing of the glyph. Fonts created in this way may allow some applications to
print more quickly to PostScript printers.

Figure 1-5 Two possible choices for the glyph origin in a Roman font. In the first case
(left) the left side bearing is x-zero. In the second (right), the aesthetic center of the
character is x-zero
In fonts for different scripts, various conventions might be preferred for the meaning of
the x o
­ rigin and y o
­ rigin. For best results with high-lighting and carets, the body of the
character should be roughly centered within the advance width. For example, a
symmetrical character would have equal left and right side bearings.
The granularity of the em square is determined by the number of FUnits per em, or
more simply units per em. The em square as divided into FUnits defines a coordinate
system with one unit equaling an FUnit. All points defined in this coordinate system
must have integral locations. The greater the number of units per em, the greater the
precision available in addressing locations within the em square.

Figure 1-6 Two em squares, 8 units per em (left), 16 units per em (right)
FUnits are relative units because they vary in size as the size of the em square changes.
The number of units per em remains constant for a given font regardless of the point
size. The number of points per em, however, will vary with the point size of a glyph. An
em square is exactly 9 points high when a glyph is displayed at 9 points, exactly 10

points high when the font is displayed at 10 points, and so on. Since the number of units
per em does not vary with the point size at which the font is displayed, the absolute size
of an FUnit varies as the point size varies.

Figure 1-7 72-point M and 127-point M and their em squares. Upem equals 8 in both
cases.
Because FUnits are relative to the em square, a given location on a glyph will have the
same coordinate location in FUnits regardless of the point size at which the font is
rendered. This is convenient because it makes it possible to instruct outline points once
considering only the original outline and have the changes apply to the glyph at
whatever size and resolution it is ultimately rendered.

Scaling a glyph
This section describes how glyph outlines are scaled from the master size stored in the
font file to the size requested by an application.

Device space
Whatever the resolution of the em square used to define a glyph outline, before that
glyph can be displayed it must be scaled to reflect the size, transformation and the
characteristics of the output device on which it is to be displayed. The scaled outline
must describe the character outline in units that reflect an absolute rather than relative
system of measurement. In this case the points that make up a glyph outline are
described in terms of pixels.
Intuitively, pixels are the actual output bits that will appear on screen or printer. To allow
for greater precision in managing outlines, TrueType describes pixel coordinates to the
nearest sixty-fourth of a pixel.

Converting FUnits to pixels

Values in the em square are converted to values in the pixel coordinate system by
multiplying them by a scale. This scale is:
pointSize * resolution / ( 72 points per inch * units_per_em )
where pointSize is the size at which the glyph is to be displayed, and resolution is the
resolution (dots or pixels per inch) of the output device. The 72 in the denominator
reflects the number of points per inch.
For example, assume that a glyph feature is 550 FUnits in length on a 72-dpi screen at
18 point. Also assume that there are 2048 units per em. The following calculation reveals
that the feature is 4.83 pixels long.
550 * 18 * 72 / ( 72 * 2048 ) = 4.83

Display device characteristics
The resolution of any particular display device is specified by the number of dots or
pixels per inch (dpi) that are displayed. For example, a VGA display under Windows is
treated as a 96-dpi device, and most laser printers have a resolution of 300 dpi or
higher. Some devices may have different resolution in the horizontal and vertical
directions (i.e. non-square pixels); for example, legacy EGA displays had a resolution of
96 dpi x 72 dpi. In such cases, horizontal dots per inch must be distinguished from
vertical dots per inch.
The number of pixels per em is dependent on the resolution of the output device. An
18-point character will have 18 pixels per em on a 72-dpi device. Change the device
resolution to 300 dpi and it has 75 pixels per em, or change to 1200 dpi and it has 300
pixels per em.

Figure 1-8 18-point figure 8 at 72 dpi, 300 dpi and 1200 dpi

Displaying type on a particular device at a specific point size yields an effective
resolution measured in pixels per em (ppem). The formula for calculating pixels per em
is:
ppem = pointSize * dpi / 72
= (pixels per inch) * (inches per pica point) * (pica points per em)
On a 300-dpi laser printer, a 12-point glyph would have 12*300/72 or 50 ppem. On a
typesetter with 2400 dpi, it would have 12*2400/72 or 400 ppem. On a VGA display, a
12-point glyph would have 12*96/72 or 16 ppem. Similarly, the ppem for a 12-point
character on a 72-dpi device would be 12*72/72, or 12. This last calculation points to a
useful rule of thumb: on any 72-dpi device, points and pixels per em are equal.
Note: In digital typography, an inch contains exactly 72 points. In traditional
typography, however, an inch contains 72.2752 points (rather than 72); that is, one
point equals .013836 inches.
If you know the ppem, the formula to convert between FUnits and pixel space
coordinates is:
pixel_coordinate = em_coordinate * ppem / upem
An em_coordinate position of (1024, 0) would yield a device_pixels coordinate of (6, 0),
given 2048 units per em and 12 pixels per em.

Grid-fitting a glyph outline
The fundamental task of instructing a glyph is one of identifying the critical
characteristics of the original design and using instructions to ensure that those
characteristics will be preserved when the glyph is rendered at different sizes on
different devices. Consistent stem weights, consistent color, even spacing, and the
elimination of pixel dropouts are common goals.
To accomplish these goals, it is necessary to ensure that the correct pixels are turned on
when a glyph is rasterized. It is the pixels that are turned on that create the bitmap
image of the glyph. Since it is the shape of the glyph outline that determines which
pixels will make up the bitmap image of that character at a given size, it is sometimes
necessary to change or distort the original outline description to produce a high-quality
image. This distortion of the outline is known as grid-fitting.
The figure below illustrates how grid-fitting a character distorts the outline found in the
original design.

Figure 1-9 12-point outlines un-grid-fitted (left) and grid-fitted (right)
As the illustration above suggests, the grid-fitting employed in TrueType goes well
beyond aligning a glyph’s left side bearing to the pixel grid. This sophisticated gridfitting is guided by instructions. The beneficial effects of grid-fitting are illustrated in the
next figure.

Figure 1-10 12-point outlines and bitmap un-grid-fitted (left) and grid-fitted (right)
Grid-fitting is the process of stretching the outline of a glyph according to the
instructions associated with it. Once a glyph is grid-fitted, the point numbers will be
unchanged but the actual location of that point in the coordinate grid may have shifted.
That is, the coordinates for a given point number will, very likely, have changed after a
glyph is grid-fitted.

What are instructions?
The TrueType instruction set provides a large number of commands designed to allow
designers to specify how character features should be rendered. Instructions are the
mechanism by which the design of a character is preserved when it is scaled. In other
words, instructions control the way in which a glyph outline will be grid-fitted for a
particular size or device.
Instructing a glyph will reshape the outline at a specific size on a given target device in
such a way that the correct pixels are included within its outline. Reshaping the outline
means moving outline points. Points that have been acted upon by an instruction are
said to have been touched. Note that a point need not actually be moved to be
touched. It must simply be acted upon by an instruction. (See the MDAP instruction, for
example.)

TrueType fonts can be used with or without instructions. Uninstructed fonts will
generally produce good quality results at sufficiently high resolutions and point sizes.
The range of sizes over which an uninstructed font will produce good quality results
depends not only on the output device resolution and point size of the character but
also on the particular font design. The intended use of the font can also be a factor in
determining whether or not a particular font should be instructed. For most fonts, if
legibility of small point sizes on low resolution devices is important, adding instructions
will be critical.
Instructing a font is a process that involves analyzing the key elements of a glyph’s
design and using the TrueType instruction set to ensure that they are preserved. The
instructions are flexible enough to allow characteristics that are roughly the same to be
“homogenized” at small sizes while allowing the full flavor of the original design to
emerge at sizes where there are sufficiently many pixels.
How does the TrueType interpreter know the manner in which an outline should be
distorted to produce a desirable result? This information is contained in instructions
attached to each glyph in the font. Instructions specify aspects of a glyph’s design that
are to be preserved as it is scaled. For example, using instructions it is possible to
control the height of an individual glyph or of all the glyphs in a font. You can also
preserve the relationship between design elements within a glyph thereby ensuring, for
example, that the widths of the three vertical stems in the lowercase m will not differ
dramatically at small sizes.
The following figure illustrates how changing a glyph’s outline at a specific size will yield
a superior result. They show that an uninstructed 9-point Arial lowercase m suffers the
loss of a stem due to chance effects in the relationship of stems to pixel centers. In the
second glyph, instructions have aligned the stems to the grid so that the glyph suffers
no similar loss.

Figure 1-11 9-point Arial m-uninstructed (left), instructed (right)

The TrueType interpreter
This section describes the actions of the TrueType interpreter. It is the interpreter, as the
name suggests, that “interprets” or carries out the instructions.
More concretely, the interpreter processes a stream or sequence of instructions.
Typically, these instructions take their arguments from the interpreter stack and place
their results on that stack. The only exceptions are a small number of instructions that
are used to push data onto the interpreter stack. These instructions take their arguments
from the instruction stream.
All of the interpreter’s actions are carried on in the context of the Graphics State, a set of
variables whose values guide the actions of the interpreter and determine the exact
effect of a particular instruction. See The Graphics State, below, for more information.
The interpreter’s actions can be summarized as follows:
1. The interpreter fetches an instruction from the instruction stream, an ordered
sequence of instruction opcodes and data. Opcodes are 1-byte in size. Data can
consist of a single byte or two bytes (a word). If an instruction takes words from
the instruction stream it will create those words by putting together two bytes.
Words are in big-endian order: the high byte appears first in the instruction stream
and the low byte appears second.
The following instruction stream is depicted as it will be shown in the examples
that follow. Note that the pointer indicates the next instruction to be executed.

2. The instruction is executed
If it is a push instruction it will take its arguments from the instruction stream.

Any other instruction will pop any data it needs from the stack. A pop is
illustrated below.

Any data the instruction produces is pushed onto the interpreter stack. A
push is illustrated below.

As the previous discussion indicates, the interpreter stack is a LIFO or last in
first out data structure. An instruction takes any data it needs from the last
item placed on the stack. The action of removing the top item from the stack
is commonly termed a pop. When an instruction produces some result, it
pushes that result to the top of the stack where it is potential input to the
next instruction.
The instruction set includes a full range of operators for manipulating the
stack including operators for pushing items onto the stack, popping items
from the stack, clearing the stack, duplicating stack elements and so forth.
The effect of execution depends on the values of the variables that make up
the Graphics State.
The instruction may modify one or more Graphics State variables. In the
illustration shown, the Graphics State variable rp0 is updated using a value
taken from the interpreter stack.

3.The process is repeated until there are no further instructions to be executed.

Using instructions
Instructions can appear in a number of places in the font file tables that make up a
TrueType font. They can appear as part of the font program, the control value program,
or as glyph data. Instructions appearing in the first two apply to the font as a whole.
Those found in glyph data (the 'glyf' table) apply to individual glyphs within a font.

The interpreter stack is cleared for each run of a font program, control value program, or
glyph program.

The font program
The font program is stored in the 'fpgm' table of a font and consists of a set of
instructions that is executed once, the first time a font is accessed by an application. It is
used to create function definitions (FDEFs) and instruction definitions (IDEFs). Functions
and instructions defined in the font program may be used in the control value program
or in glyph programs. Functions and instructions defined in the font program may also
be re-defined in the control value program.

The control value program
The control value program is stored in the 'prep' table of a font and consists of a set of
instructions executed every time the pixels per em in x or y direction changes or the
transformation changes. It is used to make font wide changes in the Control Value Table
rather than to manage individual glyphs.
The Control Value Table, or CVT, is a numbered list of values used to simplify the task of
maintaining consistency across glyphs when instructing a font. The CVT is initialized
from the font’s 'cvt ' table, and then managed using instructions in the control value
program. (See Managing the Control Value Table.) Entries in the CVT can be referenced
by either of two indirect instructions (MIRP and MIAP). CVT entries can be used to store
values that need to be the same across a number of glyphs in a font. For example, an
instruction might refer to a CVT entry whose purpose is to regularize stem weights
across a font.
ﾉ

Expand table

FIGURE 1-12 SOME SAMPLE CVT ENTRIES

Entry #

Value

Description

0

0

uppercase and lowercase flat base(base line)

1

-39

uppercase round base

2

-35

lowercase round base

3

-33

figure round base

4

1082

x-height flat

5

1114

x-height round overlap

6

1493

flat cap

7

1522

round cap

8

1463

numbers flat

9

1491

numbers round top

10

1493

flat ascender

11

1514

round ascender

12

157

x stem weight

13

127

y stem weight

14

57

serif

15

83

space between the dot and the I

Instructions that refer to values in the CVT are called indirect instructions as opposed to
the direct instructions which take their values from the glyph outline.
As part of the TrueType font file, the values in the CVT are expressed in FUnits. When the
outlines are converted from FUnits to pixel units, values in the CVT are also converted.
When writing to the CVT you may use a value that is in the glyph coordinate system
(using WCVTP) or you can use a value that is in the original FUnits (using WCVTF). The
interpreter will scale all values appropriately. Values read from the CVT are always in
pixels (F26Dot6).
The control value program may also be used to set Graphics State variables (see The
Graphics State below.) The control value program can determine whether such changes
to Graphics State variables will be visible to glyph programs using the INSTCTRL
instruction.
The control value program may also be used to define functions or instructions, or to redefine functions or instructions defined in the Font Program. The most recent definition
of a given function or instruction is used in subsequent glyph programs. If a function or
instruction is first defined in a Font Program, later re-defined in the control value
program, but not re-defined again when the control value program is run on another
size or transform change, the re-definition from the earlier control value program run is
used.

Every time the control value program is run, the zone 0 (the “twilight zone”) contour
data is initialized to 0s. (See Zones in the Instructing TrueType Glyphs chapter for details
regarding zone 0.)

The Storage Area
The interpreter also maintains a Storage Area consisting of a portion of memory that
can be used for temporary storage of data from the interpreter stack. Values can be
written in the storage area by the font program, the control value program, or glyph
programs. Values written by the font program can be used in the control value program
or glyph programs. Similarly, values written in the control value program can be used in
glyph programs. See Glyph programs and persistence regarding values written in glyph
programs. Instructions exist that make it possible to read the values of stored data and
to write new values to storage. Storage locations range from 0 to n-1 where n is the
value established in the maxStorage entry in the maxProfile table of the font file. Values
are 32-bit numbers.
ﾉ

Expand table

F I G U R E 1 - 1 3 S O M E S TO R AG E A R E A E N T R I E S

Address

Value

0

343

1

241

2

-27

3

4654

4

125

5

11

The Graphics State
The Graphics State consists of a table of variables and their values. All instructions act
within the context of the Graphics State. Graphics State variables have default values as
specified in Graphics State Summary. Their values can be determined or changed using
instructions.

The Graphics State establishes the context within which all glyphs are interpreted. All
Graphics State variables have a default value. Some of these values can be changed in
the CVT Program if desired. Whatever the default value, it will be reestablished at the
start of interpretation of any glyph. In other words, the Graphics State has no inter-glyph
memory. Changing the value of a Graphics State variable while processing an individual
glyph will result in a change that remains in effect only for that glyph.

Glyph programs and persistence
Glyph programs may write values in the storage area or the CVT. Implementations may
persist storage or CVT values set in a glyph program after the glyph program has ended,
allowing those values to be used in other glyph programs, or (for storage values only) in
subsequent runs of the control value program. Implementations may also opt not to do
this; that is, when a glyph program ends, implementations may reset storage and CVT
variables to their earlier values before that glyph program was run. Also note that
implementations can cache the results after a glyph program is run. For these reasons,
font developers should not assume that values set when a glyph program is run can be
used to affect glyphs that are subsequently displayed by an application (for example, to
simulate gradual degradation of a typewriter ribbon).
A glyph program may change contour data in zone 0 (the “twilight zone”). These values
should always persist until the next time the control value program is run.
Composite glyphs require special consideration in this regard. When a composite glyph
is processed, implementations should process component glyphs, including running
their glyph programs, rather than relying on previously cached results for the
component glyphs. Also, storage and CVT values in the glyph program of a component
glyph should be available to the composite glyph program, even if the implementation
does not otherwise persist these values after the glyph program is run when the glyph is
used alone as a simple glyph.

The scan converter
The TrueType scan converter takes an outline description of a glyph and produces a
bitmap image for that glyph.
The TrueType scan converter offers two modes: with or without dropout control, which is
described below. In the mode without dropout control, the scan converter uses a simple
algorithm for determining which pixels are part of that glyph. The rules can be stated as
follows:

Rule 1
If a pixel’s center falls within the glyph outline, that pixel is turned on and becomes part of
that glyph.
Rule 2
If a contour falls exactly on a pixel’s center, that pixel is turned on.
A point is considered to be an interior point of a glyph if it has a non-zero winding
number. The winding number is itself determined by drawing a ray from the point in
question toward infinity. (The direction in which the ray points in unimportant.) Starting
with a count of zero, we subtract one each time a glyph contour crosses the ray from
right to left or bottom to top. Such a crossing is termed an on transition. We add one
each time a contour of the glyph crossed the ray from left to right or top to bottom.
Such a crossing is termed an off transition. If the final count is non-zero, the point is an
interior point.
The direction of a contour can be determined by looking at the point numbers. The
direction is always from lower point number toward higher point number.
The illustration that follows demonstrates the use of winding numbers in determining
whether a point is inside a glyph. The point p1 undergoes a sequence of four transitions
(on transition, off transition, on transition, off transition). Since the sequence is even, the
winding number is zero and the point is not inside the glyph. The second point, p2,
undergoes an off transition followed by an on transition followed by an off transition
yielding a winding number of +1. The point is in the interior of the glyph.

Figure 1-14 Determining the winding number of a point

What is a dropout?
A dropout occurs whenever there is a connected region of a glyph interior that contains
two black pixels that cannot be connected by a straight line that only passes through
black pixels.

Figure 1-15 The letter m with two dropouts

Preventing dropouts
The TrueType instructions are designed to allow you to grid-fit a glyph so that the
desired pixels will be turned on by the simple scan converter regardless of the point size
or the transformation used. It may prove difficult to foresee all possible transformations
that a glyph might undergo. It is therefore difficult to instruct a glyph to ensure that the
proper grid-fitting distortion of the outline will take place for every desired
transformation. This problem is especially difficult for very small numbers of pixels per
em and for complex typefaces. In these situations, some renditions of a glyph may
contain dropouts.
It is possible to test for potential dropouts by looking at an imaginary line segment
connecting two adjacent pixel centers. If this line segment is intersected by both an onTransition contour and an off-Transition contour, a potential dropout condition exists.
The potential dropout only becomes an actual dropout if the two contour lines continue
on in both directions to cut other line segments between adjacent pixel centers. If the
two contours join together immediately after crossing a scan line (forming a stub), a
dropout does not occur, although a stem of the glyph may become shorter than
desired.
To prevent dropouts, type manufacturers can choose to have the scan converter use two
additional rules:
Rule 3
If a scan line between two adjacent pixel centers (either vertical or horizontal) is
intersected by both an on-Transition contour and an off-Transition contour and neither of

the pixels was already turned on by rules 1 and 2, turn on the left-most pixel (horizontal
scan line) or the bottom-most pixel (vertical scan line)
Rule 4
Apply Rule 3 only if the two contours continue to intersect other scan lines in both
directions. That is do not turn on pixels for “stubs”. The scanline segments that form a
square with the intersected scan line segment are examined to verify that they are
intersected by two contours. It is possible that these could be different contours than the
ones intersecting the dropout scan line segment. This is very unlikely but may have to be
controlled with grid-fitting in some exotic glyphs.
The type manufacturer can choose to use the simple scan converter employing rules 1
and 2 only or may optionally invoke either rule 3 or rule 4. The decision about which
scan converter mode to use is controlled using the SCANCTRL instruction. It can be
made on a font-wide basis, or a different choice can be specified for each glyph. The
selection made in the control value program will be the default for the entire font. A
change made to the default in the instructions for an individual glyph will apply only to
that glyph.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

Instructing TrueType Glyphs
Article • 05/30/2024

This chapter gives an overview of the fundamental tasks involved in instructing a glyph.

Choosing a scan conversion setting
One of the key decisions to be made in instructing a TrueType font is the choice of scan
conversion mode. Font designers can choose between a fast scan conversion mode and
a dropout control scan conversion mode. This choice is made by setting the value of the
Graphics State variable scan_control. The interpreter considers each of three conditions
in determining whether dropout control mode will be used:
Is the glyph rotated?
Is the glyph stretched?
Is the current setting for ppem less than a specified ppem value?
It is also possible to turn dropout control off completely.

Controlling rounding
The TrueType interpreter uses the round_state to determine the manner in which values
will be rounded. Instructions are used to set the value of the round_state, a Graphics
State variable. The setting of round_state determines how values will be rounded by the
interpreter.
The instruction set makes it easy to set a number of predefined round states that will
round values to the grid, pixel centers (half grid), or to either the grid or pixel centers. It
is also possible to specify whether values should be rounded down or rounded up. If
none of the predefined rounding options suffices, the SROUND instructions provide very
fine control of the rounding of values, making it possible to choose a phase, threshold,
and period for the rounding function. The S45ROUND allows the same fine control as
SROUND but is used when movement is along a 45 degree axis with the x-y plane.
A number of instructions round the value they obtain before moving any points. The
effect of using any of the MDRP, MIRP, MIAP, MDAP, or ROUND instructions depends
on the value of the round_state graphics state variable along with that of the
control_value_cut_in. The ROFF instruction turns off rounding but allows the instruction
to continue looking at the cut-in value.

Points
Outline points are specified by their location in the coordinate grid and by whether they
are on or off curve points. Managing a point means managing its position in space and
its status as an on or off curve point. The interpreter uses zones and reference points to
manage the set of points that comprise the current glyph and to refer to specific points
within that set.

Zones
Any point the font scaler interpreter references is in one of two zones, that is one of two
sets of points that potentially make up a glyph description. The first of these referenced
zones is zone 1 (Z1) and always contains the glyph currently being interpreted.
The second, zone 0 (Z0), is used for temporary storage of point coordinates that do not
correspond to any actual points in the glyph in zone 1. Zone 0 is useful when there is a
need to manipulate a point that does not exist on the glyph or if you need to remember
an intermediate point position. (This is the twilight zone.)
The profile table establishes the maximum number of twilight points. These are numbers
0 through maxTwilightPoints -1 and are all set to the origin. These points can be moved
in the same manner as any of the points in zone 1.
Points in zone 0 are moved to useful positions by using the MIAP and MIRP instructions
and setting gep0 to point to Z0. Frequently, it is useful to set points in Z0 to key metric
positions for the font.

Zone pointers
Three zone pointers, gep0, gep1 and gep2 are used to reference either zone 0 or zone 1.
Initially, all three zone pointers will point to zone 1.

Figure 2–1 gep0 and gep1 point to zone 1 (the current glyph), gep2 points to zone 0
(the twilight zone)

Reference points
Zone pointers provide access to a group of points. Reference points provide access to
specific points within the group. The interpreter uses three numbered reference points:
rp0, rp1, and rp2. Each can be set to a number corresponding to any of the outline
points in the glyph in zone 1 or any of the points in zone 0.
As shown in the following figure, two different reference points can refer to the same
outline point.

Figure 2–2 A glyph pointed to by all three reference points
Collectively the zone pointers and reference points belong to the Graphics State. Their
values can be altered using instructions. Many TrueType instructions rely on the graphics
zone pointers and the reference points to fully specify their actions.

Phantom points
The Microsoft rasterizer v.1.7 or later will always add four “phantom points” to the end
of every outline to allow either widths or heights to be controlled. (MS rasterizers earlier
than v.1.7 only add two phantom points, allowing only widths to be controlled.)
If the entire set of contours for a glyph requires “n” points (i.e., contour points
numbered from 0 to n-1), then the scaler will add points n, n+1, n+2, and n+3. Point “n”
will be placed at the glyph left sidebearing point; point “n+1” will be placed at the
advance width point; point “n+2” will be placed at the top origin; and point “n+3” will
be placed at the advance height point. For an illustration of how these phantom points
are placed, see Figure 2-1 (points 17, 18, 19, 20) and Figure 2-2 (points 27, 28, 29, and
30).
All four phantom points may be controlled by TrueType instructions, with corresponding
effects on the sidebearings, advance width, and advance height (in the case of vertical
positioning) of the instructed glyph. The side bearings, advance width, and advance
height are computed using these phantom points and are called the device-specific
widths and heights (since they reflect the results of grid fitting the width or height along
with the glyph to the characteristics of the device). The device-specific widths or heights
can be different from or identical to the linearly scaled widths or heights (obtained by

simple scaling operations), depending on the instructions applied to the phantom
points.
Before applying a TrueType instruction on height related phantom points (n+2 and n+3),
use GETINFO[ ] to check that the rasterizer is a MS rasterizer v.1.7 or later.

Determining distances
At the lowest level, instructing a glyph means managing the distances between points.
The first step in managing a distance is often one of determining its magnitude. For
example, the first step in setting up the Control Value Table involves measuring the
distances between key points in a font. Measuring the distance between two points in a
glyph outline, while not difficult, must take certain factors into account.
All distance measurements are made parallel to the projection_vector, a unit vector
whose direction will be indicated by a radius of a circle. Distances are projected onto
this vector and measured along it. Distances have a direction that reflects the direction
of the vector. Measurements can refer to the distance between points in the original
character outline or between points in the grid-fitted outline. The instruction that
measures distances (MD) takes a Boolean value which determines whether distances will
be measured on the original outline or in the grid-fitted outline.
Additionally, the TrueType interpreter distinguishes between three different types of
distances: black, white, and grey. Certain instructions (MDRP, MIRP, ROUND) require that
you specify a distance type.
Black distances cross only black areas; white distances, white areas; and grey distances a
combination of the two. In the following illustration, examples of black, white, and grey
distances are shown. The distance [2,1] is black; [3,0] is grey and [4,6] is white.

Figure 2–3 White, black and grey distances
The distance type is used in determining how the ROUND and instructions that use the
round_state will work with different output devices. For gray distances, rounding is
unaffected. Black or white distances, however, require a compensation term be added or
subtracted before rounding takes place. The amount of compensation needed will be
set by the device driver. For example, if a printing engine has large pixels, the interpreter
will compensate by shrinking black distances and growing white distances. Gray
distances, because they combine black and white distances, will not change.
For the three instructions sensitive to distance types, two bits of the opcode are used to
determine the type. For these two bits, the values 0 (grey), 1 (black) and 2 (white) are
used. The two bits allow for a fourth value, 3, which is not used. Some implementations
treat this as type 0, while other implementations treat this as an error. Fonts must not
specify distance type 3 for these instructions.
When the distance between two points is determined, the distance is always measured
in the direction specified by the projection_vector. Similarly, when a point is moved, the
distance it is moved will be measured along the projection_vector. When thinking about
how the interpreter will project a distance, you may find it convenient to imagine that
distances are projected onto a ruled line that is parallel to the projection vector.
In the example shown, distances are measured along a line that is parallel to the
projection_vector. The distance from point 1 to point 2 must be projected onto the
projection_vector (that is a line parallel to the projection_vector) before being measured.
Since the line from point 1 to point 3 is parallel to the vector, the projection of the
distance can be thought of as simply the line from 1 to 3. Since the projection of the line
from point 4 to point 1 is perpendicular to the vector, the distance from point 4 to point
1 is zero even though the points do not coincide.

The vector can be set in any direction desired. In a simple case, the projection vector
might be set to measure distance in the x-direction. In such a case, the vector is parallel
to the x-axis. Similarly to measure distance in the y-direction, the projection_vector must
be parallel to the y-axis.
To determine the distance between two points when the projection_vector points in the
positive x-direction, one need only take the difference between their x coordinates. For
example, the distance between the points (2, 1) and (7, 5) will be 5 units. Similarly, if the
projection_vector pointed in the positive y-direction, the distance between the points
would be 4 units.
Note that because the projection_vector has a direction, distances have a sign. Positive
distances are those that are measured with the projection_vector. Negative distances are
those that are measured against the projection_vector.
In the following example, the projection_vector points east (in the direction of the
positive x-axis). The distance between points 1 and 2 is positive when measured from
west to east (from point 1 to point 2). It is negative when measured from east to west
(from point 2 to point 1).

Figure 2–4 Measuring the distance between two points
In many cases, it is convenient to disregard the sign associated with a distance. When
the auto_flip Graphics State variable is set to TRUE, the sign of CVT entries will be
changed when needed to match the sign of the actual measurement. This makes it
possible to control distances measured with or against the projection_vector with a
single CVT entry.

Controlling movement
The direction in which points can move is established by the Graphics State variable
freedom_vector.
When a point is moved, its movement is constrained to be in a direction parallel to that
of the freedom_vector. Assuming the freedom_vector is pointing in the direction of the

positive x-axis (points east), movement in the positive x direction (from west to east) will
have a positive magnitude. Movement in the negative x-direction (from east to west) will
have a negative magnitude.

Moving points
WARNING: When moving points, it is not valid for the freedom_vector and the
projection_vector to be orthogonal.
There are several instructions that move outline points. These instructions either move
points relative to a reference point (the relative instructions) or move points to a
specified location in the coordinate system (the absolute instructions).
The following figure illustrates a relative move. The point p is moved so that it is at
distance d from the reference point rp.

Figure 2–5 A relative move
The figure below illustrates an absolute move. Here the point p is moved a distance d
from its current position to a new position. The distance is measured along the
projection_vector. Movement is along the freedom_vector.

Figure 2–6 An absolute move
In specifying a move, some move instructions use the outline distance (direct
instructions). Other instructions specify the value of d only indirectly by referring to a
value in the CVT or to a value on the stack (indirect instructions).
In attempting to move a point you must first decide on the direction and distance.
Beyond this, decide whether you want to move that point an absolute distance or
relative to another point. If the move is relative be sure you know which reference point
will be used by the instruction. In some cases, you may need to change the value of that

reference point to the one you desire. Finally decide whether you will use the original
outline distance or will refer to a distance in the CVT or the stack.
By choosing to use the original outline distance you can preserve the original design
distance between two points. In contrast, if you choose an indirect method of specifying
a distance, that is you use the CVT, you allow that distance to be matched to some
important value for that font or glyph.
All of the move instructions with the sole exception of MSIRP are affected by the
round_state. The instructions allow you to choose whether they should take the
round_state variable into account. In effect this means that, if rounding is turned on, the
distance a point is actually moved will be affected by the type of rounding that is
performed.
In the example below, point p is moved distance d to a new location p' and then
rounded to the nearest grid boundary.

Figure 2–7 An absolute move with round_state set to round to grid

Managing the direction of distances
The auto_flip variable owes its existence to the fact that the TrueType interpreter
distinguishes between distances measured in the direction of the projection_vector
(positive distances) and those that are measured in the direction opposite to the
projection_vector (negative distances).
The setting of the auto_flip Boolean determines whether the sign of values in the
Control Value Table is significant. If auto_flip is set to TRUE, the values of CVT entries will
be changed when necessary to match the sign of the actual measurement. This makes it
possible to control distances measured with or against the projection vector.
For example, the CVT might contain an entry for uppercase stem widths. At times it may
be convenient to control widths from left to right while at other times it may be

convenient to control them from right to left. One case will produce a positive distance,
the other a negative distance. Without auto_flip it would be necessary to have two CVT
entries (+UC_Stem and -UC_Stem) instead of just one. Setting auto_flip to TRUE makes
the sign of the value read from the CVT the same as the sign of the distance between
the points we are controlling in the original unmodified domain.
Generally, auto_flip is set to TRUE, but if it becomes necessary to distinguish between a
positive or negative distance, the variable must be set to FALSE.

Interpolating points
When instructions are used to change the position of a few of the points in a character
outline, the curves that make up the character may become kinked or otherwise
distorted. It may be desirable to smooth out the resulting curve. This smoothing out
process is actually a redistribution of all points that have not been moved so that their
positions relative to the moved points remain consistent.
To assist in managing the shape of outlines, the interpreter uses the concept of touching
a point. Whenever an instruction has the effect of moving a point, that point is marked
as touched in the x-direction or y-direction or both. The IUP instruction will affect only
untouched points. It is possible to explicitly untouch a point so that it will be affected by
an interpolation instruction.

Maintaining minimum_distance
When the width of a glyph feature decreases below a certain size, rounded values may
become zero. Allowing values to round to zero can result in certain glyph features
disappearing. For example, a stem might disappear entirely at small point sizes. By
setting a minimum_distance of one pixel you can assure that even at small sizes those
features will not disappear.
In the example shown below, the minimum_distance value is used to ensure that the
stem of the r does not disappear at small sizes. By ensuring that the distance from point
9 to point 10 is always at least one pixel, this goal is accomplished.

Controlling regularization using the cut_in
The TrueType language offers several means of coordinating values for glyph features
across a font. Such coordination results in a uniformity of appearance known as
regularization. Regularization is useful when the number of pixels available for a feature
or glyph are few in number. It prevents small differences in the size of features from
becoming vastly exaggerated by the change in the placement of pixel centers within a
glyph outline. Regularization becomes a liability when small differences in the size or
placement of features can be effectively represented by the number of available pixels.
TrueType allows you the best of two worlds in making it possible to regularize features
at small numbers of pixels per em while allowing the outline to revert to the original
design once a sufficient number of pixels is available. There are two different ways to
accomplish this goal. Each one uses a cut_in value. The first method uses the Control
Value Table and the control_value_cut_in and allows you to coordinate values using
entries in the CVT. This method allows for a variety of values to be coordinated. The
second method takes regularization a step further and forces all values to revert to a
single value. It relies on the single_width_cut_in and the single_width_value.

Control_value_cut_in
The control_value_cut_in makes it possible to limit the regularizing effects of the CVT to
cases where the difference between the table value and the measurement taken from
the original outline is sufficiently small. It allows the interpreter to choose, at some sizes,
to use the CVT value while, at other sizes, to revert to the original outline. When the
absolute difference between the value in the table and the measurement directly from
the outline is greater than the cut_in value, the outline measurement is used. The effect
of the control_value_cut_in is to allow regularization below a certain cut off point while
allowing the subtlety of the design to take over at larger sizes.

The cut_in value affects only instructions that refer to values in the CVT, the so-called
indirect instructions, MIRP and MIAP, and only if the third Boolean is set to TRUE.
ﾉ

Expand table

CVT
Value

Original Outline
Value

|Diff|

cut_in

|Diff| > cut_in use
outline

|Diff| cut_in use
CVT

93

80

13

17/16

80

-

100

99 5/16

11/16

17/16

-

100

97

95 15/16

17/16

17/16

97

In the example shown, the capital J dips below the base line in the original design. When
the character is grid-fitted, however, the curve is held to the baseline by an indirect
instruction. That instruction references the CVT, subject to the default cut_in value of
17/16. At this value the curve is held to the base line through 81 pixels per em but
reverts to its original design at 82 pixels per em as shown.

Figure 2–8 81 pixels per em (left) and 82 pixels per em (right)
The effect of the cut_in varies with its value. Decreasing the value of the cut_in will have
the effect of causing the outline to revert to the original design at a smaller ppem value.
Increasing the value of the cut_in will cause the outline to revert to the original design at
a higher ppem value.

The single_width_cut_in
The single_width_cut_in is the distance difference at which the interpreter will ignore the
values in the Control Value Table and in the outline in favor of a single-width value. It

allows features to revert to a single predetermined size for small numbers of pixels per
em.
Having all controlled glyph features assume the same dimensions might be an
advantage for certain fonts at very small grid sizes. The single_width_value is used when
the absolute difference between the single_width_value and the original value is smaller
than this single_width_cut_in.
The default value for the single_width_cut_in is zero. In effect, this means that the
default is ignore this cut_in value.

The single_width_value
The single_width_value is used when the difference between the Control Value Table and
the single_width_value is less than the single_width_cut_in. For example, if the
single_width_value were set to 2 pixels, features meeting the single_width_cut_in test
would be regularized to be 2 pixels wide.

Managing at specific sizes
Most TrueType instructions are independent of size. They are used to control a feature
over the full range of sizes. Occasionally, it is necessary to alter a glyph outline at a
specific size to include or exclude certain pixels. In other words, occasionally it is
desirable to make an exception to the outline that would otherwise be produced by the
other instructions. Such exceptions are made using the DELTA instructions.
There are two types of DELTA instructions. The DELTAP instructions work by moving
points. The DELTAC instructions work by changing values in the CVT.
For example, without a DELTA instruction the circumflex accent shrinks to a single pixel
at 9 ppem. Using DELTAs, the appearance is improved by lowering points 5, 2 and 1 by
one pixel at 9 ppem.

Note: DELTA instructions should be used sparingly, since they are associated with a
relatively high storage overhead. They can be useful for solving otherwise “impossible”

cases.

The delta_base
The delta_base is the base value used to calculate the range of point sizes to which a
delta instruction will apply. Changing the delta_base allows you to change the range of
ppem sizes affected by each of the DELTA instructions.
The three pairs of DELTA instructions are grouped according to the range of pixels they
potentially affect, with each group beginning at 16 pixels per em larger than the
previous group. All DELTAC1 and DELTAP1 instructions potentially can affect glyphs at
sizes beginning at delta_base pixels per em through delta_base plus 15 pixels per em.
The DELTAP2 and DELTAC2 instructions affect the range beginning at delta_base plus 16
pixels per em. The DELTAP3 and DELTAC3 instructions affect delta_base plus 32 pixels
per em.

The delta_shift
The delta_shift value is the power to which an exception is raised. By varying the value of
the delta_shift, you trade off fine control of outline movement as opposed to total range
of movement. A low delta_shift favors range of movement over fine control. A high
delta_shift favors fine control over range of movement.
Points can be moved by multiples of a fixed amount called a step. The size of the step is
1 divided by 2 to the power delta_shift.

Managing Anti-Aliasing
Windows offers users the option of displaying anti-aliased text. The OpenType 'gasp'
table can be used to control the size ranges at which grayscaling and gridfitting occur.
Additionally, TrueType instructions can be used to finely control the use of grayscale
pixels in rasterizer version 1.7 and later.
The following TrueType code sample illustrates how TrueType instructions can determine
if the installed rasterizer supports anti-aliasing, and then provide hints to the rasterizer.

PUSHB[2]
WS
PUSHB[3]
GETINFO
DUP

2

0

23

17

/* PUSH : storageID, FALSE */
/* FALSE by default */
1 /* PUSH : jump1, jump2, rast. version flag */
/* get the rasterizer version */

PUSHB[1]
34
LTEQ
ROLL
SWAP
JROT
34) */
PUSHB[1]
64
GT
JROT
PUSHB[2]
10
GETINFO
HintForGray */
PUSHW[1] 4096
NEQ
JROT
PUSHB[2]
2
WS
PUSHB[1]
3
JMPR
POP
POP

/* we are at MS rasterizer version 1.7 or higher (>

32

/* we are in the MS version range (<= 64) */
/* PUSH : jump3, HintForGray flag */
/* we are on the new MS Rasterizer, ask for
/* PUSH : HintForGray flag */

1

/* PUSH : storageID, TRUE */
/* Storage #2 set to TRUE, grayscale */
/* PUSH : jump4 */

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

The TrueType Instruction Set
Article • 05/30/2024

TrueType provides instructions for each of the following tasks and a set of generalpurpose instructions. This chapter describes the TrueType instruction set. Instruction
descriptions are organized by category based on their function.
Pushing data onto the interpreter stack
Managing the Storage Area
Managing the Control Value Table
Modifying Graphics State settings
Managing outlines
General purpose instructions

Anatomy of a TrueType Instruction
TrueType instructions are uniquely specified by their opcodes. For convenience, this
book will refer to instructions by their names. Each instruction name is a mnemonic
intended to aid in remembering that instruction’s function. For example, the MDAP
instruction stands for Move Direct Absolute Point. Similarly, RUTG is short for Round Up
To Grid. A brief description of each instruction clarifying the mnemonic marks the start
of a new instruction.
One name may actually refer to several different but closely related instructions. A
bracketed list of Boolean values follows each name to uniquely specify a particular
variant of a given instruction. The Boolean list can be converted to a binary number and
that number added to the base opcode for the instruction to obtain the opcode for any
instruction variant.
To obtain the opcode for any instruction, take the lower of the two opcode values given
in the code range and add the unsigned binary number represented by the list of binary
digits. The left most bit is the most significant. For example, given an instruction with the
opcode range 0xCO–0xDF and five Boolean flags (a through e) the opcode for a given
instruction base can be computed as shown:
Opcode = 0xC0 + a · 24 + b · 23 + c · 22 + d · 21 + e · 20
If these flags were set to 11101 the code would be computed as follows:
0xC0 + 1 · 24 + 1 · 23 + 1 · 22 + 0 · 21 + 1 · 20
= 0xC0 + 0x10 + 0x8 + 0x4 + 0x1

= 0xC0 + 0x1D = 0xDD
Instruction opcodes are part of the instruction stream, a sequence of opcodes and data.
The instruction stream is not a stack. While the stream of opcodes and data on the
instruction stream is gradually used up, no new data is added to the instruction stream
by the execution of another instruction (i.e. there is no equivalent of a push instruction
that adds data to the instruction stream). It is possible to alter the flow of control
through the instruction stream using one of the jump instructions described in a later
section.
The instruction stream is shown as a sequence of opcodes and data. Since the
instruction stream is 1-byte wide, words will be broken up into high bytes and low bytes
with high bytes appearing first in the stream. For added readability, instruction names
are used in illustrations instead of opcodes. An arrow will point to the next instruction
awaiting execution.

Figure 3–1 The instruction stream with a push byte instruction (left) and a push word
instruction (right)
A few instructions known collectively as push instructions move data from the
instruction stream to the interpreter stack. These instructions are unique in taking their
arguments from the instruction stream. All other TrueType instructions take any data
needed from the stack at the time they are executed. Any results produced by a
TrueType instruction are pushed onto the interpreter stack.
An instruction that expects two arguments and pushes a third would expect the two
arguments to be at the top of the stack. Any result pushed by that instruction appears at
the top of the stack.

The listing a b c denotes a stack consisting of three elements with a being at the top of
the stack, b being in the middle, and c at the bottom as shown.
To easily remember the order in which stack values are handled during arithmetic or
logical operations, imagine writing the stack values from left to right, starting with the
bottom value. Then insert the operator between the two furthest right elements. For
example, subtract a,b would be interpreted as (b-a):
cb-a
GT a,b would be interpreted as (b>a):
cb>a
The statement push d, e means push d then push e adding two elements to the stack as
shown.

To indicate that the top two stack elements are to be removed the statement would be
pop e, d.

It has already been noted that the bracketed list of binary digits that follows the
instruction name uniquely identifies an instruction variant. This is done by having the
bits represent a list of Boolean flags that can be set to TRUE with a value of 1 or to

FALSE with a value of 0. Binary digits that follow the name can also be grouped to form
a larger binary number. In such cases, the documentation specifies the meaning
associated with each possible numerical combination.
An instruction specification consists of the instruction name followed by its bracketed
Boolean flags. Additional information describing the flags and explaining the stack
interaction and any Graphics State dependencies is provided in tabular form:
ﾉ

Expand table

Code Range

the range of hexadecimal codes identifying this instruction and its variants

Flags

an explanation of the meaning of a bracketed binary number

From IS

any arguments taken from the instruction stream by push instructions

Pops

any arguments popped from the stack

Pushes

any arguments pushed onto the stack

Uses

any state variables whose value this instruction depends upon

Sets

any state variables set by this instruction

Instruction descriptions include illustrations intended to clarify stack interactions,
Graphics State effects, and changes to interpreter tables.
In the case of instructions that move points, an illustration will be provided to clarify the
direction and magnitude of the movement. In these illustrations, shades of gray will be
used to indicate the sequence in which points have been moved. The darker the fill, the
more recently a point has been moved.

Data types
The instruction stream
Instruction opcodes are always bytes. Values in the instruction stream are bytes.

The stack
Values pushed onto the stack or popped from the stack are always 32-bit quantities
(int32 or uint32). When values that are less than 32 bits are pushed onto the stack, bytes
are expanded to 32-bit quantities by padding the upper bits with zeroes and words are

sign extended to 32 bits. In cases where two instruction stream bytes are combined to
form a word, the high order bits appear first in the instruction stream.
Note: On a 16-bit system, such as Windows, all stack operations are on 16-bit values
(int16 or uint16). Care must be taken to avoid overflow. It is also important to note
that F26dot6 values (used for internal scalar math) are represented instead as 10 dot
6 values (i.e. the upper 16 bits are not supported).

Figure 3–2 A byte padded to a 32-bit long word (uint32)

Figure 3–3 A word sign extended to a 32-bit long word (uint32)
All values on the stack are signed. Instructions, however, interpret these 32-bit quantities
in a variety of ways. The interpreter variously understands quantities as integers and as
fixed-point numbers.
Values such as pixel coordinates are represented as 32-bit quantities consisting of 26
bits of whole number and 6 bits of fraction. These are fixed point numbers with the data
type name F26Dot6.
The freedom_vector and projection_vector are represented as 2.14 fixed point numbers.
The upper 16 bits of the 32-bit quantity are ignored.
A given set of 32 bits will have a different value depending upon how it is interpreted.
The following 32-bit value interpreted as an integer has the value 264.

The same 32 bit quantity interpreted as an F26Dot6 fixed point number has the value
4.125.

The figure below gives several examples of expressing pixel values as 26.6 words.

Pushing data onto the interpreter stack
Most TrueType instructions take their arguments from the interpreter stack. A few
instructions, however, take their arguments from the instruction stream. Their purpose is
to move data from the instruction stream to the interpreter stack. Collectively these
instructions are known as the push instructions.

PUSH N Bytes
ﾉ

Expand table

NPUSHB[ ]
Code
Range

0x40

From IS

n: number of bytes to push (1 byte interpreted as an integer) b1, b2,...bn: sequence
of n bytes

Pushes

b1, b2, bn: sequence of n bytes each padded to 32 bits (uint32)

Takes n unsigned bytes from the instruction stream, where n is an unsigned integer in
the range (0..255), and pushes them onto the stack. n itself is not pushed onto the stack.

PUSH N Words

ﾉ

Expand table

NPUSHW[
]
Code
Range

0x41

From IS

n: number of words to push (one byte interpreted as an integer) w1, w2,...wn:
sequence of n words formed from pairs of bytes, the high byte appearing first

Pushes

w1, w2,...wn: sequence of n words each sign extended to 32 bits (int32)

Takes n 16-bit signed words from the instruction stream, where n is an unsigned integer
in the range (0..255), and pushes them onto the stack. n itself is not pushed onto the
stack.

PUSH Bytes
ﾉ

Expand table

PUSHB[abc]
Code Range

0xB0 – 0xB7

abc

number of bytes to be pushed - 1

From IS

b0, b1,..bn: sequence of n + 1 bytes

Pushes

b0, b1, ...,bn: sequence of n + 1 bytes each padded to 32 bits (uint32)

Takes the specified number of bytes from the instruction stream and pushes them onto
the interpreter stack.
The variables a, b, and c are binary digits representing numbers from 000 to 111 (0-7 in
binary). Because the actual number of bytes (n) is from 1 to 8, 1 is automatically added
to the ABC figure to obtain the actual number of bytes pushed.

Example:

PUSH Words
ﾉ

Expand table

PUSHW[abc]
Code Range

0xB8 - 0xBF

abc

number of words to be pushed - 1.

From IS

w0,w1,..wn: sequence of n+1 words formed from pairs of bytes, the high byte
appearing first

Pushes

w0, w1,...wn: sequence of n+1 words each sign extended to 32 bits (int32)

Takes the specified number of words from the instruction stream and pushes them onto
the interpreter stack.
The variables a, b, and c are binary digits representing numbers from 000 to 111 (0-7
binary). Because the actual number of bytes (n) is from 1 to 8, 1 is automatically added
to the abc figure to obtain the actual number of bytes pushed.

Example:

Managing the Storage Area
The interpreter Storage Area is a block of memory that can be used to store and later
access 32-bit values. Instructions exist for writing values to the Storage Area and
retrieving values from the Storage Area. Attempting to read a value from a storage
location that has not previously had a value written to it will yield unpredictable results.

Read Store
ﾉ

Expand table

RS[ ]
Code Range

0x43

Pops

location: Storage Area location (uint32)

Pushes

value: Storage Area value (uint32)

Gets

Storage Area value

This instruction reads a 32-bit value from the Storage Area location popped from the
stack and pushes the value read onto the stack. It pops an address from the stack and

pushes the value found in that Storage Area location to the top of the stack. The
number of available storage locations is specified in the maxProfile table in the font file.

Example:

The effect of the RS instruction is to push the value 0x1B of the Storage Area onto the
Stack.

Write Store
ﾉ

Expand table

WS[ ]
Code Range

0x42

Pops

value: Storage Area value (uint32)
location: Storage Area location (uint32)

Pushes

–

Gets

Storage Area value

This instruction writes a 32-bit value into the storage location indexed by locations. It
works by popping a value and then a location from the stack. The value is placed in the
Storage Area location specified by that address. The number of storage locations is
specified in the maxProfile table in the font file.

Example:

Write the value 0x0000 0118 to location 3A in the Storage Area.

Managing the Control Value Table
The Control Value Table stores information that is accessed by the indirect instructions.
Values can be written to the CVT in font design units or pixel units as proves convenient.
Values read from the CVT are always in pixels (F26Dot6). This table, unlike the Storage
Area, is initialized by the font and is automatically scaled.

Write Control Value Table in Pixel units
ﾉ

Expand table

WCVTP[ ]
Code Range

0x44

Pops

value: number in pixels (F26Dot6 fixed point number)
location: Control Value Table location (uint32)

Pushes

–

Sets

Control Value Table entry

Pops a location and a value from the stack and puts that value in the specified location
in the Control Value Table. This instruction assumes the value is in pixels and not in font
design units.

Write Control Value Table in Font design units
ﾉ

Expand table

WCVTF[ ]
Code Range

0x70

Pops

value: number in font design units (uint32)
location: Control Value Table location (uint32)

Pushes

–

Sets

Control Value Table entry

Pops a location and a value from the stack and puts the specified value in the specified
address in the Control Value Table. This instruction assumes the value is expressed in
font design units and not pixels. The value is scaled before being written to the table.

Read Control Value Table
ﾉ

Expand table

RCVT[ ]
Code Range

0x45

Pops

location: CVT entry number (uint32)

Pushes

value: CVT value (F26Dot6)

Gets

Control Value Table entry

Pops a location from the stack and pushes the value in the location specified in the
Control Value Table onto the stack.

Managing the Graphics State
Instructions can be used to set the value of Graphics State variables and, in some cases,
to retrieve their current value.

Getting a value
Instructions that retrieve the value of a state variable have names that begin with the
word get. Get instructions will return the value of the state variable in question by
placing that value on the top of the stack.
The illustration shows the effect of a GPV or get projection_vector instruction. It takes
the x and y components of the projection_vector from the Graphics State and places
them on the stack.

Setting a value
Instructions that change the value of a Graphics State variable have a name that begins
with the word set. Set instructions expect their arguments to be at the top of the
interpreter stack

Figure 3–4 Setting the value of the Graphics State variable projection_vector

In addition to simple sets and gets, some instructions exist to simplify management of
the values of state variables. For example, a number of instructions exist to set the
direction of the freedom_vector and the projection_vector. In setting a vector, it is
possible to set it to either of the coordinate axes, to the direction specified by a line, or
to a direction specified by values taken from the stack. An instruction exists that directly
sets the freedom_vector to the same value as the projection_vector.

Set freedom and projection Vectors To Coordinate Axis
ﾉ

Expand table

SVTCA[a]
Code Range

0x00 - 0x01

a

0: set vectors to the y-axis
1: set vectors to the x-axis

Pops

-

Pushes

-

Sets

projection_vector
freedom_vector

Sets both the projection_vector and freedom_vector to the same one of the coordinate
axes.
The SVTCA is a shortcut for using both the SFVTCA and SPVTCA instructions. SVTCA[1] is
equivalent to SFVTCA[1] followed by SPVTCA[1]. This instruction ensures that both
movement and measurement are along the same coordinate axis.
Example:
SVTCA[1]

Sets both measurement and movement to the x direction.
SVTCA[0]

Sets both measurement and movement to the y direction.

Set Projection_Vector To Coordinate Axis
ﾉ

Expand table

SPVTCA[a]
Code Range

0x02 - 0x03

a

0: set the projection_vector to the y-axis
1: set the projection_vector to the x-axis

Pops

-

Pushes

-

Sets

projection_vector

Sets the projection_vector to one of the coordinate axes depending on the value of the
flag a.
Example:
SPVTCA[0]

Sets the projection_vector to the y-axis assuring the measurement will be in that
direction.

Set Freedom_Vector to Coordinate Axis
ﾉ

SFVTCA[a]
Code Range

0x04 - 0x05

a

0: set the freedom_vector to the y-axis
1: set the freedom_vector to the x-axis

Expand table

Pops

-

Pushes

-

Sets

freedom_vector

Sets the freedom_vector to one of the coordinate axes depending upon the value of the
flag a.
Example:
SFVTCA[0]

Sets the freedom_vector to the y-axis ensuring that movement will be along that axis.

Set Projection_Vector To Line
ﾉ

Expand table

SPVTL[a]
Code

0x06 - 0x07

Range
a

0: sets projection_vector to be parallel to line segment from p1 to p2
1: sets projection_vector to be perpendicular to line segment from p1 to p2; the
vector is rotated counter-clockwise 90 degrees

Pops

p1: point number (uint32)
p2: point number (uint32)

Pushes

-

Uses

point p1 in the zone pointed at by zp2
point p2 in the zone pointed at by zp1

Sets

projection_vector

Sets the projection_vector to a unit vector parallel or perpendicular to the line segment
from point p1 to point p2.
Example:

If parallel, the projection_vector points from p1 toward p2 as shown.

If perpendicular the projection_vector is obtained by rotating the parallel vector in a
counter-clockwise manner as shown.
Case 1:
SPVTL[1]

Sets the projection_vector to be parallel to the line from point 7 to point 14.
Case 2:
SPVTL[1]

Sets the projection_vector to be perpendicular to the line from point 7 to point 14.
Case 3:
SPVTL[1]

The order in which the points are specified matters. This instruction sets the
projection_vector to be perpendicular to the line from point 14 to point 7.

Set Freedom_Vector To Line
ﾉ

Expand table

SFVTL[a]
Code

0x08 - 0x09

Range
a

0: set freedom_vector to be parallel to the line segment defined by points p1 and p2
1: set freedom_vector perpendicular to the line segment defined by points p1 and
p2; the vector is rotated counter-clockwise 90 degrees

Pops

p1: point number (uint32)

p2: point number (uint32)
Pushes

-

Sets

freedom_vector

Uses

point p1 in the zone pointed at by zp2
point p2 in the zone pointed at by zp1

Sets the freedom_vector to a unit vector parallel or perpendicular to the line segment
defined by points p1 and p2.

If parallel the freedom_vector points from p1 toward p2 as shown.

If perpendicular the freedom_vector is obtained by rotating the parallel vector in a
counter-clockwise manner as shown.

Set Freedom_Vector To Projection Vector
ﾉ

SFVTPV[ ]
Code

0x0E

Pops

-

Pushes

-

Sets

freedom_vector

Sets the freedom_vector to be the same as the projection_vector.

Expand table

Before

After

Set Dual Projection_Vector To Line
ﾉ

Expand table

SDPVTL[a]
Code Range

0x86 - 0x87

a

0: Vectors are parallel to line
1: Vectors are perpendicular to line

Pops

p1: first point number (uint32)
p2: second point number (uint32)

Pushes

-

Sets

dual_projection_vector and projection_vector

Uses

point p1 in the zone pointed at by zp2
point p2 in the zone pointed at by zp1

Pops two point numbers from the stack and uses them to specify a line that defines a
second, dual_projection_vector. This dual_projection_vector uses coordinates from the
scaled outline before any grid-fitting took place. It is used only with the IP, GC, MD,
MDRP and MIRP instructions. Those instructions will use the dual_projection_vector
when they measure distances between ungrid-fitted points. The dual_projection_vector
will disappear when any other instruction that sets the projection_vector is used.

NOTE: The dual_projection_vector is set parallel to the points as they appeared in the
original outline before any grid-fitting took place.

Set Projection_Vector From Stack
ﾉ

Expand table

SPVFS[ ]
Code Range

0x0A

Pops

y: y component of projection_vector (2.14 fixed point number padded with zeroes)
x: x component of projection_vector (2.14 fixed point number padded with zeroes)

Pushes

-

Sets

projection_vector

Sets the direction of the projection_vector, using values x and y taken from the stack, so
that its projections onto the x and y-axes are x and y, which are specified as signed
(two’s complement) fixed-point (2.14) numbers. The square root of (x2 + y2) must be
equal to 0x4000 (hex).
If values are to be saved and used by a glyph program, font program or preprogram
across different resolutions, extreme care must be used. The values taken from or put on
the stack are 2.14 fixed-point values for the x and y components of the vector in
question. The values are based on the normalized vector lengths. More simply, the
values must always be set such that (X**2 + Y**2) is 1.

If a TrueType program uses specific values for X and Y to set the vectors to certain
angles, these values will not produce identical results across different aspect ratios.
Values that work correctly at 1:1 aspect ratios (such as VGA and 8514) will not
necessarily yield the desired results at a ratio of 1.33:1 (e.g. the EGA).
By the same token, if a TrueType program is making use of the values returned by GPV
and GFV, the values returned for a specific angle will vary with the aspect ratio in use at
the time.

Example:
SPVFS[ ]

Sets the projection_vector to a unit vector that points in the direction of the x axis

Set Freedom_Vector From Stack
ﾉ

Expand table

SFVFS[ ]
Code

0x0B

Pops

y: y component of freedom_vector (2.14 fixed point number padded with zeroes)
x: x component of freedom_vector (2.14 fixed point number padded with zeroes)

Pushes

-

Sets

freedom_vector

Sets the direction of the freedom_vector using the values x and y taken from the stack.
The vector is set so that its projections onto the x and y -axes are x and y, which are

specified as signed (two’s complement) fixed-point (2.14) numbers. The square root of
(x2 + y2) must be equal to 0x4000 (hex).
If values are to be saved and used by a glyph program, font program or preprogram
across different resolutions, extreme care must be used. The values taken from or put on
the stack are 2.14 fixed-point values for the x and y components of the vector in
question. The values are based on the normalized vector lengths. More simply, the
values must always be set such that (X**2 + Y**2) is 1.
If a TrueType program uses specific values for X and Y to set the vectors to certain
angles, these values will not produce identical results across different aspect ratios.
Values that work correctly at 1:1 aspect ratios (such as VGA and 8514) will not
necessarily yield the desired results at a ratio of 1.33:1 (e.g. the EGA).
By the same token, if a TrueType program is making use of the values returned by GPV
and GFV, the values returned for a specific angle will vary with the aspect ratio in use at
the time.

Example:

Sets the freedom_vector to a unit vector that points in the direction of the y axis.

Get Projection_Vector
ﾉ

GPV[ ]
Code Range

0x0C

Pops

-

Expand table

Pushes

x: x component of projection_vector (2.14 fixed point number padded with zeroes)
y : y component of projection_vector (2.14 fixed point number padded with
zeroes)

Gets

projection_vector

Pushes the x and y components of the projection_vector onto the stack as two 2.14
numbers.
If values are to be saved and used by a glyph program, font program or preprogram
across different resolutions, extreme care must be used. The values taken from or put on
the stack are 2.14 fixed-point values for the x and y components of the vector in
question. The values are based on the normalized vector lengths. More simply, the
values must always be set such that (X**2 + Y**2) is 1.
If a TrueType program uses specific values for X and Y to set the vectors to certain
angles, these values will not produce identical results across different aspect ratios.
Values that work correctly at 1:1 aspect ratios (such as VGA and 8514) will not
necessarily yield the desired results at a ratio of 1.33:1 (e.g. the EGA).
By the same token, if a TrueType program is making use of the values returned by GPV
and GFV, the values returned for a specific angle will vary with the aspect ratio in use at
the time.

Example:
Case 1:

The stack entry 0x4000 which when interpreted as a 2.14 number is simply 1. This
command reveals that, in this case, the projection_vector is a unit vector that points in
the x direction.
Case 2:

Here the projection_vector is a unit vector that points in the direction of the y axis.
Case 3:

NOTE: 0x2D41 is the hex equivalent of sqrt(2)/2 . As a result of this instruction, the
projection_vector is set to a 45-degree angle relative to the x-axis.

Get Freedom_Vector
ﾉ

Expand table

GFV[ ]
Code Range

0x0D

Pops

-

Pushes

x: x-component of freedom_vector (2.14 number padded with zeroes)
y: y component of freedom_vector (2.14 number padded with zeroes)

Gets

freedom_vector

Puts the x and y components of the freedom_vector on the stack. The freedom_vector is
put onto the stack as two 2.14 coordinates.
If values are to be saved and used by a glyph program, font program or preprogram
across different resolutions, extreme care must be used. The values taken from or put on
the stack are 2.14 fixed-point values for the x and y components of the vector in
question. The values are based on the normalized vector lengths. More simply, the
values must always be set such that (X**2 + Y**2) is 1.
If a TrueType program uses specific values for X and Y to set the vectors to certain
angles, these values will not produce identical results across different aspect ratios.

Values that work correctly at 1:1 aspect ratios (such as VGA and 8514) will not
necessarily yield the desired results at a ratio of 1.33:1 (e.g. the EGA).
By the same token, if a TrueType program is making use of the values returned by GPV
and GFV, the values returned for a specific angle will vary with the aspect ratio in use at
the time.

Example:
GFV[ ]

Set Reference Point 0
ﾉ

SRP0[ ]
Code Range

0x10

Pops

p: point number (uint32)

Pushes

-

Sets

rp0

Affects

IP, MDAP, MIAP, MIRP, MSIRP, SHC, SHE, SHP

Pops a point number from the stack and sets rp0 to that point number.

Expand table

Set Reference Point 1
ﾉ

Expand table

ﾉ

Expand table

SRP1[ ]
Code Range

0x11

Pops

p: point number (uint32)

Pushes

-

Sets

rp1

Affects

IP, MDAP, MDRP, MIAP, MSIRP, SHC, SHE, SHP

Pops a point number from the stack and sets rp1 to that point number.

Set Reference Point 2

SRP2[ ]
Code Range

0x12

Pops

p: point number (uint32)

Pushes

-

Sets

rp2

Pops a point number from the stack and sets rp2 to that point number.

Set Zone Pointer 0
ﾉ

Expand table

SZP0[ ]
Code

0x13

Range
Pops

n: zone number (uint32)

Pushes

-

Sets

zp0

Affects

ALIGNPTS, ALIGNRP, DELTAP1, DELTAP2, DELTAP3, IP, ISECT, MD, MDAP, MIAP,
MIRP, MSIRP, SHC, SHE, SHP, UTP

Pops a zone number, n, from the stack and sets zp0 to the zone with that number. If n is
0, zp0 points to zone 0. If n is 1, zp0 points to zone 1. Any other value for n is an error.

Example:

Set Zone Pointer 1
ﾉ

Expand table

SZP1[ ]
Code Range

0x14

Pops

n: zone number (uint32)

Pushes

-

Sets

zp1

Affects

ALIGNRPTS, ALIGNRP, IP, MD, MDRP, MSIRP, SHC, SHE, SHP, SFVTL, SPVTL

Pops a zone number, n, from the stack and sets zp1 to the zone with that number. If n is
0, zp1 points to zone 0. If n is 1, zp1 points to zone 1. Any other value for n is an error.

Example:

Set Zone Pointer 2
ﾉ

SZP2[ ]
Code Range

0x15

Pops

n: zone number (uint32)

Pushes

-

Sets

zp2

Affects

ISECT, IUP, GC, SHC, SHP, SFVTL, SHPIX, SPVTL, SC

Expand table

Pops a zone number, n, from the stack and sets zp2 to the zone with that number. If n is
0, zp2 points to zone 0. If n is 1, zp2 points to zone 1. Any other value for n is an error.

Set Zone PointerS
ﾉ

Expand table

SZPS[ ]
Code

0x16

Range
Pops

n: zone number (uint32)

Pushes

-

Sets

zp0, zp1, zp2

Affects

ALIGNPTS, ALIGNRP, DELTAP1, DELTAP2, DELTAP3, GC, IP, ISECT, IUP, MD, MDAP,
MDRP, MIAP, MIRP, MSIRP, SC, SFVTL, SHPIX, SPVTL, SHC, SHE, SHP, SPVTL, UTP

Pops a zone number from the stack and sets all of the zone pointers to point to the
zone with that number. If n is 0, all three zone pointers will point to zone 0. If n is 1, all
three zone pointers will point to zone 1. Any other value for n is an error.

Round To Half Grid
ﾉ

RTHG[ ]
Code Range

0x19

Pops

-

Expand table

Pushes

-

Sets

round_state

Affects

MDAP, MDRP, MIAP, MIRP, ROUND

Uses

freedom_vector, projection_vector

Sets the round_state variable to state 0 (hg). In this state, the coordinates of a point are
rounded to the nearest half grid line.
Example

Round To Grid
ﾉ

Expand table

RTG[ ]
Code Range

0x18

Pops

-

Pushes

-

Sets

round_state

Affects

MDAP, MDRP, MIAP, MIRP, ROUND

Uses

freedom_vector, projection_vector

Sets the round_state variable to state 1 (g). In this state, distances are rounded to the
closest grid line.
Example

Round To Double Grid
ﾉ

Expand table

RTDG[ ]
Code Range

0x3D

Pops

-

Pushes

-

Sets

round_state

Affects

MDAP, MDRP, MIAP, MIRP, ROUND

Uses

freedom_vector, projection_vector

Sets the round_state variable to state 2 (dg). In this state, distances are rounded to the
closest half or integer pixel.
Example

Round Down To Grid
ﾉ

Expand table

RDTG[ ]
Code Range

0x7D

Pops

-

Pushes

-

Sets

round_state

Affects

MDAP, MDRP, MIAP, MIRP, ROUND

Uses

freedom_vector, projection_vector

Sets the round_state variable to state 3 (dtg). In this state, distances are rounded down
to the closest integer grid line.
Example

Round Up To Grid

ﾉ

Expand table

RUTG[ ]
Code Range

0x7C

Pops

-

Pushes

-

Sets

round_state

Affects

MDAP, MDRP, MIAP, MIRP, ROUND

Uses

freedom_vector, projection_vector

Sets the round_state variable to state 4 (utg). In this state distances are rounded up to
the closest integer pixel boundary
Example

Round OFF
ﾉ

ROFF[ ]
Code Range

0x7A

Pops

-

Pushes

-

Sets

round_state

Affects

MDAP, MDRP, MIAP, MIRP, ROUND

Uses

freedom_vector, projection_vector

Expand table

Sets the round_state variable to state 5 (off). In this state rounding is turned off.
Example

Super ROUND
ﾉ

Expand table

SROUND[ ]
Code Range

0x76

Pops

n: number decomposed to obtain period, phase, threshold

Pushes

-

Sets

round_state

Affects

MDAP, MDRP, MIAP, MIRP, ROUND

SROUND allows you fine control over the effects of the round_state variable by allowing
you to set the values of three components of the round_state: period, phase, and
threshold.
More formally, SROUND maps the domain of 26.6 fixed point numbers into a set of
discrete values that are separated by equal distances. SROUND takes one argument
from the stack, n, which is decomposed into a period, phase and threshold.
The period specifies the length of the separation or space between rounded values in
terms of grid spacing.

The phase specifies the offset of the values from multiples of the period.
The threshold specifies the part of the domain that is mapped onto each value. More
intuitively, the threshold tells a value when to “fall forward” to the next largest integer.

Only the lower 8 bits of the argument n are used. For SROUND gridPeriod is equal to 1.0
pixel. The byte is encoded as follows: bits 7 and 6 encode the period, bits 5 and 4
encode the phase and bits 3, 2, 1 and 0 encode the threshold as shown here.

period

0

period = gridPeriod/2

1

period = gridPeriod

2

period = gridPeriod * 2

3

Reserved

ﾉ

Expand table

ﾉ

Expand table

ﾉ

Expand table

phase

0

phase = 0

1

phase = period/4

2

phase = period/2

3

phase = gridPeriod * 3/4

threshold

0

threshold = period -1

1

threshold = -3/8 * period

2

threshold = -2/8 * period

3

threshold = -1/8 * period

4

threshold = 0/8 * period

5

threshold = 1/8 * period

6

threshold = 2/8 * period

7

threshold =3/8 * period

8

threshold = 4/8 * period

9

threshold = 5/8 * period

10

threshold = 6/8 * period

11

threshold = 7/8 * period

12

threshold = 8/8 * period

13

threshold = 9/8 * period

14

threshold = 10/8 * period

15

threshold = 11/8 * period

For example, SROUND(01:01:1000) maps numbers into the values 0.25, 1.25, 2.25, The
numbers from -0.25 to 0.75 are mapped into 0.25. The range of numbers [0.75, 1.75)
map into 1.25. Similarly, the numbers from [1.75, 2.75) map into the number 2.25 and so
on.

Rounding occurs after compensation for engine characteristics, so the steps in the
rounding of a number n are:
add engine compensation to n.
subtract the phase from n.
add the threshold to n.
truncate n to the next lowest periodic value (ignore the phase).
add the phase back to n.
if rounding caused a positive number to become negative, set n to the positive
round value closest to 0.
if rounding caused a negative number of become positive, set n to the negative
round value closest to 0.
the period parameters can have values of 1/2 pixel, 1 pixel, or 2 pixels.
the phase parameters can have values of 0 pixels, 1/4 pixel, 1/2 pixel, or 3/4 pixel.
the threshold parameters can have values of -3/8 period, -2/8 period, 11/8 period.
It can also have the special value largest-number-smaller-than-period which

causes rounding equivalent to CEILING.

Super ROUND 45 degrees
ﾉ

Expand table

S45ROUND[ ]
Code Range

0x77

Pops

n: uint32 decomposed to obtain period, phase, threshold (uint32)

Pushes

-

Sets

round_state

Affects

MDAP, MDRP, MIAP, MIRP, ROUND

S45ROUND is analogous to SROUND. The gridPeriod is SQRT(2)/2 pixels rather than 1
pixel. It is useful for measuring at a 45-degree angle with the coordinate axes.

Set LOOP variable
ﾉ

Expand table

SLOOP[ ]
Code Range

0x17

Pops

n: value for loop Graphics State variable (integer)

Pushes

-

Sets

loop

Affects

ALIGNRP, FLIPPT, IP, SHP, SHPIX

Pops a value, n, from the stack and sets the loop variable count to that value. The loop
variable works with the SHP[a], SHPIX[ ], IP[ ], FLIPPT[ ], and ALIGNRP[ ]. The value n
indicates the number of times the instruction is to be repeated. After the instruction
executes, the loop variable is reset to 1.

Set Minimum_Distance
ﾉ

Expand table

SMD[ ]
Code Range

0x1A

Pops

distance: value for minimum_distance (F26Dot6)

Pushes

-

Sets

minimum_distance

Pops a value from the stack and sets the minimum_distance variable to that value. The
distance is assumed to be expressed in sixty-fourths of a pixel.

INSTruction execution ConTRoL
ﾉ

Expand table

INSTCTRL[ ]
Code Range

0x8E

Pops

s: selector flag (int32)
value: USHORT (padded to 32 bits) used to set value of instruction_control.

Pushes

-

Sets

instruction_control

Sets the instruction control state variable making it possible to turn on or off the
execution of instructions, to regulate use of parameters set in the control value (CV)
program, and to select ClearType™ behavior mode.
This instruction clears and sets various control flags in the rasterizer. Two arguments are
popped from the stack: a selector and a value:

The selector flag determines valid values for the value argument. The value determines
the new setting of the rasterizer control flag. In this version there are three flags in use:
Selector flag 1 is used to inhibit grid-fitting. If s=1, valid values for the value
argument are 0 (FALSE) and 1 (TRUE). If the value argument is set to TRUE (v=1),
any instructions associated with glyphs will not be executed. For example, to inhibit
grid-fitting when glyphs are being rotated or stretched, use the following
sequence in the CV program:

PUSHB[000] 6
GETINFO[]
IF[]
PUSHB[000] 1
PUSHB[000] 1
INSTCTRL[]
off */
EIF[]

/* ask GETINFO to check for stretching or rotation */
/* will push TRUE if glyphs are stretched or rotated */
/* tests value at top of stack */
/* value for INSTCTRL */
/* selector for INSTCTRL */
/* based on selector and value will turn grid-fitting

Selector flag 2 is used to establish that any parameters set in the CV program
should be ignored when instructions associated with glyphs are executed. These
include, for example, the values for scantype and the CVT cut-in. If s=2, valid
values for the value argument are 0 (FALSE) and 2 (TRUE). If the value argument is
set to TRUE (v=2), the default values of those parameters provided by the
rasterizer implementation will be used regardless of any changes that may have
been made in those values by the preprogram. If the value argument is set to
FALSE (v=0), parameter values changed by the CV program will be used in glyph
instructions.
Selector flag 3 is used to control some aspects of how certain instructions are
interpreted when ClearType™ is being used. Refinements to ClearType were
introduced in Windows XP, but this opt-in flag was included to allow backward
compatibility for existing fonts designed for the original ClearType implementation.
(For background information on compatibility mode, see Backwards compatibility
of TrueType instructions with Microsoft ClearType.) If s=3, valid values for the value
argument are 0 (FALSE) and 4 (TRUE). If the value argument is set to TRUE (v=4),

then the interpreter will be in native ClearType mode. If the value argument is set
to FALSE (v=0), then the interpreter will be in backwards compatibility mode.
Using INSTCTRL[] to set flags 1 or 2 must be done in the CV program. If set in a glyph
program, these flags have no effect on that glyph program or on subsequent operation.
The defaults flag (flag 2) is only checked once, when the CV program ends, to determine
the default parameter settings that will be set before each glyph program is executed.
The native ClearType mode flag can be set either in the CV program or in a glyph
program. It can be set or cleared within a glyph program to control behavior during
execution of that glyph program. After a glyph program is completed, this flag will be
reset to the default determined in the CV program before then next glyph program is
executed.

SCAN conversion ConTRoL
ﾉ

Expand table

SCANCTRL[
]
Code Range

0x85

Pops

n: flags indicating when to turn on dropout control mode (16-bit word padded to
32 bits)

Pushes

-

Sets

scan_control

SCANCTRL is used to set the value of the Graphics State variable scan_control which in
turn determines whether the scan converter will activate dropout control for this glyph.
Use of the dropout control mode is determined by three conditions:
1. Is the glyph rotated?
2. Is the glyph stretched?
3. Is the current setting for ppem less than a specified threshold?
The interpreter pops a word from the stack and looks at the lower 16 bits.
Bits 0-7 represent the threshold value for ppem. A value of FF in bits 0-7 means invoke
dropout_control for all sizes. A value of 0 in bits 0-7 means never invoke
dropout_control.

Bits 8-13 are used to turn on dropout_control in cases where the specified conditions
are met. Bits 8, 9 and 10 are used to turn on the dropout_control mode (assuming other
conditions do not block it). Bits 11, 12, and 13 are used to turn off the dropout mode
unless other conditions force it. Bits 14 and 15 are reserved for future use.
ﾉ

Expand table

Bit

Meaning if set

8

Set dropout_control to TRUE if other conditions do not block and ppem is less than or equal
to the threshold value.

9

Set dropout_control to TRUE if other conditions do not block and the glyph is rotated

10

Set dropout_control to TRUE if other conditions do not block and the glyph is stretched.

11

Set dropout_control to FALSE unless ppem is less than or equal to the threshold value.

12

Set dropout_control to FALSE unless the glyph is rotated.

13

Set dropout_control to FALSE unless the glyph is stretched.

14

Reserved for future use.

15

Reserved for future use.

For example:
ﾉ

Expand table

0x0000

No dropout control is invoked

0x01FF

Always do dropout control

0x0A10

Do dropout control if the glyph is rotated and has less than 16 pixels per-em

The scan converter can operate in either a “normal” mode or in a “fix dropout” mode
depending on the value of a set of enabling and disabling flags.

SCANTYPE
ﾉ

SCANTYPE[ ]
Code Range

0x8D

Expand table

Pops

n: 16-bit integer

Pushes

-

Sets

scan_control

Pops a 16-bit integer whose value is used to determine which rules the scan converter
will use. If the value of the argument is 0, the fast scan converter will be used. If the
value of the integer is 1 or 2, simple dropout control will be used. If the value of the
integer is 4 or 5, smart dropout control will be used. More specifically,
if n=0 rules 1, 2, and 3 are invoked (simple dropout control scan conversion
including stubs)
if n=1 rules 1, 2, and 4 are invoked (simple dropout control scan conversion
excluding stubs)
if n=2 rules 1 and 2 only are invoked (fast scan conversion; dropout control turned
off)
if n=3 same as n = 2
if n = 4 rules 1, 2, and 5 are invoked (smart dropout control scan conversion
including stubs)
if n = 5 rules 1, 2, and 6 are invoked (smart dropout control scan conversion
excluding stubs)
if n = 6 same as n = 2
if n = 7 same as n = 2
The scan conversion rules are shown here:
ﾉ

Expand table

Rule
1

If a pixel’s center falls within the glyph outline, that pixel is turned on.

Rule
2

If a contour falls exactly on a pixel’s center, that pixel is turned on.

Rule
3

If a scan line between two adjacent pixel centers (either vertical or horizontal) is intersected
by both an on-Transition contour and an off-Transition contour and neither of the pixels
was already turned on by rules 1 and 2, turn on the left-most pixel (horizontal scan line) or
the bottom-most pixel (vertical scan line). This is “Simple” dropout control.

Rule
4

Apply Rule 3 only if the two contours continue to intersect other scan lines in both
directions. That is, do not turn on pixels for ‘stubs.’ The scanline segments that form a
square with the intersected scan line segment are examined to verify that they are
intersected by two contours. It is possible that these could be different contours than the
ones intersecting the dropout scan line segment. This is very unlikely but may have to be
controlled with grid-fitting in some exotic glyphs.

Rule
5

If a scan line between two adjacent pixel centers (either vertical or horizontal) is intersected
by both an on-Transition contour and an off-Transition contour and neither of the pixels
was already turned on by rules 1 and 2, turn on the pixel which is closer to the midpoint
between the on-Transition contour and off-Transition contour. This is “Smart” dropout
control.

Rule
6

Apply Rule 5 only if the two contours continue to intersect other scan lines in both
directions. That is, do not turn on pixels for ‘stubs.’

New fonts wishing to use the new modes of the ScanType instruction, but still wishing to
work correctly on old rasterizers that don’t recognize the new modes should:
1. First execute a ScanType instruction using an old mode which will give the best
approximation to the desired new mode (e.g. Simple Stubs for Smart Stubs), and
then
2. Immediately execute another ScanType instruction with the desired new mode.

Set Control Value Table Cut In
ﾉ

Expand table

SCVTCI[ ]
Code Range

0x1D

Pops

n: value for cut_in (F26Dot6)

Pushes

-

Sets

control_value_cut_in

Affects

MIAP, MIRP

Sets the control_value_cut_in in the Graphics State. The value n is expressed in sixtyfourths of a pixel.

Increasing the value of the cut_in will increase the range of sizes for which CVT values
will be used instead of the original outline value.

Set Single_Width_Cut_In

ﾉ

Expand table

SSWCI[ ]
Code Range

0x1E

Pops

n: value for single_width_cut_in (F26dot6)

Pushes

-

Sets

single_width_cut_in

Affects

MIAP, MIRP

Sets the single_width_cut_in in the Graphics State. The value n is expressed in sixtyfourths of a pixel.

Set Single-width
ﾉ

Expand table

SSW[ ]
Code Range

0x1F

Pops

n: value for single_width_value (font design units)

Pushes

-

Sets

single_width_value

Sets the single_width_value in the Graphics State. The single_width_value is expressed in
font design units, which the interpreter converts to pixels (F26Dot6).

Set the auto_flip Boolean to ON

ﾉ

Expand table

FLIPON[ ]
Code Range

0x4D

Pops

-

Pushes

-

Sets

auto_flip

Affects

MIRP

Sets the auto_flip Boolean in the Graphics State to TRUE causing the MIRP instructions
to ignore the sign of Control Value Table entries. The default auto_flip Boolean value is
TRUE.

Set the auto_flip Boolean to OFF
ﾉ

Expand table

FLIPOFF[ ]
Code Range

0x4E

Pops

-

Pushes

-

Sets

auto_flip

Affects

MIRP

Set the auto_flip Boolean in the Graphics State to FALSE causing the MIRP instructions to
use the sign of Control Value Table entries. The default auto_flip Boolean value is TRUE.

Set Angle_Weight

ﾉ

Expand table

SANGW[ ]
Code Range

0x7E

Pops

weight: value for angle_weight

Pushes

-

Sets

angle_weight

SANGW is no longer needed because of dropped support to the AA (Adjust Angle)
instruction. AA was the only instruction that used angle_weight in the global graphics
state.
Pops a weight value from the stack and sets the value of the angle_weight state variable
accordingly

Set Delta_Base in the graphics state
ﾉ

Expand table

SDB[ ]
Code Range

0x5E

Pops

-

Pushes

-

Sets

delta_base

Affects

DELTAP1, DELTAP2, DELTAP3, DELTAC1, DELTAC2, DELTAC3

Pops a number, n, and sets delta_base to the value n. The default for delta_base is 9.

Set Delta_Shift in the graphics state
ﾉ

Expand table

SDS[ ]
Code Range

0x5F

Pops

n: value for the delta_shift (uint32)

Pushes

-

Sets

delta_shift

Affects

DELTAP1, DELTAP2, DELTAP3, DELTAC1, DELTAC2, DELTAC3

Sets delta_shift to the value n. The default for delta_shift is 3.

Reading and writing data
The following instructions make it possible to get and to set a point coordinate, to
measure the distance between two points, and to determine the current settings for
pixels per em and point size.

Get Coordinate projected onto the projection_vector
ﾉ

GC[a]
Code Range

0x46 - 0x47

a

0: use current position of point p
1: use the position of point p in the original outline

Pops

p: point number (uint32)

Pushes

value: coordinate location (F26Dot6)

Uses

zp2, projection_vector

Expand table

Measures the coordinate value of point p on the current projection_vector and pushes
the value onto the stack.
Example
The following example shows that the value returned by GC is dependent upon the
current position of the projection_vector. Note that point p is at the position (300,420) in
the coordinate grid.

GC[1] 9

The projection_vector is parallel to the line from (0,0) to (300,420)

Sets Coordinate From the Stack using projection_vector
and freedom_vector
ﾉ

SCFS[ ]
Code Range

0x48

Expand table

Pops

value: distance from origin to move point (F26Dot6)
p: point number (uint32)

Pushes

-

Uses

zp2, freedom_vector, projection_vector

Moves point p from its current position along the freedom_vector so that its component
along the projection_vector becomes the value popped off the stack.

Measure Distance
ﾉ

Expand table

MD[a]
Code Range

0x49 - 0x4A

a

0: measure distance in grid-fitted outline
1: measure distance in original outline

Pops

p1: point number (uint32)
p2: point number (uint32)

Pushes

distance (F26Dot6)

Uses

zp1 with point p1, zp0 with point p2, projection_vector

Measures the distance between outline point p1 and outline point p2. The value
returned is in pixels (F26Dot6) If distance is negative, it was measured against the
projection vector. Reversing the order in which the points are listed will change the sign
of the result.

Example:
In the illustration below MD[1] between points 25 and 31 will return a smaller value than
MD[0] at 10 pixels per em on a 72 dpi device. The difference is due to the effects of
grid-fitting which, at this size, stretches out the counter.

Measure Pixels Per EM
ﾉ

Expand table

MPPEM[ ]
Code Range

0x4B

Pops

-

Pushes

ppem: pixels per em (uint32)

This instruction pushes the number of pixels per em onto the stack. Pixels per em is a
function of the resolution of the rendering device and the current point size and the

current transformation matrix. This instruction looks at the projection_vector and returns
the number of pixels per em in that direction.

Measure Point Size
ﾉ

Expand table

MPS[ ]
Code Range

0x4C

Pops

-

Pushes

pointSize: the size in points of the current glyph (F26Dot6)

Pushes the current point size onto the stack.
Measure point size can be used to obtain a value which serves as the basis for choosing
whether to branch to an alternative path through the instruction stream. It makes it
possible to treat point sizes below or above a certain threshold differently

12, 18, and 36 point Helvetica g at 72 dpi

Managing outlines
The following set of instructions make it possible to move the points that make up a
glyph outline. They are the instructions that accomplish the actual work of grid-fitting.
They include instructions to move points, shift points or groups of points, flip points
from off to on the curve or vice versa, and to interpolate points

FLIP PoinT
ﾉ

Expand table

FLIPPT[ ]
Code Range

0x80

Pops

p: point number (uint32)

Pushes

-

Uses

loop, p is referenced in zp0

Flips points that are off the curve so that they are on the curve and points that are on
the curve so that they are off the curve. The point is not marked as touched. The result
of a FLIPPT instruction is that the contour describing part of a glyph outline is redefined

Before

After

FLIP RanGe ON

ﾉ

Expand table

FLIPRGON[ ]
Code Range

0x81

Pops

highpoint: highest point number in range of points to be flipped (uint32)
lowpoint: lowest point number in range of points to be flipped (uint32)

Pushes

-

Flips a range of points beginning with lowpoint and ending with highpoint so that any
off the curve points become on the curve points. The points are not marked as touched.

Example:

Before

After
Will make all off curve points between point 0 and point 5 into on curve points as
shown.

FLIP RanGe OFF
ﾉ

Expand table

FLIPRGOFF[ ]
Code Range

0x82

Pops

highpoint: highest point number in range of points to be flipped (uint32)
lowpoint: lowest point number in range of points to be flipped (uint32)

Pushes

-

Flips a range of points beginning with lowpoint and ending with highpoint so that any
on the curve points become off the curve points. The points are not marked as touched.
NOTE: This instruction changes the curve, but the position of the points is unaffected.
Accordingly, points affected by this instruction are not marked as touched.

Example:

Before

After

SHift Point by the last point

ﾉ

Expand table

SHP[a]
Code Range

0x32 - 0x33

a

0: uses rp2 in the zone pointed to by zp1
1: uses rp1 in the zone pointed to by zp0

Pops

p: point to be shifted (uint32)

Pushes

-

Uses

zp0 with rp1 or zp1 with rp2 depending on flag
zp2 with point p
loop, freedom_vector, projection_vector

Shift point p by the same amount that the reference point has been shifted. Point p is
shifted along the freedom_vector so that the distance between the new position of
point p and the current position of point p is the same as the distance between the
current position of the reference point and the original position of the reference point.
NOTE: Point p is shifted from its current position, not its original position. The distance
that the reference point has shifted is measured between its current position and the
original position.
In the illustration below rp is the original position of the reference point, rp' is the
current position of the reference point, p is the original position of point p, p' is the
current position, p" the position after it is shifted by the SHP instruction. (White
indicates original position, gray is current position, black is position to which this
instruction moves a point

SHift Contour by the last point

ﾉ

Expand table

SHC[a]
Code Range

0x34 - 0x35

a

0: uses rp2 in the zone pointed to by zp1
1: uses rp1 in the zone pointed to by zp0

Pops

c: contour to be shifted (uint32)

Pushes

-

Uses

zp0 with rp1 or zp1 with rp2 depending on flag
zp2 with contour c
freedom_vector, projection_vector

Shifts every point on contour c by the same amount that the reference point has been
shifted. Each point is shifted along the freedom_vector so that the distance between the
new position of the point and the old position of that point is the same as the distance
between the current position of the reference point and the original position of the
reference point. The distance is measured along the projection_vector. If the reference
point is one of the points defining the contour, the reference point is not moved by this
instruction.
This instruction is similar to SHP, but every point on the contour is shifted.

SHift Zone by the last pt
ﾉ

SHZ[a]
Code Range

0x36 - 0x37

a

0: the reference point rp2 is in the zone pointed to by zp1
1: the reference point rp1 is in the zone pointed to by zp0

Pops

e: zone to be shifted (uint32)

Pushes

-

Uses

zp0 with rp1 or zp1 with rp2 depending on flag
freedom_vector, projection_vector

Expand table

Shift the points in the specified zone (Z1 or Z0) by the same amount that the reference
point has been shifted. The points in the zone are shifted along the freedom_vector so
that the distance between the new position of the shifted points and their old position is
the same as the distance between the current position of the reference point and the
original position of the reference point.
SHZ[a] uses zp0 with rp1 or zp1 with rp2. This instruction is similar to SHC, but all points
in the zone are shifted, not just the points on a single contour.

SHift point by a PIXel amount
ﾉ

Expand table

SHPIX[ ]
Code Range

0x38

Pops

amount: magnitude of the shift (F26Dot6)
p1, p2,...pn: points to be shifted (uint32)

Pushes

-

Uses

zp2, loop, freedom_vector

Shifts the points specified by the amount stated. When the loop variable is used, the
amount to be shifted is put onto the stack only once. That is, if loop = 3, then the
contents of the top of the stack should be point p1, point p2, point p3, amount. The
value amount is expressed in sixty-fourths of a pixel.
SHPIX is unique in relying solely on the direction of the freedom_vector. It makes no use
of the projection_vector. Measurement is made in the direction of the freedom_vector.
Example
The instruction shifts points 27, 28, and 29 by 80/64 or 1.25 pixels in the direction of the
freedom vector. The distance is measured in the direction of the freedom_vector; the
projection vector is ignored.
SHPIX[]

Move Stack Indirect Relative Point
ﾉ

Expand table

MSIRP[a]
Code
Range

0x3A - 0x3B

a

0: Do not set rp0 to p
1: Set rp0 to p

Pops

d: distance (F26Dot6)
p: point number (uint32)

Pushes

-

Uses

zp1 with point p and zp0 with rp0, freedom_vector, projection_vector.

Sets

After it has moved the point, this instruction sets rp1 = rp0, rp2 = point p, and if
a=1, rp0 is set to point p.

Makes the distance between a point p and rp0 equal to the value specified on the stack.
The distance on the stack is in fractional pixels (F26Dot6). An MSIRP has the same effect
as a MIRP instruction except that it takes its value from the stack rather than the Control
Value Table. As a result, the cut_in does not affect the results of a MSIRP. Additionally,
MSIRP is unaffected by the round_state.

Move Direct Absolute Point
ﾉ

Expand table

MDAP[a]
Code Range

0x2E - 0x2F

a

0: do not round the value
1: round the value

Pops

p: point number (uint32)

Pushes

-

Sets

rp0 = rp1 = point p

Uses

zp0, round_state, projection_vector, freedom_vector.

Sets the reference points rp0 and rp1 equal to point p. If a=1, this instruction rounds
point p to the grid point specified by the state variable round_state. If a=0, it simply
marks the point as touched in the direction(s) specified by the current freedom_vector.
This command is often used to set points in the twilight zone.

Example:
MDAP[0]
When a=0, the point is simply marked as touched and the values of rp0 and rp1 set to
point p.

MDAP[1] assuming that the round_state is round to grid and the freedom_vector is a
shown.

Move Indirect Absolute Point
ﾉ

Expand table

MIAP[a]
Code Range

0x3E - 0x3F

a

0: don’t round the distance and don’t look at the control_value_cut_in
1: round the distance and look at the control_value_cut_in

Pops

n: CVT entry number (uint32)
p: point number (uint32)

Pushes

-

Sets

rp0 = rp1 = point p

Uses

zp0, round_state, control_value_cut_in, freedom_vector, projection_vector

Moves point p to the absolute coordinate position specified by the nth Control Value
Table entry. The coordinate is measured along the current projection_vector. If a=1, the
position will be rounded as specified by round_state. If a=1, and if the device space
difference between the CVT value and the original position is greater than the
control_value_cut_in, then the original position will be rounded (instead of the CVT
value.)
Rounding is done as if the entire coordinate system has been rotated to be consistent
with the projection_vector. That is, if round_state is set to 1, and the projection_vector
and freedom_vector are at a 45° angle to the x-axis, then a MIAP[1] of a point to 2.9
pixels will round to 3.0 pixels along the projection_vector.
The Boolean a above controls both rounding and the use of the control_value_cut_in. If
you would like the meaning of this Boolean to specify only whether or not the MIAP[ ]
instruction should look at the control_value_cut_in value, use the ROFF[ ] instruction to
turn off rounding.
This instruction can be used to create Twilight Zone points.
Example:
MIAP[1] 4 7
case 1:
rounding is OFF

The point is moved to the position specified in the CVT.

case 2:
The cut_in test succeeds and rounding is RTG.
The value in the CVT is subjected to the rounding rule and then the point is moved to
the rounded position.

case 3:
The cut_in test fails and rounding is OFF.
Here the point is not moved.

case 4:
The cut_in test fails and rounding is RTG.
In this case the point is moved to the nearest grid position.

Move Direct Relative Point
ﾉ

MDRP[abcde]

Expand table

Code Range

0xC0 - 0xDF

a

0: do not set rp0 to point p after move
1: do set rp0 to point p after move

b

0: do not keep distance greater than or equal to minimum_distance
1: keep distance greater than or equal to minimum_distance

c

0: do not round distance
1: round the distance

de

distance type for engine characteristic compensation

Pops

p: point number (uint32)

Pushes

-

Sets

after point p is moved, rp1 is set equal to rp0, rp2 is set equal to point p; if the a
flag is set to TRUE, rp0 is set equal to point

Uses

zp0 with rp0 and zp1 with point p, round_state, single_width_value,
single_width_cut_in, freedom_vector, projection_vector.

MDRP moves point p along the freedom_vector so that the distance from its new
position to the current position of rp0 is the same as the distance between the two
points in the original uninstructed outline, and then adjusts it to be consistent with the
Boolean settings. Note that it is only the original positions of rp0 and point p and the
current position of rp0 that determine the new position of point p along the
freedom_vector.
MDRP is typically used to control the width or height of a glyph feature using a value
which comes from the original outline. Since MDRP uses a direct measurement and does
not reference the control_value_cut_in, it is used to control measurements that are
unique to the glyph being instructed. Where there is a need to coordinate the control of
a point with the treatment of points in other glyphs in the font, a MIRP instruction is
needed.
Though MDRP does not refer to the CVT, its effect does depend upon the single-width
cut-in value. If the device space distance between the measured value taken from the
uninstructed outline and the single_width_value is less than the single_width_cut_in, the
single_width_value will be used in preference to the outline distance. In other words, if
the two distances are sufficiently close (differ by less than the single_width_cut_in), the
single_width_value will be used.

The setting of the round_state Graphics State variable will determine whether and how
the distance of point p from point q is rounded. If the round bit is not set, the value will
be unrounded. If the round bit is set, the effect will depend upon the choice of rounding
state. The value of the minimum distance variable is the smallest possible value the
distance between two points can be rounded to.
Distances measured with the MDRP instruction must be either black, white or gray.
Indicating this via de allows the interpreter to compensate for engine characteristics as
needed. The value de specifies the distance type as described in the Instructing TrueType
Glyphs chapter. Three values are possible: Gray=0, Black=1, White=2.
Example 1:
Graphics State Settings

Before MDRP

rp0

7

rp1

?

rp2

?

ﾉ

Expand table

ﾉ

Expand table

Case 1:

After MDRP[00001] 8

rp0

7

rp1

7

rp2

8

Case 2:

After MDRP[10001] 8

ﾉ

rp0

8

rp1

7

rp2

8

Expand table

Example 2:
Point p is moved so that its distance from rp1 is the same as it was in the original
outline.

Move Indirect Relative Point
ﾉ

Expand table

MIRP[abcde]
Code Range

0xE0 - 0xFF

a

0: Do not set rp0 to p
1: Set rp0 to p

b

0: Do not keep distance greater than or equal to minimum_distance
1: Keep distance greater than or equal to minimum_distance

c

0: Do not round the distance and do not look at the control_value_cut_in

1: Round the distance and look at the control_value_cut_in value
de

distance type for engine characteristic compensation

Pops

n: CVT entry number (uint32)
p: point number (uint32)

Pushes

-

Uses

zp0 with rp0 and zp1 with point p. round_state, control_value_cut_in,
single_width_value, single_width_cut_in, freedom_vector, projection_vector

Sets

After it has moved the point this instruction sets rp1 = rp0, rp2 = point p, and if a
= 1, rp0 is set to point p.

A MIRP instruction makes it possible to preserve the distance between two points
subject to a number of qualifications. Depending upon the setting of Boolean flag b, the
distance can be kept greater than or equal to the value established by the
minimum_distance state variable. Similarly, the instruction can be set to round the
distance according to the round_state graphics state variable. The value of the minimum
distance variable is the smallest possible value the distance between two points can be
rounded to. Additionally, if the c Boolean is set, the MIRP instruction acts subject to the
control_value_cut_in. If the difference between the actual measurement and the value in
the CVT is sufficiently small (less than the cut_in_value), the CVT value will be used and
not the actual value. If the device space difference between this distance from the CVT
and the single_width_value is smaller than the single_width_cut_in, then use the
single_width_value rather than the outline or Control Value Table distance.
MIRP measures distance relative to point rp0. More formally, MIRP moves point p along
the freedom_vector so that the distance from p to rp0 is equal to the distance stated in
the reference CVT entry (assuming that the cut_in test succeeds)
The c Boolean above controls both rounding and the use of Control Value Table entries.
If you would like the meaning of this Boolean to specify only whether or not the MIRP[ ]
instruction should look at the control_value_cut_in, use the ROFF[ ] instruction to turn off
rounding. In this manner, it is possible to specify rounding off and no cut_in.
The value de specifies the distance type as described in the Instructing TrueType Glyphs
chapter. Three values are possible: Gray=0, Black=1, White=2.
Example 1:
MIRP[00110] 3 17
case 1:

The cut_in test succeeds and rounding is off.
The point is moved so that the distance from RP0 is equal to that given in CVT entry 17.

case 2:
The cut_in test succeeds and rounding is set to RTG.
The distance in the CVT is rounded and the point is moved by the rounded distance.

case 3:
The cut_in test fails and the round_state is OFF.
The point is not moved.

case 4:
The cut_in test fails and the round_state is RTG.
The current position of the point is rounded to the grid.

ALIGN Relative Point
ﾉ

Expand table

ALIGNRP[ ]
Code Range

0x3C

Pops

p: point number (uint32))

Pushes

-

Uses

zp1 with point p, zp0 with rp0, loop, freedom_vector, projection_vector.

Reduces the distance between rp0 and point p to zero. Since distance is measured along
the projection_vector and movement is along the freedom_vector, the effect of the
instruction is to align points.

case 1:

case 2:

Adjust Angle
This instruction is no longer supported.

Move point p to the InterSECTion of two lines
ﾉ

Expand table

ISECT[ ]
Code Range

0x0F

Pops

b1: end point of line 2 (uint32)
b0: start point of line 2 (uint32)
a1: end point of line 1 (uint32)
a0: start point of line 1 (uint32)
p: point to move (uint32)

Pushes

-

Uses

zp2 with point p, zp1 with line A, zp0 with line B

Puts point p at the intersection of the lines A and B. The points a0 and a1 define line A.
Similarly, b0 and b1 define line B. ISECT ignores the freedom_vector in moving point p.

Example:
ISECT[ ] 21 9 5 4 7

If lines A and B are parallel, point p is moved to a position in the middle of the lines.
That is:
px = (a0x + a1x)/4 + (b0x + b1x)/4
py = (a0y + a1y)/4 + (b0y + b1y)/4
Example:
ISECT[ ] 21 9 5 4 7

ALIGN Points
ﾉ

ALIGNPTS[ ]
Code Range

0x27

Pops

p1: point number (uint32)
p2: point number (uint32)

Expand table

Pushes

-

Uses

zp1 with point p1, zp0 with point p2, freedom_vector, projection_vector.

Makes the distance between point 1 and point 2 zero by moving both along the
freedom_vector to the average of both their projections along the projection_vector.

Example:
ALIGNPTS[] 3 7

Interpolate Point by the last relative stretch
ﾉ

Expand table

IP[ ]
Code
Range

0x39

Pops

p: point number (uint32)

Pushes

-

Uses

zp0 with rp1, zp1 with rp2, zp2 with point p, loop, freedom_vector,
projection_vector

Moves point p so that its relationship to rp1 and rp2 is the same as it was in the original
uninstructed outline. Measurements are made along the projection_vector, and
movement to satisfy the interpolation relationship is constrained to be along the

freedom_vector. This instruction is not valid if rp1 and rp2 have the same position on
the projection_vector.

In the example shown, assume that the points referenced by rp1 and rp2 are moved as
shown. An IP instruction is then used to preserve their relative relationship with point p.
After the IP the following should be true
D(p, rp1)/D(p',rp1') = D(p,rp2)/D(p', rp2')
In other words, the relative distance is preserved.

UnTouch Point
ﾉ

Expand table

UTP[ ]
Code Range

0x29

Pops

p: point number (uint32)

Pushes

-

Uses

zp0 with point p, freedom_vector

Marks point p as untouched. A point may be touched in the x direction, the y direction,
both, or neither. This instruction uses the current freedom_vector to determine whether
to untouch the point in the x-direction, the y direction, or both. Points that are marked
as untouched will be moved by an IUP (interpolate untouched points) instruction. Using
UTP you can ensure that a point will be affected by IUP even if it was previously
touched.

Interpolate Untouched Points through the outline
ﾉ

Expand table

IUP[a]
Code Range

0x30 - 0x31

a

0: interpolate in the y-direction
1: interpolate in the x-direction

Pops

-

Pushes

-

Uses

zp2

Considers a glyph contour by contour, moving any untouched points in each contour
that are between a pair of touched points. If the coordinates of an untouched point
were originally between those of the touched pair, it is linearly interpolated between the
new coordinates, otherwise the untouched point is shifted by the amount the nearest
touched point is shifted.
This instruction operates on points in the glyph zone pointed to by zp2. This zone
should almost always be zone 1. Applying IUP to zone 0 is an error.
Consider three consecutive points all on the same contour. Two of the three points, p1
and p3 have been touched. Point p2 is untouched. The effect of an IUP in the x-direction
is to move point p2 so that is in the same relative position to points p1 and p3 before
they were moved.
The IUP instruction does not touch the points it moves. Thus, the untouched points
affected by an IUP instruction will be affected by subsequent IUP instructions unless
they are touched by an intervening instruction. In this case, the first interpolation is
ignored, and the point is moved based on its original position.

Managing exceptions
DELTA instructions can be used to alter the outline of a glyph at a particular size. They
are generally used to turn on or off specific pixels. Delta instructions work by moving
points (DELTAP’s) or by changing a value in the Control Value Table (DELTAC’s).
More formally, the DELTA instructions take a variable number of arguments from the
stack and allow the use of an exception of the form: at size x apply the movement d to
point p (or at size x add or subtract an amount less than or equal to the Control Value
Table entry c). DELTAs take a list of exceptions of the form: relative ppem value, the
magnitude of the exception and the point number to which the exception is to be
applied.
Each DELTA instruction works on a range of sizes as specified below. As a result, sizes are
specified in relative pixels per em (ppem), that is relative to the delta_base. The default
value for delta_base is 9 ppem. To set delta_base to another value, use the SDB
instruction.
The DELTAP1 and DELTAC1 instructions allow values to be changed for glyphs at 9
through 24 ppem, assuming the default value for delta_base. Lowering the value for
delta_base allows you to invoke exceptions at a smaller number of ppem.
DELTAP2 and DELTAC2 are triggered at 16 ppem higher than the value set for DELTAP1
and DELTAC1, and consequently the formula for the relative ppem is
ppem - 16 - delta_base.
DELTAP3 and DELTAC3 are triggered at 16 ppem higher than the value set for DELTAP2
and DELTAC2, or 32 ppem higher than the value set for DELTAP1 and DELTAC1, and
consequently the formula for the relative ppem is:
ppem - 32 - delta_base.

ﾉ

DELTA*1

delta_base through delta_base + 15 ppem

DELTA*2

delta_base + 16 ppem through delta_base + 31 ppem

DELTA*3

delta_base + 32 ppem through delta_base + 47 ppem

Expand table

In specifying a DELTA instruction, the high 4 bits of arg1 describe the relative ppem value
that will activate the exception.
The low 4 bits of arg1 describe the magnitude of the exception. The amount the point
moves is a function of the exception stated and the Graphics State variable delta_shift.
To set delta_shift, use the SDS instruction

NOTE: Always observe that DELTA instructions expect the argument list to be sorted
according to ppem. The lowest ppem should be deepest on the stack, and the highest
ppem should be topmost on the stack.
In the descriptions of the instructions that follow, pi is a point number, ci is a Control
Value Table entry number and argi is a byte composed of two parts: the relative ppem
(ppem - delta_base) and the magnitude of the exception.
Increasing the delta_shift will allow for more fine control over pixel movement at the
sacrifice of total range of movement. A step is the minimal amount that a delta
instruction can move a point. Points can be moved in integral multiples of steps.
The size of a step is 1 divided by 2 to the power delta_shift. The range of movement
produced by a given delta_shift can be calculated by taking the number of steps allowed
(16) and dividing it by 2 to the power delta_shift. For example, a delta_shift equal to 2
allows the smallest movement to be ± 1/4 pixel (because 22 equals 4) and the largest
movement to be ± 2 pixels (16/4 = 4 pixels of movement). A delta_shift of 5 allows the
smallest movement to be ± 1/32 pixel (because 25 equals 32), but the largest movement
is limited to ± 1/4 pixel. (16/32 = 1/2 a pixel of movement).
Internally, the value obtained for the exception is stored as a 4 bit binary number. As a
result, the desired output range must be converted to a number between 0 and 15
before being converted to binary. Here is the internal remapping table for the DELTA
instructions.
NOTE: that zero is lacking in the output range.
ﾉ

Expand table

Number of Steps

→ Exception

-8

0

-7

1

-6

2

-5

3

-4

4

-3

5

-2

6

-1

7

1

8

2

9

3

10

4

11

5

12

6

13

7

14

8

15

DELTA exception P1
ﾉ

Expand table

DELTAP1[ ]
Code
Range

0x5D

Pops

n: number of pairs of exception specifications and points (uint32)
p1, arg1, p2, arg2, ..., pnn argn: n pairs of exception specifications and points (pairs
of uint32s)

Pushes

-

Uses

zp0, delta_base, delta_shift

DELTAP1 moves the specified points at the size and by the amount specified in the
paired argument. An arbitrary number of points and arguments can be specified.
The grouping [pi, argi] can be executed n times. The value of argi may vary between
iterations.

DELTA exception P2
ﾉ

Expand table

DELTAP2[ ]
Code
Range

0x71

Pops

n: number of pairs of exception specifications and points (uint32)
p1, arg1, p2, arg2, ..., pnn argn: n pairs of exception specifications and points (pairs
of uint32s)

Pushes

-

Uses

zp0, delta_shift, delta_base

DELTAP2 moves the specified points at the size and by the amount specified in the
paired argument. An arbitrary number of points and arguments can be specified.
The grouping [pi, argi] can be executed n times. The value of argi may vary between
iterations.

DELTA exception P3
ﾉ

Expand table

DELTAP3[ ]
Code
Range

0x72

Pops

n: number of pairs of exception specifications and points (uint32)
p1, arg1, p2, arg2, ..., pnn argn: n pairs of exception specifications and points (pairs
of uint32s)

Pushes

-

Uses

zp0, delta_base, delta_shift

DELTAP3 moves the specified points at the size and by the amount specified in the
paired argument. An arbitrary number of point and arguments can be specified.
The grouping [pi, argi] can be executed n times. The value of argi may vary between
iterations.

DELTA exception C1
ﾉ

Expand table

DELTAC1[ ]
Code Range

0x73

Pops

n: number of pairs of exception specifications and CVT entry numbers (uint32)
c1, arg1, c2, arg2,..., cn, argn: (pairs of uint32s)

Pushes

-

DELTAC1 changes the value in each CVT entry specified at the size and by the amount
specified in its paired argument.
The grouping [ci, argi] can be executed n times. The value of argi may vary between
iterations.

DELTA exception C2
ﾉ

Expand table

DELTAC2[ ]
Code Range

0x74

Pops

n: number of pairs of exception specifications and CVT entry numbers (uint32)
c1, arg1, c2, arg2,..., cn, argn: (pairs of uint32s)

Pushes

-

DELTAC2 changes the value in each CVT entry specified at the size and by the amount
specified in its paired argument.
The grouping [ci, argi] can be executed n times. The value of argi may vary between
iterations.

DELTA exception C3
ﾉ

Expand table

DELTAC3[ ]
Code Range

0x75

Pops

n: number of pairs of exception specifications and CVT entry numbers (uint32)
c1, arg1, c2, arg2,..., cn, argn: (pairs of uint32s)

Pushes

-

DELTAC3 changes the value in each CVT entry specified at the size and by the amount
specified in its paired argument.
The grouping [ci, argi] can be executed n times. The value of argi may vary between
iterations.

Example of DELTA exceptions
Assume that you want to move point 15 of your glyph 1/8 of a pixel along the
freedom_vector at 12 pixels per em. Assume that delta_base has the default value 9 and
delta_shift the default value 3.
To specify that the exception should be made at 12 ppem, you subtract the delta_base,
which is 9, from 12 and store the result, which is 3, in the high nibble of argi.
To specify that the point is to be moved 1/8 of a pixel, multiply 1/8 by 2 raised to the
power delta_shift. In other words, you multiply 1/8 by 2 raised to the third power (or 8)
yielding 1. This value must be mapped to an internal value which using the table shown
is 8.
Putting these two results together yields a 3 in the high nibble and an 8 in the low
nibble or 56 (00111000, in binary).
To obtain this single exception, the top of the stack is: 56, 15, 1.

(iteration)
(point number)
(arg1: ppem and magnitude)

Now if the interpreter executes
DELTAP1[ ]
then this instruction will move point 15 of the glyph (at 12 ppem) 1/8 of a pixel along
the freedom_vector.

Managing the stack
The following set of instructions make it possible to manage elements on the stack.
They make it possible to duplicate the element at the top of the stack, remove the top
element from the stack, clear the stack, swap the top two stack elements, determine the
number of elements currently on the stack, copy a specified element to the top of the
stack, move a specified element to the top of the stack, and rearrange the order of the
top three elements on the stack.

DUPlicate top stack element
ﾉ

Expand table

ﾉ

Expand table

DUP[ ]
Code Range

0x20

Pops

e: stack element (uint32)

Pushes

e, e (two uint32s)

Duplicates the element at the top of the stack.

POP top stack element

POP[ ]
Code Range

0x21

Pops

e: stack element (uint32)

Pushes

-

Pops the top element of the stack.

CLEAR the entire stack
ﾉ

Expand table

ﾉ

Expand table

CLEAR[ ]
Code Range

0x22

Pops

all the items on the stack (uint32s)

Pushes

-

Clears all elements from the stack.

SWAP the top two elements on the stack

SWAP[ ]
Code Range

0x23

Pops

e2: stack element (uint32)
e1: stack element (uint32)

Pushes

e1, e2 (pair of uint32s)

Swaps the top two elements of the stack making the old top element the second from
the top and the old second element the top element.

Return the DEPTH of the stack
ﾉ

Expand table

DEPTH[ ]
Code Range

0x24

Pops

-

Pushes

n: number of elements (uint32)

Pushes n, the number of elements currently in the stack onto the stack.

Example:

Copy the INDEXed element to the top of the stack
ﾉ

CINDEX[ ]

Expand table

Code Range

0x25

Pops

k : stack element number

Pushes

ek: indexed element (uint32)

Puts a copy of the kth stack element on the top of the stack.

Example:

Move the INDEXed element to the top of the stack
ﾉ

MINDEX[ ]
Code Range

0x26

Pops

k : stack element number

Pushes

ek: indexed element

Moves the indexed element to the top of the stack.

MINDEX[ ]

Expand table

ROLL the top three stack elements
ﾉ

Expand table

ROLL[ ]
Code Range

0x8a

Pops

a, b, c (top three stack elements)

Pushes

b, a, c (elements reordered)

Performs a circular shift of the top three objects on the stack with the effect being to
move the third element to the top of the stack and to move the first two elements down
one position. ROLL is equivalent to MINDEX[ ] 3.

Managing the flow of control
This section describes those instructions that make it possible to alter the sequence in
which items in the instruction stream are executed. The IF and JMP instructions and their
variants work by testing the value of an element on the stack and changing the value of
the instruction pointer accordingly.

IF test

ﾉ

Expand table

IF[ ]
Code Range

0x58

Pops

e: stack element (uint32)

Pushes

-

Tests the element popped off the stack: if it is zero (FALSE), the instruction pointer is
jumped to the next ELSE or EIF instruction in the instruction stream. If the element at the
top of the stack is nonzero (TRUE), the next instruction in the instruction stream is
executed. Execution continues until an ELSE instruction is encountered or an EIF
instruction ends the IF. If an else statement is found before the EIF, the instruction
pointer is moved to the EIF statement.
case 1:
Element at top of stack is TRUE; instruction pointer is unaffected. IF terminates with EIF.

case 2:
Element at top of stack is TRUE. The instruction stream is sequentially executed until
ELSE is encountered whereupon the instruction pointer jumps to the EIF statement that
terminates the IF.

case 3:
Element at the top of the stack is FALSE; instruction pointer is moved to the ELSE
statement; instructions are then executed sequentially; EIF ends the IF statement.

ELSE
ﾉ

Expand table

ELSE[ ]
Code Range

0x1B

Pops

-

Pushes

-

Marks the start of the sequence of instructions that are to be executed if an IF
instruction encounters a FALSE value on the stack. This sequence of instructions is
terminated with an EIF instruction.

End IF
ﾉ

EIF[ ]
Code Range

0x59

Pops

-

Pushes

-

Marks the end of an IF[ ] instruction.

Expand table

Jump Relative On True
ﾉ

Expand table

JROT[ ]
Code Range

0x78

Pops

e: stack element (uint32)
offset: number of bytes to move instruction pointer (int32)

Pushes

-

Pops and tests the element value, and then pops the offset. If the element value is nonzero (TRUE), the signed offset will be added to the instruction pointer and execution will
be resumed at the address obtained. Otherwise, the jump is not taken and the next
instruction in the instruction stream is executed. The jump is relative to the position of
the instruction itself. That is, the instruction pointer is still pointing at the JROT[ ]
instruction when offset is added to obtain the new address.

Example:
case 1:
Boolean is FALSE.

case 2:
Boolean is TRUE.

JuMP
ﾉ

Expand table

JMPR[ ]
Code Range

0x1C

Pops

offset: number of bytes to move instruction pointer (int32)

Pushes

-

The signed offset is added to the instruction pointer and execution is resumed at the
new location in the instruction stream. The jump is relative to the position of the
instruction itself. That is, the instruction pointer is still pointing at the JROT[ ] instruction
when offset is added to obtain the new address.

Jump Relative On False
ﾉ

JROF[ ]
Code Range

0x79

Pops

e: stack element (uint32)
offset: number of bytes to move instruction pointer (int32)

Pushes

-

Expand table

Pops and tests the element value, and then pops the offset. If the element value is zero
(FALSE), the signed offset will be added to the instruction pointer and execution will be
resumed at the address obtained. Otherwise, the jump is not taken and the next
instruction in the instruction stream is executed. The jump is relative to the position of
the instruction itself. That is, the instruction pointer is still pointing at the JROT[ ]
instruction when the offset is added to obtain the new address.

case 1:
element is FALSE.

case 2:
element is TRUE.

Logical functions

The TrueType instruction set includes a set of logical functions that can be used to test
the value of a stack element or to compare the values of two stack elements. The logical
functions compare 32-bit values (uint32) and return a Boolean value to the top of the
stack.
To easily remember the order in which stack values are handled during logical
operations, imagine writing the stack values from left to right, starting with the bottom
value. Then insert the operator between the two furthest right elements. For example:

GT a,b would be interpreted as (b>a):
cb>a

Less Than
ﾉ

Expand table

LT[ ]
Code Range

0x50

Pops

e2: stack element (uint32)
e1: stack element (uint32)

Pushes

Boolean value (uint32 in the range [0,1])

First pops e2, then pops e1 off the stack and compares them: if e1 is less than e2, 1,
signifying TRUE, is pushed onto the stack. If e1 is not less than e2, 0, signifying FALSE, is
placed onto the stack.

Example:
LT[ ]

Less Than or EQual
ﾉ

Expand table

LTEQ[ ]
Code Range

0x51

Pops

e2: stack element (uint32)
e1: stack element (uint32)

Pushes

Boolean value (uint32 in the range [0,1])

Pops e2 and e1 off the stack and compares them. If e1 is less than or equal to e2, 1,
signifying TRUE, is pushed onto the stack. If e1 is not less than or equal to e2, 0,
signifying FALSE, is placed onto the stack.

Example:
LTEQ[ ]

Greater Than
ﾉ

Expand table

GT[ ]
Code Range

0x52

Pops

e2: stack element (uint32)
e1: stack element (uint32)

Pushes

Boolean value (uint32 in the range [0,1])

First pops e2 then pops e1 off the stack and compares them. If e1 is greater than e2, 1,
signifying TRUE, is pushed onto the stack. If e1 is not greater than e2, 0, signifying
FALSE, is placed onto the stack.

Example:
GT[ ]

Greater Than or EQual
ﾉ

GTEQ[ ]
Code Range

0x53

Pops

e2: stack element (uint32)

Expand table

e1: stack element (uint32)
Pushes

Boolean value (uint32 in the range [0,1])

Pops e1 and e2 off the stack and compares them. If e1 is greater than or equal to e2, 1,
signifying TRUE, is pushed onto the stack. If e1 is not greater than or equal to e2, 0,
signifying FALSE, is placed onto the stack.

Example:
GTEQ[ ]

EQual
ﾉ

Expand table

EQ[ ]
Code Range

0x54

Pops

e2: stack element (uint32)
e1: stack element (uint32)

Pushes

Boolean value (uint32 in the range [0,1])

Pops e1 and e2 off the stack and compares them. If they are equal, 1, signifying TRUE is
pushed onto the stack. If they are not equal, 0, signifying FALSE is placed onto the stack.

Example:
EQ[ ]

Not EQual
ﾉ

Expand table

NEQ[ ]
Code Range

0x55

Pops

e2: stack element (uint32)
e1: stack element (uint32)

Pushes

Boolean value (uint32 in the range [0,1])

Pops e1 and e2 from the stack and compares them. If they are not equal, 1, signifying
TRUE, is pushed onto the stack. If they are equal, 0, signifying FALSE, is placed on the
stack.

Example:

NEQ[ ]

ODD
ﾉ

Expand table

ODD[ ]
Code Range

0x56

Pops

e1: stack element (F26Dot6)
Boolean value

Pushes

Boolean value (uint32 in the range [0,1])

Uses

round_state

Tests whether the number at the top of the stack is odd. Pops e1 from the stack and
rounds it as specified by the round_state before testing it. After the value is rounded, it
is shifted from a fixed-point value to an integer value (any fractional values are ignored).
If the integer value is odd, one, signifying TRUE, is pushed onto the stack. If it is even,
zero, signifying FALSE, is placed onto the stack.

Example:
ODD[ ]
This example assumes that round_state is RTG.

EVEN
ﾉ

Expand table

EVEN[ ]
Code Range

0x57

Pops

e1: stack element (F26Dot6)

Pushes

Boolean value (uint32 in the range [0,1])

Uses

round_state

Tests whether the number at the top of the stack is even. Pops e1 off the stack and
rounds it as specified by the round_state before testing it. If the rounded number is
even, one, signifying TRUE, is pushed onto the stack if it is odd, zero, signifying FALSE, is
placed onto the stack.

Example:
EVEN[ ]
This example assumes that round_state is RTG.

logical AND
ﾉ

AND[ ]
Code Range

0x5A

Pops

e1: stack element (uint32)
e2: stack element (uint32)

Expand table

Pushes

( e1 and e2 ): logical and of e1 and e2 (uint32)

Pops e1 and e2 off the stack and pushes onto the stack the result of a logical and of the
two elements. Zero is returned if either or both of the elements are FALSE (have the
value zero). One is returned if both elements are TRUE (have a non-zero value).

Example:
case 1:
AND[ ]

case 2:
AND[ ]

logical OR
ﾉ

OR[ ]
Code Range

0x5B

Expand table

Pops

e1: stack element (uint32)
e2: stack element (uint32)

Pushes

( e1 or e2 ): logical or of e1 and e2 (uint32)

Pops e1 and e2 off the stack and pushes onto the stack the result of a logical or
operation between the two elements. Zero is returned if both of the elements are FALSE.
One is returned if either one or both of the elements are TRUE (has a nonzero value).

Example:
case 1:
OR[ ]

case 2:
OR[ ]

logical NOT
ﾉ

Expand table

NOT[ ]
Code Range

0x5C

Pops

e: stack element (uint32)

Pushes

(not e): logical negation of e (uint32)

Pops e off the stack and returns the result of a logical NOT operation performed on e. If
originally zero, one is pushed onto the stack if originally nonzero, zero is pushed onto
the stack.

Example:
case 1:

case 2:

Arithmetic and math instructions
These instructions perform arithmetic on stack values. Values are treated as signed
(two’s complement) 26.6 fixed-point numbers (F26Dot6) and give results in the same
form. There is no overflow or underflow protection for these instructions.
To easily remember the order in which stack values are handled during arithmetic
operations, imagine writing the stack values from left to right, starting with the bottom
value. Then insert the operator between the two furthest right elements. For example:

subtract a,b would be interpreted as (b-a): c b - a

ADD
ﾉ

Expand table

ADD[ ]
Code Range

0x60

Pops

n1, n2 (F26Dot6)

Pushes

(n2 + n1)

Pops n1 and n2 off the stack and pushes the sum of the two elements onto the stack.

SUBtract
ﾉ

Expand table

SUB[ ]
Code Range

0x61

Pops

n1, n2 (F26Dot6)

Pushes

(n2 - n1): difference

Pops n1 and n2 off the stack and pushes the difference between the two elements onto
the stack.

DIVide
ﾉ

Expand table

DIV[ ]
Code Range

0x62

Pops

n1: divisor (F26Dot6)
n2: dividend (F26Dot6)

Pushes

n2/n1 (F26Dot6)

Pops n1 and n2 off the stack and pushes onto the stack the quotient obtained by
dividing n2 by n1. Note that this truncates rather than rounds the value. The TrueType
Rasterizer v.1.7 and later will catch any division-by-zero errors.

MULtiply
ﾉ

MUL[ ]
Code Range

0x63

Pops

n1, n2: multiplier and multiplicand (F26Dot6)

Pushes

n1 * n2 (F26Dot6)

Expand table

Pops n1 and n2 off the stack and pushes onto the stack the product of the two
elements.

ABSolute value
ﾉ

ABS[ ]
Code Range

0x64

Pops

n

Pushes

|n|: absolute value of n (F26Dot6)

Pops n off the stack and pushes onto the stack the absolute value of n.

Example:
case 1:

case 2:

NEGate

Expand table

ﾉ

Expand table

NEG[ ]
Code Range

0x65

Pops

n1

Pushes

-n1: negation of n1 (F26Dot6)

This instruction pops n1 off the stack and pushes onto the stack the negated value of
n1.

NEG[ ]

FLOOR
ﾉ

FLOOR[ ]
Code Range

0x66

Pops

n1: number whose floor is desired (F26Dot6)

Pushes

n : floor of n1 (F26Dot6)

Pops n1 and returns n, the greatest integer value less than or equal to n1.

Example:
FLOOR[ ]

Expand table

case 1:

case 2:

case 3:

CEILING
ﾉ

Expand table

CEILING[ ]
Code Range

0x67

Pops

n1: number whose ceiling is desired (F26Dot6)

Pushes

n: ceiling of n1 (F26Dot6)

Pops n1 and returns n, the least integer value greater than or equal to n1. For instance,
the ceiling of 15 is 15, but the ceiling of 15.3 is 16. The ceiling of -0.8 is 0. (n is the least
integer value greater than or equal to n1)

Example:
CEILING[ ]
case 1:

case 2:

MAXimum of top two stack elements
ﾉ

Expand table

MAX[ ]
Code Range

0x8B

Pops

e1: stack element (uint32)
e2: stack element (uint32)

Pushes

maximum of e1 and e2

Pops two elements, e1 and e2, from the stack and pushes the larger of these two
quantities onto the stack.

MINimum of top two stack elements
ﾉ

MIN[ ]
Code Range

0x8C

Pops

e1: stack element (uint32)

Expand table

e2: stack element (uint32)
Pushes

minimum of e1 and e2

Pops two elements, e1 and e2, from the stack and pushes the smaller of these two
quantities onto the stack.

Compensating for the engine characteristics
The following two functions make it possible to compensate for the engine
characteristic. Each takes a value and makes the compensation. In addition to the engine
compensation, ROUND, rounds the value according to the round_state. NROUND only
compensates for the engine.

ROUND value
ﾉ

Expand table

ROUND[ab]
Flags

ab: distance type for engine characteristic compensation

Pops

n1

Pushes

n2

Code

0x68 - 0x6B

Rounds a value according to the state variable round_state while compensating for the
engine. n1 is popped off the stack and, depending on the engine characteristics, is
increased or decreased by a set amount. The number obtained is then rounded and
pushed back onto the stack as n2.
The value ab specifies the distance type as described in the Instructing TrueType Glyphs
chapter. Three values are possible: Gray=0, Black=1, White=2.

No ROUNDing of value
ﾉ

Expand table

NROUND[ab]
Flags

ab: distance type for engine characteristic compensation

Pops

n1

Pushes

n2

Code

0x6C - 0x6F

NROUND[ab] does the same operation as ROUND[ab] (above), except that it does not
round the result obtained after compensating for the engine characteristics. n1 is
popped off the stack and, depending on the engine characteristics, increases or
decreases by a set amount. This figure is then pushed back onto the stack as n2.
The value ab specifies the distance type as described in the Instructing TrueType Glyphs
chapter. Three values are possible: Gray=0, Black=1, White=2.

Defining and using functions and instructions
The following instructions make it possible to define and use both functions and new
instructions.
In addition to a simple call function, there is a loop and call function.
An IDEF or instruction definition call makes it possible to patch old scalers in order to
add newly defined instructions.

Function DEFinition
ﾉ

Expand table

FDEF[ ]
Code
Range

0x2C

Pops

f: function identifier number (integer in the range 0 to n-1 where n is specified in
the 'maxp' table )

Pushes

-

Marks the start of a function definition. The argument f is a number that uniquely
identifies this function. A function definition can appear only in the Font Program or the
CVT program; attempts to invoke the FDEF instruction within a glyph program will result
in an error. Functions must not exceed 64K in size.

END Function definition
ﾉ

Expand table

ﾉ

Expand table

ENDF[ ]
Code Range

0x2D

Pops

-

Pushes

-

Marks the end of a function definition or an instruction definition.

CALL function

CALL[ ]
Code
Range

0x2B

Pops

f: function identifier number (integer in the range 0 to n-1 where n is specified in
the 'maxp' table )

Pushes

-

Calls the function identified by the number f.

LOOP and CALL function

ﾉ

Expand table

LOOPCALL[
]
Code Range

0x2A

Pops

f: function number integer in the range 0 to n-1 where n is specified in the 'maxp'
table
count: number of times to call the function (signed word)

Pushes

-

Calls the function f, count number of times.

Example:
Assume the Font Program contains this:

PUSHB[000]
17
/* push 17 onto the stack */
FDEF[ ]
/* start defining function 17 */
/*
contents of function
*/
ENDF[ ]
/* end the function definition */
PUSHB[000]
5
/* push count */
PUSHB[000]
17
/* push function number */
LOOPCALL[ ]
/* call function 17, 5 times */

Instruction DEFinition
ﾉ

IDEF[ ]
Code Range

0x89

Expand table

Pops

opcode (8-bit code padded with zeroes to uint32)

Pushes

-

Begins the definition of an instruction. The instruction definition terminates when at
ENDF, which is encountered in the instruction stream. Subsequent executions of the
opcode popped will be directed to the contents of this instruction definition (IDEF).
IDEFs must be defined in the Font Program or the CVT Program; attempts to invoke the
IDEF instruction within a glyph program will result in an error. An IDEF affects only
undefined opcodes. If the opcode in question is already defined, the interpreter will
ignore the IDEF. This is to be used as a patching mechanism for future instructions.
Instructions must not exceed 64K in size.

Debugging
The TrueType instruction set provides the following instruction as an aid to debugging.

DEBUG call
ﾉ

Expand table

DEBUG[ ]
Code Range

0x4F

Pops

number (uint32)

Pushes

-

This instruction is only for debugging purposes and should not be a part of a finished
font. Some implementations might not support this instruction.

Miscellaneous instructions
The following instruction obtains information about the current glyph and the scaler
version.

GET INFOrmation
ﾉ

Expand table

GETINFO[ ]
Code Range

0x88

Pops

selector (integer)

Pushes

result (integer)

GETINFO is used to obtain data about the font scaler version and the characteristics of
the current glyph. The instruction pops a selector used to determine the type of
information desired and pushes a result onto the stack.
Selector bit 0 indicates that the scaler version number is the desired information.
Selector bit 1 indicates a request for glyph rotation status. Selector bit 2 asks whether
the glyph has been stretched. Selector bit 3 asks if OpenType Font Variations are
supported. Selector bit 4 asks if vertical phantom points are being used. Selector bit 5
asks whether the glyph is being rasterized for grayscale.
Selector bit 3 indicates a query as to whether or not OpenType Font Variations are
supported. The result is returned in bit 10: if bit 10 is set, Font Variations are supported.
Selector bit 4 indicates a query as to whether vertical phantom points are supported.
The result is returned in bit 11: if bit 11 is set, vertical phantom points are supported.
Note: on MS Rasterizer, this method is not supported until MS Rasterizer 2.2 — version
number 41 or later. For versions prior to version 41, see the note below.
The following selectors are for ClearType information. Selector bit 6 indicates that
ClearType is enabled. Selector bit 7 indicates that “compatible-width” ClearType is
enabled. Selector bit 8 indicates that symmetrical smoothing ClearType is enabled.
Selector bit 9 indicates that ClearType is processing the LCD stripes in BGR (Blue, Green,
Red) order.
The result pushed onto the stack contains the requested information. More precisely,
bits 0 through 7 comprise the Scaler version number. Refer to the table below for the
meaning of the version numbers. Version numbers 0, 4 through 32, and 43 through 255
are reserved.
Note: On MS Rasterizer, selector bit 4 could not be reliably used to query for support of
vertical phantom points prior to MS Rasterizer v.2.2, though support for vertical
phantom points was added in MS Rasterizer v.1.7. Before hinting vertical phantom

points or asking for grayscale information, use GETINFO to check that the rasterizer in
use is version number 35 or later. Before checking if ClearType is enabled, make sure
that the rasterizer is version number is 36 or greater. For the other ClearType bits, make
sure that the rasterizer is version number 37 or greater.
Bit 8 is set to 1 if the current glyph has been rotated. It is zero otherwise.
Bit 9 is set to 1 if the current glyph has been stretched. It is set to 0 otherwise.
Bit 10 is set to 1 if OpenType Font Variations are supported (for MS Rasterizer v.2.2 and
later). It is set to 0 otherwise.
Bit 11 is set to 1 if vertical phantom points are used (for MS Rasterizer v.2.2 and later). It
is set to zero otherwise.
Bit 12 is set to 1 if the rasterization is for grayscale using the font smoothing technique
(for MS rasterizer v.1.7 and later).
Bit 13 is set to 1 if ClearType is enabled (for MS rasterizer v.1.6+ or MS rasterizer v.1.8
and later). It is set to 0 otherwise.
Bit 14 is set to 1 if ClearType widths are compatible with bi-level and grayscale widths
(for MS Rasterizer v.1.8 and later). It is set to 0 if the widths are the natural ClearType
widths.
Bit 15 is set to 1 if ClearType symmetrical smoothing is being used (for MS Rasterizer
v.1.8 and later). It is set to 0 otherwise.
Bit 16 is set to 1 if ClearType is processing the LCD stripes in BGR (Blue, Green, Red)
order (for MS Rasterizer v.1.8 and later). It is set to 0 otherwise.
Bit 17 is set to 1 if ClearType sub-pixel text is being used (for MS Rasterizer 2.0 and
later). In this case, any hints on the right side-bearing point are ignored. Hints to
sharpen stems may also have minimal effect. It is set to 0 otherwise.
Bit 18 is set to 1 if ClearType symmetric rendering is being used (for MS Rasterizer v.2.0
and later). Depending on the horizontal LCD stripe orientation, this can impact the
rendering of horizontal features. It is set to 0 otherwise.
Bit 19 is set to 1 if ClearType gray rendering is being used (for MS Rasterizer v.2.1 and
later). It is set to 0 otherwise.
When the selector is set to request more than one piece of information, that information
is OR’d together and pushed onto the stack. For example, a selector value of 6 requests

both information on rotation and stretching and will result in the setting of both bits 8
and 9.
The following table encapsulates the above information.
ﾉ

Query
Selector

Query
Selector Bit

Bit

Mask

Version

0

Glyph Rotation

Expand table

Result
Bits

Result Bit
Mask

Version
Requirements

0x00000001

0-7

0x000000FF

All

1

0x00000002

8

0x00000100

All

Glyph Stretched

2

0x00000004

9

0x00000200

All

Font Variations

3

0x00000008

10

0x00000400

(>= 5 && <=32) ||
(>= 41 && <= 64)

Vertical Phantom
Points

4

0x00000010

11

0x00000800

(>= 5 && <=32) ||
(>= 41 && <= 64)

Windows Font
Smoothing
Grayscale

5

0x00000020

12

0x00001000

(>= 34 && <= 64)

ClearType enabled

6

0x00000040

13

0x00002000

(>= 36 && <= 64)

ClearType
compatible widths
enabled

7

0x00000080

14

0x00004000

(>= 37 && <= 64)

ClearType

8

0x00000100

15

0x00008000

(>= 37 && <= 64)

ClearType BGR
LCD stripe order

9

0x00000200

16

0x00010000

(>= 37 && <= 64)

ClearType subpixel positioned
text enabled

10

0x00000400

17

0x00020000

(>= 39 && <= 64)

ClearType
symmetric
rendering enabled

11

0x00000800

18

0x00040000

(>= 40 && <= 64)

ClearType Gray
rendering enabled

12

0x00001000

19

0x00080000

(>= 40 && <= 64)

Horizontal LCD
stripe orientation

The version information is as follows:
ﾉ

GETINFO
Version

Microsoft Rasterizer
Version

Notes

1

Macintosh System 6 INIT

2

Macintosh System 7

3

1.0

Expand table

16-bit Windows 3.1.

4

Macintosh System 6.2

5

Kirin Printer

6

Macintosh System 7.1

7

Macintosh QuickDraw GX

33

1.5

32-bit version, new scan-convertor

34

1.6

Font smoothing, new SCANTYPE

35

1.7

Composite scaling changes

36

1.6+

“Classic” ClearType (Windows CE)

37

1.8

ClearType

38

1.9

Subpixel Positioned ClearType

39

2.0

Subpixel Positioned ClearType flag

40

2.1

Symmetric ClearType flag, ClearType Gray (and
flag)

41

2.2

OpenType Font Variations

42

2.3

GETVARIATION support

GET VARIATION

ﾉ

Expand table

GETVARIATION[ ]
Code Range

0x91

Pushes

Normalized axes coordinates, one for each axis in the font. (Values are 2.14
fixed-point numbers padded with zeroes in the upper 16 bits.)

GETVARIATION is used to obtain the current normalized variation coordinates for each
axis. The coordinate for the first axis, as defined in the 'fvar' table, is pushed first on the
stack, followed by each consecutive axis until the coordinate for the last axis is on the
stack.
Since this instruction is not supported in every environment, it is required that an IDEF,
in either the 'fpgm' or 'prep' table, be provided for the GETVARIATION OpCode of 145
(0x91). Here is an example:

PUSHB[000] 145 /* OpCode 0x91, GetVariation */
IDEF[]
NPUSHW[] 2 /* Number of axes in this font */, 0, 0
ENDF[]

This program returns two zeroes on the stack, indicating the default values for each of
the two axes. Zeroes will be interpreted as the default values for this font. The 'maxp'
table should properly reflect the usage of the IDEF.
Notes:
In order to properly handle an instance font that is generated from a variable font, yet
still have the instructions provide the same behavior between the variable font and the
instance font, the following setup in the instance font is recommended.
Either identify and modify the existing, active IDEF for OpCode 0x91, or else add a new
IDEF for OpCode 0x91 at the end of the 'prep' table. Multiple IDEFs for the same
OpCode are valid, and the last one executed will be used. By placing a new IDEF at the
end of the 'prep' it is easier to dynamically update, and reduces the likelihood of
another IDEF overriding this one.
The default IDEF for OpCode 0x91, as noted above, usually returns zeroes on the stack,
indicating the default values. In the case of an instance font generated from a variable
font, the values to be returned must match the normalized values for the particular
instance, with the coordinate value for the first axis pushed first on the stack followed by

each consecutive axis in the order listed in the 'fvar' table. Caution should be made that
the 'maxp' table properly reflects the maxInstructionDefs and maxStackElements added
by this modification.
The following is an example of a replaced IDEF 145 (0x91) added for an instance:

PUSHB[000] 145 /* OpCode 0x91, GetVariation */
IDEF[]
NPUSHW[]
2 /* Number of axes in this font */, -16384, 0
ENDF[]

In this case, it provides the equivalent of GETVARIATION returning -1.0 for the first axis
and 0.0 for the second axis.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

Graphics State Summary
Article • 12/09/2021

The following tables summarize the variables that make up the Graphics State. Nearly all
of the Graphics State variables have a default value as shown below. That value is
reestablished for every glyph in a font. Instructions are available for resetting the value
of all Graphics State variables. Some state variables can be reset in the CVT Program. In
such cases the value set becomes the new default and will be reestablished for each
glyph. When value of a state variable is changed by instructions associated with a
particular glyph, it will hold only for that glyph.
The setting of the Graphics State variables will affect the actions of certain instructions.
Affected instructions are listed for each variable.
ﾉ

Expand table

Graphics State Variable

Default

Set With

Affects

auto_flip

TRUE

FLIPOFF
FLIPON

MIAP
MIRP

control_value_cut_in

17/16 pixels

SCVTCI

MIAP
MIRP

delta_base

9

SDB

DELTAP1
DELTAP2
DELTAP3
DELTAC1
DELTAC2
DELTAC3

delta_shift

3

SDS

DELTAP1
DELTAP2
DELTAP3
DELTAC1
DELTAC2
DELTAC3

dual_projection_vectors

—

SDPVTL

IP
GC
MD
MDRP
MIRP

freedom_vector

x-axis

SFVTCA
SFVTL
SFTPV

GFV

Graphics State Variable

Default

Set With

Affects

SVTCA
SFVFS
zp0

1

SZP0
SZPS

AA
ALIGNPTS
ALIGNRP
DELTAP1
DELTAP2
DELTAP3
IP
ISECT
MD
MDAP
MIAP
MIRP
MSIRP
SHC
SHZ
SHP
UTP

zp1

1

SZP1
SZPS

AA
ALIGNPTS
ALIGNRP
IP
MD
MDRP
MIRP
MSIRP
SHC
SHZ
SHP
SFVTL
SPVTL

zp2

1

SZP2

ISECT

SZPS

IUP
GC
SHC
SHP
SFVTL
SHPIX
SPVTL
SC

instruct_Control

0

INSTCTRL

all instructions

loop

1

SLOOP

ALIGNRP
FLIPPT

Graphics State Variable

Default

Set With

Affects
IP
SHP
SHPIX

minimum_distance

1 pixel

LMD

MDRP
MIRP

projection_vector

x-axis

SPVTCA
SPVTL

GPV

SVTCA
SPVFS
round_state

1

RDTG

MDAP

ROFF
RTDG

MIAP
MDRP

RTG

MIRP

RTHG
RUTG

ROUND

SROUND
S45ROUND
rp0

0

SRP0

IP
MDAP
MIAP
MIRP
MSIRP
SHC
SHZ
SHP

rp1

0

SRP1

IP
MDAP
MDRP
MIAP
MSIRP
SHC
SHZ
SHP

rp2

0

SRP2

IP
MDRP
MIRP
MSIRP
SHC
SHZ
SHP

scan_control

FALSE

SCANCTRL
SCANTYPE

Graphics State Variable

Default

Set With

Affects

singe_width_cut_in

0 pixels

SSWCI

MDRP
MIRP

single_width_value

0 pixels

SSW*

MDRP
MIRP

* The SSW argument is expressed in FUnits. The interpreter will convert this to pixels
(F26Dot6).

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

OpenType Mirroring Pairs List (OMPL)
Article • 12/09/2021

This is a placeholder page for a .txt file that will be placed on the Download
Management Center
Contents of .txt file:

#
# OpenType Mirroring Pairs List (OMPL)
#
# This file is a copy of the Bidi_Mirroring_Glyph Property of Unicode
# 5.1 (http://www.unicode.org/Public/5.1.0/ucd/BidiMirroring.txt), with
# header comments changed and the commented list at the end removed.
# Consult the URL above for specifications for the format of the data.
#
# The data in this file will not be revised.
#
# See the section "Left-to-right and right-to-left text" at
# https://www.microsoft.com/typography/otspec/TTOCHAP1.htm#ltrrtl
# for a description of how this file is to be used by an OpenType text
# layout engine.
#
# ############################################################
0028; 0029 # LEFT PARENTHESIS
0029; 0028 # RIGHT PARENTHESIS
003C; 003E # LESS-THAN SIGN
003E; 003C # GREATER-THAN SIGN
005B; 005D # LEFT SQUARE BRACKET
005D; 005B # RIGHT SQUARE BRACKET
007B; 007D # LEFT CURLY BRACKET
007D; 007B # RIGHT CURLY BRACKET
00AB; 00BB # LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
00BB; 00AB # RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
0F3A; 0F3B # TIBETAN MARK GUG RTAGS GYON
0F3B; 0F3A # TIBETAN MARK GUG RTAGS GYAS
0F3C; 0F3D # TIBETAN MARK ANG KHANG GYON
0F3D; 0F3C # TIBETAN MARK ANG KHANG GYAS
169B; 169C # OGHAM FEATHER MARK
169C; 169B # OGHAM REVERSED FEATHER MARK
2039; 203A # SINGLE LEFT-POINTING ANGLE QUOTATION MARK
203A; 2039 # SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
2045; 2046 # LEFT SQUARE BRACKET WITH QUILL
2046; 2045 # RIGHT SQUARE BRACKET WITH QUILL
207D; 207E # SUPERSCRIPT LEFT PARENTHESIS
207E; 207D # SUPERSCRIPT RIGHT PARENTHESIS
208D; 208E # SUBSCRIPT LEFT PARENTHESIS
208E; 208D # SUBSCRIPT RIGHT PARENTHESIS

2208; 220B # ELEMENT OF
2209; 220C # NOT AN ELEMENT OF
220A; 220D # SMALL ELEMENT OF
220B; 2208 # CONTAINS AS MEMBER
220C; 2209 # DOES NOT CONTAIN AS MEMBER
220D; 220A # SMALL CONTAINS AS MEMBER
2215; 29F5 # DIVISION SLASH
223C; 223D # TILDE OPERATOR
223D; 223C # REVERSED TILDE
2243; 22CD # ASYMPTOTICALLY EQUAL TO
2252; 2253 # APPROXIMATELY EQUAL TO OR THE IMAGE OF
2253; 2252 # IMAGE OF OR APPROXIMATELY EQUAL TO
2254; 2255 # COLON EQUALS
2255; 2254 # EQUALS COLON
2264; 2265 # LESS-THAN OR EQUAL TO
2265; 2264 # GREATER-THAN OR EQUAL TO
2266; 2267 # LESS-THAN OVER EQUAL TO
2267; 2266 # GREATER-THAN OVER EQUAL TO
2268; 2269 # [BEST FIT] LESS-THAN BUT NOT EQUAL TO
2269; 2268 # [BEST FIT] GREATER-THAN BUT NOT EQUAL TO
226A; 226B # MUCH LESS-THAN
226B; 226A # MUCH GREATER-THAN
226E; 226F # [BEST FIT] NOT LESS-THAN
226F; 226E # [BEST FIT] NOT GREATER-THAN
2270; 2271 # [BEST FIT] NEITHER LESS-THAN NOR EQUAL TO
2271; 2270 # [BEST FIT] NEITHER GREATER-THAN NOR EQUAL TO
2272; 2273 # [BEST FIT] LESS-THAN OR EQUIVALENT TO
2273; 2272 # [BEST FIT] GREATER-THAN OR EQUIVALENT TO
2274; 2275 # [BEST FIT] NEITHER LESS-THAN NOR EQUIVALENT TO
2275; 2274 # [BEST FIT] NEITHER GREATER-THAN NOR EQUIVALENT TO
2276; 2277 # LESS-THAN OR GREATER-THAN
2277; 2276 # GREATER-THAN OR LESS-THAN
2278; 2279 # [BEST FIT] NEITHER LESS-THAN NOR GREATER-THAN
2279; 2278 # [BEST FIT] NEITHER GREATER-THAN NOR LESS-THAN
227A; 227B # PRECEDES
227B; 227A # SUCCEEDS
227C; 227D # PRECEDES OR EQUAL TO
227D; 227C # SUCCEEDS OR EQUAL TO
227E; 227F # [BEST FIT] PRECEDES OR EQUIVALENT TO
227F; 227E # [BEST FIT] SUCCEEDS OR EQUIVALENT TO
2280; 2281 # [BEST FIT] DOES NOT PRECEDE
2281; 2280 # [BEST FIT] DOES NOT SUCCEED
2282; 2283 # SUBSET OF
2283; 2282 # SUPERSET OF
2284; 2285 # [BEST FIT] NOT A SUBSET OF
2285; 2284 # [BEST FIT] NOT A SUPERSET OF
2286; 2287 # SUBSET OF OR EQUAL TO
2287; 2286 # SUPERSET OF OR EQUAL TO
2288; 2289 # [BEST FIT] NEITHER A SUBSET OF NOR EQUAL TO
2289; 2288 # [BEST FIT] NEITHER A SUPERSET OF NOR EQUAL TO
228A; 228B # [BEST FIT] SUBSET OF WITH NOT EQUAL TO
228B; 228A # [BEST FIT] SUPERSET OF WITH NOT EQUAL TO
228F; 2290 # SQUARE IMAGE OF
2290; 228F # SQUARE ORIGINAL OF
2291; 2292 # SQUARE IMAGE OF OR EQUAL TO

2292; 2291 # SQUARE ORIGINAL OF OR EQUAL TO
2298; 29B8 # CIRCLED DIVISION SLASH
22A2; 22A3 # RIGHT TACK
22A3; 22A2 # LEFT TACK
22A6; 2ADE # ASSERTION
22A8; 2AE4 # TRUE
22A9; 2AE3 # FORCES
22AB; 2AE5 # DOUBLE VERTICAL BAR DOUBLE RIGHT TURNSTILE
22B0; 22B1 # PRECEDES UNDER RELATION
22B1; 22B0 # SUCCEEDS UNDER RELATION
22B2; 22B3 # NORMAL SUBGROUP OF
22B3; 22B2 # CONTAINS AS NORMAL SUBGROUP
22B4; 22B5 # NORMAL SUBGROUP OF OR EQUAL TO
22B5; 22B4 # CONTAINS AS NORMAL SUBGROUP OR EQUAL TO
22B6; 22B7 # ORIGINAL OF
22B7; 22B6 # IMAGE OF
22C9; 22CA # LEFT NORMAL FACTOR SEMIDIRECT PRODUCT
22CA; 22C9 # RIGHT NORMAL FACTOR SEMIDIRECT PRODUCT
22CB; 22CC # LEFT SEMIDIRECT PRODUCT
22CC; 22CB # RIGHT SEMIDIRECT PRODUCT
22CD; 2243 # REVERSED TILDE EQUALS
22D0; 22D1 # DOUBLE SUBSET
22D1; 22D0 # DOUBLE SUPERSET
22D6; 22D7 # LESS-THAN WITH DOT
22D7; 22D6 # GREATER-THAN WITH DOT
22D8; 22D9 # VERY MUCH LESS-THAN
22D9; 22D8 # VERY MUCH GREATER-THAN
22DA; 22DB # LESS-THAN EQUAL TO OR GREATER-THAN
22DB; 22DA # GREATER-THAN EQUAL TO OR LESS-THAN
22DC; 22DD # EQUAL TO OR LESS-THAN
22DD; 22DC # EQUAL TO OR GREATER-THAN
22DE; 22DF # EQUAL TO OR PRECEDES
22DF; 22DE # EQUAL TO OR SUCCEEDS
22E0; 22E1 # [BEST FIT] DOES NOT PRECEDE OR EQUAL
22E1; 22E0 # [BEST FIT] DOES NOT SUCCEED OR EQUAL
22E2; 22E3 # [BEST FIT] NOT SQUARE IMAGE OF OR EQUAL TO
22E3; 22E2 # [BEST FIT] NOT SQUARE ORIGINAL OF OR EQUAL TO
22E4; 22E5 # [BEST FIT] SQUARE IMAGE OF OR NOT EQUAL TO
22E5; 22E4 # [BEST FIT] SQUARE ORIGINAL OF OR NOT EQUAL TO
22E6; 22E7 # [BEST FIT] LESS-THAN BUT NOT EQUIVALENT TO
22E7; 22E6 # [BEST FIT] GREATER-THAN BUT NOT EQUIVALENT TO
22E8; 22E9 # [BEST FIT] PRECEDES BUT NOT EQUIVALENT TO
22E9; 22E8 # [BEST FIT] SUCCEEDS BUT NOT EQUIVALENT TO
22EA; 22EB # [BEST FIT] NOT NORMAL SUBGROUP OF
22EB; 22EA # [BEST FIT] DOES NOT CONTAIN AS NORMAL SUBGROUP
22EC; 22ED # [BEST FIT] NOT NORMAL SUBGROUP OF OR EQUAL TO
22ED; 22EC # [BEST FIT] DOES NOT CONTAIN AS NORMAL SUBGROUP OR EQUAL
22F0; 22F1 # UP RIGHT DIAGONAL ELLIPSIS
22F1; 22F0 # DOWN RIGHT DIAGONAL ELLIPSIS
22F2; 22FA # ELEMENT OF WITH LONG HORIZONTAL STROKE
22F3; 22FB # ELEMENT OF WITH VERTICAL BAR AT END OF HORIZONTAL STROKE
22F4; 22FC # SMALL ELEMENT OF WITH VERTICAL BAR AT END OF HORIZONTAL STROKE
22F6; 22FD # ELEMENT OF WITH OVERBAR
22F7; 22FE # SMALL ELEMENT OF WITH OVERBAR
22FA; 22F2 # CONTAINS WITH LONG HORIZONTAL STROKE

22FB; 22F3 # CONTAINS WITH VERTICAL BAR AT END OF HORIZONTAL STROKE
22FC; 22F4 # SMALL CONTAINS WITH VERTICAL BAR AT END OF HORIZONTAL STROKE
22FD; 22F6 # CONTAINS WITH OVERBAR
22FE; 22F7 # SMALL CONTAINS WITH OVERBAR
2308; 2309 # LEFT CEILING
2309; 2308 # RIGHT CEILING
230A; 230B # LEFT FLOOR
230B; 230A # RIGHT FLOOR
2329; 232A # LEFT-POINTING ANGLE BRACKET
232A; 2329 # RIGHT-POINTING ANGLE BRACKET
2768; 2769 # MEDIUM LEFT PARENTHESIS ORNAMENT
2769; 2768 # MEDIUM RIGHT PARENTHESIS ORNAMENT
276A; 276B # MEDIUM FLATTENED LEFT PARENTHESIS ORNAMENT
276B; 276A # MEDIUM FLATTENED RIGHT PARENTHESIS ORNAMENT
276C; 276D # MEDIUM LEFT-POINTING ANGLE BRACKET ORNAMENT
276D; 276C # MEDIUM RIGHT-POINTING ANGLE BRACKET ORNAMENT
276E; 276F # HEAVY LEFT-POINTING ANGLE QUOTATION MARK ORNAMENT
276F; 276E # HEAVY RIGHT-POINTING ANGLE QUOTATION MARK ORNAMENT
2770; 2771 # HEAVY LEFT-POINTING ANGLE BRACKET ORNAMENT
2771; 2770 # HEAVY RIGHT-POINTING ANGLE BRACKET ORNAMENT
2772; 2773 # LIGHT LEFT TORTOISE SHELL BRACKET
2773; 2772 # LIGHT RIGHT TORTOISE SHELL BRACKET
2774; 2775 # MEDIUM LEFT CURLY BRACKET ORNAMENT
2775; 2774 # MEDIUM RIGHT CURLY BRACKET ORNAMENT
27C3; 27C4 # OPEN SUBSET
27C4; 27C3 # OPEN SUPERSET
27C5; 27C6 # LEFT S-SHAPED BAG DELIMITER
27C6; 27C5 # RIGHT S-SHAPED BAG DELIMITER
27C8; 27C9 # REVERSE SOLIDUS PRECEDING SUBSET
27C9; 27C8 # SUPERSET PRECEDING SOLIDUS
27D5; 27D6 # LEFT OUTER JOIN
27D6; 27D5 # RIGHT OUTER JOIN
27DD; 27DE # LONG RIGHT TACK
27DE; 27DD # LONG LEFT TACK
27E2; 27E3 # WHITE CONCAVE-SIDED DIAMOND WITH LEFTWARDS TICK
27E3; 27E2 # WHITE CONCAVE-SIDED DIAMOND WITH RIGHTWARDS TICK
27E4; 27E5 # WHITE SQUARE WITH LEFTWARDS TICK
27E5; 27E4 # WHITE SQUARE WITH RIGHTWARDS TICK
27E6; 27E7 # MATHEMATICAL LEFT WHITE SQUARE BRACKET
27E7; 27E6 # MATHEMATICAL RIGHT WHITE SQUARE BRACKET
27E8; 27E9 # MATHEMATICAL LEFT ANGLE BRACKET
27E9; 27E8 # MATHEMATICAL RIGHT ANGLE BRACKET
27EA; 27EB # MATHEMATICAL LEFT DOUBLE ANGLE BRACKET
27EB; 27EA # MATHEMATICAL RIGHT DOUBLE ANGLE BRACKET
27EC; 27ED # MATHEMATICAL LEFT WHITE TORTOISE SHELL BRACKET
27ED; 27EC # MATHEMATICAL RIGHT WHITE TORTOISE SHELL BRACKET
27EE; 27EF # MATHEMATICAL LEFT FLATTENED PARENTHESIS
27EF; 27EE # MATHEMATICAL RIGHT FLATTENED PARENTHESIS
2983; 2984 # LEFT WHITE CURLY BRACKET
2984; 2983 # RIGHT WHITE CURLY BRACKET
2985; 2986 # LEFT WHITE PARENTHESIS
2986; 2985 # RIGHT WHITE PARENTHESIS
2987; 2988 # Z NOTATION LEFT IMAGE BRACKET
2988; 2987 # Z NOTATION RIGHT IMAGE BRACKET
2989; 298A # Z NOTATION LEFT BINDING BRACKET

298A; 2989 # Z NOTATION RIGHT BINDING BRACKET
298B; 298C # LEFT SQUARE BRACKET WITH UNDERBAR
298C; 298B # RIGHT SQUARE BRACKET WITH UNDERBAR
298D; 2990 # LEFT SQUARE BRACKET WITH TICK IN TOP CORNER
298E; 298F # RIGHT SQUARE BRACKET WITH TICK IN BOTTOM CORNER
298F; 298E # LEFT SQUARE BRACKET WITH TICK IN BOTTOM CORNER
2990; 298D # RIGHT SQUARE BRACKET WITH TICK IN TOP CORNER
2991; 2992 # LEFT ANGLE BRACKET WITH DOT
2992; 2991 # RIGHT ANGLE BRACKET WITH DOT
2993; 2994 # LEFT ARC LESS-THAN BRACKET
2994; 2993 # RIGHT ARC GREATER-THAN BRACKET
2995; 2996 # DOUBLE LEFT ARC GREATER-THAN BRACKET
2996; 2995 # DOUBLE RIGHT ARC LESS-THAN BRACKET
2997; 2998 # LEFT BLACK TORTOISE SHELL BRACKET
2998; 2997 # RIGHT BLACK TORTOISE SHELL BRACKET
29B8; 2298 # CIRCLED REVERSE SOLIDUS
29C0; 29C1 # CIRCLED LESS-THAN
29C1; 29C0 # CIRCLED GREATER-THAN
29C4; 29C5 # SQUARED RISING DIAGONAL SLASH
29C5; 29C4 # SQUARED FALLING DIAGONAL SLASH
29CF; 29D0 # LEFT TRIANGLE BESIDE VERTICAL BAR
29D0; 29CF # VERTICAL BAR BESIDE RIGHT TRIANGLE
29D1; 29D2 # BOWTIE WITH LEFT HALF BLACK
29D2; 29D1 # BOWTIE WITH RIGHT HALF BLACK
29D4; 29D5 # TIMES WITH LEFT HALF BLACK
29D5; 29D4 # TIMES WITH RIGHT HALF BLACK
29D8; 29D9 # LEFT WIGGLY FENCE
29D9; 29D8 # RIGHT WIGGLY FENCE
29DA; 29DB # LEFT DOUBLE WIGGLY FENCE
29DB; 29DA # RIGHT DOUBLE WIGGLY FENCE
29F5; 2215 # REVERSE SOLIDUS OPERATOR
29F8; 29F9 # BIG SOLIDUS
29F9; 29F8 # BIG REVERSE SOLIDUS
29FC; 29FD # LEFT-POINTING CURVED ANGLE BRACKET
29FD; 29FC # RIGHT-POINTING CURVED ANGLE BRACKET
2A2B; 2A2C # MINUS SIGN WITH FALLING DOTS
2A2C; 2A2B # MINUS SIGN WITH RISING DOTS
2A2D; 2A2E # PLUS SIGN IN LEFT HALF CIRCLE
2A2E; 2A2D # PLUS SIGN IN RIGHT HALF CIRCLE
2A34; 2A35 # MULTIPLICATION SIGN IN LEFT HALF CIRCLE
2A35; 2A34 # MULTIPLICATION SIGN IN RIGHT HALF CIRCLE
2A3C; 2A3D # INTERIOR PRODUCT
2A3D; 2A3C # RIGHTHAND INTERIOR PRODUCT
2A64; 2A65 # Z NOTATION DOMAIN ANTIRESTRICTION
2A65; 2A64 # Z NOTATION RANGE ANTIRESTRICTION
2A79; 2A7A # LESS-THAN WITH CIRCLE INSIDE
2A7A; 2A79 # GREATER-THAN WITH CIRCLE INSIDE
2A7D; 2A7E # LESS-THAN OR SLANTED EQUAL TO
2A7E; 2A7D # GREATER-THAN OR SLANTED EQUAL TO
2A7F; 2A80 # LESS-THAN OR SLANTED EQUAL TO WITH DOT INSIDE
2A80; 2A7F # GREATER-THAN OR SLANTED EQUAL TO WITH DOT INSIDE
2A81; 2A82 # LESS-THAN OR SLANTED EQUAL TO WITH DOT ABOVE
2A82; 2A81 # GREATER-THAN OR SLANTED EQUAL TO WITH DOT ABOVE
2A83; 2A84 # LESS-THAN OR SLANTED EQUAL TO WITH DOT ABOVE RIGHT
2A84; 2A83 # GREATER-THAN OR SLANTED EQUAL TO WITH DOT ABOVE LEFT

2A8B; 2A8C # LESS-THAN ABOVE DOUBLE-LINE EQUAL ABOVE GREATER-THAN
2A8C; 2A8B # GREATER-THAN ABOVE DOUBLE-LINE EQUAL ABOVE LESS-THAN
2A91; 2A92 # LESS-THAN ABOVE GREATER-THAN ABOVE DOUBLE-LINE EQUAL
2A92; 2A91 # GREATER-THAN ABOVE LESS-THAN ABOVE DOUBLE-LINE EQUAL
2A93; 2A94 # LESS-THAN ABOVE SLANTED EQUAL ABOVE GREATER-THAN ABOVE SLANTED
EQUAL
2A94; 2A93 # GREATER-THAN ABOVE SLANTED EQUAL ABOVE LESS-THAN ABOVE SLANTED
EQUAL
2A95; 2A96 # SLANTED EQUAL TO OR LESS-THAN
2A96; 2A95 # SLANTED EQUAL TO OR GREATER-THAN
2A97; 2A98 # SLANTED EQUAL TO OR LESS-THAN WITH DOT INSIDE
2A98; 2A97 # SLANTED EQUAL TO OR GREATER-THAN WITH DOT INSIDE
2A99; 2A9A # DOUBLE-LINE EQUAL TO OR LESS-THAN
2A9A; 2A99 # DOUBLE-LINE EQUAL TO OR GREATER-THAN
2A9B; 2A9C # DOUBLE-LINE SLANTED EQUAL TO OR LESS-THAN
2A9C; 2A9B # DOUBLE-LINE SLANTED EQUAL TO OR GREATER-THAN
2AA1; 2AA2 # DOUBLE NESTED LESS-THAN
2AA2; 2AA1 # DOUBLE NESTED GREATER-THAN
2AA6; 2AA7 # LESS-THAN CLOSED BY CURVE
2AA7; 2AA6 # GREATER-THAN CLOSED BY CURVE
2AA8; 2AA9 # LESS-THAN CLOSED BY CURVE ABOVE SLANTED EQUAL
2AA9; 2AA8 # GREATER-THAN CLOSED BY CURVE ABOVE SLANTED EQUAL
2AAA; 2AAB # SMALLER THAN
2AAB; 2AAA # LARGER THAN
2AAC; 2AAD # SMALLER THAN OR EQUAL TO
2AAD; 2AAC # LARGER THAN OR EQUAL TO
2AAF; 2AB0 # PRECEDES ABOVE SINGLE-LINE EQUALS SIGN
2AB0; 2AAF # SUCCEEDS ABOVE SINGLE-LINE EQUALS SIGN
2AB3; 2AB4 # PRECEDES ABOVE EQUALS SIGN
2AB4; 2AB3 # SUCCEEDS ABOVE EQUALS SIGN
2ABB; 2ABC # DOUBLE PRECEDES
2ABC; 2ABB # DOUBLE SUCCEEDS
2ABD; 2ABE # SUBSET WITH DOT
2ABE; 2ABD # SUPERSET WITH DOT
2ABF; 2AC0 # SUBSET WITH PLUS SIGN BELOW
2AC0; 2ABF # SUPERSET WITH PLUS SIGN BELOW
2AC1; 2AC2 # SUBSET WITH MULTIPLICATION SIGN BELOW
2AC2; 2AC1 # SUPERSET WITH MULTIPLICATION SIGN BELOW
2AC3; 2AC4 # SUBSET OF OR EQUAL TO WITH DOT ABOVE
2AC4; 2AC3 # SUPERSET OF OR EQUAL TO WITH DOT ABOVE
2AC5; 2AC6 # SUBSET OF ABOVE EQUALS SIGN
2AC6; 2AC5 # SUPERSET OF ABOVE EQUALS SIGN
2ACD; 2ACE # SQUARE LEFT OPEN BOX OPERATOR
2ACE; 2ACD # SQUARE RIGHT OPEN BOX OPERATOR
2ACF; 2AD0 # CLOSED SUBSET
2AD0; 2ACF # CLOSED SUPERSET
2AD1; 2AD2 # CLOSED SUBSET OR EQUAL TO
2AD2; 2AD1 # CLOSED SUPERSET OR EQUAL TO
2AD3; 2AD4 # SUBSET ABOVE SUPERSET
2AD4; 2AD3 # SUPERSET ABOVE SUBSET
2AD5; 2AD6 # SUBSET ABOVE SUBSET
2AD6; 2AD5 # SUPERSET ABOVE SUPERSET
2ADE; 22A6 # SHORT LEFT TACK
2AE3; 22A9 # DOUBLE VERTICAL BAR LEFT TURNSTILE
2AE4; 22A8 # VERTICAL BAR DOUBLE LEFT TURNSTILE

2AE5; 22AB # DOUBLE VERTICAL BAR DOUBLE LEFT TURNSTILE
2AEC; 2AED # DOUBLE STROKE NOT SIGN
2AED; 2AEC # REVERSED DOUBLE STROKE NOT SIGN
2AF7; 2AF8 # TRIPLE NESTED LESS-THAN
2AF8; 2AF7 # TRIPLE NESTED GREATER-THAN
2AF9; 2AFA # DOUBLE-LINE SLANTED LESS-THAN OR EQUAL TO
2AFA; 2AF9 # DOUBLE-LINE SLANTED GREATER-THAN OR EQUAL TO
2E02; 2E03 # LEFT SUBSTITUTION BRACKET
2E03; 2E02 # RIGHT SUBSTITUTION BRACKET
2E04; 2E05 # LEFT DOTTED SUBSTITUTION BRACKET
2E05; 2E04 # RIGHT DOTTED SUBSTITUTION BRACKET
2E09; 2E0A # LEFT TRANSPOSITION BRACKET
2E0A; 2E09 # RIGHT TRANSPOSITION BRACKET
2E0C; 2E0D # LEFT RAISED OMISSION BRACKET
2E0D; 2E0C # RIGHT RAISED OMISSION BRACKET
2E1C; 2E1D # LEFT LOW PARAPHRASE BRACKET
2E1D; 2E1C # RIGHT LOW PARAPHRASE BRACKET
2E20; 2E21 # LEFT VERTICAL BAR WITH QUILL
2E21; 2E20 # RIGHT VERTICAL BAR WITH QUILL
2E22; 2E23 # TOP LEFT HALF BRACKET
2E23; 2E22 # TOP RIGHT HALF BRACKET
2E24; 2E25 # BOTTOM LEFT HALF BRACKET
2E25; 2E24 # BOTTOM RIGHT HALF BRACKET
2E26; 2E27 # LEFT SIDEWAYS U BRACKET
2E27; 2E26 # RIGHT SIDEWAYS U BRACKET
2E28; 2E29 # LEFT DOUBLE PARENTHESIS
2E29; 2E28 # RIGHT DOUBLE PARENTHESIS
3008; 3009 # LEFT ANGLE BRACKET
3009; 3008 # RIGHT ANGLE BRACKET
300A; 300B # LEFT DOUBLE ANGLE BRACKET
300B; 300A # RIGHT DOUBLE ANGLE BRACKET
300C; 300D # [BEST FIT] LEFT CORNER BRACKET
300D; 300C # [BEST FIT] RIGHT CORNER BRACKET
300E; 300F # [BEST FIT] LEFT WHITE CORNER BRACKET
300F; 300E # [BEST FIT] RIGHT WHITE CORNER BRACKET
3010; 3011 # LEFT BLACK LENTICULAR BRACKET
3011; 3010 # RIGHT BLACK LENTICULAR BRACKET
3014; 3015 # LEFT TORTOISE SHELL BRACKET
3015; 3014 # RIGHT TORTOISE SHELL BRACKET
3016; 3017 # LEFT WHITE LENTICULAR BRACKET
3017; 3016 # RIGHT WHITE LENTICULAR BRACKET
3018; 3019 # LEFT WHITE TORTOISE SHELL BRACKET
3019; 3018 # RIGHT WHITE TORTOISE SHELL BRACKET
301A; 301B # LEFT WHITE SQUARE BRACKET
301B; 301A # RIGHT WHITE SQUARE BRACKET
FE59; FE5A # SMALL LEFT PARENTHESIS
FE5A; FE59 # SMALL RIGHT PARENTHESIS
FE5B; FE5C # SMALL LEFT CURLY BRACKET
FE5C; FE5B # SMALL RIGHT CURLY BRACKET
FE5D; FE5E # SMALL LEFT TORTOISE SHELL BRACKET
FE5E; FE5D # SMALL RIGHT TORTOISE SHELL BRACKET
FE64; FE65 # SMALL LESS-THAN SIGN
FE65; FE64 # SMALL GREATER-THAN SIGN
FF08; FF09 # FULLWIDTH LEFT PARENTHESIS
FF09; FF08 # FULLWIDTH RIGHT PARENTHESIS

FF1C; FF1E # FULLWIDTH LESS-THAN SIGN
FF1E; FF1C # FULLWIDTH GREATER-THAN SIGN
FF3B; FF3D # FULLWIDTH LEFT SQUARE BRACKET
FF3D; FF3B # FULLWIDTH RIGHT SQUARE BRACKET
FF5B; FF5D # FULLWIDTH LEFT CURLY BRACKET
FF5D; FF5B # FULLWIDTH RIGHT CURLY BRACKET
FF5F; FF60 # FULLWIDTH LEFT WHITE PARENTHESIS
FF60; FF5F # FULLWIDTH RIGHT WHITE PARENTHESIS
FF62; FF63 # [BEST FIT] HALFWIDTH LEFT CORNER BRACKET
FF63; FF62 # [BEST FIT] HALFWIDTH RIGHT CORNER BRACKET
# EOF

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

Comparison of 'glyf', 'CFF ' and CFF2
tables
Article • 05/31/2024

Three alternate formats are available for storing monochrome glyph outlines in
OpenType fonts: the 'glyf' table, the 'CFF ' table, and the CFF2 table. A functioning
OpenType font must contain one of these tables. This section provides a comparison of
these alternate formats for glyph data.
CFF2 and CFF use cubic (3rd order) Bézier curves to represent glyph outlines, whereas
the 'glyf' table uses quadratic (2nd order) Bézier curves. CFF2 and CFF also use a
different conceptual model for “hints” than the 'glyf' table. The three tables also differ in
relation to support of variations and in how variation data is stored.
The following table provides a summary comparison of the CFF2, 'CFF ' and 'glyf' tables.
Note that some of these differences might not be exposed in high-level font editing
software or in runtime programming interfaces.
ﾉ

Expand table

Consideration

glyf

CFF

CFF2

curves

quadratic (2nd order)
Bézier

cubic (3rd order)
Bézier

cubic (3rd order) Bézier

coordinate
precision

1 design unit

1/65536 design
unit

1/65536 design unit

de-duplication

contours can be shared
by multiple glyphs
using composite

CharString data
can be shared by
multiple glyphs

CharString data can be shared by
multiple glyphs using
subroutines

glyphs

using subroutines

TrueType instructions

alignment zones

alignment zones apply to

move outline points by
controlled amounts

apply to all
glyphs, stem
locations are

arbitrary groups of glyphs, stem
locations are declared in each
glyph

hinting

declared in each
glyph
decoding

not stack-based
(except TrueType
instructions)

mostly stackbased

mostly stack-based

Consideration

glyf

CFF

CFF2

OpenType

supported: outline

not supported

supported: variation data for

variations

variation data is stored
in the 'gvar' table (OFF:
7.3.4); hint variation

outlines and hints is stored
within the CFF2 table, partially
using common formats for

data is stored in the
'cvar' table (OFF: 7.3.2)

variation data also used in other
tables, and partially interleaved
within the CharString data for
individual glyph descriptions

data
redundancy

low

moderate

low

overlapping
contours

supported

not supported

supported

Other CFF2 versus CFF differences
The CFF2 format was changed from the CFF format to consolidate with other parts of
the OpenType format, to eliminate data not needed within an OpenType font, and to
support OpenType Font Variations. The following are key differences.
FontSets are not supported in a CFF2 table. Accordingly, a CFF2 table may contain
only one TopDICT, and a TopDICT INDEX is not supported.
Name INDEX and String INDEX are not supported in the CFF2 table.
Encoding and charset tables are not supported in CFF2. The corresponding
TopDICT operators are removed, along with several other TopDICT operators.
CFF2 CharStrings do not contain a value for advance width.
For CFF2 tables, the fill rule for CharStrings must always be the nonzero winding
number rule, rather than the even-odd rule. This is required in order to support
variable font data, in which it is not practical to enforce removal of overlaps
between paths.
For CFF2, the CharString stack depth is increased from 48 to 513.
The PrivateDICT and CharString operator sets are extended in CFF2 to include
blend and vsindex operators.
The Type 2 endchar and return CharString operators are removed from CFF2, as
well as all logic, storage and math operators.

６ Collaborate with us on
GitHub

OpenType specification feedback

The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

OpenType Specification Change Log
Article • 03/19/2025

Version 1.9.1
Released May 2024
Structure or field names were revised in base, chapter2, cff2, cmap, eblc, gdef, gpos,
hmtx, and jstf chapters; see below for details.
Minor editorial changes (not detailed below) were made in the following chapters: avar,
base, baselinetags, cbdt, cblc, cff, chapter2, cmap, colr, cpal, cvt, dsig, dvaraxisreg, ebdt,
eblc, ebsc, featurelist, features_ae, features_fj, features_ko, features_pt, features_uz,
featuretags, fpgm, fvar, gasp, gdef, glyf, gpos, gsub, gvar, hdmx, head, hhea, hvar, ibmfc,
jstf, kern, languagetags, loca, ltsh, math, merg, meta, mvar, name, os2, otff,
otvarcommonformats, otvaroverview, overview, pclt, post, prep, recom, sbix, scripttags,
stat, svg, tt_instructing_glyphs, tt_instructions, ttch01, ttochap1, ttoreg, vdmx, vmtx, vorg,
vvar.
Summary of changes:
base
Changed structure names:
“FeatMinMaxRecord” to “FeatMinMax”
“BaseLangSysRecord” to “BaseLangSys”
Changed field names:
FeatMinMax record: “featureTableTag” to “featureTag”
BaseCoord tables: “baseCoordFormat” to “format”
cblc
Changed field names:
BitmapSize record: “indexSubTableArrayOffset” to “indexSubtableListOffset”
BitmapSize record: “indexTablesSize” to “indexSubtableListSize”
BitmapSize record: “numberOfIndexSubTables” to “numberOfIndexSubtables”
cff2
This chapter underwent significant editorial revision.
Changed structure, field and operator names:
“FDArray” to “FontDICTINDEX”
“FDSelect” to “FontDICTSelect”
“Variation Store” to “VariationStore”

“Top DICT” to “TopDICT”
“TopDictLength” to “TopDICTLength”
“Font DICT” to “FontDICT”
“Private DICT” to “PrivateDICT”
“Global Subr INDEX” to “GlobalSubrINDEX”
“CharString INDEX” to “CharStringINDEX”
“delta” to “deltaArray”
“vstore” to “VariationStoreOffset”
INDEX “offSize” to “offsetSize”
INDEX “offset” array to “offsets”
FontDICTSelect: “fds” to “fontDictIDs”
FontDICTSelect format 3: “range3” array to “ranges”
FontDICTSelect formats 3, 4: “nRanges” to “numRanges”
FontDICTSelect format 4: “range4” array to “ranges”
Range3, Range4: “fd” to “fontDictID”
Changed type of INDEX offsetSize field to uint8.
Changed the types used for INDEX offsets to Offset8, Offset16, etc.
Changed stack notation conventions.
Added PrivateDICT hinting operator descriptions (based on Adobe Type 1 Font
Format).
Added section describing dependencies on other font tables.
Differences between CFF and CFF2 moved to a new appendix
(glyphformatcomparison).
Incorporated the content of CFF2 Charstrings chapter into this chapter.
Clarified interaction between blending and stem or edge hint encoding using
hstemhm and similar operators; and between blending and stem width values
specified using StdHW and similar operators.
Corrected the note describing blending of StemSnapH and StemSnapV
operands, and also the description of blended stem and edge hints and the
relationsip between the encoded order of stems and cntrmask and hintmask
bitflags (post-release erratum).
cff2charstr
Content of this chapter was incorporated into the CFF chapter, and this
appendex was deleted.
chapter2
Changed structure and field names:
ClassDefFormat1: “classValueArray” to “classValues”
“ClassRangeRecord” to “ClassRange”
“SequenceLookupRecord” to “SequenceLookup”

Coverage tables: “coverageFormat” to “format”
ClassDef tables: “classFormat” to “format”
Changed lookup flag name “MARK_ATTACHMENT_TYPE_MASK” to
“MARK_ATTACHMENT_CLASS_FILTER”.
Clarified processing of a Lookup table with multiple subtables.
SequenceRuleSet table: corrected reference to field for the size of the
seqRuleOffsets[] array (post-release erratum).
cmap
Clarify the modulo arithmetic for idDelta in Format 2 and Format 4.
For Format 4, correct the description of the entrySelector field.
For Format 4, revert array name to idRangeOffset.
For Format 4, correct the entrySelector value in the second example.
colr
Removed obsoleted references to ColorIndex and VarColorIndex records
(proposed in preliminary design but not used in final design).
Clarified handling of alpha with palette entries that reference text foreground
color.
Added clarifications regarding color stop ordering, and provided possible
implementation workaround for platforms that limit the range of color stop
offsets.
Clarified behavior for different extend modes when all stops have the same
offset.
Clarified radial gradient behavior when variation deltas result in a circle with
negative radius, and provided possible implementation workaround for
platforms that require non-negative radii.
Revised description of sweep gradients and the interpretation of their data
representation.
Added clarifications about applying variation deltas to F2DOT14 or Fixed values.
Replaced the generic description of offset reference for subtable offsets with
specific details in description of each structure containing subtable offsets.
dvaraxisreg
Use title case for axis names.
dvaraxistag_opsz
Use title case for axis names.
eblc
Changed structure and field names:
BitmapSize record: “indexSubTableArrayOffset” to “indexSubtableListOffset”

BitmapSize record: “indexTablesSize” to “indexSubtableListSize”
BitmapSize record: “numberOfIndexSubTables” to “numberOfIndexSubtables”
“IndexSubTableArray” to “IndexSubtableList”
“IndexSubTable1” to “IndexSubtableFormat1”
“IndexSubTable2” to “IndexSubtableFormat2”
“IndexSubTable3” to “IndexSubtableFormat3”
“IndexSubTable4” to “IndexSubtableFormat4”
“IndexSubTable5” to “IndexSubtableFormat5”
Provided a formal description for the IndexSubtableList (renamed from
IndexSubtableArray).
Clarified ordering requirements for indexSubtableRecords array.
ebsc
Description of the formats is revised to be consistent with other parts of the
spec (array of fixed-size structures without offsets described as records).
features_ae
Added feature 'apkn'.
Revised the descriptions for the 'aalt', 'chws', 'clig', 'cswh', 'cv01' – 'cv99', 'dlig'
and 'expt' features.
features_fj
Corrected name for 'flac' feature.
Revised the descriptions for the 'falt', 'fina', 'flac', 'fwid', 'halt', 'hkna', 'hngl',
'hwid', 'init', 'isol', 'jalt', 'jp78', 'jp83' and 'jp90' features.
features_ko
Revised the descriptions for the 'kern', 'liga', 'ljmo', 'lnum', 'locl', 'medi', 'mgrk',
'mset', 'numr' and 'ordn' features.
features_pt
Revised the descriptions for the 'palt', 'pcap', 'pkna', 'pwid', 'qwid', 'rclt', 'rvrn',
'size', 'smpl', 'ss01' – 'ss20', 'ssty', 'subs', 'sups', 'tjmo', 'tnam', 'trad' and 'twid'
features.
Clarified that stylistic set features may be used in the GPOS table, and may be
used in combination with one another.
features_uz
Added feature 'vapk'.
Revised the descriptions for the 'unic', 'valt', 'vchw', 'vert', 'vhal', 'vjmo', 'vkna',
'vkrn', 'vpal', 'vrt2', 'vrtr' and 'zero' features.
fvar

Revised recommendation for instance record name IDs for the default instance.
In the example 'fvar' table, corrected the axisSize field name.
gdef
Change field names:
In CaretValue tables: “caretValueFormat” to “format”
glyf
Clarified that a simple glyph with zero contours can have instructions but need
not have any glyph data.
Revised description of OVERLAP_SIMPLE to cover a broader range of
implementations.
A missing bracket was added in the pseudo code for processing component
glyph records.
Added details for the WE_HAVE_INSTRUCTIONS component flag.
glyphformatcomparison
Added page.
gpos
Changed structure and field names:
“PairValueRecord” to “PairValue”
“Class1Record” to “Class1”
“Class2Record” to “Class2”
“EntryExitRecord” to “EntryExit”
“Mark2Record” to “Mark2”
“ExtensionPosFormat1” to “PosExtensionFormat1”
multiple structures: “posFormat” to “format”
CursivePosFormat1: “entryExitRecord” to “entryExitRecords”
Anchor tables: “anchorFormat” to “format”
For Type 3, format 1, clarified that no adjustment is made if either entry or exit
Anchor offset is NULL.
gsub
Changed structure and field names:
“ExtensionSubstFormat1” to “SubstExtensionFormat1”
multiple structures: “substFormat” to “format”
Clarified the modulo arithmetic for deltaGlyphID in SingleSubstFormat1.
gvar
Corrected example for processing composite glyphs.
head

Added clarification regarding flags bit 1.
hmtx
Change data types for font unit values to FWORD, UFWORD.
Corrected casing of record name to LongHorMetrics.
jstf
Consolidated JstfGSUBModList and JstfGPOSModList table formats into a
common JstfModList table.
Corrected field name in JstfModList table: “gsubLookupIndices” to
“lookupIndices” (post-release erratum)
kern
Removed obsolete platform-specific details.
languagetags
Added 'AAQ ', 'ACY ', 'ATS ', 'BDC ', 'CAY ', 'CBG ', 'CMI ', 'COO ', 'CTO ', 'EMP ',
'HUR ', 'JDT ', 'KBC ', 'KJJ ', 'LIV ', 'MEV ', 'ONE ', 'ONO ', 'PLG0', 'SEE ', 'SJA ', 'STR ',
'TAQ ', 'TDC ', 'THP ', 'THV ', 'THZ ', 'TLY ', 'TTQ ', 'TUS ', 'UDI ', 'UPPH', 'WBL ',
'WDT ', 'WYN ', 'YUF '.
Revised descriptions for 'BEL ', 'IRT ', 'SGA ', 'TMH '.
Added BCP 47 info for APPH, IPPH, UPPH (post-release update).
Updated BCP 47 info for CPP (post-release update).
Added 'KGF ', 'KMG ', 'KSU ', 'KVQ ', 'LUT ', 'NOP ', 'NUK ', 'SJE ' , 'SJU ', 'TBV '
(post-release update).
loca
Removed recommendation that offsets be two-byte aligned.
math
Changed structure and field names:
MathGlyphConstruction: “mathGlyphVariantRecord” to
“mathGlyphVariantRecords”.
“GlyphPartRecord” to “GlyphPart”.
Corrected description of spaceAfterScript.
Corrected description of radicalDegreeBottomRaisePercent.
meta
Added clarifications regarding intended use of 'dlng' and 'slng'.
Relaxed ScriptLangTag syntax to allow (but strongly discourage) a language
subtag without a script subtag.
name

Added clarifications regarding name ID 2 and interaction with OS/2.fsSelection
style bits.
Revised description of name ID 13.
Corrected details regarding non-Unicode encoding IDs for platform 3.
Replaced list of Macintosh language IDs with reference to Apple
documentation.
Replaced list of Windows language IDs with reference to external Microsoft
documentation on language IDs.
os2
Change data types for font unit values to FWORD, UFWORD.
Added note regarding some CJK fonts having unexpected xAvgCharWidth
values.
Added details related to use of int16 for ySubscriptXSize, ySubscriptYSize,
ySuperscriptXSize, ySuperscriptYSize, yStrikeoutSize.
Added clarifications for fsSelection bits, including relation between bit 8 and the
STAT table.
otff
Corrected casing of TableRecord in TableDirectory.
Added Offset8 in table of data types.
otvaroverview
Added clarification regarding rounding of calculated values.
Clarified that supplemental deltas for corners of a design space are optional.
otvarcommonformats
Corrected calculation of size for delta-set index mapping entries.
Clarify when variations of F2DOT14 values may need to be clamped.
post
Clarified description of underlinePosition and its difference from the PostScript
UnderlinePosition FontInfo key.
prep
Corrected details regarding when the CV program is executed.
sbix
Clarified requirements related to graphicType = 'dupe' (“must”, not “should”).
scripttags
Added script tags for new scripts in Unicode 15.0 and Unicode 16.0.
Clarified usage of the 'math' script tag.

tt_instructions
Corrected description of INSTCTRL.
ttch01
Added clarification on x-axis placement of design grid in relation to pen
position.
vhea
Change data type for advanceHeightMax to unsigned.
Change data types for font unit values to FWORD, UFWORD.
vorg
Clarified that VORG may be used with CFF2.
vmtx
Change data types for font unit values to FWORD, UFWORD.

Version 1.9
Released December 2021
Structure names were revised in chapter2 and fvar chapters; see below for details.
Minor editorial changes (not detailed below) were made in the following chapters:
chapter2, cmap, dvaraxisreg, featurelist, features_ae, glyf, gpos, gsub, gvar, hvar, index,
kern, languagetags, name, otvarcommonformats, otvaroverview, prep, recom,
tt_instructions, ttch01.
Summary of changes:
chapter2
Changed spellings of field names of ConditionFormat1 table.
cmap
For platform ID 0, encoding ID 3, removed suggestion of using format 0
subtable.
Clarified requirements for UVSes in a format 14 subtable and entries in other
'cmap' Unicode subtables.
Corrected description of the entrySelector field (post-release erratum).
colr
Added version 1 header and related structures.
Revised introductory sections and other editorial changes.
Added recommendation against using bold or italic simulations.

cpal
Added reference to CSS Color Module Level 4.
Added section on interpolation of colors.
features_ae
Modified 'cvXX' description.
Corrected use of non-preferred region / language / script name (post-release
erratum).
features_fj
Modified 'frac' feature description.
features_ko
Modified 'lfbd' feature description.
features_pt
Modified 'rtbd' feature description.
fvar
Changed record name “Tuple” to “UserTuple”.
glyf
Added remarks regarding glyph bounding rectangles in variable fonts.
Clarified interpretation of X_SHORT_VECTOR and Y_SHORT_VECTOR flags.
Clarified interpretation of the ARGS_ARE_XY_VALUES and ROUND_XY_TO_GRID
component flags, and other aspects of composite glyph descriptions.
Changed FWord and F2Dot14 to FWORD and F2DOT14.
gpos
Clarified consistency requirement for extension subtables within a given Lookup
table.
gsub
Clarified consistency requirement for extension subtables within a given Lookup
table.
Corrected use of non-preferred region / language / script name (post-release
erratum).
gvar
Corrected type in sharedTuples array to Tuple.
Corrected spelling of GlyphVariationData and TupleVariationHeader.
head
Clarified meaning of unitsPerEm, xMin, yMin, xMax and yMax values.

Added remarks regarding glyph bounding rectangles in variable fonts.
hvar
Moved description of the DeltaSetIndexMap to the OpenType Font Variations
Common Table Formats chapter.
languagetags
Added information on how to request new language system tags.
Added 'MONT', 'TJL '.
Added 'INUK' (post-release update).
Corrected entries for 'TUL ', 'TUM ' (post-release erratum).
Corrected use of non-preferred region / language / script name (post-release
erratum).
maxp
Added CFF2 as requiring version 0.5.
meta
Clarified that 'slng' value should be superset of 'dlng'.
Fixed URL for BCP 47 (post-release erratum).
Corrected use of non-preferred region / language / script name (post-release
erratum).
name
Clarified encoding scheme for platform 0 strings.
Added note regarding platform 3 and non-conforming legacy CJK fonts.
Corrected use of non-preferred region / language / script name (post-release
erratum).
os2
Include details for legacy calculation of xAvgCharWidth in OS/2 versions 0 to 2
that were omitted since version 1.8.3.
Corrected use of non-preferred region / language / script name (post-release
erratum).
otff
Added Offset24 type.
Added clarifications regarding NULL subtable offsets.
Added recommendation against duplicate tables.
otvarcommonformats
Added COLR as a table using variation data.
Moved description of DeltaSetIndexMap from the HVAR chapter to this chapter.
Sub-divided the entryFormat field into separate format and entryFormat fields,

and added a format 1 DeltaSetIndexMap.
Described application of deltas to F2DOT14, Fixed.
Revised ItemVariationData subtable adding support for 32-bit deltas. Also
changed field name “shortDeltaCount” to “wordDeltaCount”.
otvaroverview
Clarified that any aspect of appearance can vary in a variable font.
Added details regarding integer bit depth in the algorithm for interpolation of
instance values.
post
Changed FWord to FWORD.
recom
Revised guidance for baseline-to-baseline distance.
scripttags
Added script tags for new scripts in Unicode 14.0.
Added remarks regarding 'jamo' and 'mymr'.
Corrected use of non-preferred region / language / script name (post-release
erratum).
stat
Emphasized recommendation to include axis value tables covering all named
instances of a variable font.
tt_graphics_state
Fix incorrect names of instructions and zone pointers.
tt_instructing_glyphs
Added clarification regarding unused distance type 3.
tt_instructions Clarified that FDEF and IDEF must not be invoked in glyph
programs.
ttch01
Clarified when the interpreter stack is cleared.
Clarified where functions and instructions can or cannot be defined or
redefined, and the persistence of definitions.
Clarified when the control value program is run and the relationship between
the control value program, Control Value Table, and the 'cvt ' table.
Clarified interaction between the control value program and Graphics State
variables.
Clarified interactions between zone 0 and the control value and glyph programs.

Clarified use of the storage area by font, control value and glyph programs.
Added section discussing persistence of storage or CVT values set in a glyph
program and interaction with glyph caches.
Clarified control of the scan converter mode using SCANCTRL.
vvar
For description of the DeltaSetIndexMap, changed the cross-reference from the
HVAR chapter to the OpenType Font Variations Common Table Formats chapter.

Version 1.8.4
Released November 2020
Names of tables, fields or flags in the following chapters were revised to conform to
conventions used across this specification:
base.htm, chapter2.htm, cmap.htm, colr.htm, cpal.htm, dsig.htm, eblc.htm,
gdef.htm, gpos.htm, gsub.htm, head.htm, jstf.htm, kern.htm, math.htm, name.htm,
otff.htm, otvarcommonformats.htm, svg.htm, vdmx.htm.
These name changes are enumerated in detail below.
References to “TrueType”, when this specification is intended, have been removed,
changed to “OpenType”, or otherwise clarified in the following chapters: chapter2.htm,
dsig.htm, hvar.htm, otff.htm, post.htm, recom.htm, ttch01.htm, vmtx.htm, vorg.htm.
Minor editorial changes (not detailed below) were made in the following chapters:
avar.htm, base.htm, baselinetags.htm, cff.htm, cff2charstr.htm, chapter2.htm, cmap.htm,
colr.htm, cpal.htm, dsig.htm, dvaraxistag_ital.htm, dvaraxistag_opsz.htm,
dvaraxistag_slnt.htm, dvaraxistag_wdth.htm, dvaraxistag_wght.htm, eblc.htm,
featurelist.htm, features_ae.htm, features_fj.htm, features_ko.htm, features_pt.htm,
features_uz.htm, featuretags.htm, gdef.htm, gpos.htm, gsub.htm, gvar.htm, hdmx.htm,
head.htm, hvar.htm, index.htm, languagetags.htm, ltsh.htm, math.htm, meta.htm,
otff.htm, otvarcommonformats.htm, post.htm, scripttags.htm, stat.htm, svg.htm,
tt_instructing_glyphs.htm, tt_instructions.htm, ttch01.htm, ttochap1.htm, ttoreg.htm,
vhea.htm, vmtx.htm, vorg.htm, vvar.htm.
Summary of changes:
avar.htm
Moved description of normalization process and example into
otvaroverview.htm.
base.htm

Changed field names:
BaseValues table: “baseCoords” to “baseCoordOffsets”
MinMax and FeatMinMax tables: “minCoord” to “minCoordOffset”
MinMax and FeatMinMax tables: “maxCoord” to “maxCoordOffset”
BaseCoordFormat3: “deviceTable” to “deviceOffset”
cbdt.htm
Added descriptions of fields for BigGlyphMetrics, SmallGlyphMetrics.
Changed characterization of BitmapSize from table to record.
cblc.htm
Changed characterization of BitmapSize from table to record.
Revised description of CBLC header to incorporate BitmapSize records array.
cff2.htm
Added note to description of FDSelect Format 3 regarding the maximum glyph
ID of 65534.
cffspec.htm
Page removed. (The page only provided an external link, already in cff.htm.)
chapter2.htm
Changed table name: “ConditionTableFormat1” to “ConditionFormat1” (table).
Changed field names:
Script table: “defaultLangSys” to “defaultLangSysOffset”
LangSys table: “lookupOrder” to “lookupOrderOffset”
Feature table: “featureParams” to “featureParamsOffset”
LookupList table: “lookups” to “lookupOffsets”
ConditionSet Table: “conditions” to “conditionOffsets”
FeatureTableSubstitutionRecord: “alternateFeatureTable” to
“alternateFeatureOffset”
Changed LookupFlag names:
“rightToLeft” to “RIGHT_TO_LEFT”
“ignoreBaseGlyphs” to “IGNORE_BASE_GLYPHS”
“ignoreLigatures” to “IGNORE_LIGATURES”
“ignoreMarks” to “IGNORE_MARKS”
“useMarkFilteringSet” to “USE_MARK_FILTERING_SET”
“markAttachmentType” to “MARK_ATTACHMENT_TYPE_MASK”
Added common formats for use in the GSUB and GPOS tables, replacing
formats in GSUB and GPOS chapters that were identical but with different
names:

SequenceContextFormat1, SequenceContextFormat2,
SequenceContextFormat3, and associated subtables (replacing
ContextSubstFormat1/ContextPosFormat1, etc.)
ChainedSequenceContextFormat1, ChainedSequenceContextFormat2,
ChainedSequenceContextFormat3, and associated subtables (replacing
ChainContextSubstFormat1/ChainContextPosFormat1, etc.)
SequenceLookupRecord (replacing SubstLookupRecord/PosLookupRecord)
Replaced Figure 2b with a clearer illustration of language system differences.
Clarified optionality of features not referenced by the requiredFeatureIndex field
of the LangSys table.
Added note regarding GSUB features being processed by applications in stages.
Added clarification regarding FeatureParams tables.
Added clarification regarding general lookup processing, and regarding filtering
lookup flags in relation to the first glyph in input sequences.
In relation to contextual lookup types, added clarification regarding lookup
flags in the main lookup table and in nested lookup tables.
Corrected reference to GPOS type 8 lookups (post-release erratum).
Corrected errors in data for Example 3.
charstr2.htm
Page removed. (The page only provided an external link, already in cff.htm.)
cmap.htm
Changed field names:
EncodingRecord: “offset” to “subtableOffset”
Format 2 subtable: “glyphIndexArray” to “glyphIdArray”
Format 4 subtable: “idRangeOffset” to “idRangeOffsets”
Format 10 subtable: “glyphs” to “glyphIdArray”
Added clarification regarding use of different formats.
Added clarification regarding subtables being used exclusively.
Changed guidance regarding the Macinthosh platform.
Added details regarding the Unicode and ISO platforms (moved from the
'name' chapter).
Revised description of encodings for the Windows platform.
Revised description of the “Custom” platform (ID 4).
Revised descriptions for formats 0, 2, 4, 6, 8, 10, 12, 14.
In description of format 4, provided details regarding purpose of searchRange,
entrySelector and rangeShift fields as well as recommendations for fonts and
parsing. Also corrected glyph mapping example.
Corrected description of the entrySelector field (post-release erratum,
correction back-ported from version 1.9).

colr.htm
In BaseGlyphRecord and LayerRecord, changed field names “gID” to “glyphId”.
Changed general requirement regarding glyph ID 1 to a compatibility note.
cpal.htm
Changed field names:
“offsetFirstColorRecord” to “colorRecordsArrayOffset”
“offsetPaletteTypeArray” to “paletteTypesArrayOffset”
“offsetPaletteLabelArray” to “paletteLabelsArrayOffset”
“offsetPaletteEntryLabelArray” to “paletteEntryLabelsArrayOffset”
Clarified use of sRGB.
Clarified meaning of alpha values.
In the section on SVG and CPAL, replaced “context-fill” and “context-fill-opacity”
with “currentColor”.
dsig.htm
In SignatureRecord, changed field name “offset” to “signatureBlockOffset”.
Corrected references for PKCS #7, PKCS #9.
Corrected the steps for creating a DSIG table, and clarified steps for creating a
DSIG table for a TTC.
Removed erroneous reference to DSIG checksum field.
dvaraxistag_opsz.htm
Revised description for the Optical size axis.
ebdt.htm
Added descriptions of fields for BigGlyphMetrics, SmallGlyphMetrics.
Changed characterization of BitmapSize from table to record.
eblc.htm
Changed field names:
IndexSubtable1 and IndexSubtable3: “offsetArray” to “sbitOffsets”
GlyphIDOffsetPair record: “offset” to “sbitOffset”
Changed characterization of BitmapSize from table to record.
Revised description of EBLC header to incorporate BitmapSize records array.
Added descriptions of fields for BigGlyphMetrics, SmallGlyphMetrics.
ebsc.htm
Changed characterization of BitmapSize from table to record.
euro.htm
Removed file. (Content not part of the font format specification, available
elsewhere.)

featurelist.htm
Added features 'chws', 'vchw'.
features_ae.htm
Added 'chws' feature description.
Modified feature descriptions: 'aalt', 'abvf', 'abvm', 'abvs', 'afrc', 'akhn', 'blwf',
'blwm', 'blws', 'calt', 'case', 'ccmp', 'cfar', 'cjct', 'clig', 'cpct', 'cpsp', 'cswh', 'curs',
'cv01' – 'cv99', 'c2pc', 'c2sc', 'dist', 'dlig', 'dnom', 'dtls', 'expt'.
features_fj.htm
Modified feature descriptions: 'falt', 'fin2', 'fin3', 'fina', 'flac', 'frac', 'fwid', 'half',
'haln', 'halt', 'hist', 'hkna', 'hlig', 'hngl', 'hoji', 'hwid', 'init', 'isol', 'ital', 'jalt', 'jp78',
'jp83', 'jp90', 'jp04'.
features_ko.htm
Deprecated 'opbd' feature.
Modified feature descriptions: 'kern', 'lfbd', 'liga', 'ljmo', 'lnum', 'locl', 'ltra', 'ltrm',
'mark', 'med2', 'medi', 'mgrk', 'mkmk', 'mset', 'nalt', 'nlck', 'nukt', 'numr', 'onum',
'opbd', 'ordn', 'ornm'.
features_pt.htm
Modified feature descriptions: 'palt', 'pcap', 'pkna', 'pnum', 'pref', 'pres', 'pstf',
'psts', 'pwid', 'qwid', 'rand', 'rclt', 'rkrf', 'rlig', 'rphf', 'rtbd', 'rtla', 'rtlm', 'ruby', 'rvrn',
'salt', 'sinf', 'smcp', 'smpl', 'ss01' – 'ss20', 'ssty', 'stch', 'subs', 'sups', 'swsh', 'titl',
'tjmo', 'tnam', 'tnum', 'trad', 'twid'
features_uz.htm
Added 'vchw' feature description.
Modified feature descriptions: 'unic', 'valt', 'vatu', 'vert', 'vhal', 'vjmo', 'vkna',
'vkrn', 'vpal', 'vrt2', 'vrtr', 'zero'.
fvar.htm
Moved recommendation regarding postScriptNameID to Recommendations.
gasp.htm
Clarified version 0 versus version 1.
gdef.htm
Changed table name: “MarkGlyphSetsTable” to “MarkGlyphSets” (table).
Changed field name in MarkGlyphSets table: “markGlyphSetsTableFormat” to
“format”.
glyf.htm

Added clarification regarding the number of points in a simple glyph
description.
Clarified descriptions of xMin, yMin, xMax, yMax.
gpos.htm
In BaseRecord, changed field name “baseAnchorOffset” to “baseAnchorOffsets”.
Removed GPOS-specific formats that were identical to formats in GSUB but with
different names, replaced by common formats shared between GSUB and
GPOS, described in chapter2.htm:
ContextPosFormat1, ContextPosFormat2, ContextPosFormat3, and associated
subtables (replaced by SequenceContextFormat1, etc.)
ChainContextPosFormat1, ChainContextPosFormat2,
ChainContextPosFormat3, and associated subtables (replaced by
ChainedSequenceContextFormat1, etc.)
PosLookupRecord (replaced by SequenceLookupRecord)
In section on position lookup records, added note regarding lookup flags in a
main lookup table and in nested lookup tables.
gsub.htm
Removed GSUB-specific formats that were identical to formats in GPOS but with
different names, replaced by common formats shared between GSUB and
GPOS, described in chapter2.htm:
ContextSubstFormat1, ContextSubstFormat2, ContextSubstFormat3, and
associated subtables (replaced by SequenceContextFormat1, etc.)
ChainContextSubstFormat1, ChainContextSubstFormat2,
ChainContextSubstFormat3, and associated subtables (replaced by
ChainedSequenceContextFormat1, etc.)
SubstLookupRecord (replaced by SequenceLookupRecord)
hdmx.htm
Changed data types for numRecords, sizeDeviceRecord to unsigned types.
head.htm
Changed field name: “checkSumAdjustment” to “checksumAdjustment”.
Added recommendation regarding flags bit 3 in hinted fonts.
Clarified descriptions for xMin, yMin, xMax, yMax.
hhea.htm
Clarified descriptions for minLeftSideBearing, minRightSideBearing.
Revised note regarding the ascender, descender and linegap fields.
hmtx.htm
Clarified wording regarding the hMetrics and leftSideBearings arrays.

Clarified the left side bearing value that should be specified for empty glyphs.
index.htm
Updated version number and reference to ISO/IEC 14496-22.
Removed reference to the WGL4.0 character set.
Incorporated links to ttch01.htm, tt_instructing_glyphs.htm, tt_instructions.htm,
tt_graphics_state.htm.
Changed links for Adobe Technical Notes #5176, #5177 to be direct, external
links, not to cffspec, charstr2 pages.
jstf.htm
Changed field names in JstfPriority table:
“shrinkageEnableGSUB” to “gsubShrinkageEnableOffset”
“shrinkageDisableGSUB” to “gsubShrinkageDisableOffset”
“shrinkageEnableGPOS” to “gposShrinkageEnableOffset”
“shrinkageDisableGPOS” to “gposShrinkageDisableOffset”
“shrinkageJstfMax” to “shrinkageJstfMaxOffset”
“extensionEnableGSUB” to “gsubExtensionEnableOffset”
“extensionDisableGSUB” to “gsubExtensionDisableOffset”
“extensionEnableGPOS” to “gposExtensionEnableOffset”
“extensionDisableGPOS” to “gposExtensionDisableOffset”
“extensionJstfMax” to “extensionJstfMaxOffset”
kern.htm
In Format 2, changed field names:
“leftClassTable” to “leftClassOffset”
“rightClassTable” to “rightClassOffset”
“array” to “kerningArrayOffset”
languagetags.htm
Added note clarifying ISO 639 identifiers that may be listed for a given language
system tag.
Added note about permanent reservation of 'dflt', 'DFLT'.
Revised details regarding ISO 639 mappings for language system tags 'AKA ',
'ATH ', 'BAD0', 'BER ', 'BML ', 'CPP ', 'FNE ', 'HAL ', 'IJO ', 'KOH ', 'KRN ', 'MYN ',
'NAH ', 'QIN ', 'SLA ', 'SRB ', 'TMH ', 'TNE ', 'TWI ', 'YCR '.
Corrections to show full tags 'HO ', 'WA '.
Revised descriptions for 'DGO ', 'DGR ', 'ZHH ', 'ZHTM'.
Added: 'AKB ', 'BTD ', 'BTK ', 'BTM ', 'BTX ', 'BTZ ', ZHTM.
Added 'DAG ' (post-release update).
Added 'AVN ', 'KAW ', 'LEF ', 'WCI ' (post-release update).

Added 'CTT ', 'HAI0', 'HEI ', 'HMD ', 'HMZ ', 'IRU ', 'KWK ', 'LPO ', 'RHG ', 'SFM ',
'TLI ', 'XUB ', 'XUJ ', 'YGP ', 'YNA ', 'YWQ ' (post-release update).
Revised ISO 639 mapping details for 'SXT ' (post-release update.)
loca.htm
Revised recommended for local offsets to be word aligned.
math.htm
Changed field name in MathValueRecord: “deviceTableOffset” to “deviceOffset”.
Changed flag name “fExtender” to “EXTENDER_FLAG”.
For fields that are values in design grid units, changed data types from int16 to
FWORD, and from uint16 to UFWORD.
Clarified meaning of “shift” in MathConstants fields.
Clarified default rule thickness.
Added clarification of suggested value for spaceAfterScript.
Added suggested value for radicalKernAfterDegree.
maxp.htm
Changed type for the version field from Fixed to Version16Dot16.
meta.htm
Corrected description of example Hant-HK.
name.htm
Changed field names:
Header: “format” to “version”
Version 0 and version 1 headers: “stringOffset” to “storageOffset”
LangTagRecord: “offset” to “langTagOffset”
NameRecord: “offset” to “stringOffset”
Re-organized content to move tables of platform, encoding and language IDs
to the end of the chapter. Also removed details relevant only to the 'cmap'
table.
Updated language and region strings for Windows language ID 042F.
Changed the language name for Windows language ID 081D to “Swedish”.
os2.htm
Corrected details for Unicode range fields regarding bit 92 and versions 3, 4.
otff.htm
Changed field names:
In TableRecord: “checkSum” to “checksum”.
In TTC Header version 1.0 and version 2.0: “offsetTable” to
“tableDirectoryOffsets”.

Clarified that LONGDATETIME values are in UTC time.
Defined a Version16Dot16 type (replacing Fixed used for table version).
Clarified use of “record” and “table” in describing defined structures.
Clarifed statement regarding file extensions.
Removed historic reference to Multiple Master support being discontinued.
(Details are retained in the change log.)
Revised terminology, removing use of “offset table” and making consistent use
of “table directory”.
Re-organized description of TableDirectory and TableRecord array, adding
tableRecords[] as a member in TableDirectory.
Provided details regarding purpose of searchRange, entrySelector and
rangeShift fields as well as recommendations for fonts and parsing.
Moved statement of the requirement for four-byte table offsets to follow
description of table records.
Clarified checksum calculation for tables with length not a multiple of four.
Clarified calculation of the 'head' table checksum and checksumAdjustment, and
checksums in collection files.
Clarified location of DSIG table within a TTC file.
Added clarifications regarding custom, vendor-defined tags.
otvarcommonformats.htm
Changed field name in DeltaSet record: “DeltaData” to “deltaData”.
Added text defining special meaning of delta-set outer- and inner-level indices
0xFFFF/0xFFFF as an indication of no variation data.
Added constraint on VariationRegionList.regionCount to be less than 32,768
(high bit reserved).
Added note regarding NULL offsets in the itemVariationDataOffsets array.
In DeltaSet record, revised description of deltaSet array to indicate number of
elements in array, not byte length.
otvaroverview.htm
Moved description of normalization process and example from avar.htm into
this chapter.
overview.htm
Complete re-write of the overview content.
pclt.htm
Revised member names to use camel case.
Clarified note on discouraged usage.
post.htm

Changed type for the version field from Fixed to Version16Dot16.
Clarified the description of version 2.0; this includes changing the type and field
name for the string data.
Clarified encoding of name strings and moved requirements from
Recommendations to here.
recom.htm
Removed byte ordering and 'OS/2' sections.
Revised the table alignment section.
Revised the 'cmap' recommendations.
Added 'fvar' section with recommendation regarding postScriptNameID.
'name' section: Revised guidance regarding names for the Macintosh platform.
'post' section: Moved name string requirements to 'post' table chapter.
Removed redundant and obsolete recommendations.
sbix.htm
Revised descriptions of originOffsetX, originOffsetY, and provided clarification
regarding positioning of the bitmap graphic.
scripttags.htm
Added script tags for new scripts in Unicode 12 and Unicode 13.
Corrected script tag for Yi. (Post-release erratum.)
stat.htm
Relaxed constraint on name IDs used for AxisRecord.axisNameID.
Revised constraints and recommendations regarding separate axis value tables
having the same information.
For AxisValueFormat2, clarified details regarding touching and overlapping
ranges.
For AxisValueFormat4, clarified precedence when two tables are partial matches,
and clarified the axis ordering to be assumed .
Adopted consistent spelling for flag names: OLDER_SIBLING_FONT_ATTRIBUTE
and ELIDABLE_AXIS_VALUE_NAME.
Revised chapter for greater clarity.
svg.htm
Changed field name “offsetToSVGDocumentList” to “svgDocumentListOffset”.
Clarified note regarding glyph advances not changing due to animations.
tt_graphics_state.htm
Corrected the list of instructions affected by single_width_cut_in and
single_width_value, and clarified the units for single_width_value.

tt_instructing_glyphs.htm
Removed incorrect statement regarding single_width_cut_in applying to indirect
instructions.
tt_instructions.htm
Corrected figures illustrating stack operations for JROF.
Correction in details for SDPVTL.
Corrected figures for SFVFS, SZP1, SMD, ALIGNRP, GC.
Clarified ISECT and corrected figure.
Clarified units for SSW.
ttinst.htm
Removed file: links to child pages incorporated into index.htm; introductory
paragraph incorporated into ttch01.htm.
ttochap1.htm
Replaced Figure 1h with a clearer illustration of language system differences.
Consolidated “TrueType versus OpenType Layout” section into the “OpenType
Layout at a glance” section.
vdmx.htm
In VDMX header, changed field name “offset” to “vdmxGroupOffsets”.
vhea.htm
Clarified scope of usage for the table.
Changed type for the version field from Fixed to Version16Dot16.
Revised descriptions of vertTypoAscender, vertTypoDescender.
wgl4.htm, wgl4b.htm, wgl4c.htm, wgl4d.htm, wgl4e.htm
Removed files. (Content was not part of the font format specification; it remains
available elsewhere.)

Version 1.8.3
Released August 2018
Minor editorial changes were made in the following chapters: base.htm,
baselinetags.htm, cbdt.htm, cblc.htm, cff.htm, cff2.htm, cff2charstr.htm, changes.htm,
chapter2.htm, cmap.htm, colr.htm, cpal.htm, cvar.htm, dsig.htm, dvaraxisreg.htm,
dvaraxistag_ital.htm, dvaraxistag_opsz.htm, dvaraxistag_slnt.htm, dvaraxistag_wdth.htm,
dvaraxistag_wght.htm, ebdt.htm, eblc.htm, ebsc.htm, featurelist.htm, features_ae.htm,
features_fj.htm, features_ko.htm, features_pt.htm, features_uz.htm, featuretags.htm,
fvar.htm, gasp.htm, gdef.htm, glyf.htm, gpos.htm, gsub.htm, gvar.htm, hdmx.htm,

head.htm, hhea.htm, hmtx.htm, hvar.htm, index.htm, jstf.htm, kern.htm,
languagetags.htm, ltsh.htm, math.htm, merg.htm, meta.htm, mvar.htm, name.htm,
namesmp.htm, os2.htm, otff.htm, otvarcommonformats.htm, otvaroverview.htm,
pclt.htm, post.htm, recom.htm, sbix.htm, scripttags.htm, stat.htm, svg.htm, ttch01.htm,
ttochap1.htm, ttoreg.htm, vdmx.htm, vhea.htm, vmtx.htm, vorg.htm, vvar.htm.
The editorial changes include applying a convention for tag values: single, straight
quotation marks are used for lowercase tags; they are not used for uppercase tags
except when extra clarification is required, such as when a tag has trailing spaces; and
marks are not when a tag is used like an object name, as in “head.macStyle”, or when
used like a function name, as in “cmap(j)”.
In the summary of changes below, details given above are not repeated.
Summary of Changes:
base.htm
Corrected figure 5c.
cmap.htm
Corrected field names for format 4.
Eliminated outdated references to “UCS-2” and “UCS-4”.
Added comments regarding use of formats 8, 10.
Corrected typo in glyphId index value equation from “startCount” to
“startCode”.
cff2.htm
Revised name of operand for blend operator.
Corrected max number of glyphs supported by FDSelect Format 3 from 65536
to 65536. (Post-release erratum.)
changes.htm
Re-organized how systemic and minor editorial changes are recorded for
Version 1.8.1.
Removed reference to proposals.htm (this legacy page was a companion to this
specification but not part of it).
Replaced references to default.htm (no longer used) with index.htm.
Added missing change to ttinst1.doc in OpenType 1.5. (Post-release erratum.)
chapter2.htm
Corrected the number of GSUB lookup types (eight).
Clarifed description of Coverage Indexes for Coverage Format 2.
dsig.htm
Revised statments regarding anticipated use of signatures.
ebdt.htm
Corrected text typo from “EDBT” to “EBDT” in the Header.

eblc.htm
Corrected text typo from “EDBT” to “EBDT” in the first paragraph.
Corrected text from “16-bit alignment” to “32-bit alignment”.
ebsc.htm
Corrected text typo from “EBLC” to “EBSC” in “EBSC Header”.
features_ko.htm
Corrected description for 'med2'.
features_pt.htm
Corrected example for 'ssty'. (Post-release erratum.)
Corrected Tag: 'ssty'. (Post-release erratum.)
featuretags.htm
Revised comments on implementation of 'init' feature for Arabic text for
consistency with description of the 'init' feature.
gdef.htm
Revised field names in MarkGlyphSetsTable format to conform to conventions.
glyf.htm
Clarified the description of simple glyph flags.
Added the OVERLAP_SIMPLE flag.
Corrected statement regarding numberOfContours for simple glyph
descriptions. (Post-release erratum.)
gpos.htm
Corrected description of the offset to Device / VariationIndex tables within
ValueRecord.
Clarified placement and advance effects of lookup types 1 – 6.
grstate.doc
Content ported into Web page: tt_graphics_state.htm.
gsub.htm
For Single Substitition Format 1, indicated that addition is modulo 65536.
Corrected error in example 7: DashAndSpaceSubRuleSet is at offset
SubRuleSet[1].
hhea.htm
Removed references to historic platforms.
index.htm
Updated version number and reference to ISO/IEC 14496-22.
Removed mention of Microsoft Word documents.
instgly.doc
Content ported into Web page: tt_instructing_glyphs.htm.
jstf.htm
Revised field name, jsftLangSysOffset, to follow conventions.
kern.htm
Removed references to historic platforms.

languagetags.htm
Added 'KJZ ', 'MFA ', 'TSJ ', 'XKF '.
Added additional ISO 639 mappings.
math.htm
Revised descriptions for better clarity.
Re-ordered content in section on MathKernInfo table for better clarity.
In description of formats for MathItalicsCorrectionInfo,
MathTopAccentAttachment, MathKernInfo and MathVariants, clarified that the
count fields must be the same as the number of glyph IDs referenced in the
Coverage tables.
Revised structure and field names to follow conventions.
maxp.htm
Clarified maxStackElements.
name.htm
Replaced obsolete recommendation to have Macintosh strings for legacy
version-control implementations with advisory that apps might display incorrect
strings.
Added link to BCP 47.
Eliminated outdated references to “UCS-2” and “UCS-4”.
Corrected Macintosh platform language ID for Inuktitut; corrected typos
(Quechua, Tagalog).
In the table for the Platform ID enumeration, corrected the description for
language IDs for Platform ID 0 (error introduced in version 1.5).
Revised descriptions for name IDs 1 and 2.
os2.htm
Incorporated relevant information regarding OS/2 versions 0 to 4. (Separate
pages removed.)
Added note regarding truncated version 0 definition in Apple’s TrueType
Reference Manual.
Corrected units for xAvgCharWidth.
fsType: Clarified “embedding”; revised presentation of flags; noted that bit 0 is
permanently reserved.
yStrikeoutSize, yStrikeoutPosition: Removed legacy statements intended for
bitmap fonts; added reference to post.underlineThickness.
panose: Clarified the contingent meaning of bytes other than the first byte.
ulUnicodeRange: Eliminated outdated references to “UCS-2” and “UCS-4”;
added note that available bits are exhausted, and reference to 'dlng' and 'slng'
tags in the 'meta' table; clarified some issues for early OS/2 versions.
achVendID: Revised description.
sTypoAscender, sTypoDescender, sTypoLineGap: Revised descriptions; clarified
the non-requirement that sTypoAscender - sTypoDescender equal unitsPerEm.

usWinAscent, usWinDescent: Revised description; clarified clipping behavior in
Windows GDI, and added note regarding interaction with VDMX.
Added more information about setting default line metric values in variable
fonts, and varying line metric values in variable fonts.
Added more information about setting usLowerOpticalPointSize and
usUpperOpticalPointSize values in variable fonts.
os2ver0.htm, os2ver1.htm, os2ver2.htm, os2ver3.htm, os2ver4.htm
Pages removed; relevant content integrated into os2.htm.
otff.htm
Added .TTC and .OTC to cited filename extensions, and removed
recommendation details, which are already provided in the Recommendations
chapter.
Added table and design-variation axis to items identified using Tag.
Moved the specification for valid Tag values from the Table Record description
into the data types section.
Made clarifications regarding representations of version numbers
Changed the data type for the first member of the Table Record to Tag, and
changed the member name and description.
For underlineThickness, added reference to OS/2.strikeoutSize.
otvaroverview.htm
Corrected the arithmetic details in the last part of the example in the
Interpolation Example section.
Corrected typo “wiht” to “with” in “Coordinate Scales and Normalization”.
recom.htm
Added filename recommendation related to CFF and revised wording related to
font collections.
Eliminated outdated references to “UCS-2”, “UCS-4” and legacy products in
'cmap' section.
Removed obsolete guidance for use of 'vrt2' feature in CJK fonts.
stat.htm
Revised the introduction to Axis Value Tables for better clarity.
Corrected typo changing “appliations” to “applications”.
svg.htm
Revised organization and descriptive text for better clarity.
Revised structure names to follow conventions.
Prohibited use of “HTML dialect” SVG documents.
Restricted usage of XML namespace declarations.
Limited capabilities to SVG 1.1. Deprecated use of context-* properties from
SVG2 (support was required in earlier versions).
Added section detailing SVG 1.1 capability requirements and restrictions.
(Several capabilities not clearly discussed in earlier versions are now

discouraged or not supported.)
Clarified use of CSS custom properties and integration of CPAL, including
interpretation of CPAL alpha values.
Added use of currentColor (supersedes use of context-fill, context-stroke).
Clarified relationship of coordinate system and viewport to glyph design grid,
and also viewport clip behavior.
Removed references to “user agent style sheets”.
Removed section on security considerations and glyph rendering restrictions
(superseded by the added section on SVG 1.1 capability requirements and
restrictions).
Added Example 1.
Revised Example 5, replacing context-fill with currentColor.
ttinst.htm
Revised links to refer to content ported from Microsoft Word files to Web
pages. (Post-release update, August 2018.)
ttinst1.doc
Content ported into Web page: tt_instructions.htm. (Post-release update,
August 2018.)
ttinst2.doc
Content ported into Web page: tt_instructions.htm. (Post-release update,
August 2018.)
tt_instructions.htm
Corrected MIRP Code range to 0xE0 - 0xFF.
Corrected errors introducted when porting from Word documents (some
changes from earlier versions were not retained). (Post-release erratum.)
Changed “NPUSHB” to “NPUSHW” in GETVARIATION. (Post-release erratum.)
Corrected error in “FLIPRGOFF” regarding on-curve versus off-curve points.
(Post-release erratum.)
Removed extra, incorrect uses from “IUP”. (Post-release erratum.)
Corrected text in GETVARIATION[] normalized coordinates. (Post-release
erratum.)
Corrected error in code range of MIRP inadvertently introduced when porting
from Word documents. (Post-release erratum.)
Corrected error in description of “logical OR” inadvertently added when porting
from Word documents. (Post-release erratum.)
Removed incorrect text inadvertently added to description of Round to Half
Grid (RTHG) when porting from Word documents. (Post-release erratum.)
ttochap1.htm
Fixed typo in image (fig1i.gif).
vhea.htm
Made corrections to the description for vertTypoDescender.

Version 1.8.2
Released July 2017.
Many editorial changes have been made, including revision of structure and field names
in several chapters to conform to conventions used across this specification. Such
changes were made in the following chapters:
Revision of structure or field names: base.htm, cff2.htm, chapter2.htm, colr.htm,
cvar.htm, ebdt.htm, eblc.htm, ebsc.htm, fvar.htm, gasp.htm, gdef.htm, gpos.htm,
gsub.htm, gvar.htm, hvar.htm, jstf.htm, merg.htm, mvar.htm,
otvarcommonformats.htm, sbix.htm, stat.htm, svg.htm, vvar.htm.
A significant editorial change pertains to documentation of design-variation axes and
axis tags: previously, these were documented within the 'fvar' table chapter. The axis
tags are also used in other tables, however, and may be relevant for non-variable fonts.
Also, the set of registered axes may grow over time. Hence, documentation of axes and
axis tags has been moved to a separate section, OpenType Design-Variation Axis Tag
Registry.
Minor editorial changes were made in the following chapters: avar.htm, base.htm,
cbdt.htm, cblc.htm, cff.htm, cff2.htm, cff2charstr.htm, chapter2.htm, cmap.htm, colr.htm,
cpal.htm, cvar.htm, dsig.htm, ebdt.htm, eblc.htm, ebsc.htm, features_fj.htm, fvar.htm,
gasp.htm, gdef.htm, glyf.htm, gpos.htm, gsub.htm, gvar.htm, hdmx.htm, head.htm,
hhea.htm, hmtx.htm, hvar.htm, jstf.htm, math.htm, maxp.htm, merg.htm, mvar.htm,
os2.htm, otff.htm, otvarcommonformats.htm, otvaroverview.htm, post.htm, sbix.htm,
scripttags.htm, stat.htm, vvar.htm, wgl4b.htm.
In the summary of changes below, details given above are not repeated.
Summary of Changes:
avar.htm
Clarified requirements on AxisValueMap records within a SegmentMap.
cff.htm
Added note about Name INDEX entry, name ID 6 and collections.
cff2.htm
In Top DICT (section 7), indicated that FontMatrix operator is required only if
head.unitsPerEm does not equal 1000, and limited the FontMatrix operand array
values. Also deprecated use of FontMatrix operator in Font DICTs (section 10
and Appendix C).
Corrected description of blend and vsindex operators (section 8).
Corrected description of operands for the Private operator (section 10).

Corrected error in numeric range of reserved two-byte DICT operators
(Appendix C).
Removed the maxstack operator.
cff2charstr.htm
In 3.2, CharString Number Encoding, corrected the described range of values
represented for byte values 251 to 254.
Revised argument stack limit in Appendix B to 513, and removed reference to
maxstack operator.
chapter2.htm
Relaxed constraint on DFLT script table and LangSysCount.
cmap.htm
Clarified description for defaultUVSOffset and nonDefaultUVSOffset.
Re-organized introductory paragraphs and details on platform/encoding IDs.
dvaraxisreg.htm
Created new page.
dvaraxistag_ital.htm
Created new page.
dvaraxistag_opsz.htm
Created new page.
dvaraxistag_slnt.htm
Created new page.
dvaraxistag_wdth.htm
Created new page.
dvaraxistag_wght.htm
Created new page.
features_ae.htm
Revised 'ccmp' feature description.
features_ko.htm
Corrected the friendly name for the 'med2' feature.
fvar.htm
Added a new flag definition for VariationAxisRecord.
Removed Variation Axis Tags section and made reference instead to OpenType
Design-Variation Axis Tag Registry page.
gasp.htm
Revised documentation of behavior flags, and indicated that reserved bits must
be set to zero.
glyf.htm
Added clarifying information about table organization, side bearings, point
numbers, scale for coordinate values, packed representation of flags and
coordinates in simple glyph descriptions, and the

SCALED_COMPONENT_OFFSET and UNSCALED_COMPONENT_OFFSET
composite glyph flags.
Clarified use of negative numberOfContours values to indicate composite
glyphs, and the recommendation that -1 be used.
Revised documentation of flags, and indicated that reserved bits must be set to
zero.
grstate.doc
Content ported into Web page: tt_graphics_state.htm. (Post-release update,
August 2018.)
gvar.htm
Amend the algorithm for inferring deltas of un-referenced points to avoid
division by zero and to completely cover possible cases.
hmtx.htm
Revise errors in the informative description.
index.htm
Version update.
Added link to OpenType Design-Variation Axis Tag Registry page.
Removed mention of Microsoft Word documents. (Post-release update, August
2018.)
instgly.doc
Content ported into Web page: tt_instructing_glyphs.htm. (Post-release update,
August 2018.)
languagetags.htm
Added CCHN.
meta.htm
Corrected the format of the table version (post-release erratum).
mvar.htm
Changed reference for variation axis tags from 'fvar' chapter to OpenType
Design-Variation Axis Tag Registry page.
name.htm
Clarified that the string data referenced by 3/1 or 3/0 name records must be
encoded in UTF-16BE.
Revised descriptions for name IDs 1, 2 and 4, and also the paragraph describing
key names for Microsoft platforms.
os2.htm
Changed reference for variation axis tags from 'fvar' chapter to OpenType
Design-Variation Axis Tag Registry page.
Corrected link to PANOSE specification (post-release erratum).
os2ver0.htm
Corrected link to PANOSE specification (post-release erratum).
os2ver1.htm

Corrected link to PANOSE specification (post-release erratum).
os2ver2.htm
Corrected link to PANOSE specification (post-release erratum).
os2ver3.htm
Corrected link to PANOSE specification (post-release erratum).
os2ver4.htm
Corrected link to PANOSE specification (post-release erratum).
otff.htm
Clarify that table lengths measure a contiguous byte range encompassing the
data for the table.
pclt.htm
Corrected the data type of the MajorVersion field (post-release erratum).
Corrected the description for SerifStyle (post-release erratum).
post.htm
Changed reference for variation axis tags from 'fvar' chapter to OpenType
Design-Variation Axis Tag Registry page.
Corrected link to Adobe glyph naming guide (post-release erratum).
recom.htm
Clarified that the string data referenced by 3/0 name records must be encoded
in UTF-16BE.
For optical size variants, clarified representation within a STAT axis value table
for an upper text size of effective infinity.
Corrected link to Adobe glyph naming guide (post-release erratum).
Corrected link to PANOSE specification (post-release erratum).
scripttags.htm
Removed details on processing of script tags, and replaced with link to details in
the OpenType Layout Common Table Formats (post-release erratum).
Added tags for additional scripts in Unicode 10, Unicode 11 (post-release
update).
stat.htm
Added axis value table format 4.
Revised Introduction to clarify purpose and use of the table as a whole; and
revised introduction in the Axis Value Tables section to clarify purpose and use
of axis value tables.
Added clarifications regarding axes, mapping to legacy font-family models, and
serialized representation of document text-formatting properties.
Clarified representation of effective infinity and negative infinity in range
min/max fields of format 2 axis value tables.
Added note regarding use of OlderSiblingFontAttribute.
Changed reference for tag requirements from 'fvar' table to the Opentype
Design Variation Tag Registry.

Revised the axis ordering in example 3 to reflect recommendation given in Axis
Value Tables section.
ttinst.htm
Revised links to refer to content ported from Microsoft Word files to Web
pages. (Post-release update, August 2018.)
ttinst1.doc
Content ported into Web page: tt_instructions.htm. (Post-release update,
August 2018.)
ttinst2.doc
Content ported into Web page: tt_instructions.htm. (Post-release update,
August 2018.)
ttochap1.htm
Added hyperlink to OpenType Mirroring Pairs List file (ompl.txt).
tt_instructions.htm
Corrected errors introduced when porting from Word documents (some
changes from earlier versions were not retained). (Post-release erratum.)
Corrected error in description of “logical OR” inadvertently added when porting
from Word documents. (Post-release erratum.)
Removed incorrect text inadvertently added to description of Round to Half
Grid (RTHG) when porting from Word documents. (Post-release erratum.)
Corrected error in code range of MIRP inadvertently introduced when porting
from Word documents. (Post-release erratum.)
vhea.htm
Corrected the calculation given in the description of yMaxExtent (post-release
erratum).
wgl4.htm
Corrected link to Adobe glyph naming guide (post-release erratum).
wgl4b.htm
Corrected link to Adobe glyph naming guide (post-release erratum).
wgl4c.htm
Corrected link to Adobe glyph naming guide (post-release erratum).
wgl4d.htm
Corrected link to Adobe glyph naming guide (post-release erratum).
wgl4e.htm
Corrected link to Adobe glyph naming guide (post-release erratum).

Version 1.8.1
Released January 2017.

Many editorial changes have been made, including global changes to the names of data
types used. Some technical corrections were made that do not affect structure
definitions. One structure change was introduced: a field was added in the STAT table.
Changes to names of data types were made in various chapters, as follows:
A single Fixed version field changed to uint16 major/minor version fields: cbdt.htm,
cblc.htm, ebdt.htm, eblc.htm, ebsc.htm, math.htm, otff.htm, pclt.htm.
Instances of “GlyphID” as a type changed to uint16: chapter2.htm, gpos.htm,
gsub.htm, jstf.htm, math.htm.
“2-byte signed short” changed to int16: ibmfc.htm.
BYTE to uint8: cbdt.htm, cblc.htm, cmap.htm, cpal.htm, dsig.htm, ebdt.htm,
eblc.htm, ebsc.htm, fpgm.htm, glyf.htm, hdmx.htm, hvar.htm, ltsh.htm, merg.htm,
os2.htm, os2ver0.htm, os2ver1.htm, os2ver2.htm, os2ver3.htm, os2ver4.htm,
otff.htm, otvarcommonformats.htm, pclt.htm, recom.htm, sbix.htm, vdmx.htm.
Card8, Card16 and Card32 to uint8, uint16 and uint32: cff2.htm.
CHAR to Tag: os2.htm, os2ver0.htm, os2ver1.htm, os2ver2.htm, os2ver3.htm,
os2ver4.htm.
CHAR to int8: cbdt.htm, cblc.htm, ebdt.htm, eblc.htm, otff.htm,
otvarcommonformats.htm, pclt.htm, post.htm.
LONG to int32: hdmx.htm, otff.htm, ttinst1.docx, ttinst2.docx.
Offset to Offset16: base.htm, chapter2.htm, gdef.htm, gpos.htm, gsub.htm, jstf.htm,
math.htm, merg.htm, mvar.htm, otff.htm.
SHORT to int16: cmap.htm ,gdef.htm, glyf.htm, gpos.htm, gsub.htm, hdmx.htm,
head.htm, hhea.htm, hmtx.htm, math.htm, os2.htm, os2ver0.htm, os2ver1.htm,
os2ver2.htm, os2ver3.htm, os2ver4.htm, otff.htm, otvarcommonformats.htm,
sbix.htm, ttinst1.docx, vdmx.htm, vhea.hdm, vmtx.htm, vorg.htm.
UINT24 to uint24: cmap.htm ,features_ae.htm, otff.htm.
ULONG used as a long offset changed to Offset32: base.htm, cblc.htm,
chapter2.htm, cmap.htm, colr.htm, cpal.htm, dsig.htm, eblc.htm, gdef.htm,
gpos.htm, gsub.htm, gvar.htm, hvar.htm, loca.htm, meta.htm, otff.htm,
otvarcommonformats.htm, sbix.htm, stat.htm, svg.htm, vvar.htm.
ULONG not used as an offset changed to uint32: cbdt.htm, cblc.htm, cff2.htm,
chapter2.htm, cmap.htm, cpal.htm, dsig.htm, eblc.htm, ebsc.htm, head.htm,

meta.htm, os2.htm, os2ver0.htm, os2ver1.htm, os2ver2.htm, os2ver3.htm,
os2ver4.htm, otff.htm, pclt.htm, post.htm, sbix.htm, svg.htm, ttinst1.docx,
ttinst2.docx.
USHORT used as an offset changed to Offset16: cvar.htm, eblc.htm, fvar.htm,
gvar.htm, kern.htm, loca.htm, merg.htm, name.htm, otvarcommonformats.htm,
stat.htm, vdmx.htm, vorg.htm.
USHORT not used as an offset changed to uint16: avar.htm, base.htm, cblc.htm,
cmap.htm, chapter2.htm, colr.htm, cpal.htm, cvar.htm, dsig.htm, ebdt.htm,
eblc.htm, features_ae.htm, features_pt.htm, fvar.htm, gasp.htm, gdef.htm, glyf.htm,
gpos.htm, gsub.htm, gvar.htm, hdmx.htm, head.htm, hhea.htm, hmtx.htm,
hvar.htm, jstf.htm, kern.htm, ltsh.htm, math.htm, maxp.htm, merg.htm, meta.htm,
mvar.htm, name.htm, os2.htm, os2ver0.htm, os2ver1.htm, os2ver2.htm,
os2ver3.htm, os2ver4.htm, otff.htm, otvarcommonformats.htm, pclt.htm, post.htm,
sbix.htm, stat.htm, svg.htm, ttinst1.docx, ttinst2.docx, vdmx.htm, vhea.htm,
vmtx.htm, vorg.htm, vvar.htm.
Minor editorial changes were made in the following chapters: base.htm, cbdt.htm,
cblc.htm, cff2.htm, cff2charstr.htm, chapter2.htm, colr.htm, cvar.htm, ebdt.htm, eblc.htm,
ebsc.htm, fvar.htm, gpos.htm, gsub.htm, gvar.htm, hdmx.htm, hmtx.htm, hvar.htm,
index.htm, jstf.htm, languagetags.htm, loca.htm, math.htm, otff.htm,
otvarcommonformats.htm, otvaroverview.htm, post.htm, stat.htm, vdmx.htm.
In the summary of changes below, details given above are not repeated.
Summary of Changes:
avar.htm
Corrected header definition, adding missing reserved field (post-release
erratum).
Corrected SegmentMaps record definition, showing axisValueMaps as an array
(post-release erratum).
cff2.htm
Revised Table 1, CFF Data Layout.
Revised description of operands in section 4, DICT Data, including removal of
the boolean operand type from Table 6.
Revised description of Top DICT data (section 7).
Deleted section 8, Glyph Organization
Revised description of CharString INDEX (now section 8).
Revised description of local and global subr indices (now section 9).
Revised description of Font DICT INDEX, Font DICTs and FDSelect (now section
10).

Revised description of Private DICT Data (now section 11).
Revised description of extensions for Font Variations (now section 12).
Added example CFF2 table in Appendix A.
Revised description of differences from CFF 1 (sections D1 to D4 of Appendix
D).
Deleted sections D5 and D6 from Appendix D.
cff2charstr.htm
Revised description of subroutines (section 2.3).
Revised description of CFF2 CharString organization (section 3.1), and
CharString number encoding (section 3.2).
Correction in Table 1, “CFF2 CharString Encoding Values” for byte values 251 –
254.
Revised description of CharString operators (section 4).
Revised description of path construction operators (section 4.1). Note that
changes to the individual operator descriptions are editorial only.
Revised description of finishing a CharString outline definition (section 4.2).
Revised description of subroutine operators (section 4.4).
Revised description of variation data operators (section 4.5).
Revised summaries of one- and two-byte operators in Appendix A.
In Appendix B, revised description of argument stack limits, and removed
TransientArray elements from the list of limits.
Deleted Appendix C, “Compatibility and Deprecated Operators”.
chapter2.htm
Correction of type of MarkFilteringSet index in Lookup table from “unit16” (sic)
to uint16.
Removed erroneous reference to ConditionSet version.
Renamed FeatureVariationRecordsCount in FeatureVariations table to
FeatureVariationRecordCount
Renamed AlternateFeatureTableOffset field in FeatureTableSubstitutionRecord
to AlternateFeatureTable.
cmap.htm
Revised presentation of formats to give names to records and to integrate
record arrays into the presentation of the format for the parent structure
containing the array.
dsig.htm
Changed field names away from Hungarian notation (“ulVersion” to “version”,
etc.).
features_pt.htm
Added note for the 'size' feature regarding the STAT table.
fvar.htm

Changed the countSizePairs field to permanently reserved, and removed note
about this field.
Clarified usage of the axisSize and instanceSize fields.
Clarified expected behavior if axisCount is zero or if instanceCount is zero.
glyf.htm
Clarified types for items with variable types depending on flags.
grstate.doc
Content ported into Web page: tt_graphics_state.htm. (Post-release update,
August 2018.)
gvar.htm
Corrected definition of flags field (post-release erratum).
hmtx.htm
Re-ordered columns in table for the hmtx format to match the convention in
other chapters. Also presented the format of the longHorMetric record using
the same table conventions.
Added explanatory text for better clarity.
index.htm
Updated version number.
Removed mention of Microsoft Word documents. (Post-release update,
September 2018.)
instgly.doc
Content ported into Web page: tt_instructing_glyphs.htm. (Post-release update,
August 2018.)
languagetags.htm
Added tags: 'CJA ', 'CJM '
mvar.htm
Changed the axisCount field to reserved/not used. (The item variation store
already contains the axis count.)
Renamed offsetToItemVariationStore field to itemVariationStore.
Clarified usage of valueRecordSize field.
Added validation details for header fields.
os2.htm
Added a comment regarding PANOSE values in variable fonts.
Added comments for usLowerOpticalPointSize and usUpperOpticalPointSize
regarding the STAT table.
os2ver0.htm
Renamed ulCharRange array to ulUnicodeRange, and revised description.
otff.htm
Added type Offset32.
Removed FUNIT, GlyphID as types.

Revised description of version numbers, including clarification of requirement
for unrecognized major version changes.
Minor revisions to TTC header field names.
In the “Font Tables” section, changed the recommendation that tables be 4-byte
aligned to be a requirement — this is stated as a requirement earlier in the
discussion of checksum calculation.
Clarified that 'cvt ', 'fpgm' and 'prep' tables are all optional.
otvarcommonformats.htm
Renamed regionCount and regionIndices field names in ItemVariationData
subtable to regionIndexCount and regionIndexes.
recom.htm
In 'kern' table section, added a comment about kerning in variable fonts.
In 'maxp' table section, revised comment about CFF to include CFF2.
In OS/2 table section, added a comment regarding PANOSE values in variable
fonts.
Removed “Device Resolutions” section.
Added section on families with optical size variants, and related comment in
OS/2 section.
Corrected link to PANOSE specification. (Post-release update, September 2018.)
stat.htm
Added elidableFallbackNameID.
Clarified usage of designAxisSize field.
Added validation details for header fields.
Clarified usage of axisOrdering values.
Clarified behaviour of AxisValueFormat2 tables if two tables have overlapping
ranges on the same axis.
ttinst.htm
Revised links to refer to content ported from Microsoft Word files to Web
pages. (Post-release update, August 2018.)
ttinst1.doc
Content ported into Web page: tt_instructions.htm. (Post-release update,
August 2018.)
ttinst2.doc
Changed “NPUSHB” to “NPUSHW” in GETVARIATION example.
Content ported into Web page: tt_instructions.htm. (Post-release update,
August 2018.)
ttochap1.htm
Clarified expected behavior for OpenType Layout processing when glyph runs
are formatted with different variation instances of a variable font.
tt_instructions.htm

Corrected errors introducted when porting from Word documents (some
changes from earlier versions were not retained). (Post-release erratum.)
Corrected error in description of “logical OR” inadvertently added when porting
from Word documents. (Post-release erratum.)
Removed incorrect text inadvertently added to description of Round to Half
Grid (RTHG) when porting from Word documents. (Post-release erratum.)
Corrected error in code range of MIRP inadvertently introduced when porting
from Word documents. (Post-release erratum.)
vdmx.htm
Revised names of member structures.
Removed VDMX groups from the header format description — these are
subtables referenced via offsets.

Version 1.8
Released September 2016.
Summary of Changes:
avar.htm
Axis variations table added.
base.htm
Changed single Fixed version field to USHORT major/minor versions.
Changed int16/uint16 to SHORT/USHORT.
Added version 1.1 header.
Added section on OpenType Font Variations.
Revised description of BaseCoord Format 3 to accommodate Font Variations.
Added section for the Item Variation Store table.
cff2.htm
Compact Font Format 2 table added.
cff2charstr.htm
CFF 2 CharString Format added.
chapter2.htm
Changed int16/uint16 to SHORT/USHORT.
Added section on OpenType Font Variations.
Added VariationIndex table.
Added FeatureVariations table and constituent formats.
cvar.htm
CVT variations table added.
featurelist.htm
Added Required Variation Alternates feature.

Added Vertical Alternates for Rotation feature.
features_fj.htm
Revised feature descriptions for 'fina', 'halt', 'init', 'isol' (similar to ISO/IEC 1449622:2015 Draft Amendment 2).
Marked the 'hngl' feature as deprecated (following ISO/IEC 14496-22:2015 Draft
Amendment 2).
features_ko.htm
Revised feature descriptions for 'medi' (similar to ISO/IEC 14496-22:2015 Draft
Amendment 2).
features_pt.htm
Added Required Variation Alternates feature.
features_uz.htm
Revised feature description for 'vert' (similar to ISO/IEC 14496-22:2015
Amendment 1).
Added Vertical Alternates for Rotation feature (similar to ISO/IEC 14496-22:2015
Amendment 1).
Revised feature description for 'vhal' (similar to ISO/IEC 14496-22:2015 Draft
Amendement 2).
fvar.htm
Font variations table added.
gasp.htm
Added section on OpenType Font Variations.
gdef.htm
Added missing sections describing Mark Attachment Class and Mark Glyph Sets
tables.
Added sections for the Item Variation Store table.
Changed single Fixed version field to USHORT major/minor versions.
Changed int16/uint16 to SHORT/USHORT.
Added version 1.2 header.
Revised description of CaretValue Format 3 to accommodate Font Variations.
glyf.htm
Revised description of WE_HAVE_A_TWO_BY_TWO flag (following ISO/IEC
14496-22:2015 Amendment 1).
In table of composite flags, revised descriptions for OVERLAP_COMPOUND,
SCALED_COMPONENT_OFFSET and UNSCALED_COMPONENT_OFFSET (similar
to changes in ISO/IEC 14496-22:2015 Amendment 1).
gpos.htm
Changed single Fixed version field to USHORT major/minor versions.
Changed int16/uint16 to SHORT/USHORT.
Added section on OpenType Font Variations.
Added version 1.1 header and FeatureVariations table.

Revised descriptions of ValueRecord and ValueFormat to allow for
VariationIndex table.
Revised reserved mask for ValueFormat to 0xFF00.
Revised description of Anchor format 3 to allow for VariationIndex table.
grstate.doc
Content ported into Web page: tt_graphics_state.htm. (Post-release update,
September 2018.)
gsub.htm
Changed single Fixed version field to USHORT major/minor versions.
Changed int16/uint16 to SHORT/USHORT.
Added section on OpenType Font Variations.
Added version 1.1 header and FeatureVariations table.
gvar.htm
Glyph variations table added.
head.htm
Changed single Fixed version field to USHORT major/minor versions.
Changed description of checkSumAdjustment (following ISO/IEC 14496-22:2015
Amendment 1).
Revised description of flags bits 1, 5 and 6 – 10.
Added note about variable fonts.
hhea.htm
Changed single Fixed version field to USHORT major/minor versions.
Added section on OpenType Font Variations.
hvar.htm
Horizontal metrics variations table added.
index.htm
Added chapters: OpenType Font Variations Overview, OpenType Font Variations
Common Table Formats, The CFF 2 CharString Format, Adobe Technical Note
#5209.
Reordered entries between “Specification” and “Appendices” sections.
Removed mention of Microsoft Word documents. (Post-release update,
September 2018.)
instgly.doc
Content ported into Web page: tt_instructing_glyphs.htm. (Post-release update,
September 2018.)
jstf.htm
Changed single Fixed version field to USHORT major/minor versions.
Changed int16/uint16 to SHORT/USHORT.
Added section and other remarks on OpenType Font Variations.
languagetags.htm
Revised introductory text regarding tag syntax.

Revised ISO 639 values for 'QIN ', 'SYR '.
Added tags: SYRE, SYRJ, SYRN.
merg.htm
Merge table added.
meta.htm
Added meta table.
mvar.htm
Metrics variations table added.
name.htm
Changed description of name ID 6 (following ISO/IEC 14496-22:2015
Amendment 1).
Added new name ID 25.
os2.htm
Added comment for usWeightClass regarding variable fonts and 'wght' style
axis.
Added comment for usWidthClass regarding variable fonts and 'wdth' style axis.
Corrected misspelling of field name (following ISO/IEC 14496-22:2015
Amendment 1).
Added section on OpenType Font Variations.
Added note regarding fsSelection bit 15.
os2ver0.htm
Corrected misspelling of field name (following ISO/IEC 14496-22:2015
Amendment 1).
Added footer.
os2ver1.htm
Corrected misspelling of field name (following ISO/IEC 14496-22:2015
Amendment 1).
Added footer.
os2ver2.htm
Corrected misspelling of field name (following ISO/IEC 14496-22:2015
Amendment 1).
os2ver3.htm
Corrected misspelling of field name (following ISO/IEC 14496-22:2015
Amendment 1).
os2ver4.htm
Corrected misspelling of field name.
otff.htm
Changed sfntVersion to ULONG, and clarified discussion of version numbers.
Revised description of font collections (similar to changes in ISO/IEC 1449622:2015 Amendment 1).

Added new tables (CFF2, 'avar', 'cvar', 'gvar', 'gvar', HVAR, MVAR, VVAR, STAT)
and notes on OpenType Font Variations.
Removed obsolete reference to ATM.
otvarcommonformats.htm
Added OpenType Font Variations Common Table Formats chapter.
otvaroverview.htm
Added OpenType Font Variations Overview chapter.
post.htm
Revised descriptions of Versions 1.0, 2.0 and 3.0 to allow for use in fonts with
CFF 2 outlines.
Added section on OpenType Font Variations.
recom.htm
Added note in Filenames recommendations about naming of files for variable
fonts.
Removed section on first four glyphs (following ISO/IEC 14496-22:2015
Amendment 1).
Revised title and content of section on .notdef (similar to ISO/IEC 1449622:2015 Amendment 1).
Added notes in 'name' table recommendations about naming of variable fonts.
Revised 'name' table recommendation for name ID 6 (increased length limit
from 63 to 127).
Revised OS/2 table recommendation regarding PANOSE value (following
ISO/IEC 14496-22:2015 Amendment 1), and fixed external link.
Revised symbol-font recommendations regarding PANOSE value (following
ISO/IEC 14496-22:2015 Amendment 1).
Added section on stroke reduction in variable fonts.
Corrected link to PANOSE specification. (Post-release update, September 2018.)
sbix.htm
Standard bitmap graphics table added.
stat.htm
Style attributes table added.
svg.htm
Added requirement that SVG documents must be encoded in UTF-8 (following
ISO/IEC 14496-22:2015 Draft Amendment 2).
Added clarification for rendering multiple glyphs from a shared SVG document.
Removed context-* properties from default stylesheet applied to SVG
documents.
Revised language for handling different SVG versions (following ISO/IEC 1449622:2015 Draft Amendment 2).
Added SVG Glyph Examples section (following ISO/IEC 14496-22:2015 Draft
Amendment 2).

Minor typo corrections and clarifications.
ttinst.htm
Revised links to refer to content ported from Microsoft Word files to Web
pages. (Post-release update, September 2018.)
ttinst1.doc
Content ported into Web page: tt_instructions.htm. (Post-release update,
September 2018.)
ttinst2.doc
Clarified description of the GET INFO instruction.
Added GET VARIATION instruction.
Content ported into Web page: tt_instructions.htm. (Post-release update,
September 2018.)
ttochap1.htm
Added section on OpenType Font Variations.
tt_instructions.htm
Corrected error in description of “logical OR” inadvertently added when porting
from Word documents. (Post-release erratum.)
Removed incorrect text inadvertently added to description of Round to Half
Grid (RTHG) when porting from Word documents. (Post-release erratum.)
Corrected error in code range of MIRP inadvertently introduced when porting
from Word documents. (Post-release erratum.)
vhea.htm
Added section on OpenType Font Variations.
vvar.htm
Vertical metrics variations table added.

Version 1.7
Released March 2015.
Summary of Changes:
cbdt.htm
Created new page
cblc.htm
Created new page
cmap.htm
Minor text change in format 4
colr.htm
Created new page
cpal.htm

Created new page
featurelist.htm
Added Dotless Forms, Flattened accent forms, Math script style alternates,
Required Contextual Alternates and Stretching Glyph Decomposition
features_ae.htm
Updated 'cvXX'
Added Dotless forms
features_fj.htm
Added Flattened ascent forms
Updated UI suggestion for 'halt'
features_pt.htm
Updated Stylistic sets and Optical size
Added Math script style alternates, Required Contextual Alternates and
Stretching Glyph Decomposition
features_uz.htm
Updated UI suggestion for 'vhal'
gasp.htm
Added bit flag
grstate.doc
Content ported into Web page: tt_graphics_state.htm. (Post-release update,
September 2018.)
gsub.htm
Fixed typo in ligature substitution
head.htm
Clarified date description
Update description of bit 11
hmtx.htm
Updated text beneath table
index.htm
Updated version number
Removed mention of Microsoft Word documents. (Post-release update,
September 2018.)
instgly.doc
Content ported into Web page: tt_instructing_glyphs.htm. (Post-release update,
September 2018.)
jstf.htm
Fixed typo in Jstf priority table
languagetags.htm
Added new tags
math.htm
Added new table

maxp.htm
Updated maxFunctionDefs description
name.htm
Changed name IDs 16 and 17 from Preferred name to Typographic name and
updated descriptions
Added name IDs 23 and 24
Updated description for name ID 6
Updated description for name ID 20
os2.htm
Updated version to 5.0
Updated formats
Added usLowerOpticalPointSize and usUpperOpticalPointSize
os2ver4.htm
Added page to archive version 4.0
otff.htm
Changed Mantissa to Integer
Changed Truetype collection to Font Collection
Added new tables (CBDT, CBLC, COLR, CPAL and MATH)
Moved 'gasp' table to TT Outline table
Marked VORG table as optional in relation to Postscript outlines
post.htm
Updated reference to glyph list
Updated reference to index numbers
recom.htm
Added info on .OTC
Added post table note
Corrected link to PANOSE specification. (Post-release update, September 2018.)
scripttags.htm
Added new tags
svg.htm
Created new page
ttinst.htm
Revised links to refer to content ported from Microsoft Word files to Web
pages. (Post-release update, September 2018.)
ttinst1.doc
Content ported into Web page: tt_instructions.htm. (Post-release update,
September 2018.)
ttinst2.doc
Content ported into Web page: tt_instructions.htm. (Post-release update,
September 2018.)
vorg.htm

Indicated table is optional

Version 1.6
Released April 2009; updated July 2010.
Summary of Changes:
Updated HTML to be compliant with W3C standards
cff.htm
Appended description(July 2010)
chapter2.htm
Added information regarding GDEF table requirements
Updated page to show correct number of LookupTypes for GSUB and GPOS
Added MarkFilteringSet to Lookup table
cmap.htm
Updated outdated terminology
Added note to 'cmap' header explaining where to find definitions of ID values
Changed platform name from Microsoft to Windows
Added Format 13 (updated July 2010)
Updated note on the language field in 'cmap' subtables (July 2010)
featurelist.htm
Updated feature list
features_ae.htm
Added Character Variants feature
Clarified script/language sensitivity for 'c2sc' feature
features_ko.htm
Added Left-to-right alternates
Added Left-to-right mirrored forms
Updated 'lnum' and 'onum' (July 2010)
features_pt.htm
Added to recommended implementation for Stylistic Sets
Updated Right-to-left alternates
Added Right-to-left mirrored forms
Fixed link to 'name' table
Clarified script/language sensitivity for 'smcp' feature
Clarified script/language sensitivity for 'size' feature
gdef.htm
Updated information relating to GSUB and GPOS tables
Added MarkGlyphSetsDef to GDEF header
Updated version number

Change version number from fixed to ULONG
Updated GDEF header description (July 2010)
gpos.htm
Updated text in Pair Positioning Adjustment: Format 2
grstate.doc
Content ported into Web page: tt_graphics_state.htm. (Post-release update,
August 2018.)
head.htm
Deprecated fontDirectionHint
Updated description for bit 14 (July 2010)
index.htm
Updated version number
Added appendix for OMPL
Removed mention of Microsoft Word documents. (Post-release update, August
2018.)
instgly.doc
Content ported into Web page: tt_instructing_glyphs.htm. (Post-release update,
August 2018.)
kern.htm
Updated definition (July 2010)
languagetags.htm
Removed the word “standard” from French and German tags
Added IPPH and AMPH tags
Added additional expanatory text
Added column for ISO 639
loca.htm
Added information about zero length glyphs at the end of the table
name.htm
Changed platform name from Microsoft to Windows
Updated outdated terminology
Added Format 1 Naming table
Removed “set to zero” from name ID 15
Updated Unicode Platform Specific encoding ID table (July 2010)
Updated description for Name ID 4 (July 2010)
ompl.txt
Added OpenType Mirrored Pairs List
os2.htm
Fixed typo in Telugu range
Updated bit 61 (July 2010)
Corrected comments under fsSelection bit table (July 2010)
otff.htm

Changed ULONG to FIXED for TTC Header version numbers
Changed “Table Directory” to “Table Record” since it is refering to a single entry
in the directory
prep.htm
Fixed typo (changed CVT to CV)
Added reference to table’s previous name
recom.htm
Updated recommendations for 'glyf' table, 'kern' table, 'name' table and nonstandard (symbol) fonts (July 2010)
Corrected link to PANOSE specification. (Post-release update, September 2018.)
ttchap1.htm
Added text processing information for ltr and rtl text
ttinst.htm
Revised links to refer to content ported from Microsoft Word files to Web
pages. (Post-release update, August 2018.)
ttinst1.doc
Content ported into Web page: tt_instructions.htm. (Post-release update,
August 2018.)
ttinst2.doc
Content ported into Web page: tt_instructions.htm. (Post-release update,
August 2018.)

Version 1.5
Released May 2008.
Summary of Changes:
changes.htm
Reversed order so newest changes are at the top
cmap.htm
Added Format 14: Unicode Variation Sequences
featurelist.htm
Added new features to list
features_ae.htm
Added Centered CJK Punctuation, Conjunct Forms and Conjunct Form after Ro
Updated Akhand and Below-base Forms
features_fj.htm
Updated Half Forms
features_ko.htm
Explained 'kern'/'palt' interaction

Added date to JIS reference in NLC Kanji Forms
Updated Nukta Forms
features_pt.htm
Explained 'kern'/'palt' interaction
Added Proportional Kana
Updated Pre-base, Post-base and Reph Forms
Added Rakar Forms
features_uz.htm
Explained 'vpal'/'vkrn' interaction
Updated Vattu Variants
gasp.htm
Changed version number to 1 in 'gasp' table
Added flags for symmetric gridfit and symmetric smoothing
gdef.htm
Fixed typo regarding the number of tables within the Glyph Definition table
Fixed spelling error under CaretValue Format 1
grstate.doc
Content ported into Web page: tt_graphics_state.htm. (Post-release update,
August 2018.)
gsub.htm
Corrected title for ContextSubstFormat3 subtable
glyf.htm
Fixed typo in simple glyph description
head.htm
Updated description for bit 13
ibmfc.htm
Removed examples that were inaccurate
Updated references to ISO standard
Adjusted wording for subclasses not specifically refected in ISO standard
index.htm
Updated version number
Added ISO information
Removed mention of Microsoft Word documents. (Post-release update, August
2018.)
instgly.doc
Content ported into Web page: tt_instructing_glyphs.htm. (Post-release update,
August 2018.)
languagetags.htm
Updated list of tags
loca.htm
Removed incorrect example

Changed “should” to “must”
maxp.htm
Removed redundant sentence
name.htm
Added platform 0 encoding ID 5 for Unicode variation sequences
Added Name IDs 21 and 22
Updated Microsoft language IDs
os2.htm
Updated text describing ulUnicodeRange1 – ulUnicodeRange4
Added bits 7, 8 and 9 to fsSelection table
Updated version number
Updated ulUnicodeRange with latest range bits and added block ranges
Added recommendation to usDefaultChar and usBreakChar description
Corrected link to PANOSE specification. (Post-release update, September 2018.)
os2ver0.htm
Corrected link to PANOSE specification. (Post-release update, September 2018.)
os2ver1.htm
Corrected link to PANOSE specification. (Post-release update, September 2018.)
os2ver2.htm
Corrected link to PANOSE specification. (Post-release update, September 2018.)
os2ver3.htm
Created new page to archive previous version of OS/2 table
Corrected link to PANOSE specification. (Post-release update, September 2018.)
otff.htm
Added new data type (UINT24) to handle Unicode variation sequences
Added recommendation regarding VORG table
recom.htm
Added additional cross-platform recommendations
Added additional BASE table recommendations
Added recommendation regarding VORG table
Corrected link to PANOSE specification. (Post-release update, September 2018.)
scripttags.htm
Added script tags for scripts recently added to Unicode
Changed 'dflt' script to DFLT script in the description at the bottom of the page
ttinst.htm
Revised links to refer to content ported from Microsoft Word files to Web
pages. (Post-release update, August 2018.)
ttinst1.doc
INSTCTRL: Correct value stated for selector flag 3.
Content ported into Web page: tt_instructions.htm. (Post-release update,
August 2018.)

ttinst2.doc
Updated GETINFO with ClearType information
Content ported into Web page: tt_instructions.htm. (Post-release update,
August 2018.)
ttochap1.htm
Removed outdated information about behavior on Windows 95
wgl4d.htm
Added four Macedonian characters

Version 1.4
Released 11 October 2002.
Summary of Changes:
baselinetags.htm
Corrected typographic error.
Changed hanging baseline references from Hindi to Tibetan.
chapter2.htm
Corrected link to GDEF table.
Add documentation on new script tag DFLT.
cmap.htm
Add Name column to tabular data to make consistent with other parts of spec.
Correct description of Encoding Record.
cvt.htm
Indicate that length must be integral value of FWORD units.
dsig.htm
Provide information for ulVersion to be 0x00000001.
Update to show usFlag bits that are assigned.
Add section on signatures for TrueType Collections.
ebdt.htm
Change wording to indicate EBDT is superset of 'bdat'. These are not the same.
featurelist.htm
Added new features: 'abvf', 'c2pc', 'ljmo', 'nlck', 'pcap', 'pref', 'rtla', 'tjmo', 'unic',
and 'vjmo'.
Change friendly name of 'calt' from Connection Forms to Contextual Alternates.
fpgm.htm
Add comment that array size n is the number of bytes in the table.
gdef.htm
Example 6, typos in the comments column for increasing 15 and 16ppem
corrected.

gpos.htm
Clarify origin of Cartesian coordinate system at baseline of the left side.
Specify all values are done in font unit measurements.
Update images for better presentation.
PairPosFormat1 subtable ValueRecord changed to Offset,
PairSetOffset[PairSetCount].
Update wording on MarkToMark attachment.
grstate.doc
Content ported into Web page: tt_graphics_state.htm. (Post-release update,
August 2018.)
gsub.htm
Add Lookup Type 8, Reverse Chaining contextual single substitution.
hdmx.htm
Remove references to EGA.
Add statement that bit 2 of head.flag must be set to 1.
Add Name columns to tabular data for consistency with spec.
head.htm
Updated macStyle bit descriptions for bits 2 to 15.
unitsPerEm annotated that it should be a power of 2.
hhea.htm
Change FWord to FWORD for correct data type spelling.
ibmfc.htm
Fix formatting to indent subclasses for better readability.
index.htm
Update the version number to 1.4.
Removed mention of Microsoft Word documents. (Post-release update, August
2018.)
instgly.doc
Content ported into Web page: tt_instructing_glyphs.htm. (Post-release update,
August 2018.)
name.htm
Add Name column to tabular data for consistency with spec.
Correct descriptions in Naming Table for count and nameRecord[count].
Clarified description of encoding ID 0/3. Added encoding ID 0/4. Changed
description of encoding ID 3/10 to UTF-32.
Added description and example, for use of name ID 4 in CFF fonts.
Clarified working for use of name ID 5 (Version string).
Changed wording for name ID 16 (Preferred Family) and name ID 17 (Preferred
Subfamily).
Suggest that style strings (name ID 2 or 17) match with OS/2.usWeightClass and
OS/2.usWidthClass.

os2.htm
Updated version number to 0x0003
Updated Unicode sub-range bits to be aligned with Unicode 3.2.
Remove weighted calculation of xAvgCharWidth.
Make fsType bits 0-3 to be mutually exclusive. In other words, only one of those
bits may be set to “1” at a time. This is to avoid problems of ambiguity in what
the font designer intends.
Change link to PANOSE specification.
Updated description of usFirstCharIndex, usLastCharIndex, usDefaultChar,
usBreakChar; in context of fonts that provide surrogate character support.
Corrected link to PANOSE specification. (Post-release update, September 2018.)
os2ver0.htm
Corrected link to PANOSE specification. (Post-release update, September 2018.)
os2ver1.htm
Corrected link to PANOSE specification. (Post-release update, September 2018.)
os2ver2.htm
Corrected link to PANOSE specification. (Post-release update, September 2018.)
otff.htm
Update filename information for TrueType outline fonts.
Add data types for FWORD and UFWORD.
Corrected content and description of TTC header v1 and v2.
Moved VORG table to PostScript Outlines group.
pclt.htm
Change to discourage use of this table.
recom.htm
Added recommendation for first four glyphs in font.
Added recommendation for shape of .notdef glyph.
Corrected link to PANOSE specification. (Post-release update, September 2018.)
scripttags.htm
Add script tags for Byzantine Music and Default.
ttinst.htm
Revised links to refer to content ported from Microsoft Word files to Web
pages. (Post-release update, August 2018.)
ttinst1.doc
Content ported into Web page: tt_instructions.htm. (Post-release update,
August 2018.)
ttinst2.doc
Corrected description in Logical_Functions.Greater_Than.
Content ported into Web page: tt_instructions.htm. (Post-release update,
August 2018.)
ttoreg.htm

Reworded and reorganized for better readability.
vdmx.htm
Change ratio record and vTable record to tabular format.
Recommend use of version 1 VDMX.
wgl4e.htm
Optional glyphs identified and marked. Added a footnote.

Version 1.3
Released April, 2001.
Summary of Changes:
Multiple Master support in OpenType, discontinued. The following tables
pertaining to it have been removed from this version of the OpenType
specification: 'fvar', MMSD, MMFX.
base.htm
BaseTagList Table
Added a sentence with a link to the baseline tags in the tags registry.
BaseCoord Format 4
Removed.
cff.htm
Removed references to MM fonts in the CFF and Type 2 CharString Format
specifications. See the change log in each specification for additional changes
made.
chapter2.htm
Table Organisation
In paragraph 3, changed the number of types of GSUB and GPOS lookups.
Phrase added to Paragraph 4 to exclude the Extension lookup.
LookupFlag bit enumeration
Name of the first bit reverted back to RightToLeft. Provided newer description of
its use.
Coverage Table
Phrase added to exclude the Extension lookup.
cmap.htm
Merged paragraph 3 and 4 in the introduction section.
Added notes that fonts for Windows that support UCS-4 characters (surrogates),
need to use an encoding ID 10 and format 12.
The version field has been renamed as “language”, to align it with Apple’s TT
spec. Added a note to clarify the use of this field.
Added information that platform ID 3, encoding ID 7,8 and 9 are reserved.

Added platform ID 3, encoding ID 10.
Swapped the description of encoding ID 3 and 4. They were incorrectly mapped
to Big5 and PRC respectively, in earlier versions of the specification.
Added a note on OTF Windows compatibility mapping.
Formats 2, 4, 6.
Made the description of the length field in these formats consistent with the
rest of the formats.
Format 2
Removed the duplicate entry for subHeaders[ ].
Format 4
Corrected endCode and startCode values in the example for this format.
Supporting 4-byte character codes (Formats 8, 10, 12)
Added these new formats.
ebdt.htm
Minor typo in the name of ebdtComponent corrected.
feattags.htm
Added features 'ccmp', 'fin2', 'fin3', 'med2' and 'rlig'.
Clarified the Feature Interaction sections for 'kern', 'vkrn'.
Updated GSUB lookup type to be used, in the Recommended implementation
section of 'ordn'.
fvar.htm
This table removed.
gdef.htm
Introduction
Added information on the MarkAttachClassDef field.
Overview
Updated image to contain MarkAttachClassDef.
GDEF Header
Added missing information on the MarkAttachClassDef field.
GDEF Header Table
Added the note that offsets might be null for the GlyphClassDef, AttachList,
LigCaretList, MarkAttachClassDef
GlyphClassDef Enumeration List
An explanatory note added for definition of ligatures and component glyphs.
Mark Attachment Class Definition Table
An explanatory section and example 7 added.
CaretValue: Format 4
This format used by MM fonts removed.
gpos.htm
Corrected the link “Common Table Formats” to read “OpenType Common Table
Formats” throughout table.

Table Organization
Updated the image. Added links for all lookup types. Added Extension
positioning as LookupType 9, types 10+ are now Reserved.
PairPosFormat1 subtable
PairSet field corrected to specify it as an array of Offsets.
Lookup Type 6
Sentence added to clarify input context for MarkToBase, MarkToLigature and
MarkToMark positioning tables.
LookupType 9: Extension Positioning
This new lookup type added.
ValueRecord table
Removed XIdPlacement, YIdPlacement, XIdAdvance, YIdAdvance and the
sentence following the table.
ValueFormat bit enumeration
Removed XIdPlacement, YIdPlacement, XIdAdvance, YIdAdvance and the
sentence following the table.
Anchor Table: Format 4
Removed.
gsub.htm
Corrected the link “Common Table Formats” to read “OpenType Common Table
Formats” throughout table.
Substituting Glyphs with OpenTypeTM
Types of lookups corrected to six. Added an explanation to the ligature
substitution section, to clarify the location occupied by a ligature glyph when it
replaces a sequence of glyphs. Missing paragraph on Chaining contextual
substitution added.
Table Organization
Updated image.
LookupType Enumeration table for glyph substitution
Added links for all lookup types. Added Extension Substitution as the 7th
lookup type. This hence classifies types 8+ as Reserved.
LookupType 2:
Prohibited the deletion of an input glyph, and added that GlyphCount should
always be greater than 0.
Chaining Context Substitution Format 1: Simple Chaining Context Glyph
Substitution
Added that the match for the string backtrack sequence + input sequence +
lookahead sequence takes place in the simplest of cases; and that lookup flag
values affect backtrack/lookahead sequences. Since the input sequence includes
the covered glyph, removed “covered glyph” from the above string.

LookupType 7: Extension Substitution
This new lookup type added.
head.htm
table
Clarified description for bit 1, 5-10.
Added specification for bit 13.
hhea.htm
table
Added a footnote for the fields Ascender, Descender and LineGap.
hmtx.htm
Added a note that the advanceWidth for each glyph in CFF OpenType fonts
must match its x width in the CFF table.
loca.htm
Corrected minor typo.
maxp.htm
Added a note to indicate the difference in representing the fractional part of a
version number when it is non-zero.
mmfx.htm
This table removed.
mmsd.htm
This table removed.
name.htm
Minor rewording of text done in the introduction section related to fonts for the
Macintosh.
Platform ID, specific encoding ID and languageId information combined into one
table.
Unicode platform-specific encoding IDs (platform ID = 0)
This new table added.
Microsoft platform-specific encoding IDs
This table replaced with a more comprehensive table from the cmap.htm.
Mac platform-specific encoding IDs:
Clarified IDs 2 and 25. Corrected typo in ID 32.
Mac language IDs:
Newer IDs added 23-150.
ISO specific encodings (platform ID=2)
Marked as deprecated. Minor typo in the sentence below the table corrected.
Custom platform-specific encoding IDs (platform ID = 4)
Newer platform ID added.
Name IDs
Added newer description for nameID 5. Added nameID 19 and 20.

Examples
Added example for nameID 19.
LCID-CP list
Updated this list.
os2.htm
xAvgCharWidth.description
Comments for this field updated.
fsType.table
Added Bit Mask and description details for the case when no bit is set; added
Bit Mask value 0x0001.
fsType.comments
Information on setting Bit Masks consolidated into the description column of
the table. Removed the redundant section below the table.
yStrikeoutPosition.description
Added that this is the distance of the top of the strikeout stroke.
panose.description
Removed dead URL for the PANOSE evaluation document, added that the
“greybook” reference could be used instead.
ulUnicodeRange.table
Updated the Unicode standard version number to 3.0 in the description for
these fields. Added bits 70- 127. Added a footnote for setting bit 57
(Surrogates).
usFirstCharIndex.description
Minor correction: added the word platform specific.
sTypoAscender and sTypodescender
Minor corrections done; “design space” now referred to as “ideo em box” in the
descriptions; added a links to recom.htm for these fields.
usWinAscent
Explanatory note added to explain the circumstances in which clipping will take
place.
usWinDescent
Explanatory note added to explain the circumstances in which clipping will take
place.
sxHeight
Added a note that this metric can be used in font substitution.
usDefaultChar
Added that for a given font, missing glyphs will be displayed using the content
of glyph 0 in the selected font.
otff.htm
Version Numbers
Added explanation that representation of a non-zero fractional part in version

numbers, differs from the representation of the matissa.
Tables Related to PostScript Outlines
Removed links and description details for the fvar, MMSD and MMFX tables.
Advanced Typographic Tables
Added a link to OpenType Layout Common Table Formats.
Other OpenType Tables
Added the VORG table name to the list.
otover.htm
Related documentation
Removed sections in the description related to MM fonts.
post.htm
table.version.description
Added versions 2.5 and 3.0
table.underlinePosition.description
PostScript information added.
version2.0
Updated name and description details in the table contents
version2.5
Updated table contents, added that this version has been deprecated.
recom.htm
BASE Table
This section added.
'cmap' table
Added details on requirements that need to be satisfied by surrogate fonts on
Windows.
'head' Table
Added details regarding usage of the fontRevision value.
'hhea' Table
Removed sentence which incorrectly stated that OpenType fonts that include
CFF data must set numberOfHMetrics equal to the number of glyphs in the font.
'post' Table
Updated content related to glyph names in the post table.
OS/2 Table
Added section on sTypoAscender, sTypoDescender, sTypoLineGap.
General Recommendations
Updated the table ordering list for OpenType fonts containing CFF data by
adding the 'maxp' table; and, removing the 'fvar' and MMSD tables.
Baseline to Baseline Distances
Added a paragraph on the recommended use of sTypoAscender,
sTypoDescender, and sTypoLineGap.

OpenType CJK Font Guidelines
This new section added.
ttochap1.htm
Introduction
Removed MMSD reference.
Expanded the brief description of the content of Registered OpenType Layout
Tags to reflect all OpenType tags: scripts, languages, baselines, features.
How Multiple Master OpenType Fonts Use OpenType Layout Tables
This section removed.
ttoreg.htm
Added links in the introduction section, to help jump to the script, language,
baseline and feature tag sections.
Script tags
Corrected script tag length description.
Added newer script tags.
Language system tags
Added newer language tags.
Baseline tags
Added newer baseline tags: 'icfb', 'icft' and 'idtp'. Expanded the description of
existing tags into two categories: “Baseline for HorizAxis” and “Baseline for
VertAxis”.
Ideographic Em-Box
This new section added.
Ideographic Character Face
This new section added.
vhea.htm
Introduction
Added a link each for the vmtx table and the CJK guidelines section.
table.version.description
Version number increased to 1.1. Added a note to indicate the difference in
representing the fractional part of a version number when it is non-zero.
table.ascent
Replaced by vertTypoAscender.
table.descent
Replaced by vertTypoDescender.
table.lineGap
Replaced by vertTypoLineGap.
Vertical Header Table Example
Changed version value to 1.1. Corrected the name for vertTypoLineGap
vmtx.htm

Introduction
Added a link for accessing the CJK guidelines section.
Vertical Origin and Advance Height
This new section added.
Vertical Metrics Table Format
Added note on the calculating the top side bearing.
vorg.htm
This new table added. This is needed by CFF OpenType fonts to locate the origin
of vertical glyphs.
wgl4d.htm
Added a missing asterisk for PostScriptName.macron
Added U+02DC (tilde) — was missing from the list.

Version 1.25
Released July, 2000.
Summary of Changes:
feattags.htm (Feature Tags) Features added:
'abvm' (Above-base Mark Positioning); 'abvs' (Above-base Substitutions); 'akhn'
(Akhand); 'blwf' (Below-base Forms); 'blws' (Below-base Substitutions); 'clig'
(Contextual Ligatures); 'cswh' (Contextual Swash); 'curs' (Cursive Positioning);
'dist' (Distances); 'falt' (Final Glyph on Line Alternates); 'half' (Half Forms); 'haln'
(Halant Forms); 'hkna' (Horizontal Kana Alternates); 'isol' (Isolated Forms); 'jalt'
(Justification Alternates); 'locl' (Localized Forms) (replaces 'jajp', 'kokr', 'vivn',
'zhch', and 'zhtw'); 'mkmk' (Mark to Mark Positioning); 'nukt' (Nukta Forms);
'pres' (Pre-base substitutions); 'pstf' (Post-base Forms); 'psts' (Post-base
Substitutions); 'rphf' (Reph Forms); 'ruby' (Ruby Notation Forms); 'size' (Optical
Size); 'vatu' (Vattu Variants); 'vhal' (Alternate Vertical Half Metrics); 'vkna' (Vertical
Kana Alternates); 'vkrn' (Vertical Kerning) 'vpal' (Proportional Alternate Vertical
Metrics).
Features removed:
'crcy' (Currency), 'dpng' (Diphthongs), 'jajp' (Japanese Forms), 'kokr' (Korean
Forms), 'vivn' (Vietnamese Forms), 'zhcn' (Simplified Chinese Forms), 'zhtw'
(Traditional Chinese Forms).
Features modified:
'aalt': Added ordering suggestion, reworked user interface suggestions, clarified
implementation recommendation, feature interaction and function.
'altv': changed tag to 'valt'.

'c2sc', 'dlig': Clarified function, example and feature interaction.
'calt', 'case', 'dnom', 'expt', 'halt', 'hist', 'hwid', 'jp78', 'jp83', 'jp90', 'kern', 'lfbd',
'liga', 'lnum', 'numr', 'onum', 'pwid', 'qwid', 'rtbd', 'smpl', 'sups', 'titl', 'twid', 'valt':
Clarified feature interaction.
'fina', 'init', 'medi', 'rand', 'salt', 'swsh': Clarified user interface suggestion and
feature interaction.
'frac': Added 'numr' and 'dnom' extensions, clarified feature interaction.
'fwid', 'palt': Clarified feature interaction and function.
'hngl': Clarified feature interaction and implementation recommendation.
'ital': Clarified function and feature interaction.
'mark': Added example, application interface, user interface suggestion, script
sensitivity, feature interaction. Modified recommended implementation.
'mset': Added example.
'nalt': Clarified user interface suggestion, implementation recommendation and
feature interaction.
'opbd': Added 'lfbd' and 'rtbd' extensions; clarified user interface suggestion
and feature interaction.
'ordn': Clarified script sensitivity, corrected lookup type, clarified implementation
recommendation and feature interaction. 'ornm': Clarified user interface
suggestion, implementation recommendation, feature interaction and function
description.
'smcp': Added note about dotlessi; clarified function and feature interaction.
'trad': corrected terminology (hanzi, not hanja), clarified user interface
suggestion and implementation recommendation.
'vert': Clarified feature interaction and added ordering recommendation;
extended application interface notes.
'vrt2': Changed “friendly” name, clarified feature interaction and added ordering
recommendation; added ATM/OTF driver information and descriptions of how
to construct the rotated glyphs in the Function section.
'zero': Clarified user interface suggestion.
Features relocated:
'mark' and 'mset' have been moved from the Metric Behaviors category, to the
Other Substitutions category for consistency in classification.
chapter2.htm - modified description of FeatureParams field for a non-null offset
(the 'size' feature uses it).

Version 1.2
Released November, 1998.
Summary of Changes:

Data type notation and spelling corrected throughout
base.htm - added BaseCoord Table Format 4
chapter2.htm - corrected example 3; refined description of next glyph; reserved
RightToLeft lookup flag; corrected descriptions of LookupFlag bits
cmap.htm - removed legacy encodings
dsig.htm - updated field names and format of signature record; added step to
creation of content digest
feattags.htm - registered new features 'crcy', 'dnom', 'jajp', 'kokr', 'lfbd', 'numr',
'rtbd', 'vivn', 'vrt2', 'zhcn', 'zhtw'; removed features 'trak', 'vrot'; edited and clarified
descriptions of features 'afrc', 'altv', 'c2sc', 'calt', 'case', 'cpsp', 'dlig', 'dpng', 'expt',
'fina', 'frac', 'fwid', 'halt', 'hlig', 'lngl', 'hwid', 'init', 'ital', 'jp78', 'jp90', 'kern', 'lnum',
'medi', 'mgrk', 'onum', 'opbd', 'ordn', 'ornm', 'palt', 'pnum', 'pwid', 'qwid', 'smcp',
'smpl', 'sups', 'tnam', 'tnum', 'trad', 'twid', 'vert'
gdef.htm - added MarkAttachClassDef to header, and MarkAttachmentType bit
setting to LookupFlag bits; added CaretValue Table Format 4
glyf.htm - added table detailing component record structure
gsub.htm - added format 6, for chaining contextual substitution; general editing
gpos.htm - added format 8, for chaining contextual positioning; clarified pair
positioning operations; corrected Example 10; clarified coordinate system
description; refined description of when a lookup is finished; added AnchorTable
Format 4; general editing
head.htm - added note about fontRevision field; clarified description of
compression flag
hhea.htm - corrected description of numberOfHMetrics
mmfx.htm - corrections throughout; added MMFXIdZero
name.htm - general editing
os2.htm - renamed usMaxLookup to usMaxContext; edited descriptions of
defaultChar and breakChar; updated registered vendors
otff.htm - general editing; added ulDsigTag and related fields to TTC header; added
datatypes LONGDATETIME; clarified checksum calculations; added tag name
restrictions; clarified use of version numbers
post.htm - renamed FormatType to Version
vhea.htm - replaced mention of centerline with vertical baseline; corrected
description of numOfLongVerMetrics
CFF.pdf and Type2.pdf updated (December 1998)
Several PostScript glyph names corrected in the WGL tables (18 December 1998)
name.htm - Descriptions of name ID 13 and 14 corrected (29 January 1999)
mmsd.htm - Attribute flags corrected (29 January 1999)
head.htm - Data type of xMin corrected (29 January 1999)

Version 1.1
Released April, 1998.
Summary of Changes:
CFF and Type2 specs updated
chapter2.htm - corrected typo in figure 2d (fig2d.gif)
dsig.htm - added info about location of DSIG table; added list of sfnt structural
requirements
feattags.htm - created more comprehensive list and description of layout feature
tags
gpos.htm - corrected illustration 4f (fig4f.gif)
head.htm - added bit 12 (converted) to flags field
hhea.htm - removed CFF restriction listed in numberOfHMetrics field; added
caretOffset field.
maxp.htm - added version 0.5 table (numGlyphs field); general editing
name.htm - added name IDs 16, 17, and 18; corrected name ID example
os2.htm - added new version (2), adding new fields sxHeight, sCapHeight,
usDefaultChar, usBreakChar, usMaxLookup; clarified sTypoAscender and
sTypoDescender fields; changed some Unicode range values to reflect Unicode 2;
updated registered vendors
otff.htm - general editing; added description of two types of TTC headers, and
DSIG table location
recom.htm - general editing

Version 1.01
Released October, 1997.
Summary of Changes:
mmfx.htm, fvar.htm, mmsd.htm, otover.htm, recom.htm - edits throughout
loca.htm - changed long-aligned to word-aligned for local offsets
wgl4.htm - added reference to Euro symbol
dsig.htm - added note about system use of DSIG table to distinguish OT from TT
fonts
ttoreg.htm - added 'VIT ', 'TRK ', and 'ROM ' lang sys tags
otff.htm - rearranged table list
base.htm - change to basecoordformat3 data type
gpos.htm - pairposformat1 subtable valuerecord becomes offset
kern.htm - GPOS clarification

name.htm - added name IDs 13 and 14
ltsh.htm - clarified option for fixed-pitch fonts
vdmx.htm - version 1 added to VDMX table
os2.htm - added codepage range 8 for Vietnamese; added new vendor IDs,
including UNKN

Version 1.0
Released April, 1997.

Archive of OpenType® Versions
Article • 05/30/2024

The OpenType specification was developed as an extension of the TrueType Open and
TrueType specifications which preceded it. The first version was published in April 1997.
The current version is OpenType 1.9.
The following lists all the published versions of the OpenType specification, in reverse
chronological order. Links are provided for archived versions that are available.
OpenType 1.9.1 (current version) — released May 2024
OpenType 1.9 — released December 2021
OpenType 1.8.4 — released November 2020
OpenType 1.8.3 — released August 2018
OpenType 1.8.2 — released July 2017
OpenType 1.8.1 — released January 2017
OpenType 1.8 — released September 2016
OpenType 1.7 — released March 2015
OpenType 1.6 — released April 2009; updated July 2010
OpenType 1.5 — released May 2008
OpenType 1.4 — released October 2002
OpenType 1.3 — released April 2001
OpenType 1.25 — released July 2000
OpenType 1.2 — released November 1998
OpenType 1.1 — released April 1998
OpenType 1.01 — released October 1997
OpenType 1.0 — released April 1997
For a detailed change history, see the change log for the current version.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

OpenType® Specification Version 1.9
Article • 05/31/2024

Core specification
OpenType overview
The OpenType font file
Font file tables
Advanced typographic extensions (OpenType layout)
OpenType layout common table formats
OpenType font variations overview
OpenType font variations common table formats

Errata
OpenType 1.9 errata

Appendices
Recommendations
OpenType Layout Tag Registry
OpenType Design-Variation Axis Tag Registry
TrueType outlines and instructions
TrueType fundamentals
Instructing TrueType Glyphs
The TrueType Instruction Set
Graphics State Summary
OpenType Mirroring Pairs list
Adobe technical note #5176: “The Compact Font Format Specification”
Adobe technical note #5177: “Type 2 Charstring Format”
The CFF 2 Charstring Format
Adobe Technical Note #5902: “PostScript Name Generation for Variation Fonts”
Specification changes log file
OpenType 1.9 incorporates revisions in Draft Amendment 2 of the 4th edition of the
ISO/IEC 14496-22 “Open Font Format” standard. Current editions and amendments of
ISO/IEC 14496-22 are freely available for download from the ISO website
Updates to this specification are noted in the change log.

.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

OpenType specification feedback
OpenType specification is an open source
project. Select a link to provide feedback:
 Open a documentation issue
 Provide product feedback

OpenType® Specification (OpenType
1.8.4)
Article • 06/09/2022

The OpenType™ specification has been formatted in HTML, but may link to .PDF files.

OpenType specification version 1.8.4
OpenType overview
The OpenType font file
Font file tables
Advanced typographic extensions (OpenType layout)
OpenType layout common table formats
OpenType font variations overview
OpenType font variations common table formats

Errata
OpenType 1.8.4 errata

Appendices
Recommendations
OpenType Layout Tag Registry
OpenType Design-Variation Axis Tag Registry
TrueType outlines and instructions
TrueType fundamentals
Instructing TrueType Glyphs
The TrueType Instruction Set
Graphics State Summary
OpenType Mirroring Pairs list
Adobe technical note #5176: “The Compact Font Format Specification”
Adobe technical note #5177: “Type 2 Charstring Format”
The CFF 2 Charstring Format
Adobe Technical Note #5902: “PostScript Name Generation for Variation Fonts”
Specification changes log file

OpenType 1.8.4 incorporates revisions in Amendment 1 of the 4th edition of the ISO/IEC
14496-22 “Open Font Format” standard. Current editions and amendments of ISO/IEC
14496-22 are freely available for download from the ISO website .
Updates to this specification are noted in the change log.

OpenType® specification (OpenType
1.8.3)
Article • 06/09/2022

The OpenType™ specification has been formatted in HTML, but may link to .PDF files.

OpenType specification version 1.8.3
OpenType overview
The OpenType font file
Font file tables
Advanced typographic extensions (OpenType layout)
OpenType layout common table formats
OpenType font variations overview
OpenType font variations common table formats

Errata
OpenType 1.8.3 errata

Appendices
Recommendations
OpenType Layout Tag Registry
OpenType Design-Variation Axis Tag Registry
The WGL4.0 character set
TrueType fundamentals
The TrueType instruction set
OpenType Mirroring Pairs list
Adobe technical note #5176: “The Compact Font Format Specification”
Adobe technical note #5177: “Type 2 Charstring Format”
The CFF 2 Charstring Format
Adobe Technical Note #5902: “PostScript Name Generation for Variation Fonts”
Specification changes log file
OpenType 1.8.3 incorporates revisions in DIS draft of the 4th edition of the ISO/IEC
14496-22 “Open Font Format” standard. Current editions and amendments of ISO/IEC
14496-22 are freely available for download from the ISO website .

Updates to this specification are noted in the change log.

OpenType® specification (OpenType
1.8.2)
Article • 06/09/2022

The OpenType™ specification has been formatted in HTML, but may link to .PDF files.

OpenType specification version 1.8.2
OpenType overview
The OpenType font file
Font file tables
Advanced typographic extensions (OpenType layout)
OpenType layout common table formats
OpenType font variations overview
OpenType font variations common table formats

Errata
OpenType 1.8.2 errata

Appendices
Recommendations
OpenType layout tag registry
OpenType design-variation axis tag registry
The WGL4.0 character set
TrueType fundamentals
The TrueType instruction set
OpenType Mirroring Pairs list
Adobe technical note #5176: “The Compact Font Format Specification”
Adobe technical note #5177: “Type 2 Charstring Format”
The CFF 2 Charstring Format
Adobe Technical Note #5902: “PostScript Name Generation for Variation Fonts”
Specification changes log file
OpenType 1.8.2 incorporates revisions in Amendment 1 and Draft Amendment 2 of the
ISO/IEC 14496-22:2015 “Open Font Format (3rd edition)” standard. Additionally, it
incorporates extensions not included in ISO/IEC 14496-22:2015 plus Amendments 1 and

2, including the 'MERG', 'meta' and 'sbix' tables, and all of the addtions related to
OpenType Font Variations. Current editions and amendments of ISO/IEC 14496-22 are
freely available for download from the ISO website .
Updates to this specification are noted in the change log.

OpenType specification (OpenType 1.8.1)
Article • 06/09/2022

The OpenType™ specification has been formatted in HTML, but may link to .PDF files.

OpenType specification version 1.8.1
OpenType overview
The OpenType font file
Font file tables
Advanced typographic extensions (OpenType Layout)
OpenType Layout Common Table Formats
OpenType Font Variations Overview
OpenType Font Variations Common Table Formats

Errata
OpenType 1.8.1 Errata

Appendices
Recommendations
OpenType Layout Tag Registry
The WGL4.0 character set
TrueType fundamentals
The TrueType instruction set
OpenType Mirroring Pairs List
Adobe technical note #5176: “The Compact Font Format Specification.”
Adobe technical note #5177: “Type 2 CharString Format.”
The CFF2 CharString Format
Adobe Technical Note #5902: “PostScript Name Generation for Variation Fonts”
Specification changes log file
OpenType 1.8.1 incorporates revisions in Amendment 1 and Draft Amendment 2 of the
ISO/IEC 14496-22:2015 “Open Font Format (3rd edition)” standard. Additionally, it
incorporates extensions not included in ISO/IEC 14496-22:2015 plus Amendments 1 and
2: the 'MERG', 'meta' and 'sbix' tables, and all of the addtions related to OpenType Font
Variations. Current editions and amendments of ISO/IEC 14496-22 are freely available
for download from the ISO website.

Updates to this specification are noted in the change log.

OpenType specification (OpenType 1.8)
Article • 06/09/2022

The OpenType™ specification has been formatted in HTML, but may link to .PDF files.

OpenType specification version 1.8
OpenType overview
The OpenType font file
Font file tables
Advanced typographic extensions (OpenType Layout)
OpenType Layout Common Table Formats
OpenType Font Variations Overview
OpenType Font Variations Common Table Formats

Errata
OpenType 1.8 Errata

Appendices
Recommendations
OpenType Layout Tag Registry
The WGL4.0 character set
TrueType fundamentals
The TrueType instruction set
OpenType Mirroring Pairs List
Adobe technical note #5176: “The Compact Font Format Specification.”
Adobe technical note #5177: “Type 2 Charstring Format.”
The CFF 2 Charstring Format
Adobe Technical Note #5902: “PostScript Name Generation for Variation Fonts”
Specification changes log file
OpenType 1.8 incorporates revisions in Amendment 1 and Draft Amendment 2 of the
ISO/IEC 14496-22:2015 “Open Font Format (3rd edition)” standard. Additionally, it
incorporates extensions not included in ISO/IEC 14496-22:2015 plus Amendments 1 and
2: the 'MERG', 'meta' and 'sbix' tables, and all of the addtions related to OpenType Font
Variations. Current editions and amendments of ISO/IEC 14496-22 are freely available
for download from the ISO website.

Updates to this specification are noted in the change log.

OpenType specification (OpenType 1.7)
Article • 09/22/2020

The OpenType™ specification has been formatted in HTML, but may link to .PDF files.

OpenType specification version 1.7
OpenType overview
The OpenType font file
Font file tables
Recommendations

Appendices
Advanced typographic extensions (OpenType Layout)
OpenType Layout Common Table Formats
OpenType Layout Tag Registry
The WGL4.0 character set
TrueType fundamentals
The TrueType instruction set
OpenType Mirroring Pairs List
Adobe technical note #5176: “The Compact Font Format Specification.”
Adobe technical note #5177: “Type 2 Charstring Format.”
Specification changes log file
OpenType 1.70 is fully equivalent to the ISO/IEC 14496-22:2015 (3rd edition) “Open Font
Format” standard. The standard will be published in June 2015 and at that time will be
freely available for download from the ISO website.
Updates to this specification are noted in the change log.

OpenType specification (OpenType 1.6)
Article • 06/09/2022

The OpenType™ specification has been formatted in HTML, but may link to .PDF files.

OpenType specification version 1.6
OpenType overview
The OpenType font file
Font file tables
Recommendations

Appendices
Advanced typographic extensions (OpenType Layout)
OpenType Layout Common Table Formats
OpenType Layout Tag Registry
The WGL4.0 character set
TrueType fundamentals
The TrueType instruction set
OpenType Mirroring Pairs List
Adobe technical note #5176: “The Compact Font Format Specification.”
Adobe technical note #5177: “Type 2 Charstring Format.”
Specification changes log file
Updates to this specification are noted in the change log. OpenType version 1.6 is fully
technically equivalent to the ISO/IEC 14496-22:2009 (Second Edition) “Open Font
Format” standard. The standard was published in July 2009, and is now freely available
for download from the ISO website.

OpenType specification (OpenType 1.5)
Article • 09/22/2020

The OpenType™ specification has been formatted in HTML, but may link to .PDF files.

OpenType specification version 1.5
OpenType overview
The OpenType font file
Font file tables
Recommendations
Appendices
Advanced typographic extensions (OpenType Layout)
OpenType Layout Common Table Formats
OpenType Layout Tag Registry
The WGL4.0 character set
TrueType fundamentals
The TrueType instruction set
Adobe technical note #5176: "The Compact Font Format Specification."
Adobe technical note #5177: "Type 2 Charstring Format."
Specification changes log file
Updates to this specification are noted in the change log and have been submitted for
inclusion in ISO/IEC 14496-22, the “Open Font Format”. These changes are reflected in
the Committee Draft of the second edition of the ISO/IEC 14496-22.

OpenType specification (OpenType 1.4)
Article • 02/04/2021

The OpenType™ specification has been formatted in HTML, but may link to .PDF files.

OpenType specification version 1.4
self extracting archive

[about 1.5Mb]

OpenType overview
The OpenType font file
Font file tables
Recommendations
Appendices
Advanced typographic extensions (OpenType Layout)
OpenType Layout Common Table Formats
OpenType Layout Tag Registry
The WGL4.0 character set
TrueType fundamentals
The TrueType instruction set
Adobe technical note #5176: "The Compact Font Format Specification."
Adobe technical note #5177: "Type 2 Charstring Format."
Specification changes log file
OpenType version 1.4 has been contributed to ISO and became the foundation for the
development of ISO/IEC 14496-22 “Open Font Format” standard. The standard was
published in 2007, and is now freely available for download from ITTF website.

Developing OpenType Fonts for
Standard Scripts
Article • 06/09/2022

This document presents information that will help font developers create or support
OpenType fonts for all "standard" scripts covered by the Unicode Standard, for example:
Latin, Cyrillic, Greek and Armenian.

Introduction
In this document, "standard" refers to any non-complex script, that is, any script that
does not require re-ordering or contextual analysis.
Font developers will learn how to encode script features in their fonts, choose character
sets, organize font information, and use existing tools to produce standard script fonts.
Registered features of standard scripts are defined and illustrated, encodings are listed,
and templates are included for compiling layout tables for OpenType fonts.
This document also presents information about the standard OpenType shaping engine
of Uniscribe, an operating system component responsible for text layout.
In addition to being a primer and specification for the creation and support of standard
script fonts, this document is intended to more broadly illustrate the OpenType Layout
architecture, feature schemes, and operating system support for shaping and
positioning text.

Glossary
The following terms are useful for understanding the layout features and script rules
discussed in this document.
Base Glyph - Any glyph that can have a diacritic mark above or below it. Layout
operations are defined in terms of a base glyph, not a base character, as a ligature may
act as the base.
Character - Each character represents a Unicode character code point. For example the
'A' character is U+0041. A character may have multiple forms of glyphs.
Diacritic Marks - A character that is positioned above or below a character to provide
pronunciation guidance (i.e. accent acute, grave, tilde, etc.)

Glyph - A glyph represents a form of one or more characters.
Ligature - A combination of glyphs that join to form a single glyph. It is up to the font
designer to create the ligatures as he deems best for the font he is working with.
Standard Script - Any non-complex script; any script that does not require re-ordering
or contextual analysis in the shaping process.

Shaping Engine
The Uniscribe standard shaping engine processes text in stages. The stages are:
1. Shaping (substituting) glyphs with OTLS (OpenType Library Services)
2. Positioning glyphs with OTLS
The descriptions which follow will help font developers understand the rationale for the
standard feature encoding model, and help application developers better understand
how layout clients can divide responsibilities with operating system functions.

Shaping with OTLS
The first step Uniscribe takes in shaping the character string is to map all characters to
their nominal form glyphs.
Next, Uniscribe calls OTLS to apply the features. All OTL processing is divided into a set
of predefined features (described and illustrated in the Features section of this
document). Each feature is applied, one by one, to the appropriate glyphs in the syllable
and OTLS processes them. Uniscribe makes as many calls to the OTL Services as there
are features. This ensures that the features are executed in the desired order.
The steps of the shaping process are outlined below. Not all of the features listed apply
to all standard script languages, but are features that are 'on' by default. However, you
may choose to implement more features based on the script or language system.

Shaping features:
1. Language forms
a. Apply feature 'ccmp' to preprocess any glyphs that require composition or
decomposition
2. Typographical forms
a. Apply feature 'liga' to compose any optional standard ligatures, like fi or fl
b. Apply feature 'clig' to compose any optional contextual ligatures

Positioning glyphs with OTLS
Uniscribe next applies features concerned with positioning, calling functions of OTLS to
position glyphs.

Positioning features:
1. Kerning
a. Apply feature 'kern' to provide pair kerning between base glyphs requiring
adjustment for better typographical quality
2. Mark to base
a. Apply feature 'mark' to position diacritic glyphs to the base glyph
3. Mark to Mark
a. Apply feature 'mkmk' to position diacritic glyphs to other diacritic glyphs

Features
The features listed below have been defined to create the basic forms for standard
scripts and languages. Regardless of the model an application chooses for supporting
layout of standard scripts, Uniscribe requires a fixed order for executing features within
a run of text to consistently obtain the proper basic form. This is achieved by calling
features one-by-one in the standard order listed below.
The order of the lookups within each feature is also very important. For more
information on lookups and defining features in OpenType fonts, see Encoding feature
information in the OpenType font development section.
In the table below, required means that the feature will be applied during the shaping
process and cannot be suppressed by the application where the text is being rendered.
Applications may supress non-required features and they may trigger optional features
(usually based on user’s discretion). The complete list of features is defined in the
OpenType Spec.
The order for applying standard features encoded in OpenType fonts:
Feature

Feature function

Layout
operation

Language based forms:
ccmp

Character composition/decomposition substitution

Typographical forms:

GSUB

Required

Feature

Feature function

Layout
operation

liga

Standard ligature substitution

GSUB

clig

Contextual ligature substitution

GSUB

Required

Positioning features:
dist

Distances

GPOS

X

kern

Pair kerning

GPOS

mark

Mark to base positioning

GPOS

X

mkmk

Mark to mark positioning

GPOS

X

[GSUB = glyph substitution, GPOS = glyph positioning]

Descriptions and examples of above features
Character composition (and decomposition)
Feature Tag: "ccmp"
The 'ccmp' feature is used to compose a number of glyphs into one glyph, or
decompose one glyph into a number of glyphs. This feature is implemented before any
other features because there may be times when a font vender wants to control certain
shaping of glyphs. An example of using this table is seen below. The 'ccmp' table maps
default alphabetic forms to both a composed form (essentially a ligature, GSUB lookup
type 4), and decomposed forms (GSUB lookup type 2).

Example: The 'ccmp' feature is used to form the dotless i (used when the 'i' is followed
by an above diacritic mark).

Standard ligatures
Feature Tag: "liga"

The 'liga' feature is used to map glyphs to their optional ligated form. Font developers
should use this table for all ligatures that they want the user to be able to control by
user preference. Uniscribe has a flag that will allow this type of feature to be
deactivated. The 'liga' feature maps sequences of glyphs to corresponding ligatures
(GSUB lookup type 4). Ligatures with more components must be stored ahead of those
with fewer components in order to be found. See Ordering ligatures in the Encoding
Feature Information section. The set of optional ligatures will vary by typeface design
and script.

Example: a standard fi ligature.

Contextual ligatures
Feature Tag: "clig"
The 'clig' feature is used to map glyphs to their contextual ligated form which may be
preferred for typographic purposes. Unlike other ligature features, 'clig' specifies the
context in which the ligature is recommended. This capability is important in some script
designs and for swash ligatures. The 'clig' table maps sequences of glyphs to
corresponding ligatures in a chained context (GSUB lookup type 8). Ligatures with more
components must be stored ahead of those with fewer components in order to be
found. See Ordering ligatures in the Encoding Feature Information section. The set of
optional contextual ligatures will vary by typeface design and script.

Example: The ligature glyph 'ft' replaces the sequence f t, except when preceded by an
ascending letter.

Kerning
Feature Tag: "kern"

The 'kern' feature is used to adjust amount of space between glyphs, generally to
provide optically consistent spacing between glyphs. Although a well-designed typeface
has consistent inter-glyph spacing overall, some glyph combinations require adjustment
for improved legibility. Besides standard adjustment in either horizontal or vertical
direction, this feature can supply size-dependent kerning data via device tables, "crossstream" kerning in the Y text direction, and adjustment of glyph placement independent
of the advance adjustment. Note that this feature would not be used in monospaced
fonts.
The font stores a set of adjustments for pairs of glyphs (GPOS lookup type 2 or 8). These
may be stored as one or more tables matching left and right classes, and/or as
individual pairs. If both forms are used, the classes should be listed last, so as to provide
a means to replace any non-ideal values that may result from the class tables. Additional
adjustments may be provided for larger sets of glyphs (e.g., triplets, quadruplets, etc.) to
overwrite the results of pair kerns in particular combinations. These should precede the
pairs.

Creating a kerning pair using Microsoft VOLT

Mark to base positioning
Feature Tag: "mark"
The 'mark' feature positions mark glyphs in relation to a base glyph, or a ligature glyph.
This feature may be implemented as a MarkToBase Attachment lookup (GPOS
LookupType = 4) or a MarkToLigature Attachment lookup (GPOS LookupType = 5).

Positioning mark to base using Microsoft VOLT

Mark to mark positioning
Feature Tag: "mkmk"
The 'mkmk' feature positions mark glyphs in relation to another mark glyph. This feature
may be implemented as a MarkToMark Attachment lookup (GPOS LookupType = 6).

Positioning mark to mark using Microsoft VOLT

Appendix
Appendix: Writing System Tags
Features are encoded according to both a designated script and language system. The
language system tag specifies a typographic convention associated with a language or
linguistic subgroup. For example, there are different language systems defined for the
Latin script; English, German, Spanish, etc.
Currently, the Uniscribe engine only supports the "default" language for each script.
However, font developers may want to build language specific features which are
supported in other applications and will be supported in future Microsoft OpenType
implementations.
NOTE: It is strongly recommended to include the "dflt" language tag in all
OpenType fonts because it defines the basic script handling for a font. The "dflt"
language system is used as the default if no other language specific features are
defined or if the application does not support that particular language. If the "dflt"
tag is not present for the script being used, the font may not work in some
applications.
The following tables list the registered tag names for scripts and language systems.
Registered tags for standard scripts

Registered tags for standard language systems

Script tag

Script

Language system tag

Language

"latn"

Latin

"dflt"

*default script handling

languages with Basic Latin & Latin-1:
"DAN "

Danish

"NLD "

Dutch

"ENG "

English

"FOS "

Faroese

"FIN "

Finnish

"FLE "

Flemish

"DEU "

German

"ISL "

Icelandic

"IRI "

Irish

"ITA "

Italian

"NOR "

Norwegian

"PTG "

Portuguese

"ESP "

Spanish

"SVE "

Swedish

languages with Unicode Extended Latin:
"AFK "

Afrikaans

"EUQ "

Basque

"BRE "

Breton

"CAT "

Catalan

"HRV "

Croatian

"CSY "

Czech

"NTO "

Esperanto

"ETI "

Estonian

"FRA "

French

"FRI "

Frisian

"GRN "

Greenlandic

"HUN "

Hungarian

"LAT "

Latin

"LVI "

Latvian

"LTH "

Lithuanian

"MTS "

Maltese

"PLK "

Polish

"PRO "

Provencal

"RMS "

Romansh

"ROM "

Romanian

"ROY "

Romany

"cyrl"

"grek"

"armn"

"geor"

Cyrillic

Greek

Armenian

Georgian

"SKY "

Slovak

"SLV "

Slovenian

"LSB "

Sorbian (Lower)

"USB "

Sorbian (Upper)

"TRK "

Turkish

"WEL "

Welsh

"VIT "

Vietnamese

"dflt"

*default script handling

"RUS "

Russian

"dflt"

*default script handling

"COP "

Coptic

"ELL "

Greek

"dflt"

*default script handling

"HYE "

Armenian

"dflt"

*default script handling

"KAT "

Georgian

"runr"

Runic

"dflt"

*default script handling

"ogam"

Ogham

"dflt"

*default script handling

Note: both the script and language tags are case sensitive (script tags should be
lowercase, language tags are all caps) and must contain four characters (ie. you must
add a space to the three character language tags).

Creating and supporting OpenType
fonts for the Universal Shaping Engine
Article • 09/15/2024

Microsoft Typography
Last updated: September 2024
This document presents information that will help font developers in creating OpenType
fonts for complex scripts included in the Unicode Standard 16.0, but not otherwise
supported by a dedicated shaping engine.

Introduction
This document targets developers implementing shaping behavior compatible with the
Microsoft OpenType specification for complex scripts not supported by a dedicated
shaping engine. It contains information about terminology, font features and behavior
of the Universal Shaping Engine (USE). While it does not contain instructions for creating
fonts, it will help font developers understand how the Universal shaping engine
processes complex script text.

How the Universal Shaping Engine works
The Universal Shaping Engine processes text in stages. The stages are:
1. Character classification
a. Overrides to Unicode categories
2. Split vowel handling
3. Cluster validation
4. OpenType feature application I
a. Basic cluster formation, GSUB
5. Glyph reordering
6. OpenType feature application II
a. Topographical features, GSUB
b. Standard typographical features, GSUB
c. Custom substitution features requested by the application, GSUB
d. Positional features, GPOS

Character classification

The run of text that the shaping engine receives for the purpose of shaping is a
sequence of Unicode characters. Itemization preprocessing ensures that the runs of text
being shaped contain characters belonging to a single script but may include
SCRIPT_COMMON characters. The shaping engine divides the text into syllable clusters
and identifies character properties. Character properties are used in parsing syllables
and identifying their parts as well as determining whether any special behavior or
contextual reordering is required. The Universal Shaping Engine (USE) generates
character properties from Unicode data. There is a mapping between Unicode’s
categories and the classes used internally by USE. This section defines how USE’s classes
and subclasses are derived from Unicode data.
Unicode categories:
AJT = Unicode, Arabic Joining Type
UISC = Unicode, Indic Syllabic Category
UGC = Unicode, General Category
UIPC = Unicode, Indic Positional Category, prior to Unicode 8.0 this property was known
as Indic Matra Category

.

Note: Non-Indic complex scripts are not included in Unicode's UISC and UIPC data.
Where necessary for USE's processing, data for such scripts has been provided in
supplementary data files included in USE's GitHub archive . Hieroglyphic scripts require
syllabic categories not defined in UISC. The use of these hieroglyphic categories is
documented in this specification and the values are defined in the ISC-Additional data
file

.

Extended categories:
ESC = USE, Extended Syllabic Category
ﾉ

Sigla

USE class

Derivation

B

BASE

AJT = C, D, L, or R;
UISC = Number;
UISC = Avagraha & UGC = Lo;
UISC = Bindu & UGC = Lo;
UISC = Consonant;

Expand table

Sigla

USE class

Derivation
UISC = Consonant_Final & UGC = Lo;
UISC = Consonant_Head_Letter;
UISC = Consonant_Medial & UGC = Lo;
UISC = Consonant_Subjoined & UGC = Lo;
UISC = Tone_Letter;
UISC = Vowel & UGC = Lo;
UISC = Vowel_Independent;
UISC = Vowel_Dependent & UGC = Lo

CGJ

CGJ

U+034F

CM

CONS_MOD

UISC = Nukta;
UISC = Gemination_Mark;
UISC = Consonant_Killer;
UISC = Symbol_Modifier

CS

CONS_WITH_STACKER

UISC = Consonant_With_Stacker

F

CONS_FINAL

UISC = Consonant_Final & UGC != Lo;
UISC = Consonant_Succeeding_Repha

FM

CONS_FINAL_MOD

UISC = Syllable_Modifier

G

HIEROGLYPH

ESC = Hieroglyph

GB

BASE_OTHER

UISC = Consonant_Placeholder;
U+2015, U+2022, U+25FB–25FE

H

HALANT

UISC = Virama;
UISC = Invisible_Stacker

HM

HIEROGLYPH_MOD

ESC = Hieroglyph_Modifier

HN

HALANT_NUM

UISC = Number_Joiner

HR

HIEROGLYPH_MIRROR

ESC = Hieroglyph_Mirror

IND

BASE_IND

UISC = Consonant_Dead;
UISC = Modifying_Letter;

Sigla

USE class

Derivation
UISC = Other;
UGC = Po (Punctuation signs), except U+104E,
U+2022

J

HIEROGLYPH_JOINER

ESC = Hieroglyph_Joiner

M

CONS_MED

UISC = Consonant_Medial & UGC != Lo

N

BASE_NUM

UISC = Brahmi_Joining_Number

O

OTHER

Any other SCRIPT_COMMON characters;
White space characters, UGC=Zs

R

REPHA

UISC = Consonant_Preceding_Repha;
UISC = Consonant_Prefixed

RK

Reordering Killer

UISC = Reordering_Killer

Rsv

Reserved characters

Any character not currently assigned or otherwise
reserved in Unicode

S

SYM

UGC = So except U+25CC;
UGC = Sc

SB

HIEROGLYPH_SEGMENT_BEGIN

ESC = Hieroglyph_Mark_Begin;
ESC = Hieroglyph_Segment_Begin

SE

HIEROGLYPH_SEGMENT_END

ESC = Hieroglyph_Mark_End;
ESC = Hieroglyph_Segment_End

SUB

CONS_SUB

UISC = Consonant_Subjoined & UGC != Lo

V

VOWEL

UISC = Vowel & UGC != Lo;
UISC = Vowel_Dependent & UGC != Lo;
UISC = Pure_Killer

VM

VOWEL_MOD

UISC = Bindu & UGC != Lo;
UISC = Tone_Mark;
UISC = Cantillation_Mark;
UISC = Register_Shifter;
UISC = Visarga

Sigla

USE class

Derivation

VS

VARIATION_SELECTOR

U+FE00‒FE0F

WJ

Word joiner

U+2060

ZWJ

Zero width joiner

UISC = Joiner

ZWNJ

Zero width non-joiner

UISC = Non_Joiner

Classes that can vary by position are defined in Unicode’s Indic_Positional_Category
(UIPC), additional subclasses are defined:
ﾉ

Expand table

Sigla

USE subclass

Derivation

CMAbv

CONS_MOD_ABOVE

UIPC = Top

CMBlw

CONS_MOD_BELOW

UIPC = Bottom

FAbv

CONS_FINAL_ABOVE

UIPC = Top

FBlw

CONS_FINAL_BELOW

UIPC = Bottom

FPst

CONS_FINAL_POST

UIPC = Right

MAbv

CONS_MED_ABOVE

UIPC = Top

MBlw

CONS_MED_BELOW

UIPC = Bottom

MPre

CONS_MED_PRE

UIPC = Left

MPst

CONS_MED_POST

UIPC = Right

VAbv

VOWEL_ABOVE

UIPC = Top

VOWEL_ABOVE_BELOW

UIPC = Top_And_Bottom

VOWEL_ABOVE_BELOW_POST

UIPC = Top_And_Bottom_And_Right

VOWEL_ABOVE_POST

UIPC = Top_And_Right

VOWEL_BELOW

UIPC = Bottom;

VBlw

UIPC = Overstruck

VPre

VOWEL_BELOW_POST

UIPC = Bottom_And_Right

VOWEL_PRE

UIPC = Left

VOWEL_PRE_ABOVE

UIPC = Top_And_Left

Sigla

USE subclass

Derivation

VOWEL_PRE_ABOVE_POST

UIPC = Top_And_Left_And_Right

VOWEL_PRE_POST

UIPC = Left_And_Right

VPst

VOWEL_POST

UIPC = Right

VMAbv

VOWEL_MOD_ABOVE

UIPC = Top

VMBlw

VOWEL_MOD_BELOW

UIPC = Bottom;
UIPC = Overstruck

VMPre

VOWEL_MOD_PRE

UIPC = Left

VMPst

VOWEL_MOD_POST

UIPC = Right

Overrides to Unicode categories
USE makes use of overrides to Unicode categories to achieve the desired shaping
behavior when the Unicode value is not well aligned with shaping requirements or when
no Unicode value is provided. These overides are available in two data files:
IndicSyllabicCategory-Additional.txt
IndicPositionalCategory-Additional.txt

Split vowel handling
USE decomposes split vowel characters belonging to UISC = Vowel_Dependent
according to character decomposition mappings

defined in UnicodeData.txt:

0DCF;SINHALA VOWEL SIGN AELA-PILLA;Mc;0;L;;;;;N;;;;;
0DD9;SINHALA VOWEL SIGN KOMBUVA;Mc;0;L;;;;;N;;;;;
0DDC;SINHALA VOWEL SIGN KOMBUVA HAA AELA-PILLA;Mc;0;L;0DD9 0DCF;;;;N;;;;;

When a decomposition is not defined in UnicodeData.txt, it is up to the font developer
to handle any required decomposition during GSUB processing.
Cluster validation, is done based on the decomposed state of a split vowel. Therefore,
the validation schemas only take into account the cardinal positions (Pre, Above, Below,
Post) since the full decompositions occupy one position only. Therefore cluster

validation depends on the sequence of decompositions which may be more restrictive
than with ordinary vowels.
1. Split vowel decomposition needs to be applied recursively so that split vowels get
fully decomposed before shaping is applied
2. Note, if a character belonging to a split vowel class that includes Pre, does not
have a canonical decomposition, it is up to the font developer to specify a
decomposition. The logical first glyph in that decomposition will be considered to
be the VPre. Any subsequent glyphs from that decomposition will not reorder.
There are no characters of this category in the currently supported scripts
Note: Font developers must include glyphs for all required decompositions.

Cluster validation
Cluster validation allows sequences of characters to be arranged into groups called
“clusters” based on their classification (both class and subclass). In Abugida writing
systems, a cluster is an orthographic unit of text that combines multiple phonetic and
orthographic elements. It is desirable to control the sequence of characters forming a
cluster so that a single visual cluster does not have multiple different encoding
sequences as that would create problems for data interchange in terms of stability and
security.
USE employs a generalized and permissive cluster structure in order to be flexible
enough to accommodate a wide range of script needs. The goal of the clustering logic is
to enable what is graphically consistent with a given script’s rules, rather than enforcing
particular orthographic or linguistic rules. Such considerations should be applied at
another layer, such as a spelling checker.
The maximal cluster scheme used by USE may be visualized as follows:

Visualized form of standard cluster in the Universal Shaping Engine
Schemas and rules for cluster analysis and syllable analysis use the following additional
symbols:
ﾉ

X*

sequence of zero or more occurrences of X

X+

sequence of one or more occurrences of X

<X | Y>

disjunction of elements: X or Y

[X]

optional (zero or one) occurrence of X

#

occurrence of a boundary

×

no boundary allowed at indicated position

÷

boundary allowed at indicated position

Expand table

^

Except

Well-formed character clusters can have combinations of groups as defined below.
There are four options:
1. Independent cluster

< IND | O | Rsv | WJ > [VS]

The independent cluster normally consists of a single member. The only other
character class it can combine with is VARIATION_SELECTOR. The BASE_IND,
OTHER, Reserved Characters and the word joiner (WJ) can only have a single code
point per cluster. When a VARIATION_SELECTOR occurs in any context other than
immediately following one of the valid bases (IND, O, Rsv, WJ, B, GB, N, S), it forms
an independent cluster.
2. Standard cluster

[< R | CS >] < B | GB > [VS] (CMAbv)* (CMBlw)* (< H B [VS] | SUB >
(CMAbv)* (CMBlw)*)*
[MPre] [MAbv] [MBlw] [MPst]
(VPre)* (VAbv)* (VBlw)* (VPst)*
(VMPre)* (VMAbv)* (VMBlw)* (VMPst)*
(FAbv)* (FBlw)* (FPst)* [FM]

The only required component of a standard cluster is a BASE or BASE_OTHER. A
cluster may optionally begin with a REPH or CONS_WITH_STACKER. A BASE or
BASE_OTHER may be followed immediately by a VARIATION_SELECTOR and/or
multiple CONS_MOD characters in the order CONS_MOD_ABOVE
CONS_MOD_BELOW. Multiple sequences of a HALANT BASE with optional
VARIATION_SELECTOR or optional CONS_MOD can occur. The sequence can
continue with zero or one CONS_MED for each cardinal position (Pre, Above,
Below, Post); zero to many VOWEL characters in each cardinal position; zero to
many VOWEL_MODs in each cardinal position; zero to many CONS_FINALs in each
of Above, Below, and Post; and lastly, an optional FINAL_MOD.
3. Virama terminated cluster

[< R | CS >] < B | GB > [VS] (CMAbv)* (CMBlw)* (< H B [VS] | SUB >
(CMAbv)* (CMBlw)*)* < H | RK >

This is similar to the Standard cluster but terminates in a final HALANT or RK.
When a HALANT or RK follows a BASE or BASE_OTHER it will form a cluster. When
any character other than a Base follows the Virama or RK there will be a cluster
break between the Virama and the following character. Multiple sequences of a
HALANT BASE with optional VARIATION_SELECTOR or optional CONS_MOD can
occur. A CONS_SUB is equivalent to the sequence HALANT BASE.
4. Number-joiner terminated cluster

N [VS] (HN N [VS])* HN

When HALANT_NUM follows a BASE_NUM it will form a cluster. When any
character other than BASE_NUM follows the HALANT_NUM there will be a cluster
break between the HALANT_NUM and the following character. A BASE_NUM may
be followed immediately by a VARIATION_SELECTOR. Multiple sequences of a
HALANT_NUM BASE_NUM with optional VARIATION_SELECTOR can occur.
5. Numeral cluster

N [VS] (HN N [VS])*

A BASE_NUM may form a cluster with another BASE_NUM when joined using a
HALANT_NUM. The join may be repeated. Any BASE_NUM may be followed by a
VARIATION_SELECTOR.
6. Symbol cluster

< S | GB > [VS] (CMAbv)* (CMBlw)*

A SYM character may be followed by an optional VARIATION_SELECTOR and zero
to many CONS_MOD_ABOVE, then zero to many CONS_MOD_BELOW.
7. Hieroglyph cluster

SB* G [VS] [HR] [HM] SE* ( J SB* G [VS] [HR] [HM] SE* )*

The basic unit of a Hieroglyph cluster is a HIEROGLYPH character. Each
HIEROGLYPH character may be modified by zero or one of each of the following in
this order:
VARIATION_SELECTOR — used to select a specific graphic variant of the base
HIEROGLYPH
HIEROGLYPH_MIRROR — used to select a horizontally mirrored alternate of
the base
HIEROGLYPH_MODIFIER — used to specify graphic variation of the base
The base HIEROGLYPH may be preceded by zero or more
HIEROGLYPH_SEGMENT_BEGIN characters and and may be followed by zero or
more HIEROGLYPH_SEGMENT_END characters. This basic unit may be extended by
joining additional instances of this unit using a HIEROGLYPH_JOINER.
Hieroglyph clusters may be nested. Hieroglyph clusters are attested with three
levels of nested segments. Therefore, at least two HIEROGLYPH_SEGMENT_BEGIN
and at least two HIEROGLYPH_SEGMENT_END characters can occur in sequence.
So, at minimum SB* and SE* should be SB{0,2} and SE{0,2}, respectively, in the
above model.
To support input of Hieroglyph clusters character-by-character, implementations
should support a Hieroglyph cluster terminated by a joiner so the cluster is valid
prior to input of a following HIEROGLYPH character.
Note: Superfluous use of nested segments may prevent text matching in collation
scenarios. However, this cluster model does not check for or enforce the minimal
use of nested segments. Marking superfluous use of nested segments is left to a
higher-level protocol such as orthographic checking.

Independent Vowel (IV) plus Dependent Vowel constraints (DV)
The core-specification of the Unicode standard prohibits forming certain IV forms from
other bases plus a DV (e.g., TUS Table 13-0

). Since these combinations apply to

particular pairs and not globally across classes, USE maintains a list of prohibited
sequences where they would not be prohibited by the cluster model. The list of
prohibited sequences is available as a data file: IndicShapingInvalidCluster.txt .

Combining Grapheme Joiner (CGJ)

CGJ has been omitted from the above schema in order to avoid unnecessary complexity.
It may occur anywhere in a cluster with no effect. The purpose of CGJ is to block
normalization processing which could change the order of marks in a sequence. CGJ
handling will need to be updated if USE is modified to support normalization.

Zero-width non-joiner (ZWNJ)
The zero-width non-joiner is used to prevent a fusion of two characters. It continues a
preceding cluster but causes a cluster break after itself when the following character is
not a mark character (gc=Mn or gc=Mc). ZWNJ does not reset the cluster model.

Zero-width joiner (ZWJ)
The zero-width joiner is used to fuse two characters. It continues a preceding cluster and
joins it to a following character unless the following character is another ZWJ. In which
case there will be a cluster break between the two ZWJs. ZWJ does not reset the cluster
model.

Standalone characters
Characters of the class BASE_IND occur as standalone characters and do not form
clusters with following characters. When a character belong to class VS or WJ occurs
outside of a cluster, i.e., at the start of a run, or following one of these standalone
characters, they should also be treated as standalone characters.

Defective clusters
When a cluster starts with any character that has UGC=Mc or UGC=Mn, USE inserts a
dotted circle glyph (U+25CC) to indicate a broken cluster. Defective clusters do not form
extended clusters themselves. A sequence of marks without a valid base forms separate
clusters for each mark. Note that an explicit character U+25CC is a valid generic base
(GB, BASE_OTHER) and so can form extended clusters.

Cluster length
A practical maximum cluster length is 31 characters. After this limit is reached, a cluster
break may be forced and a new cluster is started. During GSUB processing a cluster may
expand considerably beyond 31 glyphs.

OpenType feature application I

Basic cluster formation GSUB
Default glyph pre-processing group
These features are applied together, one cluster at a time. Lookups associated with any
of these features will be triggered in the lookup-order specified by the font developer. It
is possible to interleave lookups for different features. The order of features given here
is recommended.
locl — Localized forms
This provides a starting point to shape any language-specific forms. USE leverages
any language system tags provided by the edit control to trigger language-specific
substitutions.
ccmp — Glyph composition/decomposition
nukt ― Nukta forms
This feature is intended to enable substitutions with a combining nukta. In general
terms, a nukta is a consonant modifier that may be used to indicate an alternate
phoneme, often used to indicate foreign sounds to the native language of the
writing system.
akhn ― Akhands
Used to form traditional ligatures from sequences

Reordering group
These features are applied individually in this order, rphf, pref. The output of each of
these features is reordered as specified in the next section.
rphf ― Reph form
This feature is traditionally applied to invoke a combining form of a
preconsonantal r, which reorders after the following base. This feature may be
used generically to identify any component which has the reordering properties of
a reph. Feature application is scoped to the first three glyphs in a cluster.
pref — Pre-base forms
This feature may be used generically to identify a post-base component that has
the reordering properties of a pre-base medial consonant. The feature is applied to
the entire cluster.
Note that reordering is not done until after all of the basic features have been applied.

Orthographic unit shaping group

Like the Default glyph pre-processing group, these features are applied together, one
cluster at a time. It is, therefore, up to the font developer to specify the order of lookups
for these features in the font’s OTL. The order given here is recommended but not
required.
rkrf — Rakar forms
abvf — Above-base forms
This feature should be used to trigger substitutions relating to above-base
components.
blwf — Below-base forms
This feature should be used to trigger substitutions relating to below-base
components.
half ― Half forms
This feature is used to invoke half forms for scripts that use them.
pstf — Post-base forms
This feature should be used to trigger substitutions relating to post-base
components.
vatu ― Vattu variants
This feature is used to trigger ligatures with a below-base form.
cjct ― Conjunct forms
This feature is used to complete basic conjunct forms not already covered by other
features.

Glyph reordering
All reordering and anchoring of marks is done in relation to the base consonant. USE
does reordering in a single late phase. This is because all reordering is dependent on the
formation of the base which may be modified during basic cluster formation. USE does
not do checks or look-ahead in a font’s feature tables. Therefore feature lookups for the
basic features must be designed for the logical glyph order before any reordering has
been applied. There are two categories of glyphs that reorder: feature based and
property based. Actual glyph reordering is done between basic cluster formation
(OpenType feature application I) and Topographical substitutions (first part of OpenType
feature application II). Reordering is applied in logical order: rphf, pref, VPre, VMPre:
ﾉ

Before reordering

Expand table

After reordering

When the base cluster is broken by an explicit virama that has not been replaced during
basic cluster formation the reordering is impacted since reordering components do not
reorder past an explicit virama:
ﾉ

Expand table

Before
reordering

After reordering

If a font developer wants the reordering behavior to not be blocked by an explicit
virama, they can substitute the virama for an alternate glyph during basic cluster
formation so that USE treats the cluster as a continuous cluster without explicit virama.

Feature-based reordering
ﾉ

Expand table

Sigla

Name

Description

rphf

Reph form

Many abugida scripts render a preconsonantal r as a
sign above the consonant it precedes. This sign is
called reph. For the purposes of OT layout, reph is
normally rendered with a mark glyph, and as such,
must follow the base to which it applies. Contexts
which produce the reph glyph must use the 'rphf'
feature. The output of this feature reorders after the
following full base. Reph does not reorder past an
explicit Virama. Lookups under the rphf feature
should output no more than one glyph per cluster.

pref

Pre-base form

Scripts (e.g., Javanese) may reorder a medial
consonant to the beginning of a cluster based on
context. The contextual logic is encoded in the font’s
OT logic. Cases which require reordering should use
the 'pref' feature to identify the glyph or glyphs that
is or are to be reordered. One or more glyphs may
be substituted for a single feature glyph that is to be

Sigla

Name

Description
reordered before the first spacing glyph in the
cluster or the first spacing glyph after an explicit
virama if present. Only one such glyph is reordered
per cluster.

Note that prebase medial consonants (CONS_MED_PRE) do not get reordered
automatically by USE. Rather, the font designer is expected to use the 'pref' feature
to signal when a glyph belonging to this class should be reordered through the
application of the pref feature. Only one glyph per cluster can be reordered using
'pref'.

Property-based reordering
ﾉ

Expand table

Sigla

Name

Description

R

REPHA

Pre-base REPHA is reordered by USE after a
following full base as if the 'rphf' feature has been
applied. Font developers do not need to use the
'rphf' feature explicitly.

VPre

VOWEL_PRE

Pre-base vowels and pre-base vowel components
from split vowels are reordered before the base
glyph and, if present, before a pre-base glyph
reordered via the 'pref' feature.

VMPre

VOWEL_MOD_PRE

Pre-base vowel modifiers are reordered before the
base glyph and, if present, before a pre-base vowel
and/or before a pre-base glyph reordered via the
'pref' feature.

Note that the category REPHA is not currently supported by USE.
Note that the split vowels, VOWEL_PRE_ABOVE, VOWEL_PRE_ABOVE_POST, and
VOWEL_PRE_POST have multiple positions that include a pre-base element. Since
split vowel decomposition is done before reordering, only one glyph will have the
VOWEL_PRE class, and so only this vowel class needs special handling at this stage.

OpenType feature application II
Topographical features, GSUB

USE applies positional features required for scripts like Arabic which have alternate
glyph shapes depending on the position of a glyph within a word.
isol ― Isolated forms
init ― Initial forms
medi ― Medial forms
fina ― Final forms
USE applies these as required features on a per cluster basis in order to invoke a
particular form based on non-joining or white space boundaries. Non-joining
boundaries occur between glyphs belonging to a joining script when one or both
characters have a non-joining property that applies to the side of the connection on
which a join would occur. The control characters ZWJ and ZWNJ may be used to
artificially invoke or prevent a join. Joining properties are defined by the Unicode
property Joining Type in ArabicShaping.txt.
Note:Support for topographical features for non-joining scripts is not currently
implemented in USE. Additional specification is required.

Standard typographic presentation, GSUB
The remaining required features are applied all together to the entire run. It is up to the
font developer to specify the order of lookups for this set of features:
abvs — Above-base substitutions
blws — Below-base substitutions
calt — Contextual alternates
clig — Contextual ligature
haln ― Virama forms
liga — Standard ligatures [horizontal text only]
pres — Pre-base substitutions
psts — Post-base substitutions
rclt ― Required contextual forms
rlig — Required ligatures [horizontal text only]
vert — Vertical writing [implemented by edit control]
vrt2 — Vertical alternates and rotation [implemented by edit control]
The vertical layout features are applied when text layout is vertical and triggered
by the edit control as a custom feature. Only one feature vert or vrt2 should be
applied, not both.

Custom substitution features requested by the application, GSUB

Positional feature application, GPOS
During GPOS processing, these required features are applied simultaneously to the
entire run. The order specified here is recommended, but it is up to font developers to
define the order of GPOS lookups for this set of features in OTL.
curs — Cursive positioning
This feature should be used to position bases in relation to other bases.
dist — distances
This feature should be used to make required width adjustments.
kern — Kerning
This feature should be used to provide optimal letter spacing. This feature can be
disabled by edit controls.
mark — Mark positioning
This feature should be used to position marks in relation to a base sign.
abvm — Above-base mark positioning
This feature is functionally equivalent to the mark feature. It may be used as an
organizing mechanism to separate above mark processing from below mark
processing.
blwm — Below-base mark positioning
This feature is functionally equivalent to the mark feature. It may be used as an
organizing mechanism to separate below mark processing from above mark
processing.
mkmk — Mark to Mark Positioning
This feature should be used to position marks in relation to preceding marks.
An important OT technique for excluding certain base glyphs from contextual lookups is
to classify the base glyph as a mark in the font's GDEF table, since marks can be
selectively included or omitted from OT processing. However, whenever this technique is
used, the width of the base glyph must be added back using the 'dist' feature. This is
necessary because OT processing cancels the width associated with a mark. It is
necessary to cancel the width of a non-spacing mark because it is not clear where to
apply the width of a non-spacing mark during OpenType processing.
A typical use case of this is Javanese which has prebase vowels. Since the prebase
vowels do not reorder until after basic cluster formation, they are present in their logical
position. This may interrupt other contextual substitutions. If the vowels are treated as
marks, they can be excluded from OT context, and thus reduce the number of contextual
rules required for processing. Consequently the expected width of the prebase vowels
may be restored with the dist feature, for example (in VOLT OT Language):

DEF_LOOKUP "j.dist_preVowel" PROCESS_BASE PROCESS_MARKS ALL DIRECTION LTR
AS_POSITION
ADJUST_SINGLE
GLYPH "jSignE" BY POS ADV 1433 END_POS
GLYPH "jSignAi" BY POS ADV 1433 END_POS
END_ADJUST
END_POSITION
END

Other encoding issues
Handling invalid combining marks
Combining marks and signs that do not occur in conjunction with a valid base are
considered invalid. USE treats an invalid mark as a separate cluster and displays the
stand-alone mark positioned on a dotted circle (U+25CC). If multiple marks are required
to position on a dotted circle, the dotted circle can be explicitly inserted into the text
stream followed by any marks in accordance with the standard clustering rules.
To allow for shaping engine implementations that expect to position an invalid mark on
a dotted circle, it is recommended that font using USE contain glyphs for the dotted
circle character, U+25CC. If this character is not supported in the font, such
implementations will display invalid signs on the missing glyph shape (white box).

Recommended Glyphs
Unicode code points that are recommended for inclusion in any font using USE are:
ﾉ

Code point

Description

U+200B

Zero Width Space

U+200C

Zero Width Non-Joiner

U+200D

Zero Width Joiner

U+25CC

Dotted Circle

U+00A0

No-break space

U+00D7

Multiplication sign

Expand table

Code point

Description

U+2012

Figure dash

U+2013

En dash

U+2014

Em dash

U+2015

Horizontal bar

U+2022

Bullet

U+25FB

White medium square

U+25FC

Black medium square

U+25FD

White medium small square

U+25FE

Black medium small square

Appendix
Writing system and language tags
OpenType features are enabled in a font according to both a designated script and
language system. The language system tag specifies a typographic convention
associated with a language or linguistic subgroup. Not all software applications support
specific language tags for use when rendering text runs.
Note: It is strongly recommended to include the “dflt” language tag in all OpenType
fonts because it defines the basic script handling for a font. The “dflt” language system
is used as the default if no other language specific features are defined or if the
application does not support that particular language. If the “dflt” tag is not present for
the script being used, the font may not work in some applications.
The following tables list the registered tag names for scripts currently supported by USE.
This list will grow as new complex scripts are enabled by Unicode and USE is updated.
Language system tags are not listed here and should be determined by font developers
as appropriate for the script concerned.
ﾉ

Expand table

Registered tags for the Universal Shaping Engine
Script

Script tag

ADLaM

adlm

Ahom

ahom

Bhaiksuki

bhks

Balinese

bali

Batak

batk

Brahmi

brah

Buginese

bugi

Buhid

buhd

Chakma

cakm

Cham

cham

Chorasmian

chrs

Cypro Minoan

cpmn

Dives Akuru

diak

Dogra

dogr

Duployan

dupl

Egyptian Hieroglyphs

egyp

Elymaic

elym

Garay

gara

Grantha

gran

Gunjala Gondi

gong

Gurung Khema

gukh

Hanifi Rohingya

rohg

Hanunoo

hano

Javanese

java

Kaithi

kthi

Registered tags for the Universal Shaping Engine
Script

Script tag

Kawi

kawi

Kayah Li

kali

Kharoshthi

khar

Khitan Small Script

kits

Khojki

khoj

Khudawadi

sind

Kirat Rai

krai

Lepcha

lepc

Limbu

limb

Mahajani

mahj

Makasar

maka

Mandaic

mand

Manichaean

mani

Marchen

marc

Masaram Gondi

gonm

Medefaidrin

medf

Meitei Mayek

mtei

Miao

plrd

Modi

modi

Mongolian

mong

Multani

mult

Nag Mundari

nagm

Nandinagari

nand

Newa

newa

N’Ko

nko

Registered tags for the Universal Shaping Engine
Script

Script tag

Nyiakeng Puachue Hmong

hmnp

Old Sogdian

sogo

Old Uyghur

ougr

Ol Onal

onao

Pahawh Hmong

hmng

Phags-pa

phag

Psalter Pahlavi

phlp

Rejang

rjng

Saurashtra

saur

Sharada

shrd

Siddham

sidd

Sinhala

sinh

Sogdian

sogd

Soyombo

soyo

Sunuwar

sunu

Sundanese

sund

Syloti Nagri

sylo

Tagalog

tglg

Tagbanwa

tagb

Tai Le

tale

*Tai Tham

lana

Tai Viet

tavt

Takri

takr

Tangsa

tnsa

Tibetan

tibt

Registered tags for the Universal Shaping Engine
Script

Script tag

Tifinagh

tfng

Tirhuta

tirh

Todhri

todr

Toto

toto

Tulu Tigalari

tutg

Vithkuqi

vith

Wancho

wcho

Yezidi

yezi

Zanabazar Square

zanb

Note: script tags are case sensitive (script tags should be lowercase) and must contain
four characters.
Note: Tai Tham support is currently limited. Additional encoding work is required for full
text representation to be possible.

Developing OpenType Fonts for Arabic
Script
Article • 06/09/2022

This document presents information that will help font developers create or support
OpenType fonts for all Arabic script languages covered by the Unicode Standard.

Introduction
Font developers will learn how to encode complex script features in their fonts, choose
character sets, organize font information, and use existing tools to produce Arabic fonts.
Registered features of the Arabic script are defined and illustrated, encodings are listed,
and templates are included for compiling Arabic layout tables for OpenType fonts.
This document also presents information about the Arabic OpenType shaping engine of
Uniscribe, the Windows component responsible for text layout.
In addition to being a primer and specification for the creation and support of Arabic
fonts, this document is intended to more broadly illustrate the OpenType Layout
architecture, feature schemes, and operating system support for shaping and
positioning text.

Glossary
The following terms are useful for understanding the layout features and script rules
discussed in this document.
Base Glyph - Any glyph that can have a diacritic mark above or below it. Layout
operations are defined in terms of a base glyph, not a base character, as a ligature may
act as the base.
Character - Each character represents a Unicode character code point. For example 'lam'
character is U+0644. A character may have multiple forms of glyphs.
Diacritic Marks - A character that is positioned above or below a character to provide
pronunciation guidance (i.e. accent acute, grave, tilde, etc.)
Glyph - A glyph represents a form of one or more characters. For example, the final,
initial and medial 'lam' glyphs (U+FEDE, U+FEDF & U+FEE0) are all forms of the 'lam'
character (U+0644).

Kashida - Also known as the 'tatweel' character (U+0640). This character is used for
elongation between connecting characters and is used for justification.
Ligature - A combination of glyphs that join to form a single glyph. For example, the
'lam alef' combinations of glyphs are mandatory ligatures for Arabic. Other ligatures, like
'lam meem initial', are optional.

Shaping Engine
Analyzing the Characters
Shaping with OTLS
Positioning Glyphs with OTLS
Handling Invalid Combining Marks
The Uniscribe Arabic shaping engine processes text in stages. The stages are:
1. Analyzing the characters for contextual shape
2. Shaping (substituting) glyphs with OTLS (OpenType Library Services)
3. Positioning glyphs with OTLS
The descriptions which follow will help font developers understand the rationale for the
Arabic feature encoding model, and help application developers better understand how
layout clients can divide responsibilities with operating system functions.

Analyzing the Characters
The unit that the shaping engine receives for the purpose of shaping is a string of
Unicode characters, in a sequence. The contextual analysis engine determines the
correct contextual form the character should take, based on the character before and
after it. The contextual shape maps to an OTL feature for that form (isol, init, medi, fina).
Additionally, during the analysis process, the engine verifies valid diacritic combinations.
For additional information, see the Handling Invalid Combining Marks section.

Shaping with OTLS
The first step Uniscribe takes in shaping the character string is to map all characters to
their nominal form glyphs (e.g. the glyph for U+0627). Then, Uniscribe applies
contextual shape features to the glyph string.
Next, Uniscribe calls OTLS to apply the features. All OTL processing is divided into a set
of predefined features (described and illustrated in the Features section of this

document). Each feature is applied, one by one, to the appropriate glyphs in the syllable
and OTLS processes them. Uniscribe makes as many calls to the OTL Services as there
are features. This ensures that the features are executed in the desired order.
The steps of the shaping process are outlined below. Not all of the features listed apply
to all Arabic script languages.

Shaping features:
1. Language forms
a. Apply feature 'ccmp' to preprocess any glyphs that require composition or
decomposition (for example, 'alef' followed by 'hamza above' may be composed
into 'alef with hamza above')
b. Apply feature 'isol' to get the isolated form of characters
c. Apply feature 'fina' to get final form glyphs
d. Apply feature 'medi' to get medial form glyphs
e. Apply feature 'init' to get initial form glyphs
f. Apply feature 'rlig' to compose any mandatory ligatures, like 'lam alef'
g. Apply feature 'calt' to apply any desired alternative forms of connections; this
can provide type designers with the capability to contextually exchange a glyph
to give a better calligraphic presentation
2. Typographical forms
a. Apply feature 'liga' to compose any optional ligatures, like 'lam meem'
b. Apply feature 'dlig' to compose any discretionary ligatures
c. Apply feature 'cswh' to substitute any swash characters based on context; for
example, a swash 'noon' might be used if followed by n glyphs that do not
extend below the baseline
d. Apply feature 'mset' to apply mark positioning via substitution; this does not
produce the best typographic possibilities as would the use of the positioning
feature 'mark'

Positioning Glyphs with OTLS
Uniscribe next applies features concerned with positioning, calling functions of OTLS to
position glyphs.

Positioning features:
1. Cursive connection
a. Apply feature 'curs' to connect cursive font glyphs as appropriate

2. Kerning
a. Apply feature 'kern' to provide pair kerning between base glyphs requiring
adjustment for better typographical quality
3. Mark to base
a. Apply feature 'mark' to position diacritic glyphs to the base glyph
4. Mark to Mark
a. Apply feature 'mkmk' to position diacritic glyphs to other diacritic glyphs

Handling Invalid Combining Marks
Combining marks and signs that appear in text not in conjunction with a valid
consonant base are considered invalid. Uniscribe displays these marks using the fallback
rendering mechanism defined in the Unicode Standard (section 5.12, 'Rendering NonSpacing Marks' of the Unicode Standard 3.1), i.e. positioned on a dotted circle.
Please note that to render a sign standalone (in apparent isolation from any base) one
should apply it on a space (see section 2.5 'Combining Marks' of Unicode Standard 3.1).
Uniscribe requires a ZWJ to be placed between the space and a mark for them to
combine into a standalone sign.
For the fallback mechanism to work properly, an Arabic OTL font should contain a glyph
for the dotted circle (U+25CC). In case this glyph is missing form the font, the invalid
signs will be displayed on the missing glyph shape (white box).
In addition to the 'dotted circle,' other Unicode code points that are recommended for
inclusion in any Arabic font are: ZWNJ (zero width non-joiner; U+200C), ZWJ (zero width
joiner U+200D), LTR (left to right mark; U+200E), and RTL (right to left mark; U+200F).
The ZWNJ can be used between two letters to prevent them from forming a cursive
connection.

If an invalid combination is found, like two fathas on the same base character, the
diacritic that causes the invalid state is placed on a dotted circle to indicate to the user
the invalid combination. The shaping engine for non-OpenType fonts will cause invalid
mark combinations to overstrike. This is the problem that inserting the dotted circle for
the invalid base solves. It should also be noted that the dotted circle is not inserted into
the application's backing store. This is a run-time insertion into the glyph array that is
returned from the ScriptShape function.

The invalid diacritic logic for Arabic is based on the classes listed below. There is a check
to make sure more than one mark of a class is not placed on the same base.
Additionally, DIAC1 and DIAC2 classes should not be applied on the same base
character.
Class

Description

Code points

DIAC1

Arabic above diacritics

U+064B, U+064C, U+064E, U+064F, U+0652,
U+0657, U+0658, U+06E1

DIAC2

Arabic below diacritics

U+064D, U+0650, U+0656

DIAC3

Arabic seat shadda

U+0651

DIAC4

Arabic Qur'anic marks above

U+0610 - U+0614, U+0659, U+06D6 U+06DC, U+06DF, U+06E0, U+06E2, U+06E4,
U+06E7, U+06E8, U+06EB, U+06EC

DIAC5

Arabic Qur'anic marks below

U+06E3, U+06EA, U+06ED

DIAC6

Arabic superscript alef

U+0670

DIAC7

Arabic madda

U+0653

DIAC8

Arabic madda

U+0654, U+0655

Features
The features listed below have been defined to create the basic forms for the languages
that are supported on Arabic systems. Regardless of the model an application chooses
for supporting layout of complex scripts, Uniscribe requires a fixed order for executing
features within a run of text to consistently obtain the proper basic form. This is
achieved by calling features one-by-one in the standard order listed below.
The order of the lookups within each feature is also very important. For more
information on lookups and defining features in OpenType fonts, see the Encoding
section of the OpenType Font Development document.
The standard order for applying Arabic features encoded in OpenType fonts:
Not all of the features listed below apply to all Arabic script languages.
Feature

Feature function

Layout

Always

On by

Off by

operation

applied

default

default

GSUB

X

Language based forms:
ccmp

Character composition/decomposition

substitution
isol

Isolated character form substitution

GSUB

X

fina

Final character form substitution

GSUB

X

medi

Medial character form substitution

GSUB

X

init

Initial character form substitution

GSUB

X

rlig

Required ligature substitution

GSUB

X

rclt

Required contextual alternates
substitution

GSUB

X

calt

Contextual alternates substitution

GSUB

X

Typographical forms:
liga

Standard ligature substitution

GSUB

X

dlig

Discretionary ligature substitution

GSUB

X

cswh

Contextual swashes

GSUB

X

mset

Mark positioning via substitution

GSUB

X

Positioning features:
curs

Cursive positioning

GPOS

X

kern

Pair kerning

GPOS

X

mark

Mark to base positioning

GPOS

X

mkmk

Mark to mark positioning

GPOS

X

[GSUB = glyph substitution, GPOS = glyph positioning]

Descriptions and examples of above features
Many of the registered features described and illustrated in this document are based on
the OpenType font Arabic Typesetting. Arabic Typesetting contains layout information
and glyphs to support all of the required features for the Arabic script and language
systems supported. The Arabic Typesetting font will be available as part of Visual
OpenType Layout Tool (VOLT) and is provided under the terms of the VOLT
supplemental files end user license agreement. The Arabic Typesetting font is available
for download in the Appendix of this document

Character composition (and decomposition)
Feature Tag: "ccmp"
The 'ccmp' feature is used to compose a number of glyphs into one glyph, or
decompose one glyph into a number of glyphs. This feature is implemented before any
other features because there may be times when a font vender wants to control certain
shaping of glyphs. An example of using this table is seen below. The 'ccmp' table maps
default alphabetic forms to both a composed form (essentially a ligature, GSUB lookup
type 4), and decomposed forms (GSUB lookup type 2).

The rationale for the decomposition illustrated above is to take advantage of the color
diacritic feature found in Microsoft applications like Word and Publisher.

Isolated form
Feature Tag: "isol"
The 'isol' feature is used to map the Unicode character value to its isolated form. This is
usually the same glyph form. However, Unicode defines Arabic presentation forms as
different than the Unicode character form. If a vender has a good quality font tool, or a
font utility that can edit the CMAP table, more than one Unicode character can point to
the same glyph ID. (GSUB lookup type 1).

Final form

Feature Tag: "fina"
The 'fina' feature is used to map the Unicode character value to its final form. (GSUB
lookup type 1).

Medial form
Feature Tag: "medi"
The 'medi' feature is used to map the Unicode character value to its medial form. (GSUB
lookup type 1).

Initial form
Feature Tag: "init"
The 'init' feature is used to map the Unicode character value to its initial form. (GSUB
lookup type 1).

Required ligatures
Feature Tag: "rlig"

The 'rlig' feature is used to map glyph values to their correct ligated form. Font
developers should use this table for all ligatures that they want to map as such all of the
time. Ligatures that should be optional, based on user preferences should not be
included in this table. Optional ligatures are defined in the 'liga' table.
The 'rlig' feature maps sequences of glyphs to corresponding ligatures (GSUB lookup
type 4). Ligatures with more components must be stored ahead of those with fewer
components in order to be found. See Ordering ligatures) in the Encoding section of the
OpenType Font Development document. The set of required ligatures will vary by design
and script.
NOTE: If you want your fonts to have some level of backward compatibility with
Windows9x/ME system level support you will also want to include the items in the 'rlig'
feature in the 'liga' feature. This is because older operating systems do not use Uniscribe
for shaping and are not aware of the 'rlig' feature.

Connection forms
Feature Tag: "rclt" or "calt"
In specified situations, replaces default glyphs with alternate forms that provide better
joining behavior. Used in script typefaces which are designed to have some or all of
their glyphs join. The 'calt' feature specifies the context in which each substitution
occurs, and maps one or more default glyphs to replacement glyphs (GSUB lookup type
6). Substitutions that are required for script correctness should be put under 'rclt'.”
NOTE: If you want your fonts to have some level of backward compatibility with
Windows7/8.1 system level support you will also want to include the items in the 'rclt'
feature in the 'calt' feature. This is because older operating systems are not aware of the
'rclt' feature. The 'calt' is always applied for Arabic to preserve documents using older
fonts.
The 'calt' feature specifies the context in which each substitution occurs, and maps one
or more default glyphs to replacement glyphs (GSUB lookup type 6). Substitutions that
are required for script correctness should be put under 'rclt'.

Standard ligatures
Feature Tag: "liga"
The 'liga' feature is used to map glyphs to their optional ligated form. Font developers
should use this table for all ligatures that should be on by default but may be turned off
by user preference. Uniscribe applies this feature by default but will allow this feature to
be deactivated. Non-required features, including ‘liga’, can be disabled by passing in a
custom font feature list that specifies a feature as off for the entire run. The 'liga' feature
maps sequences of glyphs to corresponding ligatures (GSUB lookup type 4). Ligatures
with more components must be stored ahead of those with fewer components in order
to be found. See Ordering ligatures in the Encoding section of the OpenType Font
Development document. The set of optional ligatures will vary by typeface design and
script.
NOTE: Ligatures that should be formed all of the time should not be included in this
feature type. Required ligatures are defined in the 'rlig' table.

Discretionary ligatures

Feature Tag: "dlig"
The 'dlig' feature is used to map glyphs to their optional ligated form. Font developers
should use this table for all ligatures that should be off by default but may be turned on
by user preference. Optional features, including ‘dlig’, can be enabled by passing in a
custom font feature list that specifies an optional feature as on for the entire run. The
'dlig' feature maps sequences of glyphs to corresponding ligatures (GSUB lookup type
4). Ligatures with more components must be stored ahead of those with fewer
components in order to be found. See Ordering ligatures in the Encoding section of the
OpenType Font Development document. The set of optional ligatures will vary by
typeface design and script.

Contextual swash
Feature Tag: "cswh"
The 'cswh' feature replaces default character glyphs with corresponding swash glyphs
based upon the context surrounding the character. Note that there may be more than
one swash alternate for a given character. The 'cswh' table maps glyph IDs for default
forms to those for one or more corresponding swash forms. While many of these
substitutions are one-to-one (GSUB lookup type 1), others require a selection from a set
(GSUB lookup type 3). Font developers may choose to build two tables (one for each
lookup type) or only one that uses lookup type 3 for all substitutions. If several styles of
swash are present across the font, the set of forms for each character should be ordered
consistently
The 'cswh' feature is off by default but may be turned on by user preference. Optional
features, including ‘cswh’, can be enabled by passing in a custom font feature list that
specifies an optional feature as on for the entire run.

Mark positioning via substitution
Feature Tag: "mset"
The 'mset' feature is used to position Arabic combining marks in fonts for Windows 95
using glyph substitution. In Arabic, the Hamza is positioned differently when placed
above a Yeh Barree as compared to the Alef. Windows 95 implementation: In contrast to
the "mark" feature, the 'mset' feature uses glyph substitution to combine marks and
base glyphs. It replaces a default mark glyph with a correctly positioned mark glyph. The
font designer specifies the position of the mark when describing the mark's contour in
the font file. Microsoft's Arabic fonts, created for Windows 95, use a contextual
substitution lookup (GSUB LookupType = 5) to implement the 'mset' feature.

Example: the default fatha is positioned high and the 'mset' feature is used to substitute
a low form when placed over a Beh.

Cursive positioning
Feature Tag: "curs"
The 'curs' feature positions cursive characters so that the exit point of the current
character matches with entry point of the following character. The 'curs' table maps
connecting point of joining glyphs and may be implemented as a Cursive Attachment
(GPOS lookup type 3).

Kerning
Feature Tag: "kern"
The 'kern' feature is used to adjust amount of space between glyphs, generally to
provide optically consistent spacing between glyphs. Although a well-designed typeface
has consistent inter-glyph spacing overall, some glyph combinations require adjustment
for improved legibility. Besides standard adjustment in either horizontal or vertical
direction, this feature can supply size-dependent kerning data via device tables, "crossstream" kerning in the Y text direction, and adjustment of glyph placement independent
of the advance adjustment. Note that this feature would not be used in monospaced
fonts.
The font stores a set of adjustments for pairs of glyphs (GPOS lookup type 2 or 8). These
may be stored as one or more tables matching left and right classes, and/or as
individual pairs. If both forms are used, the classes should be listed last, so as to provide
a means to replace any non-ideal values that may result from the class tables. Additional
adjustments may be provided for larger sets of glyphs (e.g., triplets, quadruplets, etc.) to
overwrite the results of pair kerns in particular combinations. These should precede the
pairs.

Creating kern table using Microsoft VOLT

Mark to base positioning
Feature Tag: "mark"
The 'mark' feature positions mark glyphs in relation to a base glyph, or a ligature glyph.
This feature may be implemented as a MarkToBase Attachment lookup (GPOS
LookupType = 4) or a MarkToLigature Attachment lookup (GPOS LookupType = 5).

Positioning mark to base using Microsoft VOLT

Positioning mark to base (ligature) using Microsoft VOLT

Mark to mark positioning
Feature Tag: "mkmk"
The 'mkmk' feature positions mark glyphs in relation to another mark glyph. This feature
may be implemented as a MarkToMark Attachment lookup (GPOS LookupType = 6).
Positioning mark to mark using Microsoft VOLT

Appendices
Appendix A: Writing System Tags
Appendix B: ARABTYPE.TTF (sample font)

Appendix A: Writing System Tags
Features are encoded according to both a designated script and language system. The
language system tag specifies a typographic convention associated with a language or
linguistic subgroup. For example, there are different language systems defined for the
Arabic script; Arabic, Baluchi, Ladakhi, Pashto, etc. Other typographic systems could be
defined for Moroccan Arabic or Wahabi tradition of Qur'anic typography.

Currently, the Uniscribe engine only supports the "default" language for each script.
However, font developers may want to build language specific features which are
supported in other applications and will be supported in future Microsoft OpenType
implementations.
NOTE: It is strongly recommended to include the "dflt" language tag in all
OpenType fonts because it defines the basic script handling for a font. The "dflt"
language system is used as the default if no other language specific features are
defined or if the application does not support that particular language. If the "dflt"
tag is not present for the script being used, the font may not work in some
applications.
The following tables list the registered tag names for scripts and language systems.
Registered tags for the Arabic script

Registered tags for Arabic language systems

Script tag

Language

Script

Language

system tag
"arab"

Arabic

"dflt"

*default script handling

"ARA "

Arabic

"BLI "

Baluchi

"BLT "

Balti

"BBR "

Berber

"BRH "

Brahui

"FAR "

Persian

"FUL "

Fulah

"HAU "

Hausa

"HND "

Hindko

"KNR "

Kanuri

"KSH "

Kashmiri

"KHW "

Khowar

"KUR "

Kurdish

"LDK "

Ladakhi

"MLY "

Malay

"MND "

Mandinka

"PAS "

Pashto

"PAN "

Punjabi

"SRK "

Saraiki

"SND "

Sindhi

"SML "

Somali

"SWK "

Swahili

"URD "

Urdu

"UYG "

Uyghur

NOTE: both the script and language tags are case sensitive (script tags should be
lowercase, language tags are all caps) and must contain four characters (i.e. you must
add a space to the three character language tags).

Appendix B: ARABTYPE.TTF (sample font)
The Arabic Typesetting font is distributed with Microsoft Visual OpenType Layout Tool
(VOLT) and is provided under the terms of the VOLT supplemental files end user license
agreement. It is provided for illustration only, and may not be altered or redistributed.
Arabic Typesetting supports all characters from the Unicode Arabic and Arabic Extended
blocks. As such, it can be used to produce documents in Arabic, Farsi, Urdu, Sindhi,
Malay, and Uighur. The font is the Arabic naskh style of calligraphy.
Arabic Typesetting contains layout information and glyphs to support all of the required
features for the languages supported. The font contains over 1600 Arabic glyphs. It is
not necessary for all fonts to support this many glyphs or ligatures. Each font should be
designed as the font creator desires.
Many shaped glyph forms (such as ligatures) have no Unicode encoding. These glyphs
have id's in the font, and applications can access these glyphs by "running" the layout
features which depend on these glyphs. An application can also identify non-Unicode
glyphs contained in the font by traversing the OpenType layout tables, or using the
layout services for purely informational purposes.
Arabic Typesetting contains three OpenType Layout tables: GSUB (glyph substitution),
GPOS (glyph positioning), and GDEF (glyph definition, distinguishing base glyphs,
ligatures, classes of mark glyphs, etc.).

Creating and Supporting OpenType
Fonts for the Buginese Script
Article • 06/16/2022

This document presents information that will help font developers in creating OpenType
fonts for Buginese script as covered by the Unicode Standard 6.3. The Buginese script is
used to write the Buginese language. It is also used to write Makasar and Mandar.
NOTE: Starting in Windows 10, Buginese will be supported by the Universal Shaping
Engine rather than a stand-alone shaping engine. Moving forward, developers should
refer to this new specification.

Introduction
This document targets developers implementing shaping behavior compatible with the
Microsoft OpenType specification for the Buginese script. It contains information about
terminology, font features and behavior of the Buginese shaping engine. While it does
not contain instructions for creating Buginese fonts, it will help font developers
understand how the Buginese shaping engine processes Buginese text.

Terms
The following terms are useful for understanding the layout features and script rules
discussed in this document.
Base glyph – Any glyph that can have a diacritic mark attached to it. Layout operations
are defined in terms of a base glyph, not a base character, as a ligature may act as a
base
Character – Each character represents a Unicode character code point. A character may
have multiple glyph forms
Cluster – A group of characters that form an integral unit in Brahmi-derived scripts,
oftentimes this corresponds to a syllable
Consonant – Buginese consonants have an inherent vowel (the short vowel /a/). For
example, “Ka” and “Ta”, rather than just “K” or “T”
Format controls – special formatting characters used in the shaping process of Buginese
scripts (U+200c and U+200D). These characters have no visual appearance, except when

an application chooses to display zero width glyphs
Glyph – A glyph represents a form of one or more characters
Halant – The character used after a consonant to “strip” it of its inherent vowel
Ligature – A combination of glyphs that join to form a single glyph
Matra (dependent vowel) – Used to represent a vowel sound that is not inherent to the
consonant. Dependent vowels are referred to as “matras” in Sanskrit. They are always
depicted in combination with a single consonant, or with a consonant cluster
OpenType layout engine – The library responsible for executing OpenType layout
features in a font. In the Microsoft text formatting stack, it is named OTLS (OpenType
layout services)
OpenType tag – A 4-byte identifier for script, language system or feature in the font
Shaping engine - Code responsible for shaping input, classified to a particular script

How the Buginese shaping engine works
Analyzing the characters
Reordering pre-base vowels (VPre)
Apply OpenType GSUB features for localized forms and basic shaping forms
Applying OpenType GSUB presentation features
Applying OpenType GPOS features to position glyphs or marks
The Uniscribe Buginese shaping engine processes text in stages. The stages are:
1. Analyzing the characters
2. Reordering pre-base vowels (VPre)
3. Apply OpenType GSUB features for localized forms and basic shaping forms
4. Applying OpenType GSUB presentation features
5. Applying OpenType GPOS features to position glyphs or marks
The descriptions which follow will help font developers understand the rationale for the
Buginese feature encoding model, and help application developers better understand
how layout clients can divide responsibilities with operating system functions.

Analyzing the characters
The run of text that the shaping engine receives for the purpose of shaping is a
sequence of Unicode characters. The shaping engine divides the text into syllable

clusters and identifies character properties. Character properties are used in parsing
syllables and identifying their parts as well as determining whether any contextual
reordering is required.
In the diagrams below, the rules for forming clusters are given in terms of the classes of
characters in the character stream. The meanings of the symbols are:
C

Consonants (1A00-1A16)

GB

Generic base characters (00A0, 00D7, 2012–2015, 2022, 25CC, 25FB–25FE)

J

Joiners (200C, 200D)

O

SCRIPT_COMMON characters in a Buginese run

R

Reserved characters from the Buginese block (1A1C, 1A1D)

S

Symbols (1A1E, 1A1F, A9CF)

VAbv

Above base dependent vowel (1A17, 1A1B)

VBlw

Below base dependent vowel (1A18)

VPre

Pre base dependent vowel (1A19)

VPst

Post base dependent vowel (1A1A)

VS

Variation selectors (FE00–FE0F)

WJ

Word joiner (2060)

WS

White space (any white space character including ZWSP)

X*

sequence of zero or more occurrences of X. Since this could extend a cluster indefinitely
an arbitrary limit of 31 characters in a sequence has been used

X+

Sequence of one or more occurrences of x

<X|Y

disjunction of elements: X or Y

>
[X]

optional (zero or one) occurrence of X

#

occurrence of a boundary

×

no boundary allowed at indicated position

÷

boundary allowed at indicated position

^

Except

The shaping engine inserts a placeholder glyph (U+25CC) wherever combining marks
occur without a valid base. The character U+25CC belongs to the class of generic bases
(GB). Well-formed Buginese character clusters are defined as follows:
Simple non-compounding cluster
< S | Rsv | WS | O | J | WJ >
Symbols (S), reserved characters (Rsv), white space (WS), other SCRIPT_COMMON
characters (O), Joiners and word joiner (WJ).
Clusters
< C | GB > [VS] (VPre)* (VAbv)* (VBlv)* (VPst)* [J]
A consonant or generic base and optional variation selector. One or more of each vowel
type can occur in the specified order. Zero-width joiner and zero-width non joiner will
be the last item in any cluster in which they occur.

Reordering pre-base vowels (VPre)
Once the Buginese shaping engine has analyzed the run into clusters as described
above, it performs any required reordering. Pre-base vowels (VPre) are reordered to the
start of the syllable cluster. A sequence of multiple pre-base vowels is permitted. Such
sequences are moved as a block to the beginning of the cluster. In the following
example, the run of code points represents a single cluster.
INPUT
1A00 1A19 034F 1A19 034F 1A17
Base Pre-base vowels
REORDERED
1A19 034F 1A19 034F 1A00 1A17
Note: the OpenType lookups in a Buginese font must be written to match glyph
sequences after re-ordering has occurred. OpenType fonts should not have substitutions
that attempt to perform the re-ordering. If a font developer attempted to encode such
reordering information in an OpenType font, they would need to add a large number of
many-to-many glyph mappings to cover the general algorithms that a shaping engine
will use.

Apply OpenType GSUB features for localized
forms and basic shaping forms
Uniscribe calls OTLS to apply the features. OTL processing is divided into a sets of
predefined features (described and illustrated in the Features section of this document).
The first application of GSUB features are applied per cluster in the following order.
Note: not all of the features listed here need to be used when defining a font for the
Buginese script.
A. Localized forms
Apply feature ‘locl’ to preprocess any localized forms for the current language

Apply OpenType GSUB features for
presentation forms
The presentation form features are applied simultaneously over the entire run.
Therefore, several features are operationally equivalent to a single feature. The order of
application, therefore, is the order of features defined in the font.
C. Presentation forms
Apply feature ‘ccmp’ to substitute glyph composition/decomposition glyph forms
Apply feature ‘rlig’ to substitute required ligature glyph forms
Apply feature ‘liga’ to substitute standard ligature glyph forms
Apply feature ‘clig’ to substitute contextual ligature glyph forms
•Apply feature ‘calt’ to substitute contextual alternate glyph forms

Apply OpenType GPOS features
The shaping engine next processes the GPOS (glyph positioning) table, applying
features concerned with positioning. All features are applied simultaneously to the
entire run.
The font developer must consider the effects of re-ordering when creating the GPOS
feature and lookup tables.
D. Kerning
Apply feature ‘dist’ to make any required distance adjustments

Apply feature ‘kern’ to provide pair kerning between glyphs for better typographic
quality. Note this feature may be disabled by some applications
E. Mark Placement
Apply feature ‘mark’ to position diacritic glyphs relative to the base glyph
Apply feature ‘mkmk’ to position diacritic glyphs relative to each other

Features of the Buginese Script
The features listed below have been defined to create the basic forms for languages that
use the Buginese script. Regardless of the model an application chooses for supporting
layout of complex scripts, Uniscribe requires a fixed order for executing localized and
basic shaping form features within a run of text to consistently obtain the proper basic
form. This is achieved by calling features one-by-one in the standard order listed below.
The order of the lookups within each feature is also very important. For more
information on lookups and defining features in OpenType fonts, see Encoding feature
information in the OpenType font development section.
The standard order for applying Buginese features encoded in OpenType fonts:
Feature

Feature function

Layout
operation

Required

Localized forms
locl

GSUB

Presentation forms
ccmp

Glyph composition/decomposition

GSUB

X

rlig

Required ligatures

GSUB

X

liga

Standard ligatures

GSUB

clig

Contextual ligatures

GSUB

calt

Contextual alternates

GSUB

kern

Pair kerning

GPOS

dist

Distance adjustments

GPOS

Kerning

Mark placement

X

mark

Mark positioning

GPOS

X

mkmk

Mark to mark positioning

GPOS

X

[GSUB = glyph substitution, GPOS = glyph positioning]

Feature examples
The registered features described and illustrated in this document are based on the
Microsoft OpenType font Leelawadee UI (LeelawUI.ttf). Leelawadee UI contains layout
information and glyphs to support all of the required features of the Buginese script.
The illustrations in the following examples show the result of that particular feature
being applied. Features must be written to match glyph sequences after re-ordering has
occurred. Note that the input context for a feature may be the result of a previous
feature having already been applied.

Localized forms
Feature Tag: “locl”
This feature is used in association with OpenType language system tags to trigger
lookups that will select alternate glyphs needed for language-specific typographic
conventions. The ‘locl’ should not be used in association with the default language
system, but only used with other language system tags. See the Appendix of this
document for language system tags associated with the Buginese script.

Presentation forms
Feature Tag: “ccmp”
This feature may be used to do glyph composition and decompositions. The Leelawadee
UI font does not use this feature.

Feature Tag: “rlig”
This feature may be used to form required ligatures. The Leelawadee UI font uses this
feature to form the iya ligature.

Feature Tag: “liga”
This feature may be used to form standard ligatures. The Leelawadee UI font does not
use this feature.

Feature Tag: “clig”
This feature may be used to form contextual ligatures. The Leelawadee UI font does not
use this feature.

Feature Tag: “calt”
This feature may be used to substitute contextual alternates. The Leelawadee UI font
does not use this feature.

Kerning
Feature Tag: “kern”
This feature may be used to adjust the positioning of glyph pairs. The Leelawadee UI
font does not use this feature.

Feature Tag: “dist”
This feature may be used to adjust distances. The Leelawadee UI font does not use this
feature.

Note that mark glyphs have their width set to zero by OTLS. If a mark glyph must have
width, it is necessary to add back lost width for correct display. The dist feature is a
required feature and should be used for this purpose as well as other required distance
adjustments.

Mark placement
Feature Tag: “mark”
This feature is used to position marks relative to a base glyph. The Leelawadee UI font
uses this feature to position above and below marks on bases.

Note that the mark feature is a required feature and will always be triggered by the
shaping engine.

Feature Tag: “mkmk”
This feature is used to position marks relative to each other. The Leelawadee UI font
uses this feature to position a sequence of below-base marks.

Note that the mkmk feature is a required feature and will always be triggered by the
shaping engine.

Other encoding issues
Handling invalid combining marks
Combining marks and signs that do not occur in conjunction with a valid base are
considered invalid. Shaping engine implementations may adopt different strategies for
how invalid marks are handled. For example, a shaping engine implementation might
treat an invalid mark as a separate cluster and display the stand-alone mark positioned
on some default base glyph, such as a dotted circle (U+25CC). (See Fallback Rendering
in section 5.13 of the Unicode Standard 4.0.) Shaping engine implementations may vary
somewhat with regard to what sequences are or are not considered valid. For instance,
some implementations may impose a limit of at most one above-base vowel mark while
others may not.
To allow for shaping engine implementations that expect to position an invalid mark on
a dotted circle, it is recommended that a Buginese OT font contain a glyph for the
dotted circle character, U+25CC, and that appropriate mark positioning lookups are
written to position marks relative to it. If this character is not supported in the font, such
implementations will display invalid signs on the missing glyph shape (white box).

Recommended Glyphs
Unicode code points that are strongly recommended for inclusion in any Buginese font
are:
Code
point

Description

U+200B

Zero Width Space

U+200C

Zero Width Non-Joiner

U+200D

Zero Width Joiner

U+25CC

Dotted Circle

U+00A0

No-break space

U+00D7

Multiplication sign

U+2012

Figure dash

U+2013

En dash

U+2014

Em dash

U+2015

Horizontal bar

U+2022

Bullet

U+25FB

White medium square

U+25FC

Black medium square

U+25FD

White medium small square

U+25FE

Black medium small square

These glyphs may be used in text as generic bases and so should be enabled in mark
positioning lookups supported by the font.

Appendix
Writing system and language tags
Features are encoded according to both a designated script and language system. The
language system tag specifies a typographic convention associated with a language or

linguistic subgroup. For example, there are different language systems defined for the
Buginese script: Buginese, Makasar, and Mandar.
Not all software applications support specific language tags for use when rendering text
runs.
NOTE: It is strongly recommended to include the “dflt” language tag in all OpenType
fonts because it defines the basic script handling for a font. The “dflt” language system
is used as the default if no other language specific features are defined or if the
application does not support that particular language. If the “dflt” tag is not present for
the script being used, the font may not work in some applications.
The following tables list the registered tag names for scripts and language systems.
Registered tags for the Buginese script

Registered tags for Buginese language
systems

Script tag

Script

Language

Language

system tag
“bugi”

Buginese

“dflt”

*default script handling

BUG

Bugis

MKR

Makasar

MDR

Mandar

Note: both the script and language tags are case sensitive (script tags should be
lowercase, language tags are all caps) and must contain four characters (ie. you must
add a space to the three character language tags).

Developing OpenType Fonts for Korean
Hangul Script
Article • 06/16/2022

This document presents information that will help font developers create or support
OpenType fonts for the Korean Hangul script covered by the Unicode Standard.

Introduction
The Korean Hangul script is a 'syllabic' script. The syllables are formed by combining
sequences of elemental, alphabetic consonants and vowels. The process of composing
syllables is additive in nature and follows a set of predefined rules. The glyph elements
of each composed syllable are shaped and positioned into a square display cell, often
referred to as a 'syllable block', or 'syllable glyph'.
The Unicode Standard provides encodings for pre-composed Hangul syllables known as
'Modern Hangul', as well as encodings for individual Hangul alphabetic elements, called
'Jamo' and known as 'Old Hangul'. 'Modern Hangul' has 11,172 pre-composed
characters in the Unicode range U+AC00 through U+D7AF. 'Old Hangul' syllables can be
composed from the individual Hangul Jamos encoded in the Unicode Hangul Jamo
block (U+1100 through U+11FF). More specifically, only certain sequences of these
Jamo characters can combine to form Old Hangul syllables. These sequences are
defined in Appendix B. Only sequences defined in Appendix B will result in formation of
Old Hangul syllables. Sequences of character codes from the Hangul Jamo Block that do
not match any sequence pattern in Appendix B, will be considered as a sequence of
individual non-Old Hangul characters.

In this specification, font developers will learn how to address Old Hangul syllable
formation, encode complex script features in their fonts, choose character sets, organize
font information, and use existing tools to produce Old Hangul fonts. Registered
features of the Korean Hangul script are defined and illustrated, encodings are listed,

and templates are included for compiling Korean Hangul layout tables for OpenType
fonts.
This document also presents information about the Korean OpenType shaping engine of
Uniscribe, the Windows component responsible for text layout.
In addition to being a primer and specification for the creation and support of Hangul
fonts, this document is intended to more broadly illustrate the OpenType Layout
architecture, feature schemes, and operating system support for shaping and
positioning text.

Glossary
The following terms are useful for understanding the layout features and script rules
discussed in this document.
Jamo - Individual Hangul alphabetic elements or atomic unit in a syllable. Consonants
and vowels are both known as Jamos.
Consonant - Represents a single consonant sound. Consonants are further divided into
leading consonants and trailing consonants.
Leading consonant (Leading Jamo) "Choseong" - the syllable initial character
Trailing Consonant (Trailing Jamo) "Jongseong" - the syllable final character
Vowel (Vowel Jamo) "Jungseong" - A phoneme; an independent unit in a syllable. It does
not combine with any consonant to result in the transformation of any consonant-vowel
combination.

Notation
The following notation is used in this document to illustrate layout operations:
L – Leading consonant
V – Vowel
T – Trailing consonant
S – Syllable
X – Non-Jamo character
{ } – Indicates 0, 1 or multiple occurrence

[ ] – Indicates 0 or 1 occurrence
() – Indicates 1 or multiple occurrence

Shaping Engine
Compose Old Hangul Jamo Combinations
Analyze the Syllables
Shape Glyphs with OTLS
Handling Invalid Combining Marks
The Uniscribe Korean shaping engine processes text in stages. The stages are:
1. Compose Old Hangul Jamo combinations
2. Identify syllable boundaries with OTLS
3. Analyze the syllables
4. Shape glyphs with OTLS (OpenType Library Services)
The descriptions which follow will help font developers understand the rationale for the
Korean Hangul feature encoding model, and help application developers better
understand how layout clients can divide responsibilities with operating system
functions.

Compose Old Hangul Jamo combinations
The shaping engine receives a sequence of characters (character run), which have been
identified into sequences of leading consonant (L), vowel (V) and trailing consonant (T)
Jamos. In each of these sequences, the shaping engine identifies the maximum length of
characters which can combine to form registered Jamos. This is done according to the
list of standard character combinations in Appendix B.
Next, it replaces these with the corresponding old Hangul Jamo. This process is repeated
on the next longest string in the sequence. This process of identification and
replacement is repeated for all sequences.
The result of this process is a string of registered Old Hangul Jamos like the example
below:

V1L1L2L3V2V3T1T2T3L4L5V4T4V5V6L6V7
---> V1L1(L2L3)V2V3(T1T2T3)L4L5V4T4(V5V6)L6V7
---> V1L1(L23)V2V3(T123)L4L5V4T4(V56)L6V7

Analyze the Syllables
The syllable unit that the shaping engine receives for the purpose of shaping is a string
of Unicode characters, in a sequence. Since each Hangul syllable has the canonical
format of LVT, fillers Lf and Vf, are then added, where required, in the registered Jamo
sequence to convert each of them to canonical form. The shaping engine then flags
each of these for appropriate feature processing. OTLS will then be called to perform
OpenType layout processing for each syllable in turn.
It is important to note that if any of the Jamo sequences being analyzed is capable of
forming a Modern Hangul Syllable, the shaping engine does not apply OpenType
features to shape them. Composition of Modern Hangul syllables is expected to be
done using the pre-composed section (U+AC00 – U+D7AF), as described in the Unicode
Standard.

Shaping with OTLS
The first step Uniscribe takes in shaping the character string is to map all characters to
their nominal form glyphs.
Next, Uniscribe calls the OTL Services Library to shape the Old Hangul syllable. All OTL
processing is divided into a set of predefined features (described and illustrated in the
Features section of this document). Each feature is applied, one by one, to the
appropriate glyphs in the syllable and OTLS processes them. Uniscribe makes as many
calls to the OTL Services as there are features. This ensures that the features are
executed in the desired order.
The steps of the shaping process are outlined below.

Shaping features:
1. Language forms
a. Apply feature 'ccmp' to preprocess any glyphs that require composition
b. Apply feature 'ljmo' to get the leading consonant Jamo
c. Apply feature 'vjmo' to get the vowel Jamo
d. Apply feature 'tjmo' to get the trailing consonant Jamo

Handling Invalid Combining Marks
Combining marks and signs that appear in text not in conjunction with a valid
consonant base are considered invalid. When an invalid combination of letters is

encountered, Uniscribe simply starts a new syllable/cluster.
Please note that to render a sign standalone (in apparent isolation from any base) one
should apply it on a space (see section 2.5 'Combining Marks' of Unicode Standard 3.1).
Uniscribe requires a ZWJ to be placed between the space and a mark for them to
combine into a standalone sign.

While not required for OpenType functionality, inclusion of the ZWJ (zero width joiner;
U+200C), the ZWNJ (zero width non-joiner; U+200D) and the ZWSP (zero width space;
U+200B) are recommended for inclusion in Korean Hangul fonts.

Features
The features listed below have been defined to create the basic forms for the languages
that are supported on Korean Hangul systems. Regardless of the model an application
chooses for supporting layout of complex scripts, Uniscribe requires a fixed order for
executing features within a run of text to consistently obtain the proper basic form. This
is achieved by calling features one-by-one in the standard order listed below.
The order of the lookups within each feature is also very important. For more
information on lookups and defining features in OpenType fonts, see the Encoding
section of the OpenType Development document.
The standard order for applying Korean Hangul features encoded in OpenType fonts:
Feature

Feature function

Layout
operation

Required

Language based forms:
ccmp

Character composition/decomposition substitution

GSUB

ljmo

Leading consonant Jamo

GSUB

X

vjmo

Vowel Jamo

GSUB

X

tjmo

Trailing consonant Jamo

GSUB

X

[GSUB = glyph substitution, GPOS = glyph positioning]

Descriptions and examples of above features
Character composition (and decomposition)
Feature Tag: "ccmp"
The 'ccmp' feature is used to compose a number of glyphs into one glyph (GSUB lookup
type 4). This feature is implemented before any other features because there may be
times when a font vender wants to control certain shaping of glyphs.
This feature permits the composition of Old Hangul Jamos corresponding to sequences
described in Appendix B. To compose Old Hangul syllables, these Jamo glyphs are then
substituted to the appropriate form using the 'ljmo', 'vjmo' and 'tjmo' features. The
'ccmp' feature should be implemented before any other feature, so that these actions
are given topmost priority. It is applicable to each of: Leading, Vowel and Trailing Jamo
sequences.
For example: the below sequence (U1107 + U1109 + U1110) of leading Jamos
composed with the 'ccmp' feature.

Leading consonant Jamo
Feature Tag: "ljmo"
The 'ljmo' feature is used to substitute the correct shape of a leading consonant Jamo
for a Hangul syllable. The shaping of leading consonant Jamos is context based and
depends on whether the leading Jamo is followed by a vowel Jamo alone or a sequence
of vowel and trailing Jamo.
For example: the leading Jamo (U1113) is replaced by the correct leading form when
followed by a vowel Jamo alone.

Vowel Jamo
Feature Tag: "vjmo"
The 'vjmo' feature is used to substitute the correct shape of a vowel Jamo for a Hangul
syllable. The shaping of vowel Jamos is context based and depends on whether it is
preceded by a leading Jamo alone, or a leading Jamo and followed by a trailing Jamo.
For example: the Hangul vowel Jungseong AE (U1162) is replaced by the correct form
when preceded by a leading Jamo alone.

Trailing consonant Jamo
Feature Tag: "tjmo"
The 'tjmo' feature is used to substitute the correct shape of a trailing consonant Jamo
for a Hangul syllable. The shaping of trailing consonant Jamos is context based and
depends on whether the trailing Jamo is preceded by a leading Jamo filler and vowel
Jamo or by a leading Jamo and vowel Jamo.
For example: U11C7 is replaced by the correct trailing consonant when preceded by a
leading Jamo and vowel Jamo.

More Examples
1. Old Hangul Jamo containing leading consonants, vowels and trailing Jamos.
Input sequence: This sequence consists of: Choseong Pieup, Choseong Sios, Choseong
Thieuth, Jungseong O, Jungseong Ya, Jungseong I, Jongseong Rieul, Jongseong Mieum,
Jongseong Hieuh.

'ccmp' feature applied:

'ljmo', 'vjmo' and 'tjmo' features applied:

2. Leading consonant Jamo + vowel Jamo + trailing Jamo.
Input sequence: This sequence consists of: Choseong Ssangkiyeok, Jungseong A,
Jongseong Nieun-Sios.

'ljmo', 'vjmo' and 'tjmo' features applied:

3. Leading consonant Jamo + vowel Jamo
Input sequence: This sequence consists of: Choseong Nieun-Kiyeok, Jungseong Ae.

'ljmo' and 'vjmo' features applied:

Appendices
Appendix A: Writing System Tags
Appendix B: Standard Composition for Old Hangul Jamos

Appendix A: Writing System Tags
Features are encoded according to both a designated script and language system. The
language system tag specifies a typographic convention associated with a language or
linguistic subgroup.
Currently, the Uniscribe engine only supports the "default" language for each script.
However, font developers may want to build language specific features which are
supported in other applications and will be supported in future Microsoft OpenType
implementations.

NOTE: It is strongly recommended to include the "dflt" language tag in all
OpenType fonts because it defines the basic script handling for a font. The "dflt"
language system is used as the default if no other language specific features are
defined or if the application does not support that particular language. If the "dflt"
tag is not present for the script being used, the font may not work in some
applications.
The following tables list the registered tag names for scripts and language systems.
Registered tags for the Korean Hangul script

Registered tags for Korean Hangul language
systems

Script tag

Script

Language
system tag

Language

"hang"

Korean Hangul

"dflt"

*default script handling

"KOR "

Korean

Note: both the script and language tags are case sensitive (script tags should be
lowercase, language tags are all caps) and must contain four characters (ie. you must
add a space to the three character language tags).

Appendix B: Standard Composition for Old
Hangul Jamos
Leading Consonants
Code point
U+115F
U+1100
U+1101
U+1102
U+1113
U+1114
U+1115

Glyph

Code point

Glyph

Code point

Glyph

U+1116
U+1102

+

U+1109

U+1102

+

U+110C

U+1102

+

U+1112

U+1103

+

U+1105

U+1103

+

U+1106

U+1103

+

U+1107

U+1103

+

U+1109

U+1103

+

U+110C

U+1105

+

U+1100

U+1105

+

U+1100

U+1105

+

U+1103

U+1105

+

U+1103

+

U+1106

U+1103
U+1117
U+1104

U+1105

+

U+1100

+

U+1103

U+1118

U+1119
U+1105

U+1105

+

U+1107

U+1105

+

U+1107

U+1105

+

U+112B

U+1105

+

U+1109

U+1105

+

U+110C

U+1105

+

U+110F

U+1106

+

U+1100

U+1106

+

U+1103

+

U+1109

U+111A
U+111B
U+1106

U+111C
U+1106
U+111D
U+1107
U+111E
U+111F
U+1120
U+1108
U+1121

+

U+1107

U+1122
U+1123
U+1124
U+1125
U+1126
U+1107

+

U+1109

+

U+110F

+

U+1112

U+1127
U+1128
U+1107
U+1129
U+112A
U+1107
U+112B
U+112C
U+1109
U+112D
U+112E
U+112F
U+1130
U+1131

+

U+1110

U+1132
U+1133
U+110A
U+1109
U+1134
U+1135
U+1136
U+1137
U+1138
U+1139
U+113A
U+113B
U+113C
U+113D
U+113E
U+113F
U+1140
U+110B
U+1141
U+1142

+

U+1109

+

U+1107

U+110B

+

U+1105

+

U+1112

+

U+110C

U+1143
U+1144
U+1145
U+1146
U+1147
U+1148
U+1149
U+114A
U+114B
U+110B
U+114C
U+110C
U+114D
U+110D
U+110C
U+114E
U+114F
U+1150
U+1151

+

U+1112

U+110E
U+1152
U+1153
U+1154
U+1155
U+110F
U+1110
U+1110

+

U+1110

+

U+1112

+

U+1109

+

U+1159

U+1111
U+1156
U+1111
U+1157
U+1112
U+1112
U+1158
U+1159
U+1159

Vowels
Code point
U+1160
U+1161

Glyph

Code point

Glyph

Code point

Glyph

U+1176
U+1177
U+1161

+

U+1173

+

U+116E

+

U+1163

U+1162
U+1163
U+1178
U+1179
U+1163
U+1164
U+1165
U+117A
U+117B
U+117C
U+1166
U+1167
U+1167
U+117D
U+117E
U+1168

U+1169
U+116A
U+116B
U+1169

+

U+1163

U+1169

+

U+1163

+

U+1167

+

U+1169

U+116D

+

U+1161

U+116D

+

U+1161

+

U+1165

+

U+1175

+

U+1175

+

U+1175

U+117F
U+1180
U+1169
U+1181
U+1182
U+1169
U+1183
U+116C
U+116D

U+1184
U+1185
U+116D
U+1186

U+1187
U+1188
U+116E
U+1189
U+118A
U+116F
U+118B
U+1170
U+116E

+

U+1167

+

U+1175

+

U+1175

+

U+1161

+

U+1175

U+118C
U+118D
U+1171
U+116E
U+1172
U+118E
U+1172
U+118F
U+1190
U+1191
U+1192

U+1172

+

U+1169

U+1173

+

U+1161

U+1173

+

U+1165

U+1173

+

U+1165

U+1173

+

U+1169

U+1175

+

U+1175

U+1193
U+1194
U+1173

+

U+1175

U+1163

+

U+1169

+

U+1163

+

U+1175

U+1175

+

U+1167

U+1175

+

U+1167

+

U+1175

U+1195
U+1196
U+1174
U+1197
U+1175
U+1198
U+1199

U+119A

U+1175

+

U+1169

U+1175

+

U+116D

+

U+1172

+

U+1175

+

U+1161

+

U+1165

+

U+1175

+

U+1175

U+119B
U+1175
U+119C
U+1175
U+119D
U+119E
U+119E
U+119F
U+119E
U+11A0
U+11A1
U+11A2

**Trailing Consonants**
Code point

Glyph

Code point

U+11A8
U+11A9
U+11A8
U+11C3

+

U+11AB

Glyph

Code point

Glyph

U+11A8

+

U+11B8

U+11A8

+

U+11BE

U+11A8

+

U+11BF

U+11A8

+

U+11C2

+

U+11AB

+

U+11AF

+

U+11BE

+

U+11AE

U+11AA
U+11C4

U+11AB
U+11C5
U+11AB
U+11C6
U+11AB
U+11C7
U+11C8
U+11AC
U+11AB
U+11C9
U+11AD
U+11AE
U+11CA
U+11AE

U+11AE

+

U+11AE

+

U+11B8

U+11AE

+

U+11B8

U+11AE

+

U+11BA

U+11AE

+

U+11BA

+

U+11A8

U+11AE

+

U+11BD

U+11AE

+

U+11BE

U+11AE

+

U+11C0

+

U+11A8

+

U+11A8

+

U+11A8

+

U+11C2

+

U+11AF

+

U+11BF

U+11CB

U+11AF
U+11B0
U+11AF
U+11CC
U+11AF
U+11CD
U+11CE
U+11CF
U+11D0
U+11AF
U+11B1
U+11D1

U+11D2
U+11AF

+

U+11B7

+

U+11C2

+

U+11B8

+

U+11AE

+

U+11B8

+

U+11C1

+

U+11F0

U+11AF

+

U+11F9

+

U+11C2

U+11AF

+

U+11BC

U+11B2
U+11AF
U+11D3
U+11AF
U+11D4
U+11D5
U+11B3
U+11D6
U+11D7
U+11AF
U+11D8
U+11B4
U+11B5
U+11B6
U+11D9

U+11B7

U+11DA
U+11B7

+

U+11AB

U+11B7

+

U+11AB

+

U+11B7

+

U+11B8

+

U+11BD

+

U+11AE

U+11B8

+

U+11AF

U+11B8

+

U+11B7

U+11B8

+

U+11B8

+

U+11AB

+

U+11BA

+

U+11C1

U+11DB
U+11B7
U+11DC
U+11B7
U+11DD
U+11DE
U+11DF
U+11B7
U+11E0
U+11E1
U+11E2
U+11B8
U+11B8
U+11E3

U+11B9
U+11B8

+

U+11BA

+

U+11AE

U+11B8

+

U+11BD

U+11B8

+

U+11BE

+

U+11B7

+

U+11E6

U+11BA

+

U+11BA

+

U+11A8

U+11BA

+

U+11BA

+

U+11AE

U+11BA

+

U+11EB

U+11BA

+

U+11BD

U+11BA

+

U+11BE

U+11E4
U+11E5
U+11E6

U+11BA
U+11E7
U+11E8
U+11E9
U+11BA
U+11EA
U+11BA

U+11BB

U+11BA

+

U+11C0

U+11BA

+

U+11C2

U+11EB

+

U+11B8

U+11EB

+

U+11E6

U+11BC

+

U+11B7

U+11BC

+

U+11BA

+

U+11C2

+

U+11A8

U+11F0

+

U+11BF

U+11F0

+

U+11C2

U+11EB

U+11BC
U+11EC
U+11ED

U+11EE
U+11EF
U+11BC
U+11F0
U+11F0
U+11F1
U+11F2

U+11BD

U+11BD

+

U+11B8

U+11BD

+

U+11B8

U+11BD

+

U+11BD

U+11C1

+

U+11BA

U+11C1

+

U+11C0

U+11BE
U+11BF
U+11C0
U+11C1
U+11F3

U+11F4
U+11C2
U+11F5
U+11F6
U+11F7
U+11F8
U+11F9

+

U+11B8

Developing OpenType Fonts for Hebrew
Script
Article • 06/11/2022

This document presents information that will help font developers create or support
OpenType fonts for all Hebrew script languages covered by the Unicode Standard.

Introduction
In this specification, font developers will learn how to encode complex script features in
their fonts, choose character sets, organize font information, and use existing tools to
produce Hebrew fonts. Registered features of the Hebrew script are defined and
illustrated, encodings are listed, and templates are included for compiling Hebrew
layout tables for OpenType fonts.
This document also presents information about the Hebrew OpenType shaping engine
of Uniscribe, the Windows component responsible for text layout.
In addition to being a primer and specification for the creation and support of Hebrew
fonts, this document is intended to more broadly illustrate the OpenType Layout
architecture, feature schemes, and operating system support for shaping and
positioning text.

Glossary
The following terms are useful for understanding the layout features and script rules
discussed in this document.
Base Glyph - Any glyph that can carry one or more combining marks, typically above,
below or, in the case of the dagesh mark, within the base glyph shape. Layout
operations are defined in terms of a base /glyph/, not a base /character/, as a ligature
may act as a base glyph.
Cantillation Mark (Teamin) – A feature of Masoretic Bible text, these marks are
positioned above or below a base glyph as a guide to the correct chanting of the text
during liturgical worship. The correct position of the cantillation marks is frequently
influenced by that of other diacritic marks, and should be be handled contextually by
the font.

Character - Each character represents a Unicode character code point. For example the
'‫ 'א‬is the Alef character is U+05D0. A character may have multiple forms of glyphs.
Diacritic Mark (Nikud) - A combining mark character that is applied to a base character
to provide pronunciation guidance. In Hebrew, most diacritic marks are optional in most
circumstances, and are omitted in most text. When they occur, they need to be correctly
positioned relative to the base character. Typographic conventions may vary slightly
between biblical and modern Hebrew. Most diacritic marks are vowel signs and all but
one of are positioned below the base. In addition to these vowel signs, there are three
consonant markers: the dagesh, shin and sin dots. A base character may carry both a
consonant marker and a vowel sign, and in biblical text may also carry a cantillation
mark.
Glyph - A glyph represents a form of one or more characters.
Note: The Unicode Hebrew block contains the Tiberian (Palestinian) vowel system, which
has been the standard for western Judaism for many centuries. There are other ancient
vowel systems, the most important of which is the Babylonian system which has not yet
been encoded.

Shaping Engine
Analyzing the Characters
Shaping with OTLS
Positioning Glyphs with OTLS
Handling Invalid Combining Marks
The Uniscribe Hebrew shaping engine processes text in stages. The stages are:
1. Shaping (substituting) glyphs with OTLS (OpenType Library Services)
2. Positioning glyphs with OTLS
The descriptions which follow will help font developers understand the rationale for the
Hebrew feature encoding model, and help application developers better understand
how layout clients can divide responsibilities with operating system functions.

Analyzing the Characters
The unit that the shaping engine receives for the purpose of shaping is a string of
Unicode characters, in a sequence. The contextual analysis engine verifies valid diacritic
combinations. For additional information, see Handling Invalid Combining Marks, later
on in this document.

Shaping with OTLS
The first step Uniscribe takes in shaping the character string is to map all characters to
their nominal form glyphs.
Next, Uniscribe calls OTLS to apply the features. All OTL processing is divided into a set
of predefined features (described and illustrated in the Features section of this
document). Each feature is applied, one by one, to the appropriate glyphs in the syllable
and OTLS processes them. Uniscribe makes as many calls to the OTL Services as there
are features. This ensures that the features are executed in the desired order.
The steps of the shaping process are outlined below. Not all of the features listed apply
to all Hebrew script languages.

Shaping features:
1. Language forms
a. Apply feature 'ccmp' to preprocess any glyphs that require composition or
decomposition. For example, the 'sin dot' and 'shin dot' are only used with the
'SHIN', therefore a dotted circle would be inserted for the 'sin/shin dot' to sit on
if the base is not a 'SHIN'.
2. Typographical forms
a. Apply feature 'dlig' to compose any discretionary ligatures

Positioning glyphs with OTLS
Uniscribe next applies features concerned with positioning, calling functions of OTLS to
position glyphs.

Positioning features:
1. Kerning
a. Apply feature 'kern' to provide pair kerning between base glyphs requiring
adjustment for better typographical quality
2. Mark to base
a. Apply feature 'mark' to position diacritic glyphs to the base glyph

Handling Invalid Combining Marks

Combining marks and signs that appear in text not in conjunction with a valid
consonant base are considered invalid. Uniscribe displays these marks using the fallback
rendering mechanism defined in the Unicode Standard (section 5.12, 'Rendering NonSpacing Marks' of the Unicode Standard 3.1), i.e. positioned on a dotted circle.
For the fallback mechanism to work properly, a Hebrew OTL font should contain a glyph
for the dotted circle (U+25CC). In case this glyph is missing form the font, the invalid
signs will be displayed on the missing glyph shape (white box).
In addition to the 'dotted circle,' other Unicode code points that are recommended for
inclusion in any Hebrew font are: LTR (left to right mark; U+200E), and RTL (right to left
mark; U+200F).

If an invalid combination is found, like two 'nikuds' on the same base character, the
diacritic that causes the invalid state is placed on a dotted circle to indicate to the user
the invalid combination. The shaping engine for non-OpenType fonts will cause invalid
mark combinations to overstrike. This is the problem that inserting the dotted circle for
the invalid base solves. It should also be noted that the dotted circle is not inserted into
the application's backing store. This is a run-time insertion into the glyph array that is
returned from the ScriptShape function.
The invalid diacritic logic for Hebrew is based on the classes listed below. There is a
check to make sure more than one mark of a class is not placed on the same base.
ﾉ

Expand table

Class

Description

Code points

DIAC

Hebrew diacritic

U+05B0 - U+05B6, U+05BB

CANT1

Hebrew cantilation - above left

U+0599, U+05A1, U+05A9,
U+05AE

CANT2

Hebrew cantilation - above center left

U+0597, U+05A8, U+05AC

CANT3

Hebrew cantilation - above center

U+0592 - U+0595, U+05A7,
U+05AB

CANT4

Hebrew cantilation - above center right

U+0598, u+059C, U+059E,
U+059F

CANT5

Hebrew cantilation - above right

U+059D, U+05A0

CANT6

Hebrew cantilation - below left

U+059B, U+05A5

CANT7

Hebrew cantilation - below center left

U+0591, U+05A3, U+05A6

CANT8

Hebrew cantilation - below center right

U+0596, U+05A4, U+05AA

CANT9

Hebrew cantilation - below right

U+059A, U+05AD

CANT10

Hebrew cantilation - Masora Circle

U+05AF

DAGESH

Hebrew dagesh/mapiq

U+05BC

DOTABV

Hebrew upper dot

U+05C4

HOLAM

Hebrew holam

U+05B9

METEG

Hebrew Meteg/sof pasuq

U+05BD

PATAH

Hebrew patah

U+05B7

QAMATS

Hebrew shin/sin dot

U+05B8

RAFE

Hebrew Rafe

U+05BF

SHINSIN

Hebrew shin/sin dot

U+05C1, U+05C2

Features
The features listed below have been defined to create the basic forms for the languages
that are supported on Hebrew systems. Regardless of the model an application chooses
for supporting layout of complex scripts, Uniscribe requires a fixed order for executing
features within a run of text to consistently obtain the proper basic form. This is
achieved by calling features one-by-one in the standard order listed below.
The order of the lookups within each feature is also very important. For more
information on lookups and defining features in OpenType fonts, see the Encoding
section of the OpenType Font Development document.
The standard order for applying Hebrew features encoded in OpenType fonts:
Not all of the features listed below apply to all Hebrew script languages.
ﾉ

Feature

Feature function

Expand table

Layout
operation

Required

Language based forms:
ccmp

Character composition/decomposition substitution

GSUB

Typographical forms:
dlig

Discretionary ligature substitution

GSUB

Positioning features:
kern

Pair kerning

GPOS

mark

Mark to base positioning

GPOS

X

[GSUB = glyph substitution, GPOS = glyph positioning]

Descriptions and examples of above features
Character composition (and decomposition)
Feature Tag: "ccmp"
The 'ccmp' feature is used to compose a number of glyphs into one glyph, or
decompose one glyph into a number of glyphs. This feature is implemented before any
other features because there may be times when a font vender wants to control certain
shaping of glyphs. An example of using this table is seen below. The 'ccmp' table maps
default alphabetic forms to both a composed form (essentially a ligature, GSUB lookup
type 4), and decomposed forms (GSUB lookup type 2).

Example; the 'ccmp' feature used to pre-compose the Yiddish ligature 'yod yod patah'.
(uni05F2 + uni05B7 -> uniFB1F)

Discretionary ligatures
Feature Tag: "dlig"
The 'dlig' feature is also used to map glyphs to their optional ligated form. Font
developers should use this table for all ligatures that they want the user to be able to

control by user preference. Uniscribe has a flag that will allow this type of feature to be
deactivated. The 'dlig' feature maps sequences of glyphs to corresponding ligatures
(GSUB lookup type 4). Ligatures with more components must be stored ahead of those
with fewer components in order to be found. See Ordering ligatures in the Encoding
section of the OpenType Font Development document. The set of optional ligatures will
vary by typeface design and script.

Example; the 'dlig' feature used to substitute the alef lamed ligature.

Kerning
Feature Tag: "kern"
The 'kern' feature is used to adjust amount of space between glyphs, generally to
provide optically consistent spacing between glyphs. Although a well-designed typeface
has consistent inter-glyph spacing overall, some glyph combinations require adjustment
for improved legibility. Besides standard adjustment in either horizontal or vertical
direction, this feature can supply size-dependent kerning data via device tables, "crossstream" kerning in the Y text direction, and adjustment of glyph placement independent
of the advance adjustment. Note that this feature would not be used in monospaced
fonts.
The font stores a set of adjustments for pairs of glyphs (GPOS lookup type 2 or 8). These
may be stored as one or more tables matching left and right classes, and/or as
individual pairs. If both forms are used, the classes should be listed last, so as to provide
a means to replace any non-ideal values that may result from the class tables. Additional
adjustments may be provided for larger sets of glyphs (e.g., triplets, quadruplets, etc.) to
overwrite the results of pair kerns in particular combinations. These should precede the
pairs.
It is unlikely that there are many needs for kerning in Hebrew fonts. A few exceptions
may be the use of kerning for adding space to bases with diactitics (Nikud or Teamin) or
for better spacing on handwriting style typefaces. However, this feature is being made
available for the instances that a type designer might want to take advantage of kerning.

Mark to base positioning

Feature Tag: "mark"
The 'mark' feature positions mark glyphs in relation to a base glyph, or a ligature glyph.
This feature may be implemented as a MarkToBase Attachment lookup (GPOS
LookupType = 4) or a MarkToLigature Attachment lookup (GPOS LookupType = 5).
Positioning mark to base using Microsoft VOLT

Appendices
Appendix A: Writing System Tags
Appendix B: VILNA.TTF (sample font)
Appendix C: Suggest Glyphs

Appendix A: Writing System Tags
Features are encoded according to both a designated script and language system. The
language system tag specifies a typographic convention associated with a language or
linguistic subgroup. For example, there are different language systems defined for the
Hebrew script; Hebrew, Judezmo, Yiddish, etc.
Currently, the Uniscribe engine only supports the "default" language for each script.
However, font developers may want to build language specific features which are
supported in other applications and will be supported in future Microsoft OpenType
implementations.

NOTE: It is strongly recommended to include the "dflt" language tag in all
OpenType fonts because it defines the basic script handling for a font. The "dflt"
language system is used as the default if no other language specific features are
defined or if the application does not support that particular language. If the "dflt"
tag is not present for the script being used, the font may not work in some
applications.
The following tables list the registered tag names for scripts and language systems.
ﾉ

Registered tags for the Hebrew script

Expand table

Registered tags for Hebrew language
systems

Script tag

Script

Language
system tag

Language

"hebr"

Hebrew

"dflt"

*default script handling

"IWR "

Hebrew

"JUD "

Ladino

"JII "

Yiddish

Note: both the script and language tags are case sensitive (script tags should be
lowercase, language tags are all caps) and must contain four characters (ie. you must
add a space to the three character language tags).

Appendix B: VILNA.TTF (sample font)
The Guttman Vilna font will be distributed with Microsoft Visual OpenType Layout Tool
(VOLT) and is provided under the terms of the VOLT supplemental files end user license
agreement. It is provided for illustration only, and may not be altered or redistributed.
Guttman Vilna contains layout information and glyphs to support all of the required
features for the languages supported in a Hebrew script. Each font should be designed
as the font creator desires.
Some shaped glyph forms (such as ligatures) have no Unicode encoding. These glyphs
have id's in the font, and applications can access these glyphs by "running" the layout
features which depend on these glyphs. An application can also identify non-Unicode
glyphs contained in the font by traversing the OpenType layout tables, or using the
layout services for purely informational purposes.

Guttman Vilna contains three OpenType Layout tables: GSUB (glyph substitution), GPOS
(glyph positioning), and GDEF (glyph definition, distinguishing base glyphs, ligatures,
classes of mark glyphs, etc.).
Go to the VOLT community web site

to download this sample font. Please be sure to

read the end user license agreement that accompanies the download.

Appendix C: Suggested Glyphs
Hebrew has three cases where the METEG/SOF PASUQ is put between parts of a nikud.
To allow correct display, it is suggested to add the following three glyphs to the font.
The 'ccmp' feature can be used with a Lookup Type 4 to shape the ligated form. These
glyphs do not need Unicode character values assigned.
In addition, Unicode

gives further advice for combinations of meteg and hataf vowels.

６ Collaborate with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide.

Script development specifications
feedback
Script development specifications is an
open source project. Select a link to provide
feedback:
 Open a documentation issue
 Provide product feedback

Developing OpenType Fonts for Bengali
Script
Article • 05/09/2023

Please note: This document reflects the changes made in 2005 recommendations for
Indic-script OpenType font and shaping-engine implementations. While Indic fonts
made according to the earlier recommendations will still function properly in the new
versions of Uniscribe, font developers may choose to update their fonts, particularly if
they wish to avoid certain limitations of the earlier implementation.
This document presents information that will help font developers create or support
OpenType fonts for all Bengali script languages covered by the Unicode Standard. The
Bengali script, closely related to the Devanagari script, is used to write Bengali, Assamese
and Manipuri.

Introduction
This document targets developers implementing Indic shaping behavior compatible
with Microsoft OpenType specification for Indic scripts. It contains information about
terminology, font features and behavior of the Indic shaping engine in regards to the
Bengali script. While it does not contain instructions for creating Bengali fonts, it will
help font developers understand how the Indic shaping engine processes Indic text. In
addition, registered features of the Bengali script are defined and illustrated with
examples.
The new Indic shaping engine allows for variations in typographic conventions, giving a
font developer control over shaping by the choice of designation of glyphs to certain
OpenType features. For example, the location where the reph and pre-pended matra are
re-ordered within a syllable cluster is affected by the presence of a half form. See
illustrations below.
In the example below (Ra + halant + Da+ halant + Ka + I-matra), Ra + halant will form
the reph, but how the Da is classified will determine the position of the reph as well as
the location of the pre-pended matra.

Option 1= The re-ordering behavior of the shaping engine for Bengali where the 'Da'
has a half form; the reph will be positioned on the first main consonant; and the I-matra
will be positioned immediately in front of the "half-form" D(a).
Option 2= If the Da did not have a half form and was NOT listed in the half feature, the
halant-form will display and the shaping engine will treat it as the first main consonant
on which to position the reph. And the I-matra will be positioned immediately in front of
the base (or half-form) preceding it, which in this case is the Ka.

Glossary
The following terms are useful for understanding the layout features and script rules
discussed in this document.
Above-base form of consonants - A variant form of a consonant that appears above
the base glyph. In Bengali, only the consonant Ra has an above-base form, known as
"reph".
Akhand ligatures - Required consonant ligatures that may appear anywhere in the
syllable, and may or may not involve the base glyph. Akhand ligatures have the highest
priority and are formed first; some languages include them in their alphabets. Akhand
ligatures may be displayed in either half- or full-form.
Base glyph - The only consonant or consonant conjunct in the syllable that is written in
its "full" (nominal) form. In Bengali, the last consonant of the syllable (except for
syllables ending with letter "Ra") usually forms the base glyph. In "degenerate" syllables
that have no vowel (last letter of a word), the last consonant in halant form serves as the
base consonant and is mapped as the base glyph. Layout operations are defined in
terms of a base glyph, not a base character, since the base can often be a ligature.
Below-base form of consonants - A variant form of a consonant that appears below the
base glyph. In Bengali, the consonant Ra and Ba have below-base forms. In the glyph
sequence, the below-base form comes after the consonant(s) that form the base glyph.
Below-base forms are represented by a non-spacing mark glyph.

Bengali syllable - Effective orthographic "unit" of Bengali writing systems. Syllables are
composed of consonant letters, independent vowels, and dependant vowels. In a text
sequence, these characters are stored in phonetic order (although they may not be
represented in phonetic order when displayed). Once a syllable is shaped, it is
indivisible. The cursor cannot be positioned within the syllable. Transformations
discussed in this document do not cross syllable boundaries.
Cluster - a group of characters that form an integral unit in Indic scripts, often times a
syllable.
Consonant - Each represents a single consonant sound. Consonants may exist in
different contextual forms and have an inherent vowel (usually, the short vowel "a"). For
example, "Ka" and "Ta", rather than just "K" or "T."
Consonant conjuncts (aka 'conjuncts') - Ligatures of two or more consonants.
Consonant conjuncts may have both full and half forms, or only full forms.
Halant (Virama) - The character used after a consonant to "strip" it of it's inherent
vowel. A halant follows all but the last consonant in every Bengali syllable; a halant also
follows the last consonant if the syllable has no vowel.
NOTE: A syllable containing halant characters may be shaped with no visible halant
signs by using different consonant forms or conjuncts instead.
Halant form of consonants - The form produced by adding the halant (virama) to the
nominal shape. The Halant form is used in syllables that have no vowel or as the half
form when no distinct shape for the half form exists.
Half form of consonants (pre-base form) - A variant form of consonants which appear
to the left of the base consonant, if they do not participate in a ligature. Consonants in
their half form precede the ones forming the base glyph. Bengali has distinctly shaped
half forms for most consonants. If a consonant does not have a distinct shape for the
half form and does not form any ligature, it will be displayed with an explicit Virama
(same shape as the halant form).
Matra (Dependent Vowel) - Used to represent a vowel sound that is not inherent to the
consonant. Dependent vowels are referred to as "matras" in Sanskrit. They are always
depicted in combination with a single consonant, or with a consonant cluster. The
greatest variation among different Indian scripts is found in the rules for attaching
dependent vowels to base characters.
New shaping behavior - Shaping behavior defined in this version of the Indic OpenType
Font Specification. Information in this document relates primarily to the new

implementation model. Old behavior may be mentioned in comments about
compatibility.
Nukta - A combining character that alters the way a preceding consonant (or matra) is
pronounced.
Old shaping behavior - Shaping behavior defined in previous versions of the Indic
OpenType Font Specification.
OpenType layout engine Library responsible for executing OpenType layout features in
a font. In the Microsoft text formatting stack, it is named OTLS (OpenType layout
services).
OpenType tag - 4-byte identifier for script, language system or feature in the font.
Post-base form of consonants - A variant form of a consonant that appears to the right
of the base glyph. A consonant that takes a post-base form is preceded by the
consonant(s) forming the base glyph plus a halant (virama). Post-base forms are usually
spacing glyphs.
Pre-base form of consonants - A variant form of a consonant that appears to the left of
the base glyph. Note that most pre-base consonant forms are logically as well as visually
before the base consonant. Half forms are examples of this kind of pre-base form. In
some scripts, though, a pre-base Ra may logically follow the base consonant (that is, it
follows it phonetically and in the character sequence of the text), even though it is
presented visually before the base. The shaping engine detects such cases dynamically
using the 'pref' feature and re-orders the pre-base-form glyph as needed.
Reph - the above-base form of the letter "Ra" that is used in Bengali when "Ra" is the
first consonant in the syllable and is not the base consonant.
Shaping Engine - code that processes text strings that is aware of language rules.
Split Matra - A matra that is decomposed into pieces for rendering. Usually the different
pieces appear in different positions relative to the base. For instance, part of the matra
may be placed at the beginning of the cluster and another part at the end of the cluster.
Syllable - A single unit of Indic text processing. Shaping of Indic text is performed
independently for each syllable. Process of identifying boundaries of each syllable is
described below.
Vattu - A below-base form of a consonant.

1. Pre-base form
2. The base consonant
3. Above-base form (reph)
4. Post-base (matra)
5. Below-base form (vattu)

Shaping Engine
Analyze the text
Reorder characters
Shape glyph sequences (GSUB processing)
Position glyphs sequences (GPOS processing)
Base elements
Invalid combining marks
Use of ZWJ, ZWNJ and NBSP
The Indic shaping engine processes Bengali text in stages. The stages are:
1. Analyze the text sequence; breaking it into syllable clusters
2. Reorder the characters as necessary
3. Apply OpenType GSUB font features to get the correct glyph shape
4. Apply OpenType GPOS features to position glyphs or marks
The descriptions which follow will help font developers understand the rationale for the
Bengali feature encoding model, and help application developers better understand
how layout clients can divide responsibilities with operating system functions.

Analyze the syllables
Character properties
The shaping engine divides the text into syllable clusters and identifies character
properties.
Character properties are used in parsing syllables and identifying its parts, in

determining proper character or glyph reordering and in OpenType feature application.
Properties for each character are divided into two types: static properties and dynamic
properties.
Static properties define basic characteristics that do not change from font to font:
character type (consonant, matra, vedic sign, etc.) or type of matra reordering. They
differ from script to script, but can't be controlled by font developer.
Dynamic properties are font dependent and are retrieved by the shaping engine as the
font is loaded. These properties affect shaping and reordering behavior.
*Note: in old shaping-engine implementations, all consonant properties were static:
consonants were assumed to have particular conjoining forms. In the new
implementation model, consonant conjoining behavior is a dynamic property.

Retrieving dynamic character properties from Indic fonts
Fonts define dynamic properties for consonants through implementing standard
features. Consonant types (and corresponding feature tags) that the shaping engine
reads from the font are:
Reph 'rphf'
Half forms 'half'
Pre-base-reordering forms of Ra/Rra 'pref'
Below-base forms 'blwf'
Post-base forms 'pstf'
Each of the features above is applied together with 'locl' feature to input sequences
consisting of two characters: for 'rphf' and 'half', features are applied to Consonant +
Halant combinations; for 'pref', 'blwf' and 'pstf', features are applied to Halant +
Consonant combinations. This is done for each consonant. If these two glyphs form a
ligature, with no additional glyphs in context, this means the consonant has the
corresponding form. For instance, if a substitution occurs when the 'half' and 'locl'
features are applied to a sequence Da + Halant, then Da is classified as having a half
form.
Note that a font may be implemented to re-order a Ra to pre-base position only in
certain syllables and display it as a below-base or post-base form otherwise. This means
that the Pre-base-form classification is not mutually exclusive with either Below-baseform or Post-base-form classifications. However, all classifications are determined as
described above using context-free substitutions.

Font-dependent character classification only defines consonant types. Reordering
positions, however, are fixed for each character class.
*Note: for fonts that support the old implementation, all features are applied to
Consonant + Halant sequences.

Indic input processing
The following steps should be repeated while there are characters left in the input
sequence. All shaping operations are done on a syllable-by-syllable basis, independent
from other characters.

Find next syllable in the input
Engine should find the character sequence matching one of the patterns below:
Consonant syllable
{C+[N]+<H+[<ZWNJ|ZWJ>]|<ZWNJ|ZWJ>+H>} +
C+[N]+[A] + [< H+[<ZWNJ|ZWJ>] | {M}+[N]+[H]>]+[SM]+[(VD)]
Vowel-based syllable:
[Ra+H]+V+[N]+[<[<ZWJ|ZWNJ>]+H+C|ZWJ+C>]+[{M}+[N]+[H]]+[SM]+[(VD)]
Stand Alone cluster (at the start of the word only):
[Ra+H]+NBSP+[N]+[<[<ZWJ|ZWNJ>]+H+C>]+[{M}+[N]+[H]]+[SM]+[(VD)]
Where
{}

zero or more occurrences

[]

optional occurrence

<|>

'one of'

()

one or two occurrences

C

consonant

V

independent vowel

N

nukta

H

halant/virama

ZWNJ

zero width non-joiner

ZWJ

zero width joiner

M

matra (up to one of each type: pre-, above-, below- or post- base)

SM

syllable modifier sign

VD

vedic

A

anudatta (U+0952)

NBSP

NO-BREAK SPACE

Identify key positions inside syllable
Syllable structure consists of the following parts:
Reph + HalfConsonant(s) + MainConsonant(s) + BelowBaseConsonant(s) +
PostBaseConsonant(s) + PreBaseReorderingRa + MatrasAndSigns
The consonant parts include all associated halants and nuktas. (For example, an instance
of BelowBaseConsonant consists of a sequence of Halant + Below-base-forming
Consonant.) All parts are optional, except the main consonant.
All parts are shown in the order they would occur within a syllable, with one
qualification: depending on a font implementation, PreBaseReorderingRa may occur
before all BelowBaseConsonants, after BelowBaseConsonants and before
PostBaseConsonants, or after PostBaseConsonants. Also, a font may be implemented to
re-order a Ra to pre-base position only in certain syllables and display it as a belowbase or post-base form otherwise. Thus, final determination of whether an occurrence of
Ra in a specific syllable can be treated as a pre-base reordering Ra can be made only
after the 'pref' feature has been applied to that syllable.
There could be several main consonants in the case where more than one consonant
doesn't have a half-, below-base, post-base or pre-base form. In a case of a cluster
where the first consonant does not have a half form, the shaping engine will recognize it
as the 1st 'full form' and go on to identify the 2nd full form consonant, if there is one.
This information will then be used to determine the reordering behavior of the reph or
any matras, vowel modifiers or stress marks.
All other elements are classified by their position relative to the base: pre-base (half
forms and reordering pre-base Ra forms), below-base, above-base and post-base.

Indic clusters are subject to the following constraints:
Only one reph is allowed per syllable.

Only one pre-base reordering Ra is allowed per syllable.
A nukta can be placed on a consonant, matra or independent vowel. It cannot be
placed on a pre-composed nukta character.
One matra from each positioning class is permitted (exception in the Kannada
script). A composite matra is treated as belonging to all the classes from which its
components belong.
One syllable modifier sign is allowed per cluster.
Vedic signs are combining marks (used for Sanskrit) that should be included in all
Indic scripts.
Danda and Double Danda are punctuation marks that should be included in all
Indic scripts.

Reorder characters
Once the Indic shaping engine has analyzed the cluster as described above, it creates
and manages a buffer of appropriately reordered elements (glyphs) representing the
cluster, according to several rules (described below).
The OpenType lookups in an Indic font must be written to match glyph sequences after
re-ordering has occurred. OpenType fonts should not have substitutions that attempt to
perform the re-ordering. If a font developer attempted to encode such reordering
information in an OpenType font, they would need to add a huge number of many-tomany glyph mappings to cover the general algorithms that a shaping engine will use.
1. Find base consonant: The shaping engine finds the base consonant of the syllable,
using the following algorithm: starting from the end of the syllable, move
backwards until a consonant is found that does not have a below-base or postbase form (post-base forms have to follow below-base forms), or that is not a prebase reordering Ra, or arrive at the first consonant. The consonant stopped at will
be the base.
If the syllable starts with Ra + Halant (in a script that has Reph) and has more
than one consonant, Ra is excluded from candidates for base consonants.
2. Decompose and reorder Matras: Each matra and any syllable modifier sign in the
cluster aremoved to the appropriate position relative to the consonant(s) in the
cluster. The shaping engine decomposes two- or three-part matras into their
constituent parts before any repositioning. Matra characters are classified by which
consonant in a conjunct they have affinity for and are reordered to the following
positions:
Before first half form in the syllable

After subjoined consonants
After post-form consonant
After main consonant (for above marks)
3. Reorder marks to canonical order: Adjacent nukta and halant or nukta and vedic
sign are always repositioned if necessary, so that the nukta is first.
4. Final reordering: After the localized forms and basic shaping forms GSUB features
have been applied (see below), the shaping engine performs some final glyph
reordering before applying all the remaining font features to the entire cluster.
Reorder matras: If a pre-base matra character had been reordered before
applying basic features, the glyph can be moved closer to the main
consonant based on whether half-forms had been formed. Actual position for
the matra is defined as 'after last standalone halant glyph, after initial matra
position and before the main consonant'. If ZWJ or ZWNJ follow this halant,
position is moved after it.
Reorder reph: Reph's original position is always at the beginning of the
syllable, (i.e. it is not reordered at the character reordering stage). However, it
will be reordered according to the basic-forms shaping results. Possible
positions for reph, depending on the script, are; after main, before post-base
consonant forms, and after post-base consonant forms.
a. If reph should be positioned after post-base consonant forms, proceed to
step 5.
b. If the reph repositioning class is not after post-base: target position is after
the first explicit halant glyph between the first post-reph consonant and
last main consonant. If ZWJ or ZWNJ are following this halant, position is
moved after it. If such position is found, this is the target position.
Otherwise, proceed to the next step.
Note: in old-implementation fonts, where classifications were fixed in
shaping engine, there was no case where reph position will be found on this
step.
c. If reph should be repositioned after the main consonant: from the first
consonant not ligated with main, or find the first consonant that is not a
potential pre-base reordering Ra.
d. If reph should be positioned before post-base consonant, find first postbase classified consonant not ligated with main. If no consonant is found,
the target position should be before the first matra, syllable modifier sign
or vedic sign.
e. If no consonant is found in steps 3 or 4, move reph to a position
immediately before the first post-base matra, syllable modifier sign or
vedic sign that has a reordering class after the intended reph position. For

example, if the reordering position for reph is post-main, it will skip abovebase matras that also have a post-main position.
f. Otherwise, reorder reph to the end of the syllable.
Reorder pre-base reordering consonants: If a pre-base reordering consonant is
found, reorder it according to the following rules:
a. Only reorder a glyph produced by substitution during application of the
'pref' feature. (Note that a font may shape a Ra consonant with the 'pref'
feature generally but block it in certain contexts.)
b. Try to find a target position the same way as for pre-base matra. If it is
found, reorder pre-base consonant glyph.
c. If position is not found, reorder immediately before main consonant.

Character reordering Classes for Bengali:
Characters

Reorder Class

09B0, 09F0 (reph)

AfterSubscript

09BF, 09C7, 09C8

BeforeHalf

09C1-09C4, 09E2, 09E3

AfterSubscript

09BE, 09C0, 09D7

AfterPostscript

0981

AfterPostscript

Shape glyph sequences (GSUB processing)
All characters from a string are first mapped to their nominal glyphs using the cmap
lookup. The shaping engine then proceeds to shape (substitute) the glyphs using GSUB
lookups.
The features for localized forms and basic shaping forms are applied one at a time to the
cluster or a relevant portion of the cluster.
The results after basic shaping forms features have been applied impact the final syllable
analysis in terms of final designation of Ra as a pre-base reordering form and final
reordering positions for reph and matras. Next, the features for presentation forms are
applied to the entire cluster simultaneously. Note: since the presentation form features
are applied simultaneously over the entire cluster, several features are operationally
equivalent to a single feature. Multiple features are provided as an aid for font
developers to organize the lookups they implement.

Note: final reordering occurs after features for basic shaping forms have been applied
and before features for presentation forms are applied. Font developers must consider
the effects of initial reordering (before any features are applied) and final reordering
(after basic shaping forms features have applied) when they create GSUB feature and
lookup tables.
These predefined features are described and illustrated in the Features section and are
applied in the order below.

Shaping features:
Localized forms
1. Apply feature 'locl' to select language-specific forms.
Basic Shaping forms
1. Apply feature 'nukt' to substitute nukta forms of consonants.
2. Apply feature 'akhn' to substitute required akhand ligatures, or to substitute forms
that take precedence over forms produced by features applied later.
3. Apply feature 'rphf' to substitute reph glyph (above-base form of 'Ra').
4. Apply feature 'blwf' to substitute below-base forms (ba + ra phala).
5. Apply feature 'half' to substitute half forms of pre-base consonants.
6. Apply feature 'pstf' to substitute post-base forms of consonants.
7. Apply feature 'vatu' to substitute ligature consonant-vattu or conjunct-vattu forms
for sequences of a consonant or conjunct glyph (full or half form) followed by the
below-base mark.
8. Apply feature 'cjct' to substitute conjunct forms. (This is needed particularly for
ligature conjuct forms when the pre-base consonant does not have a half form.)
Presentation forms
1. Apply feature 'init' to substitute initial forms
2. Apply feature 'pres' to substitute pre-base consonant conjuncts and pre-base
matra conjuncts. (ie. consonant and matra conjuncts to the left of the base glyph).
3. Apply feature 'abvs' to substitute above-base matra conjuncts, reph conjuncts,
above-base vowel modifiers and above-base stress and tone marks.
4. Apply feature 'blws' to substitute below-base consonant conjuncts, below-base
matra conjuncts, below-base vowel modifier forms and below-base stress and tone
mark forms.
5. Apply feature 'psts' to substitute post-base consonant conjuncts, post-base matra
conjuncts and post-base vowel modifiers.

6. Apply feature 'haln' to substitute the halant form of base (or conjunct base) glyph
in syllables ending with a halant.
7. Apply feature 'calt' to substitute the contextual alternate of a consonant.

Position glyph sequences (GPOS processing)
The shaping engine next processes the GPOS (glyph positioning) table, applying
features concerned with positioning. All features are applied simultaneously to the
entire cluster.
The font developer must consider the effects of re-ordering when creating the GPOS
feature and lookup tables (i.e., the glyphs will be in the order they were in after the
GSUB presentation forms features were applied).

Positioning features:
Kerning
1. Apply feature 'kern' to adjust distances (e.g., to provide kerning between post- or
pre-base elements and the base glyph).
2. Apply feature 'dist' to adjust distances. (NOTE - the feature 'dist' can be used in the
same way as the 'kern' feature. The advantage of using the 'dist' feature is that it
does not rely on the application to enable kerning. Therefore, if you want to make
sure certain spacing adjustments will always be displayed, you should use the 'dist'
feature).
Above-base marks
1. Apply feature 'abvm' to position above-base marks (above-base consonant forms,
matras, vowel modifiers or stress/tone marks) on base glyphs or post-base matra.
Below-base marks
1. Apply feature 'blwm' to position below-base marks (below-base consonant forms,
matras, vowel modifiers or stress/tone marks) on base glyphs or post-base matra.

Base elements
Commonly, a feature is required for dealing with the base glyph and one of the postbase, pre-base or above-base elements. Since it is not possible to reorder ALL of these
elements next to the base glyph, we need to skip over the elements "in the middle"
(reordering-wise).

The solution is to assign different mark attachment classes to different elements of the
syllable and positional forms, and in any given lookup work with one mark type only. For
example, in above-base substitutions we need only consider above-base elements most
of the time.
Generally, it is good practice to label as "mark" glyphs that are denoted as marks in the
Unicode Standard as well as below-base/above-base forms of consonants. Then,
different attachment classes should be assigned to different marks depending on their
position with respect to the base.
For example, after the shaping engine has re-ordered elements within the cluster,
matras will always occur before syllable modifiers such as the candrabindu. In an actual
sequence, though, potentially some other mark glyph, such as nukta, may occur
between the matra and the candrabindu. Thus, when processing the matra and
candrabindu, you may need to allow for the possibility that some other mark glyphs
may occur between them. Using lookup flags, you can specify that a lookup should
process only a certain class of marks, such as 'above-base marks', and ignore all other
marks. In that way, a match will occur whether or not a mark from another class is
present. Otherwise, the lookup would fail to apply.
Using Microsoft VOLT, you can assign glyphs to attachment classes.
In the example below this 'abvm' feature was set to process only TopMarks, therefore
the presence of another mark class would be ignored. If Process ALL was used and
another mark glyph followed the matra, this positioning lookup would fail to apply. This
example comes from the Devanagari font Mangal.

Invalid combining marks
Combining marks and signs that do not occur in conjunction with a valid base are
considered invalid. Shaping engine implementations may adopt different strategies for
how invalid marks are handled. For example, a shaping engine implementation might
treat an invalid mark as a separate cluster and display the stand-alone mark positioned
on some default base glyph, such as a dotted circle. (See Fallback Rendering in section
5.13 of the Unicode Standard 4.0.) Shaping engine implementations may vary somewhat
with regard to what sequences are or are not considered valid. For instance, some
implementations may impose a limit of at most one above-base vowel mark while
others may not.
To allow for shaping engine implementations that expect to position an invalid mark on
a dotted circle, it is recommended that a Bengali OT font contain a glyph for the dotted
circle character, U+25CC. If this character is not supported in the font, such
implementations will display invalid signs on the missing glyph shape (white box).

In addition to the 'dotted circle' other Unicode code points that are recommended for
inclusion in any Bengali font are the ZWJ (zero width non-joiner; U+200C), the ZWNJ
(zero width joiner; U+200D) and the ZWSP (zero width space; U+200B). For more
information see the Suggested glyphs section of the OpenType Font Development
document.

Effect of ZWJ, ZWNJ and NBSP on Consonant
Shaping
Unicode defines specific behaviors for zwj and zwnj in relation to Indic scripts. The Indicspecific behavior retains the general behavior that zwj requests connection between text
elements while zwnj inhibits connection between text elements.
1. The main intent of using ZWJ in this context is to prevent a ligature-conjunct from
forming (and in Devanagari or Gujuarati, to request a half form, below-base form
or post-base form instead). The Indic engine does not need to take any action to
prevent ligature-conjuct formation: the presence of ZWJ will prevent GSUB
substitution lookups from matching the input glyph sequence. If the first
consonant does not have a half form, an overt-halant form should result, which
would also happen with no particular action by the engine.
2. A secondary intent of using ZWJ in this context is to prevent the display of reph in
the case that the first consonant is RA. If a cluster begins with RA H (halant) ZWJ,
the engine must ensure that the 'rphf' feature is not applied, and that re-ordering
for reph does not take place. Note that use of either joiner in this context should
prevent formation and re-ordering of reph when RA is the first consonant.
3. The main intent of using ZWNJ is to prevent conjunct ligature or half forms from
forming, and to display an explicit halant form instead. The shaping engine must
take specific actions to prevent half forms for a sequence of Consonant + Halant +
ZWNJ.

The following example illustrates these behaviors:

Just as the zwj can be used to display a half form in isolation, it can also be used to
display a mark, sub- or post-base form in isolation. Unlike the stand-alone half form,
however, sequences to display them must begin with a no-break space (NBSP). This is
because marks, sub- and post-base forms have a 'zero-width' so must be placed on the
NBSP. For example, to get a shape of I-matra without the dotted circle one should type
NBSP + I-matra.
In the illustration below the I-matra is displayed without the dotted circle by using the
NBSP.
The combination of NBSP and ZWJ is used to display the below-base form of Ra in
isolation.

Features
The features listed below have been defined to create the basic forms for the languages
that are supported on Bengali systems. Regardless of the model an application chooses
for supporting layout of complex scripts, the shaping engine requires a fixed order for
executing features within a run of text to consistently obtain the proper basic form.
The features of the basic shaping forms are applied one at a time to the cluster or
portion of the cluster. The result impacts the analysis in terms of the conjoining behavior
and final reordering. The features of the presentation forms are applied next, to the
entire cluster simultaneously. Mandatory features must always be applied; the
discretionary presentation-forms features listed should be applied by default, but can be
suppressed by a client (normally at the discretion of the user).

The order of the lookups within each feature is also very important. For more
information on lookups and defining features in OpenType fonts, see the Encoding
section of the OpenType Font Development document.
OpenType features used for Bengali scripts, applied in the following order:
Feature

Feature function

Layout operation

Localized forms:
locl

Localization form substitution

GSUB

Basic shaping forms:
nukt

Nukta form substitution

GSUB

akhn

Akhand ligature substitution

GSUB

rphf

Reph form substitution

GSUB

blwf

Below-base form substitution

GSUB

half

Half-form substitution

GSUB

pstf

Post-base form substitution

GSUB

vatu

Vattu variants

GSUB

cjct

Conjunct form substitution

GSUB

Mandatory presentation forms:
init

Initial form

GSUB

pres

Pre-base substitution

GSUB

abvs

Above-base substitution

GSUB

blws

Below-base substitution

GSUB

psts

Post-base substitution

GSUB

haln

Halant form substitution

GSUB

Discretionary presentation forms:
calt

Contextual alternates

GSUB

Positioning features:
kern

Kerning

GPOS

dist

Distances

GPOS

abvm

Above-base mark positioning

GPOS

blwm

Below-base mark positioning

GPOS

[GSUB = glyph substitution, GPOS = glyph positioning]

Feature examples
Many of the registered features described and illustrated in this document are based on
the Microsoft OpenType font Vrinda. Vrinda contains layout information and glyphs to
support all of the required features for the Bengali script and language systems
supported.
The illustrations in the following examples show the result of that particular feature
being applied. Features must be written to match glyph sequences after re-ordering has
occurred. Note that the input context for a feature may be the result of a previous
feature having already been applied.

Localized forms
Feature Tag: "locl"
This feature is used in association with OpenType language system tags to trigger
lookups that will select alternate glyphs needed for language-specific typographic
conventions. The 'locl' should not be used in association with the default language
system, but only used with other language system tags. See the Appendix of this
document for language system tags associated with the Bengali script.

Basic shaping forms
Nukta
Feature Tag: "nukt"
The nukta alters the way a preceding consonant or vowel is pronounced. The most
common nukta forms have been defined as separate characters in Unicode with their
own code points. All consonants, as well as akhand forms should have an associated
nukta form.
Note - Rather than using substitution, nukta forms can also be created by positioning
the nukta as a below-base mark on the base glyph using the 'blwm' positioning feature.

The input context for the nukt feature always consists of the full form of the consonant.
The half form of nukta consonants will be substituted using the half feature.
Nukta feature used to substitute pre-composed glyph (Yya) for Ya + Nukta:

Akhand
Feature Tag: "akhn"
An akhand is a required consonant ligatures that may appear anywhere in the syllable,
and may or may not involve the base glyph. Akhand ligatures have the highest priority
and are formed first; some languages include them in their alphabets.
The input context for the akhand feature always consists of the full form of the
consonant. The half forms of Akhand ligatures will be called later in the half feature.
Because the akhand feature is applied early in the sequence of features and is applied
over the entire cluster, it can also be used to create certain forms that must take priority
in particular contexts over forms that would be created during subsequent feature
application.
Ka + halant + Ssa is substituted with the KaSsa ligature:

Ja + halant + Nya is substituted with the JaNya ligature:

Reph
Feature Tag: "rphf"
Applying this feature substitutes the Reph glyph. If the first consonant of the cluster
consists of the full form of Ra + Halant, this feature substitutes the combining-mark

form of Reph. In addition, the position of the Reph glyph is adjusted with the 'abvm'
GPOS feature.
The input context for the Reph feature always consists of the full form of Ra + Halant.
Example 1- Reph feature substitutes the mark glyph form of Ra. After final reordering,
positioning is adjusted in the 'abvm' GPOS feature:

Example 2 - Reph feature applied with multiple consonants. Note- reph is re-ordered to
position on the 1st main consonant, not the half-form:

Below form of consonant
Feature Tag: "blwf"
This feature substitutes the below-base forms of Consonants like the Ra + Ba in Bengali,
when they do not form a ligature with the preceding consonant.
Halant + Ra (preceded by a consonant which does not form a ligature) substitutes a
below-base Ra:

Halant + Ba (preceded by a consonant which does not form a ligature) substitutes a
below-base Ba:

Half form of consonant

Feature Tag: "half"
Applying this feature substitutes half forms - forms of consonants used in the pre-base
position. Consonants that have a half form should be listed in the 'half' feature. Bengali
has distinctly shaped half forms for most of the consonants. If a consonant does not
have a distinct shape for the half form and does not form any ligature, it will be
displayed with an explicit Virama (same shape as the halant form).
Note - the result of listing a consonant in the half feature (whether it has a true half
form or not) will affect the re-ordering (and positioning) of the reph and pre-pended
matras. See illustration in the Introduction section of this document.
This feature is applied to all consonants preceding the 'main' consonant.
Half feature substitutes half form of Ka:

Half feature applied to multiple consonants:

Post-base form of consonant
Feature Tag: "pstf"
Applying this feature substitutes post-base forms, such as the 'Bengali Ya'.
The post-base form of the Ya is substituted, when it is the last consonant in a syllable:

Vattu variants
Feature Tag: "vatu"
The 'vatu' feature can be used to substitute a ligature of a full (or half) form consonant
plus a below-base vattu (Bengali ra-phala). The 'blws' can also be used for these ligature

substitutions.
The input context for the 'vatu' feature consists of a consonant (in full or half form) +
vattu glyph.
The 'vatu' feature used to substitute a ligature of Ka + below-base Ra:

The 'vatu' feature used to substitute a ligature of Tta + below-base Ra:

Conjunct forms
Feature Tag: "cjct"
Apply feature 'cjct' to substitute conjunct forms where the first consonant in the
consonant-cluster pair does not have a half form. This feature allows for control over reordering 'Žof reph and pre-pended matras in case of consonants that do not take half
forms yet do form 'Žconjunct ligatures in combination with certain following
consonants.
The 'cjct' feature used to substitute a ligature for Gha + Na:

Presentation forms
After the glyphs have been reordered, the presentation lookups are applied to provide
the best typographic rendering of the text. The features of the presentation forms are
applied to the entire cluster simultaneously, executing lookups within each feature in
the order that they are specified in the font.
The pres, abvs, blws, psts and haln features are all mandatory for software
implementations: they are required for correct script behaviour and none should ever be
treated as discretionary. Because of this and because they are all applied simultaneously

over entire clusters, they are not functionally different: a set of lookups could be divided
between these features or grouped together under one of them with no difference in
effect. These multiple features are provided, however, as an aid to the font developer for
organizing lookups based on the combinations of glyphs they apply to. There are no
specific requirements on how each should be used; the examples provided below
illustrate typical usage, however.

Initial form
Feature Tag: "init"
This feature is used to substitute initial forms of the vowels E and Ai, in Bengali scripts.
The initial form is a glyph variant that does not have a connecting bar on the leading
side of the glyph.
All initial forms must be based on an input context consisting of the full form of
consonants.
Initial feature applied:

Pre-base substitutions
Feature Tag: "pres"
This feature is used to substitute pre-base consonant conjuncts made with half forms,
the type most common in Bengali. The resulting conjunct can be in full or half form.
This feature is also used to select typographically correct forms of the I-Matra. For
example, a font can have several versions of the I-Matra to be used in context with
different consonant bases or clusters. In addition the 'pres' feature can contain precomposed ligatures of the I-matra with certain bases.
Example 1 - half Ka + full Ka is substituted by the KaKa conjunct:

Example 2 - half Ka + full Ma is substituted by the KaMa conjunct:

Example 3 - half La + full Ka is substituted by the LaKa conjunct:

Example 4 - half Ka + half Ssa + full Nna is substituted by the KaSsaNna ligature:

Example 5 - The 'pres' feature is also used to substitute ligatures with the I-Matra:

Above-base substitutions
Feature Tag: "abvs"
This feature is used for substitutions involving above-base marks. Such substitutions
might be used to select contextual forms of marks, to create mark-mark ligatures, or to
create mark-base ligatures. Specific context-dependent forms or below-base consonants
are handled by this lookup as well.
The 'abvs' feature used to substitute a ligature for the reph + matre I combination:

The 'abvs' feature used to substitute a ligature for the reph + candrabindu glyphs:

Below-base substitutions
Feature Tag: "blws"
This feature is used for glyph substitutions involving below-base marks or consonants.
Such substitutions can be used to create conjuncts of base glyphs with below-base
consonants, below mark ligatures or below mark-base ligatures. Specific contextdependent forms are handled by this lookup as well.
Example 1- 'blws' substitution for base + below-base conjuncts:

Example 2- In the presence of below-base consonants, the below-base matra can
change shape in the ligature:

Example 3- 'blws' substitution when conjunct base + matra form a new ligature:

Post-base substitutions
Feature Tag: "psts"
This feature is used to substitute post-base consonants or matras. Such substitutions
can be used to create conjuncts of base glyphs with post-base consonants or post-base
matra ligatures. It can also be used to specify contextual alternates of post-base forms.

Example 1- 'psts' used to substitute conjunct of base and post-base matra:

Example 2- 'psts' used to substitute conjunct of base and post-base matra:

Halant form of consonants
Feature Tag: "haln"
This feature is used to substitute a pre-composed halant form of a base (or conjunct
base) glyph in syllables ending with a halant. (Rather than using substitution, halant
forms can also be created by positioning the halant as a below-base mark on the base
glyph using the 'blwm' positioning feature.)
This feature is applied only on the base glyph if the syllable ends with a halant, or in the
case of non-final consonants that do not take a half form and do not form a conjunct
ligature with the following consonant.
Example 1 - 'haln' feature used to substitute halant form of base glyph:

Example 2 - 'haln' feature used to substitute halant form of conjunct base glyph:

Contextual Alternates
Feature Tag: "calt"
Unlike the previous presentation lookups, the 'calt' feature is optional and is used to
substitute discretionary contextual alternates. It is important to note that an application

may allow users to turn off this feature, therefore should not be used for any obligatory
Bengali typography.

Positioning features
Distances
Feature Tag: "dist"
This feature covers positioning lookups that adjust distances between glyphs, such as
kerning between pre- and post-base elements and the base glyph. Note; the feature
'dist' can be used in the same way as the 'kern' feature. The advantage of using the 'dist'
feature is that it does not rely on the application to enable kerning.

Above-base marks
Feature Tag: "abvm"
This feature positions all above-base marks on the base glyph or the post-base matra.
The best method for encoding this feature in an OpenType font is to use a chaining
context positioning lookup that triggers mark-to-base and mark-to-mark attachments
for above-base marks.
The 'abvm' lookup in MS Volt using 'Anchor Attachment' for adjusting positions of
above-marks over bases:

A contextual 'abvm' lookup in MS Volt using 'Single Adjustment' for positioning
candrabindu over certain bases:

Below-base marks
Feature Tag: "blwm"

This feature positions all below-base marks on the base glyph. The best method for
encoding this feature in an OpenType font is to use a chaining context positioning
lookup that triggers mark-to-base and mark-to-mark attachments for below-base
marks.
The 'blwm' lookup in MS Volt using 'Anchor Attachment' for adjusting positions of
below-marks with bases:

Examples of Bengali syllables
Complex Bengali syllable formation is possible using the wide range of features
available in OpenType. The following examples show how the shaping engine applies
the OpenType features, one at a time to the input string. These combinations do not
necessarily represent actual syllables or words, but are meant to illustrate the various
OpenType features in a Bengali font.

Example #1:

Example #2:

Appendices
Appendix A: Writing System Tags

Appendix A: Writing System Tags
Features are encoded according to both a designated script and language system. There
are different language systems defined for the Assamese, Bengali and Manipuri
languages, although they all use the Bengali script.
Currently most shaping engine implementations only support the "default" language
system for each script. However, font developers may want to build language specific
features which are supported in other applications and will be supported in future
Microsoft OpenType implementations.

NOTE: It is strongly recommended to include the "dflt" language tag in all OpenType
fonts because it defines the basic script handling for a font. The "dflt" language system
is used as the default if no other language specific features are defined, or if the
application does not support that particular language. If the "dflt" tag is not present for
the script being used, the font may not work in some applications.
The following table lists the registered tag names for script and language systems. Note
for new Indic shaping implementation 'bng2' is used (old-behavior implementations
used 'beng').
Registered tags for the Bengali script

Registered tags for Bengali language
systems

Script tag

Script

Language
system tag

Language

"bng2"

Bengali

"dflt"

*default script handling

"ASM "

Assamese

"BEN "

Bangla

"MNI "

Manipuri

Note: both the script and language tags are case sensitive (script tags should be
lowercase, language tags are all caps) and must contain four characters (ie. you must
add a space to the three character language tags).

Developing OpenType Fonts for
Devanagari Script
Article • 06/24/2022

Please note: This document reflects the changes made in 2005 recommendations for
Indic-script OpenType font and shaping-engine implementations. While Indic fonts
made according to the earlier recommendations will still function properly in the new
versions of Uniscribe, font developers may choose to update their fonts, particularly if
they wish to avoid certain limitations of the earlier implementation.
This document presents information that will help font developers create or support
OpenType fonts for all Devanagari script languages covered by the Unicode Standard,
including classical Sanskrit. Other languages written with the Devanagari script include
Hindi, Kashmiri, Konkani, Marathi, Nepali, Sanskrit and Sindhi.

Introduction
This document targets developers implementing Indic shaping behavior compatible
with Microsoft OpenType specification for Indic scripts. It contains information about
terminology, font features and behavior of the Indic shaping engine in regards to the
Devanagari script. While it does not contain instructions for creating Devanagari fonts, it
will help font developers understand how the Indic shaping engine processes Indic text.
In addition, registered features of the Devanagari script are defined and illustrated with
examples.
The new Indic shaping engine allows for variations in typographic conventions, giving a
font developer control over shaping by the choice of designation of glyphs to certain
OpenType features. For example, the location where the reph and pre-pended matra are
re-ordered within a syllable cluster is affected by the presence of a half form. See
illustrations below.
In the example below (Ra + halant + Da+ halant + Ma + I-matra), Ra + halant will form
the reph, but how the Da is classified will determine the position of the reph as well as
the location of the pre-pended matra.

Option 1: While the Da does not have a true half form in Devanagari, it can be listed in
the ‘half’ feature lookup substituting the ‘halant form’ of Da. Thus, the shaping engine
will treat it as a half form and the reph will be positioned on the first main consonant;
and the I-matra will be positioned immediately in front of the “half-form” D(a).
Option 2: By not listing Da in the ‘half’ feature lookup, the halant form will display and
the shaping engine will treat it as the first main consonant on which to position the
reph. And the I-matra will be positioned immediately in front of the base (or half-form)
preceding it, which in this case is the Ma.

Glossary
The following terms are useful for understanding the layout features and script rules
discussed in this document.
Above-base form of consonants - A variant form of a consonant that appears above
the base glyph. In Devanagari, only the consonant Ra has an above-base form, known as
“reph”.
Akhand ligatures - Required consonant ligatures that may appear anywhere in the
syllable and may or may not involve the base glyph. Akhand ligatures have the highest
priority and are formed first; some languages include them in their alphabets. Akhand
ligatures in Devanagari may be displayed in either half- or full-form.
Base glyph - The only consonant or consonant conjunct in the orthographic syllable that
is written in its "full" (nominal) form. In Devanagari, the last consonant of the syllable
(except for syllables ending with letter "Ra") usually forms the base glyph. In
"degenerate" syllables that have no vowel (last letter of a word), the last consonant in
halant form serves as the base consonant and is mapped as the base glyph. Layout
operations are defined in terms of a base glyph, not a base character, since the base can
often be a ligature.

Below-base form of consonants - A variant form of a consonant that appears below the
base glyph. In Devanagari, only the consonant Ra has a below-base form. In the glyph
sequence, the below-base form comes after the consonant(s) that form the base glyph.
Below-base forms are represented by a non-spacing mark glyph.
Cluster - A group of characters that form an integral unit in Indic scripts, often times a
syllable.
Consonant - Each represents a single consonant sound. Consonants may exist in
different contextual forms and have an inherent vowel (usually, the short vowel "a"). For
example, "Ka" and "Ta", rather than just "K" or "T."
Consonant conjuncts (aka 'conjuncts') - Ligatures of two or more consonants.
Consonant conjuncts may have both full and half forms, or only full forms.
Devanagari syllable - Effective orthographic "unit" of Devanagari writing systems.
Syllables are composed of consonant letters, independent vowels and dependant
vowels. In a text sequence, these characters are stored in phonetic order (although they
may not be represented in phonetic order when displayed). Once a syllable is shaped, it
is indivisible. The cursor cannot be positioned within the syllable. Transformations
discussed in this document do not cross syllable boundaries.
Halant (Virama) - The character used after a consonant to "strip" it of it’s inherent
vowel. A halant follows all but the last consonant in every Devanagari syllable; a halant
also follows the last consonant if the syllable has no vowel.
NOTE: A syllable containing halant characters may be shaped with no visible halant
signs by using different consonant forms or conjuncts instead.
Halant form of consonants - The form produced by adding the halant (virama) to the
nominal shape. The Halant form is used in syllables that have no vowel or as the half
form when no distinct shape for the half form exists.
Half form of consonants (pre-base form) - A variant form of consonants which appear
to the left of the base consonant, if they do not participate in a ligature. Consonants in
their half form precede the ones forming the base glyph. Devanagari has distinctly
shaped half forms for most consonants. If a consonant does not have a distinct shape
for the half form and does not form any ligature, it will be displayed with an explicit
Virama (same shape as the halant form).
Matra (Dependent Vowel) - Used to represent a vowel sound that is not inherent to the
consonant. Dependent vowels are referred to as "matras" in Sanskrit. They are always
depicted in combination with a single consonant, or with a consonant cluster. The

greatest variation among different Indian scripts is found in the rules for attaching
dependent vowels to base characters.
New Shaping Behavior - Shaping behavior defined in this version of the Indic OpenType
Font Specification. Information in this document relates primarily to the new
implementation model. Old behavior may be mentioned in comments about
compatibility.
Nukta - A combining character that alters the way a preceding consonant (or matra) is
pronounced.
Old Shaping Behavior - Shaping behavior defined in previous versions of the Indic
OpenType Font Specification.
OpenType Layout engine - Library responsible for executing OpenType layout features
in a font. In the Microsoft text formatting stack, it is named OTLS (OpenType layout
services).
OpenType tag - 4-byte identifier for script, language system or feature in the font.
Post-base form of consonants - A variant form of a consonant that appears to the right
of the base glyph. A consonant that takes a post-base form is preceded by the
consonant(s) forming the base glyph plus a halant (virama). Post-base forms are usually
spacing glyphs.
Pre-base form of consonants - A variant form of a consonant that appears to the left of
the base glyph. Note that most pre-base consonant forms are logically as well as visually
before the base consonant. Half forms are examples of this kind of pre-base form. In
some scripts, though, a pre-base Ra may logically follow the base consonant (that is, it
follows it phonetically and in the character sequence of the text), even though it is
presented visually before the base. The shaping engine detects such cases dynamically
using the 'pref' feature and re-orders the pre-base-form glyph as needed.
Rakaar - The below-base form of "Ra" in Devanagari, which forms a ligature with most
preceding consonant(s). If the preceding consonant has a half form, then the consonantrakaar combination, typically also has a half form.
Reph - The above-base form of the letter "Ra" that is used in Devanagari when "Ra" is
the first consonant in the syllable and is not the base consonant.
Shaping Engine - Code responsible for shaping input, classified to a particular script.
Split Matra - A matra that is decomposed into pieces for rendering. Usually the different
pieces appear in different positions relative to the base. For instance, part of the matra
may be placed at the beginning of the cluster and another part at the end of the cluster.

Syllable - A single unit of Indic text processing. Shaping of Indic text is performed
independently for each syllable. Process of identifying boundaries of each syllable is
described below.
Vattu (Rakar) - A below-base form of a consonant. In Devanagari, "Ra" can take a vattu
form within a cluster; this "Vattu-Ra" is also known as Rakaar.

1. Pre-base form
2. The base consonant
3. Above-base form (reph)
4. Post-base (matra)
5. Below-base form (vattu/rakaar)

Shaping Engine
Analyze the text
Reorder characters
Shape glyph sequences (GSUB processing)
Position glyph sequences (GPOS processing)
Base elements
Invalid combining marks
Use of ZWJ, ZWNJ and NBSP
The Indic shaping engine processes Devanagri text in stages. The stages are:
1. Analyze the text sequence; breaking it into syllable clusters
2. Reorder the characters as necessary
3. Apply OpenType GSUB font features to get the correct glyph shape
4. Apply OpenType GPOS features to position glyphs or marks
The descriptions which follow will help font developers understand the rationale for the
Devanagri feature encoding model and help application developers better understand
how layout clients can divide responsibilities with operating system functions.

Analyze the text
Character properties
The shaping engine divides the text into syllable clusters and identifies character
properties. Character properties are used in parsing syllables and identifying its parts, in
determining proper character or glyph reordering and in OpenType feature application.
Properties for each character are divided into two types: static properties and dynamic
properties.
Static properties define basic characteristics that do not change from font to font:
character type (consonant, matra, vedic sign, etc.) or type of matra reordering. They
differ from script to script, but can’t be controlled by font developer.
Dynamic properties are font dependent and are retrieved by the shaping engine as the
font is loaded. These properties affect shaping and reordering behavior.
*Note: in old shaping-engine implementations, all consonant properties were static:
consonants were assumed to have particular conjoining forms. In the new
implementation model, consonant conjoining behavior is a dynamic property.

Retrieving dynamic character properties from Indic fonts
Fonts define dynamic properties for consonants through implementing standard
features. Consonant types (and corresponding feature tags) that the shaping engine
reads from the font are:
Reph 'rphf'
Half forms 'half'
Pre-base-reordering forms of Ra/Rra 'pref'
Below-base forms 'blwf'
Post-base forms 'pstf'
Each of the features above is applied together with 'locl' feature to input sequences
consisting of two characters: for 'rphf' and 'half', features are applied to Consonant +
Halant combinations; for 'pref', 'blwf' and 'pstf', features are applied to Halant +
Consonant combinations. This is done for each consonant. If these two glyphs form a
ligature, with no additional glyphs in context, this means the consonant has the
corresponding form. For instance, if a substitution occurs when the 'half' and 'locl'
features are applied to a sequence Da + Halant, then Da is classified as having a half
form.

Note that a font may be implemented to re-order a Ra to pre-base position only in
certain syllables and display it as a below-base or post-base form otherwise. This means
that the Pre-base-form classification is not mutually exclusive with either Below-baseform or Post-base-form classifications. However, all classifications are determined as
described above using context-free substitutions.
Font-dependent character classification only defines consonant types. Reordering
positions, however, are fixed for each character class.
*Note: for fonts that support the old implementation, all features are applied to
Consonant + Halant sequences.

Indic input processing
The following steps should be repeated while there are characters left in the input
sequence. All shaping operations are done on a syllable-by-syllable basis, independent
from other characters.

Find next syllable in the input
Engine should find the character sequence matching one of the patterns below:
Consonant syllable:
{C+[N]+<H+[<ZWNJ|ZWJ>]|<ZWNJ|ZWJ>+H>} + C+[N]+[A] + [< H+[<ZWNJ|ZWJ>] |
{M}+[N]+[H]>]+[SM]+[(VD)]
Vowel-based syllable:
[Ra+H]+V+[N]+[<[<ZWJ|ZWNJ>]+H+C|ZWJ+C>]+[{M}+[N]+[H]]+[SM]+[(VD)]
Stand Alone cluster (at the start of the word only):
[Ra+H]+NBSP+[N]+[<[<ZWJ|ZWNJ>]+H+C>]+[{M}+[N]+[H]]+[SM]+[(VD)]
Where:
{}

zero or more occurrences

[]

optional occurrence

<|>

“one of”

()

one or two occurrences

C

consonant

V

independent vowel

N

nukta

H

halant/virama

ZWNJ

zero width non-joiner

ZWJ

zero width joiner

M

matra (up to one of each type: pre-, above-, below- or post- base)

SM

syllable modifier signs

VD

vedic

A

anudatta (U+0952)

NBSP

NO-BREAK SPACE

Identify key positions inside syllable
Syllable structure consists of the following parts:
Reph + HalfConsonant(s) + MainConsonant(s) + BelowBaseConsonant(s) +
PostBaseConsonant(s) + PreBaseReorderingRa + MatrasAndSigns
The consonant parts include all associated halants and nuktas. (For example, an instance
of BelowBaseConsonant consists of a sequence of Halant + Below-base-forming
Consonant.) All parts are optional, except the main consonant.
All parts are shown in the order they would occur within a syllable, with one
qualification: depending on a font implementation, PreBaseReorderingRa may occur
before all BelowBaseConsonants, after BelowBaseConsonants and before
PostBaseConsonants, or after PostBaseConsonants. Also, a font may be implemented to
re-order a Ra to pre-base position only in certain syllables and display it as a belowbase or post-base form otherwise. Thus, final determination of whether an occurrence of
Ra in a specific syllable can be treated as a pre-base reordering Ra can be made only
after the 'pref' feature has been applied to that syllable.
There could be several main consonants in the case where more than one consonant
doesn’t have a half-, below-base, post-base or pre-base form. In a case of a cluster
where the first consonant does not have a half form, the shaping engine will recognize it
as the 1st ‘full form’ and go on to identify the 2nd full form consonant, if there is one.
This information will then be used to determine the reordering behavior of the reph or
any matras, vowel modifiers or stress marks.

All other elements are classified by their position relative to the base: pre-base (half
forms and reordering pre-base Ra forms), below-base, above-base and post-base.

Indic clusters are subject to the following constraints:
Only one reph is allowed per syllable.
Only one pre-base reordering Ra is allowed per syllable.
A nukta can be placed on a consonant, matra or independent vowel. It cannot be
placed on a pre-composed nukta character.
One matra from each positioning class is permitted (exception in the Kannada
script). A composite matra is treated as belonging to all the classes from which its
components belong.
One syllable modifier sign is allowed per cluster.
Vedic signs are combining marks (used for Sanskrit) that should be included in all
Indic scripts.
Danda and Double Danda are punctuation marks that should be included in all
Indic scripts.

Reorder characters
Once the Indic shaping engine has analyzed the cluster as described above, it creates
and manages a buffer of appropriately reordered elements (glyphs) representing the
cluster, according to several rules (described below).
The OpenType lookups in an Indic font must be written to match glyph sequences after
re-ordering has occurred. OpenType fonts should not have substitutions that attempt to
perform the re-ordering. If a font developer attempted to encode such reordering
information in an OpenType font, they would need to add a huge number of many-tomany glyph mappings to cover the general algorithms that a shaping engine will use.
1. Find base consonant: The shaping engine finds the base consonant of the syllable,
using the following algorithm: starting from the end of the syllable, move
backwards until a consonant is found that does not have a below-base or postbase form (post-base forms have to follow below-base forms), or that is not a prebase reordering Ra, or arrive at the first consonant. The consonant stopped at will
be the base.
If the syllable starts with Ra + Halant (in a script that has Reph) and has more
than one consonant, Ra is excluded from candidates for base consonants.
2. Decompose and reorder Matras: Each matra and any syllable modifier sign in the
cluster are moved to the appropriate position relative to the consonant(s) in the

cluster. The shaping engine decomposes two- or three-part matras into their
constituent parts before any repositioning. Matra characters are classified by which
consonant in a conjunct they have affinity for and are reordered to the following
positions:
Before first half form in the syllable
After subjoined consonants
After post-form consonant
After main consonant (for above marks)
3. Reorder marks to canonical order: Adjacent nukta and halant or nukta and vedic
sign are always repositioned if necessary, so that the nukta is first.
4. Final reordering: After the localized forms and basic shaping forms GSUB features
have been applied (see below), the shaping engine performs some final glyph
reordering before applying all the remaining font features to the entire cluster.
Reorder matras: If a pre-base matra character had been reordered before
applying basic features, the glyph can be moved closer to the main
consonant based on whether half-forms had been formed. Actual position for
the matra is defined as “after last standalone halant glyph, after initial matra
position and before the main consonant”. If ZWJ or ZWNJ follow this halant,
position is moved after it.
Reorder reph: Reph’s original position is always at the beginning of the
syllable, (i.e. it is not reordered at the character reordering stage). However, it
will be reordered according to the basic-forms shaping results. Possible
positions for reph, depending on the script, are; after main, before post-base
consonant forms, and after post-base consonant forms.
a. If reph should be positioned after post-base consonant forms, proceed to
step 'e'.
b. If the reph repositioning class is not after post-base: target position is after
the first explicit halant glyph between the first post-reph consonant and
last main consonant. If ZWJ or ZWNJ are following this halant, position is
moved after it. If such position is found, this is the target position.
Otherwise, proceed to the next step.
Note: in old-implementation fonts, where classifications were fixed in
shaping engine, there was no case where reph position will be found on this
step.
c. If reph should be repositioned after the main consonant: from the first
consonant not ligated with main, or find the first consonant that is not a
potential pre-base reordering Ra.
d. If reph should be positioned before post-base consonant, find first postbase classified consonant not ligated with main. If no consonant is found,

the target position should be before the first matra, syllable modifier sign
or vedic sign.
e. If no consonant is found in steps 'c' or 'd', move reph to a position
immediately before the first post-base matra, syllable modifier sign or
vedic sign that has a reordering class after the intended reph position. For
example, if the reordering position for reph is post-main, it will skip abovebase matras that also have a post-main position.
f. Otherwise, reorder reph to the end of the syllable.
Reorder pre-base reordering consonants: If a pre-base reordering consonant is
found, reorder it according to the following rules:
a. Only reorder a glyph produced by substitution during application of the
'pref' feature. (Note that a font may shape a Ra consonant with the 'pref'
feature generally but block it in certain contexts.)
b. Try to find a target position the same way as for pre-base matra. If it is
found, reorder pre-base consonant glyph.
c. If position is not found, reorder immediately before main consonant.

Character reordering Classes for Devanagari:
_Characters_

_Reorder Class_

0930 (reph)

BeforePostscript

093F

BeforeHalf

0945-0948

AfterSubscript

0941-0944, 0962, 0963

AfterSubscript

093E, 0940, 0949-094C

AfterSubscript

Shape glyph sequences (GSUB processing)
All characters from a string are first mapped to their nominal glyphs using the cmap
lookup. The shaping engine then proceeds to shape (substitute) the glyphs using GSUB
lookups.
The features for localized forms and basic shaping forms are applied one at a time to the
cluster or a relevant portion of the cluster.
The results after basic shaping forms features have been applied impact the final syllable
analysis in terms of final designation of Ra as a pre-base reordering form and final
reordering positions for reph and matras. Next, the features for presentation forms are

applied to the entire cluster simultaneously. Note: since the presentation form features
are applied simultaneously over the entire cluster, several features are operationally
equivalent to a single feature. Multiple features are provided as an aid for font
developers to organize the lookups they implement.
Note: final reordering occurs after features for basic shaping forms have been applied
and before features for presentation forms are applied. Font developers must consider
the effects of initial reordering (before any features are applied) and final reordering
(after basic shaping forms features have applied) when they create GSUB feature and
lookup tables.
These predefined features are described and illustrated in the Features section and are
applied in the order below.

Shaping features:
Localized forms
1. Apply feature 'locl' to select language-specific forms.
Basic Shaping forms
1. Apply feature 'nukt' to substitute nukta forms of consonants.
2. Apply feature 'akhn' to substitute required akhand ligatures, or to substitute forms
that take precedence over forms produced by features applied later.
3. Apply feature 'rphf' to substitute the reph glyph (above-base form of 'Ra').
4. Apply feature 'rkrf' to substitute any rakaar ligatures.
5. Apply feature 'blwf’ to substitute below-base forms.
6. Apply feature 'half' to substitute half forms of pre-base consonants.
7. Apply feature 'vatu' to substitute ligature consonant-vattu or conjunct-vattu forms
for sequences of a consonant or conjunct glyph (full or half form) followed by the
below-base rakaar mark. (This feature is not needed if the rkrf feature is used, but
is available for old-behavior implementations).
8. Apply feature 'cjct' to substitute conjunct forms. (This is needed particularly for
ligature conjuct forms when the pre-base consonant does not have a half form).
Presentation forms
1. Apply feature 'pres' to substitute pre-base consonant conjuncts and pre-base
matra conjuncts. (ie. consonant and matra conjuncts to the left of the base glyph).
2. Apply feature 'abvs' to substitute above-base matra conjuncts, reph conjuncts,
above-base vowel modifiers and above-base stress and tone marks.

3. Apply feature 'blws' to substitute below-base consonant conjuncts, below-base
matra conjuncts, below-base vowel modifier forms and below-base stress and tone
mark forms.
4. Apply feature 'psts' to substitute post-base consonant conjuncts, post-base matra
conjuncts and post-base vowel modifiers.
5. Apply feature 'haln' to substitute the halant form of base (or conjunct base) glyph
in syllables ending with a halant.
6. Apply feature 'calt' to substitute the contextual alternate of a consonant.

Position glyph sequences (GPOS processing)
The shaping engine next processes the GPOS (glyph positioning) table, applying
features concerned with positioning. All features are applied simultaneously to the
entire cluster.
The font developer must consider the effects of re-ordering when creating the GPOS
feature and lookup tables (i.e., the glyphs will be in the order they were in after the
GSUB presentation forms features were applied).

Positioning features:
Kerning
1. Apply feature 'kern' to adjust distances (e.g., to provide kerning between post- or
pre-base elements and the base glyph).
2. Apply feature 'dist' to adjust distances. (NOTE – the feature ‘dist’ can be used in the
same way as the ‘kern’ feature. The advantage of using the ‘dist’ feature is that it
does not rely on the application to enable kerning. Therefore, if you want to make
sure certain spacing adjustments will always be displayed, you should use the ‘dist’
feature).
Above-base marks
1. Apply feature 'abvm' to position above-base marks (above-base consonant forms,
matras, vowel modifiers or stress/tone marks) on base glyphs or post-base matra.
Below-base marks
1. Apply feature 'blwm' to position below-base marks (below-base consonant forms,
matras, vowel modifiers or stress/tone marks) on base glyphs or post-base matra.

Base elements

Commonly, a feature is required for dealing with the base glyph and one of the postbase, pre-base, above-base or below-base elements. Since it is not possible to reorder
ALL of these elements next to the base glyph, we need to skip over the elements "in the
middle" (reordering-wise).
The solution is to assign different mark attachment classes to different elements of the
syllable and positional forms, and in any given lookup work with one mark type only. For
example, in above-base substitutions we need only consider above-base elements most
of the time.
Generally, it is good practice to label as "mark" any glyphs that are denoted as
combining marks in the Unicode Standard as well as below-base/above-base forms of
consonants. Then, different attachment classes should be assigned to different marks
depending on their position with respect to the base.
For example, after the shaping engine has re-ordered elements within the cluster,
matras will always occur before syllable modifier sign such as the candrabindu. In an
actual sequence, though, potentially some other mark glyph, such as nukta, may occur
between the matra and the candrabindu. Thus, when processing the matra and
candrabindu, you may need to allow for the possibility that some other mark glyph(s)
may occur between them. Using lookup flags, you can specify that a lookup should
process only a certain class of marks, such as ‘above-base marks’, and ignore all other
marks. In that way, a match will occur whether or not a mark from another class is
present. Otherwise, the lookup would fail to apply.
Using Microsoft VOLT, you can assign glyphs to attachment classes.
In the example below this ‘abvm’ feature was set to process only TopMarks, therefore
the presence of another mark class would be ignored. If Process ALL was used and
another mark glyph followed the matra, this positioning lookup would fail to apply. This
example comes from the Devanagari font Mangal

Invalid Combining Marks
Combining marks and signs that do not occur in conjunction with a valid base are
considered invalid. Shaping engine implementations may adopt different strategies for
how invalid marks are handled. For example, a shaping engine implementation might
treat an invalid mark as a separate cluster and display the stand-alone mark positioned
on some default base glyph, such as a dotted circle. (See Fallback Rendering in section
5.13 of the Unicode Standard 4.0.) Shaping engine implementations may vary somewhat
with regard to what sequences are or are not considered valid. For instance, some
implementations may impose a limit of at most one above-base vowel mark while
others may not.
To allow for shaping engine implementations that expect to position an invalid mark on
a dotted circle, it is recommended that a Devanagari OT font contain a glyph for the
dotted circle character, U+25CC. If this character is not supported in the font, such
implementations will display invalid signs on the missing glyph shape (white box).

In addition to the 'dotted circle' other Unicode code points that are recommended for
inclusion in any Devanagari font are the ZWJ (zero width joiner; U+200D), the ZWNJ
(zero width non-joiner; U+200C) and the ZWSP (zero width space; U+200B). For more
information see the Suggested glyphs section of the OpenType Font Development
document.

Effect of ZWJ, ZWNJ and NBSP on Consonant
Shaping
Unicode defines specific behaviors for ZWJ and ZWNJ in relation to Indic scripts. The
Indic-specific behavior retains the general behavior that ZWJ requests connection
between text elements while ZWNJ inhibits connection between text elements.
1. The main intent of using ZWJ in this context is to prevent a ligature-conjunct from
forming (and in Devanagari or Gujuarati, to request a half form, below-base form
or post-base form instead). The Indic engine does not need to take any action to
prevent ligature-conjuct formation: the presence of ZWJ will prevent GSUB
substitution lookups from matching the input glyph sequence. If the first
consonant does not have a half form, an overt-halant form should result, which
would also happen with no particular action by the engine.
2. A secondary intent of using ZWJ in this context is to prevent the display of reph in
the case that the first consonant is RA. If a cluster begins with RA H (halant) ZWJ,
the engine must ensure that the ‘rphf’ feature is not applied, and that re-ordering
for reph does not take place. Note that use of either joiner in this context should
prevent formation and re-ordering of reph when RA is the first consonant.
3. A third use of ZWJ involves RA specifically in the case of Devanagari script: the
sequence RA H ZWJ is used for the encoded representation for ‘eyelash RA’ used
for the Marathi language. Apart from the requirement not to create and re-order
reph, however, no additional actions in the engine are required.
4. The main intent of using ZWNJ is to prevent conjunct ligature or half forms from
forming, and to display an explicit halant form instead. The shaping engine must
take specific actions to prevent half forms for a sequence of Consonant + Halant +
ZWNJ.

The following example illustrates some of these behaviors:

Just as the ZWJ can be used to display a half form in isolation, it can also be used to
display a mark, sub- or post-base form in isolation. Unlike the stand-alone half form,
however, sequences to display them must begin with a no-break space (NBSP). This is
because mark glyphs must combine with a base glyph: to appear in isolation, a NBSP
must be provided as a base. For example, to get a shape of I-matra without the dotted
circle one should type NBSP + I-matra.
In the illustration below the I-matra is displayed without the dotted circle by using the
NBSP. The combination of NBSP and ZWJ is used to display the below-base form of Ra
(Rakaar) in isolation.

Last updated: May 22, 2008

Features
The features listed below have been defined to create the basic forms for the languages
that are supported on Devanagari systems. Regardless of the model an application
chooses for supporting layout of complex scripts, the shaping engine requires a fixed
order for executing features within a run of text to consistently obtain the proper basic
form.
The features of the basic shaping forms are applied one at a time to the cluster or
portion of the cluster. The result impacts the analysis in terms of the conjoining behavior
and final reordering. The features of the presentation forms are applied next, to the

entire cluster simultaneously. Mandatory features must always be applied; the
discretionary presentation-forms features listed should be applied by default, but can be
suppressed by a client (normally at the discretion of the user).
The order of the lookups within each feature is also very important. For more
information on lookups and defining features in OpenType fonts, see the Encoding
section of the OpenType Font Development document.
OpenType features used for Devanagari scripts, applied in the following order:
Feature

Feature function

Layout
operation

Localized forms:
locl

Localized form substitution

GSUB

nukt

Nukta form substitution

GSUB

akhn

Akhand ligature substitution

GSUB

rphf

Reph form substitution

GSUB

rkrf

Rakaar form substitution

GSUB

blwf

Below-base form substitution

GSUB

half

Half-form substitution

GSUB

vatu

Vattu variants

GSUB

cjct

Conjunct form substitution

GSUB

Basic shaping forms:

Mandatory presentation forms:
pres

Pre-base substitution

GSUB

abvs

Above-base substitution

GSUB

blws

Below-base substitution

GSUB

psts

Post-base substitution

GSUB

haln

Halant form substitution

GSUB

Discretionary presentation forms:
calt
Positioning features:

Contextual alternates

GSUB

kern

Kerning

GPOS

dist

Distances

GPOS

abvm

Above-base mark positioning

GPOS

blwm

Below-base mark positioning

GPOS

[GSUB = glyph substitution, GPOS = glyph positioning]

Feature examples
Many of the registered features described and illustrated in this document are based on
the Microsoft OpenType font Mangal (Mangal.ttf). Mangal contains layout information
and glyphs to support all of the required features for the Devanagari script and
language systems supported. Instructions for obtaining the Mangal font are given in the
Appendix of this document.
The illustrations in the following examples show the result of that particular feature
being applied. Features must be written to match glyph sequences after re-ordering has
occurred. Note that the input context for a feature may be the result of a previous
feature having already been applied.

Localized forms
Feature Tag: "locl"
This feature is used in association with OpenType language system tags to trigger
lookups that will select alternate glyphs needed for language-specific typographic
conventions. The 'locl' should not be used in association with the default language
system, but only used with other language system tags. See the Appendix of this
document for language system tags associated with the Devanagari script.

Basic shaping forms
Nukta
Feature Tag: "nukt"
The nukta alters the way a preceding consonant or vowel is pronounced. The most
common nukta forms have been defined as separate characters in Unicode with their

own code points. All consonants, as well as akhand forms should have an associated
nukta form.
Note - Rather than using substitution, nukta forms can also be created by positioning
the nukta as a below-base mark on the base glyph using the 'blwm' positioning feature
The input context for the nukt feature always consists of the full form of the consonant.
The half form of nukta consonants will be substituted using the half feature.
Nukta feature applied substitutes Ka-nukta pre-composed glyph:

Akhand
Feature Tag: "akhn"
An akhand is a required consonant ligatures that may appear anywhere in the syllable,
and may or may not involve the base glyph. Akhand ligatures have the highest priority
and are formed first; some languages include them in their alphabets. There are 2
Akhand ligatures in Devanagari.
The input context for the akhand feature always consists of the full form of the
consonant. The half forms of Akhand ligatures will be called later in the half feature.
Because the akhand feature is applied early in the sequence of features and is applied
over the entire cluster, it can also be used to create certain forms that must take priority
in particular contexts over forms that would be created during subsequent feature
application.
Using the 'akhn' feature, Ka + halant + Ssa is substituted with the KaSsa ligature:

Ja + halant + Nya is substituted with the JaNya Ligature:

Reph
Feature Tag: "rphf"
Applying this feature substitutes the Reph glyph. If the first consonant of the cluster
consists of the full form of Ra + Halant, this feature substitutes the combining-mark
form of Reph. In addition, the position of the Reph glyph is adjusted with the 'abvm'
GPOS feature.
The input context for the Reph feature always consists of the full form of Ra + Halant.
Reph feature substitutes the mark glyph form of Ra. After final reordering, positioning is
adjusted in the 'abvm' GPOS feature:

Reph feature applied with multiple consonants. Note: reph is re-ordered to position on
the 1st main consonant:

Rakaar
Feature Tag: "rkrf"
Applying this feature substitutes a consonant-rakaar (below-base Ra) ligature or an
akhand-rakaar ligature. For consonants that do not form a ligature with the rakaar, the
'rkrf' feature may also be used to substitute a pre-composed glyph for the consonant
plus rakaar.
Note: the rakaar forms feature is required specifically for those scripts in which a halfform of a consonant-rakaar ligature can occur. This includes Devanagari and Gujarati
scripts. It is not used for the other Indic scripts.
The input context for the rakaar feature always consists of the full form consonant +
halant + Ra. The half forms of rakaar ligatures should be substituted using the half
feature.

The 'rkrf' feature applied to substitute the rakaar form of Ka:

Rakaar variants for 'nukta' glyphs as well as 'akhand' ligatures should also be created:

For consonants that do not form a ligature with the rakaar (like the Cha) the 'rkrf' feature
may also be used to substitute a pre-composed glyph for the consonant plus rakaar
combination:

Below-base form of consonant
Feature Tag: "blwf"
This feature substitutes the below-base forms of Consonants like the Ra in Devanagari
(aka 'rakaar') when the rakaar does not form a ligature with the preceding consonant. If
the rakaar and preceding consonant do form a ligature, it should be substituted in the
previous feature 'rkrf'.
Halant plus Ra (preceded by a consonant which does not form a 'rkrf' ligature)
substitutes the rakaar form:

Half form of consonant
Feature Tag: "half"
Applying this feature substitutes half forms - forms of consonants used in the pre-base
position. Consonants that have a half form should be listed in the 'half' feature.
Devanagari has distinctly shaped half forms for most of the consonants as well as nukta
and Akhand glyphs. If a consonant does not have a distinct shape for the half form and
does not form any ligature, it will be displayed with an explicit Virama (same shape as
the halant form).
Note - the result of listing a consonant in the half feature (whether it has a true half
form or not) will affect the re-ordering (and positioning) of the reph and pre-pended
matras. See illustration in the Introduction section of this document.
This feature is applied to all consonants preceding the 'main' consonant.
Example 1 - Half feature substitutes half form of Ka:

Example 2 - Half feature applied to multiple consonants:

Example 3 - Half feature used to substitute half form of Ta-Nukta:

Example 4 - Half form of Akhand ligature (KaSsa):

Example 5 - Half feature applied to Da, produces 'halant' form of Da since it has no
distinct half form shape: (remember listing the Da in the half feature will cause it to

behave like a half form for purposes of re-ordering)

Vattu variants
Feature Tag: "vatu"
The 'vatu' feature can be used to substitute a ligature of a full (or half) form consonant
plus a below-base vattu (rakaar) mark. This feature was needed in earlier
implementations to combine rakaar with both full and half forms It is not useful,
however, for newer implementations that distinguish consonants that do not have half
forms from other consonants, for purposes of re-ordering the reph and pre-pended
matras. In Devanagari, this feature is not required if the 'rkrf' feature is used, however it
is still supported for backward compatibility with existing fonts.
Example; the 'vatu' feature used in earlier implementations of the shaping engine to
substitute a ligature of consonant (full or half form) plus vattu (rakaar), which now
should be created using the 'rkrf' and 'half' features.

Conjunct forms
Feature Tag: "cjct"
Apply feature 'cjct' to substitute conjunct forms where the first consonant in the
consonant-cluster pair does not have a half form. This feature allows for control over reordering of reph and pre-pended matras in case of consonants that do not take half
forms yet do form conjunct ligatures in combination with certain following consonants.

The 'cjct' feature applied to substitute conjunct form of Da + Ga:

The 'cjct' feature applied to substitute conjunct form of Da + Ma:

Presentation forms
After the glyphs have been reordered, the presentation lookups are applied to provide
the best typographic rendering of the text. The features of the presentation forms are
applied to the entire cluster simultaneously, executing lookups within each feature in
the order that they are specified in the font.
The pres, abvs, blws, psts and haln features are all mandatory for software
implementations: they are required for correct script behaviour and none should ever be
treated as discretionary. Because of this and because they are all applied simultaneously
over entire clusters, they are not functionally different: a set of lookups could be divided
between these features or grouped together under one of them with no difference in
effect. These multiple features are provided, however, as an aid to the font developer for
organizing lookups based on the combinations of glyphs they apply to. There are no
specific requirements on how each should be used; the examples provided below
illustrate typical usage, however.

Pre-base substitutions
Feature Tag: "pres"
This feature is used to substitute pre-base consonant conjuncts made with half forms,
the type most common in Devanagari. The resulting conjunct can be in full or half form.
See examples 1-4.
This feature is also used to select typographically correct forms of the I-Matra. For
example, a font can have several versions of the I-Matra to be used in context with
different consonant bases or clusters. See example 5 + 6. In addition the 'pres' feature
can contain pre-composed ligatures of the I-matra with certain bases.

Example 1 - half Ka + full Ta is substituted by the full KaTa conjunct:

Example 2 - half Sha + full Na is substituted by the full ShaNa conjunct:

Example 3 - half Kha + half Na is substituted by the half KhaNa conjunct:

Example 4 - half Sha + half La is substituted by the half ShaLa conjunct:

Example 5 - The 'pres' feature is also used to substitute variations of the I-Matra based
on context:

Example 6 - Using MS Volt, different shapes of the I-matra are selected based on the
context. Note; in this example 'glyph groups' listing consonants with similar widths, have

been used for substitution context.

Above-base substitutions
Feature Tag: "abvs"
This feature is used for glyph substitutions involving above-base marks. Such
substitutions might be used to select contextual forms of marks, to create mark-mark
ligatures, or to create mark-base ligatures. Specific context-dependent forms or belowbase consonants are handled by this lookup as well.
Example 1- contextual 'abvs' substitution; used to select smaller candrabindu, when
preceded by vowel short E.

Example 2- mark to mark 'abvs' substitution; matre E + reph substituted with matraE
reph ligature. Note- the positioning of the ligature matra is done in the 'abvm' feature:

Example 3- mark to base 'abvs' substitution; vowel Ii + candrabindu substituted with
pre-composed ligature:

Below-base substitutions
Feature Tag: "blws"
This feature is used for glyph substitutions involving below-base marks or consonants.
Such substitutions can be used to create conjuncts of base glyphs with below-base
consonants, below mark ligatures or below mark-base ligatures. Specific contextdependent forms are handled by this lookup as well.
Example 1- 'blws' substitution to create base + below base conjunct:

Example 2- 'blws' substitution to create base + below mark conjunct:

Example 3- 'blws' substitution used to create below-mark to base conjunct:

Post-base substitutions
Feature Tag: "psts"
This feature is used to substitute post-base consonants or matras. Such substitutions
can be used to create conjuncts of base glyphs with post-base consonants or post-base
matra ligatures. It can also be used to specify contextual alternates of post-base forms.
Example 1- contextual 'psts' substitution; used to select alternate form of vowel Ii, when
preceded by a Ka.

Example 2 - contextual 'psts' substitution; Using MS Volt, different shapes of the vowel Ii
are substituted based on the context. Note; in this example 'glyph groups' with similar
widths are used for the context:

Halant form of consonants
Feature Tag: "haln"
This feature is used to substitute a pre-composed halant form of a base (or conjunct
base) glyph in syllables ending with a halant. (Rather than using substitution, halant

forms can also be created by positioning the halant as a below-base mark on the base
glyph using the 'blwm' positioning feature.)
This feature is applied only on the base glyph if the syllable ends with a halant, or in the
case of non-final consonants that do not take a half form and do not form a conjunct
ligature with the following consonant.
Example 1 - 'haln' feature used to substitute halant form of base glyph:

Example 2 - 'haln' feature used to substitute halant form of conjunct base glyph:

Contextual Alternates
Feature Tag: "calt"
Unlike the previous presentation lookups, the 'calt' feature is optional and is used to
substitute discretionary contextual alternates. It is important to note that an application
may allow users to turn off this feature, therefore should not be used for any obligatory
Devanagari typography.

Positioning features
Distance
Feature Tag: "dist"
This feature covers positioning lookups that adjust distances between glyphs, such as
kerning between pre- and post-base elements and the base glyph. Note; the feature
'dist' can be used in the same way as the 'kern' feature. The advantage of using the 'dist'
feature is that it does not rely on the application to enable kerning.

Above-base marks
Feature Tag: "abvm"

This feature positions all above-base marks on the base glyph or the post-base matra.
The best method for encoding this feature in an OpenType font is to use a chaining
context positioning lookup that triggers mark-to-base and mark-to-mark attachments
for above-base marks.
The 'abvm' lookup in MS Volt using 'Anchor Attachment' for adjusting positions of
above-marks over bases:

The 'abvm' lookup in MS Volt using 'Pair Adjustment' for adjusting positions of abovemarks with post-base vowel:

Below-base marks

Feature Tag: "blwm"
This feature positions all below-base marks on the base glyph. The best method for
encoding this feature in an OpenType font is to use a chaining context positioning
lookup that triggers mark-to-base and mark-to-mark attachments for below-base
marks.
The 'blwm' lookup in MS Volt using 'Anchor Attachment' for adjusting positions of
below-marks with bases:

The 'blwm' lookup in MS Volt using 'Anchor Attachment' can also be used for adjusting
positions of below-marks with other below-marks.

Examples Devanagari syllables
Complex Devanagari syllable formation is possible using the wide range of features
available in OpenType. The following examples show how the shaping engine applies
the OpenType features, one at a time to the input string. These combinations do not
necessarily represent actual syllables or words, but are meant to illustrate the various
OpenType features in a Devanagari font.

Example #1: Input text string and resulting display as OT features are applied.

Example #2: Input text string and resulting display as OT features are applied.

Example #3: Input text string and resulting display as OT features are applied.

Example #4: Input text string and resulting display as OT features are applied.

Example #5: Input text string and resulting display as OT features are applied.

Last updated: May 22, 2008

Appendices

Appendix A: Writing System Tags
Appendix B: MANGAL.TTF (sample font)

Appendix A: Writing System Tags
Features are encoded according to both a designated script and language system. There
are different language systems defined for the Hindi, Sanskrit, and Marathi languages,
although they all use the Devanagari script.
Currently most shaping engine implementations only support the "default" language
system for each script. However, font developers may want to build language specific
features which are supported in other applications and will be supported in future
Microsoft OpenType implementations.
NOTE: It is strongly recommended to include the "dflt" language tag in all OpenType
fonts because it defines the basic script handling for a font. The "dflt" language system
is used as the default if no other language specific features are defined, or if the
application does not support that particular language. If the "dflt" tag is not present for
the script being used, the font may not work in some applications.
The following table lists the registered tag names for script and language systems. Note
for new Indic shaping implementation 'dev2' is used (old-behavior implementations
used 'deva').
Registered tags for the Devanagari script

Registered tags for Devanagari language
systems

Script tag

Script

Language
system tag

Language

"dev2"

Devanagari

"dflt"

*default script handling

"HIN "

Hindi

"KSH "

Kashmiri

"KOK "

Konkani

"MAR "

Marathi

"NEP "

Nepali

"SAN "

Sanskrit

"SND "

Sindhi

Note: both the script and language tags are case sensitive (script tags should be
lowercase, language tags are all caps) and must contain four characters (ie. you must
add a space to the three character language tags).

Appendix B: MANGAL.TTF (sample font)
The MANGAL OpenType font is available to licensed users of VOLT, Microsoft's Visual
OpenType Layout Tool. It is provided for illustration only, and may not be altered or
redistributed.
MANGAL supports the characters and features in the Unicode Standard, which is a
superset of the ISCII-1988 standard. The same Unicode character code layout is followed
for nine Indian scripts: Bengali, Devanagari, Gurumukhi (Punjabi), Gujarati, Kannada,
Oriya, Malayalam, Tamil and Telugu.
MANGAL is a Windows 2000 system font. MANGAL contains layout information and
glyphs to support all of the required features for the scripts and languages supported.
Many shaped glyph forms (such as ligatures) have no Unicode encoding. These glyphs
have id's in the font, and applications can access these glyphs by "running" the layout
features which depend on these glyphs. An application can also identify non-Unicode
glyphs contained in the font by traversing the OpenType layout tables, or using the
layout services for purely informational purposes.
MANGAL contains three OpenType Layout tables: GSUB (glyph substitution), GPOS
(glyph positioning), and GDEF (glyph definition, distinguishing base glyphs, ligatures,
classes of mark glyphs, etc.).
The font is available as part of the VOLT supplemental files. Once you install VOLT you
need to run a separate installer to get the supplemental files. Both installers are part of
the VOLT download package.

Developing OpenType Fonts for Gujarati
Script
Article • 06/16/2022

Please note:: This document reflects the changes made in 2005 recommendations for
Indic-script OpenType font and shaping-engine implementations. While Indic fonts
made according to the earlier recommendations will still function properly in the new
versions of Uniscribe, font developers may choose to update their fonts, particularly if
they wish to avoid certain limitations of the earlier implementation.
This document presents information that will help font developers create or support
OpenType fonts for the Gujarati script covered by the Unicode Standard. Gujarati is closely
related to Devanagari and is used to write the Gujarati language of north India.

Introduction
This document targets developers implementing Indic shaping behavior compatible
with Microsoft OpenType specification for Indic scripts. It contains information about
terminology, font features and behavior of the Indic shaping engine in regards to the
Gujarati script. While it does not contain instructions for creating Gujarati fonts, it will
help font developers understand how the Indic shaping engine processes Indic text. In
addition, registered features of the Gujarati script are defined and illustrated with
examples.
The new Indic shaping engine allows for variations in typographic conventions, giving a
font developer control over shaping by the choice of designation of glyphs to certain
OpenType features. For example, the location where the reph and pre-pended matra are
re-ordered within a syllable cluster is affected by the presence of a half form. See
illustrations below.
In the example below (Ra + halant + Da+ halant + La + I-matra), Ra + halant will form
the reph, but how the Da is classified (listed in the half feature or not) will determine the
position of the reph as well as the location of the pre-pended matra.

Option 1= While the 'Da' does not have a true half form in Gujarati, it can be listed in
the 'half' feature lookup substituting the 'halant form' of Da. Thus, the shaping engine
will treat it as a half and the reph is positioned on the first main consonant; and the Imatra will be positioned immediately in front of the 'half-form' D(a).**
Note:** if the second consonant was a Ma, the Da + Ma would be substituted with the
DaMa ligature.
Option 2= By not listing Da in the 'half' feature lookup, the shaping engine will read it as
the first main consonant on which to position the reph. And the I-matra is positioned
immediately in front of the previous base (or half-form) preceding it, which in this case
is the La.

Glossary
The following terms are useful for understanding the layout features and script rules
discussed in this document.
Above-base form of consonants - A variant form of a consonant that appears above
the base glyph. In Gujarati, only the consonant Ra has an above-base form, known as
'reph'.
Akhand ligatures - Required consonant ligatures that may appear anywhere in the
syllable, and may or may not involve the base glyph. Akhand ligatures have the highest
priority and are formed first; some languages include them in their alphabets. Akhand
ligatures in Gujarati may be displayed in either half- or full-form.
Base glyph - The only consonant or consonant conjunct in the orthographic syllable that
is written in its "full" (nominal) form. In Gujarati, the last consonant of the syllable
(except for syllables ending with letter "Ra") usually forms the base glyph. In
"degenerate" syllables that have no vowel (last letter of a word), the last consonant in
halant form serves as the base consonant and is mapped as the base glyph. Layout
operations are defined in terms of a base glyph, not a base character, since the base can
often be a ligature.

Below-base form of consonants - A variant form of a consonant that appears below the
base glyph. In Gujarati, only the consonant Ra has a below-base form. In the glyph
sequence, the below-base form comes after the consonant(s) that form the base glyph.
Below-base forms are represented by a non-spacing mark glyph.
Cluster - A group of characters that form an integral unit in Indic scripts, often times a
syllable.
Consonant - Each represents a single consonant sound. Consonants may exist in
different contextual forms and have an inherent vowel (usually, the short vowel "a"). For
example, "Ka" and "Ta", rather than just "K" or "T."
Consonant conjuncts (aka 'conjuncts') - Ligatures of two or more consonants.
Consonant conjuncts may have both full and half forms, or only full forms.
Gujarati syllable - Effective orthographic "unit" of Gujarati writing systems. Syllables are
composed of consonant letters, independent vowels and dependant vowels. In a text
sequence, these characters are stored in phonetic order (although they may not be
represented in phonetic order when displayed). Once a syllable is shaped, it is
indivisible. The cursor cannot be positioned within the syllable. Transformations
discussed in this document do not cross syllable boundaries.
Halant (Virama) - The character used after a consonant to "strip" it of it's inherent
vowel. A Halant follows all but the last consonant in every Gujarati syllable.
NOTE: A syllable containing halant characters may be shaped with no visible halant
signs by using different consonant forms or conjuncts instead.
Halant form of consonants - The form produced by adding the halant (virama) to the
nominal shape. The Halant form is used in syllables that have no vowel or as the half
form when no distinct shape for the half form exists.
Half form of consonants (pre-base form) - A variant form of consonants which appear
to the left of the base consonant, if they do not participate in a ligature. Consonants in
their half form precede the ones forming the base glyph. Gujarati has distinctly shaped
half forms for most consonants. If a consonant does not have a distinct shape for the
half form and does not form any ligature, it will be displayed with an explicit Virama
(same shape as the halant form).
Matra (Dependent Vowel) - Used to represent a vowel sound that is not inherent to the
consonant. Dependent vowels are referred to as "matras" in Sanskrit. They are always
depicted in combination with a single consonant, or with a consonant cluster. The
greatest variation among different Indian scripts is found in the rules for attaching
dependent vowels to base characters.

New shaping behavior - Shaping behavior defined in this version of the Indic OpenType
Font Specification. Information in this document relates primarily to the new
implementation model. Old behavior may be mentioned in comments about
compatibility.
Nukta - A combining character that alters the way a preceding consonant (or matra) is
pronounced.
Old shaping behavior - Shaping behavior defined in previous versions of the Indic
OpenType Font Specification.
OpenType layout engine - Library responsible for executing OpenType layout features
in a font. In the Microsoft text formatting stack, it is named OTLS (OpenType layout
services).
OpenType tag - 4-byte identifier for script, language system or feature in the font.
Post-base form of consonants - A variant form of a consonant that appears to the right
of the base glyph. A consonant that takes a post-base form is preceded by the
consonant(s) forming the base glyph plus a halant (virama). Post-base forms are usually
spacing glyphs.
Pre-base form of consonants - A variant form of a consonant that appears to the left of
the base glyph. Note that most pre-base consonant forms are logically as well as visually
before the base consonant. Half forms are examples of this kind of pre-base form. In
some scripts, though, a pre-base Ra may logically follow the base consonant (that is, it
follows it phonetically and in the character sequence of the text), even though it is
presented visually before the base. The shaping engine detects such cases dynamically
using the 'pref' feature and re-orders the pre-base-form glyph as needed.
Rakaar - The below-base form of "Ra" in Gujarati, which forms a ligature with most
preceding consonant(s). If the preceding consonant has a half form, then the consonantrakaar combination, typically also has a half form.
Reph - The above-base form of the letter "Ra" that is used in Gujarati when "Ra" is the
first consonant in the syllable and is not the base consonant.
Shaping Engine - Code responsible for shaping input, classified to a particular script.
Split Matra - A matra that is decomposed into pieces for rendering. Usually the different
pieces appear in different positions relative to the base. For instance, part of the matra
may be placed at the beginning of the cluster and another part at the end of the cluster.
Syllable - A single unit of Indic text processing. Shaping of Indic text is performed
independently for each syllable. Process of identifying boundaries of each syllable is

described below.
Vattu - A below-base form of a consonant. In Gujarati, "Ra" can take a vattu form within
a cluster; this "Vattu-Ra" is also known as Rakaar.

1. Pre-base form
2. The base consonant
3. Above-base form (reph)
4. Post-base (matra)
5. Below-base form (vatu/rakaar?)

Shaping Engine
Analyze the text
Reorder characters
Shape glyph sequences (GSUB processing)
Position glyphs sequences (GPOS processing)
Base elements
Invalid combining marks
Use of ZWJ, ZWNJ and NBSP
The Indic shaping engine processes Gujarati text in stages. The stages are:
1. Analyze the text sequence; breaking it into syllable clusters
2. Reorder the characters as necessary
3. Apply OpenType GSUB font features to get the correct glyph shape
4. Apply OpenType GPOS features to position glyphs or marks
The descriptions which follow will help font developers understand the rationale for the
Devanagri feature encoding model and help application developers better understand
how layout clients can divide responsibilities with operating system functions.

Analyze the text

Character properties
The shaping engine divides the text into syllable clusters and identifies character
properties.
Character properties are used in parsing syllables and identifying its parts, in
determining proper character or glyph reordering and in OpenType feature application.
Properties for each character are divided into two types: static properties and dynamic
properties.
Static properties define basic characteristics that do not change from font to font:
character type (consonant, matra, vedic sign, etc.) or type of matra reordering. They
differ from script to script, but can't be controlled by font developer.
Dynamic properties are font dependent and are retrieved by the shaping engine as the
font is loaded. These properties affect shaping and reordering behavior.
*Note: in old shaping-engine implementations, all consonant properties were static:
consonants were assumed to have particular conjoining forms. In the new
implementation model, consonant conjoining behavior is a dynamic property.

Retrieving dynamic character properties from Indic fonts
Fonts define dynamic properties for consonants through implementing standard
features. Consonant types (and corresponding feature tags) that the shaping engine
reads from the font are:
Reph 'rphf'
Half forms 'half'
Pre-base-reordering forms of Ra/Rra 'pref'
Below-base forms 'blwf'
Post-base forms 'pstf'
Each of the features above is applied together with 'locl' feature to input sequences
consisting of two characters: for 'rphf' and 'half', features are applied to Consonant +
Halant combinations; for 'pref', 'blwf' and 'pstf', features are applied to Halant +
Consonant combinations. This is done for each consonant. If these two glyphs form a
ligature, with no additional glyphs in context, this means the consonant has the
corresponding form. For instance, if a substitution occurs when the 'half' and 'locl'
features are applied to a sequence Da + Halant, then Da is classified as having a half
form.

Note that a font may be implemented to re-order a Ra to pre-base position only in
certain syllables and display it as a below-base or post-base form otherwise. This means
that the Pre-base-form classification is not mutually exclusive with either Below-baseform or Post-base-form classifications. However, all classifications are determined as
described above using context-free substitutions.
Font-dependent character classification only defines consonant types. Reordering
positions, however, are fixed for each character class.
*Note: for fonts that support the old implementation, all features are applied to
Consonant + Halant sequences.

Indic input processing
The following steps should be repeated while there are characters left in the input
sequence. All shaping operations are done on a syllable-by-syllable basis, independent
from other characters.

Find next syllable in the input
Engine should find the character sequence matching one of the patterns below:
Consonant syllable
{C+[N]+<H+[<ZWNJ|ZWJ>]|<ZWNJ|ZWJ>+H>} +
C+[N]+[A] + [< H+[<ZWNJ|ZWJ>] | {M}+[N]+[H]>]+[SM]+[(VD)]
Vowel-based syllable:
[Ra+H]+V+[N]+[<[<ZWJ|ZWNJ>]+H+C|ZWJ+C>]+[{M}+[N]+[H]]+[SM]+[(VD)]
Stand Alone cluster (at the start of the word only):
[Ra+H]+NBSP+[N]+[<[<ZWJ|ZWNJ>]+H+C>]+[{M}+[N]+[H]]+[SM]+[(VD)]
Where
{}

zero or more occurrences

[]

optional occurrence

<|>

'one of'

()

one or two occurrences

C

consonant

V

independent vowel

N

nukta

H

halant/virama

ZWNJ

zero width non-joiner

ZWJ

zero width joiner

M

matra (up to one of each type: pre-, above-, below- or post- base)

SM

syllable modifier sign

VD

vedic

A

anudatta (U+0952)

NBSP

NO-BREAK SPACE

Identify key positions inside syllable
Syllable structure consists of the following parts:
Reph + HalfConsonant(s) + MainConsonant(s) + BelowBaseConsonant(s) +
PostBaseConsonant(s) + PreBaseReorderingRa + MatrasAndSigns
The consonant parts include all associated halants and nuktas. (For example, an instance
of BelowBaseConsonant consists of a sequence of Halant + Below-base-forming
Consonant.) All parts are optional, except the main consonant.
All parts are shown in the order they would occur within a syllable, with one
qualification: depending on a font implementation, PreBaseReorderingRa may occur
before all BelowBaseConsonants, after BelowBaseConsonants and before
PostBaseConsonants, or after PostBaseConsonants. Also, a font may be implemented to
re-order a Ra to pre-base position only in certain syllables and display it as a belowbase or post-base form otherwise. Thus, final determination of whether an occurrence of
Ra in a specific syllable can be treated as a pre-base reordering Ra can be made only
after the 'pref' feature has been applied to that syllable.
There could be several main consonants in the case where more than one consonant
doesn't have a half-, below-base, post-base or pre-base form. In a case of a cluster
where the first consonant does not have a half form, the shaping engine will recognize it
as the 1st 'full form' and go on to identify the 2nd full form consonant, if there is one.
This information will then be used to determine the reordering behavior of the reph or
any matras, vowel modifiers or stress marks.

All other elements are classified by their position relative to the base: pre-base (half
forms and reordering pre-base Ra forms), below-base, above-base and post-base.

Indic clusters are subject to the following constraints:
Only one reph is allowed per syllable.
Only one pre-base reordering Ra is allowed per syllable.
A nukta can be placed on a consonant, matra or independent vowel. It cannot be
placed on a pre-composed nukta character.
One matra from each positioning class is permitted (exception in the Kannada
script). A composite matra is treated as belonging to all the classes from which its
components belong.
One syllable modifier sign is allowed per cluster.
Vedic signs are combining marks (used for Sanskrit) that should be included in all
Indic scripts.
Danda and Double Danda are punctuation marks that should be included in all
Indic scripts.

Reorder characters
Once the Indic shaping engine has analyzed the cluster as described above, it creates
and manages a buffer of appropriately reordered elements (glyphs) representing the
cluster, according to several rules (described below).
The OpenType lookups in an Indic font must be written to match glyph sequences after
re-ordering has occurred. OpenType fonts should not have substitutions that attempt to
perform the re-ordering. If a font developer attempted to encode such reordering
information in an OpenType font, they would need to add a huge number of many-tomany glyph mappings to cover the general algorithms that a shaping engine will use.
1. Find base consonant: The shaping engine finds the base consonant of the syllable,
using the following algorithm: starting from the end of the syllable, move
backwards until a consonant is found that does not have a below-base or postbase form (post-base forms have to follow below-base forms), or that is not a prebase reordering Ra, or arrive at the first consonant. The consonant stopped at will
be the base.
If the syllable starts with Ra + Halant (in a script that has Reph) and has more
than one consonant, Ra is excluded from candidates for base consonants.
2. Decompose and reorder Matras: Each matra and any syllable modifier sign in the
cluster aremoved to the appropriate position relative to the consonant(s) in the

cluster. The shaping engine decomposes two- or three-part matras into their
constituent parts before any repositioning. Matra characters are classified by which
consonant in a conjunct they have affinity for and are reordered to the following
positions:
Before first half form in the syllable
After subjoined consonants
After post-form consonant
After main consonant (for above marks)
3. Reorder marks to canonical order: Adjacent nukta and halant or nukta and vedic
sign are always repositioned if necessary, so that the nukta is first.
4. Final reordering: After the localized forms and basic shaping forms GSUB features
have been applied (see below), the shaping engine performs some final glyph
reordering before applying all the remaining font features to the entire cluster.
Reorder matras: If a pre-base matra character had been reordered before
applying basic features, the glyph can be moved closer to the main
consonant based on whether half-forms had been formed. Actual position for
the matra is defined as 'after last standalone halant glyph, after initial matra
position and before the main consonant'. If ZWJ or ZWNJ follow this halant,
position is moved after it.
Reorder reph: Reph's original position is always at the beginning of the
syllable, (i.e. it is not reordered at the character reordering stage). However, it
will be reordered according to the basic-forms shaping results. Possible
positions for reph, depending on the script, are; after main, before post-base
consonant forms, and after post-base consonant forms.
a. If reph should be positioned after post-base consonant forms, proceed to
step 5.
b. If the reph repositioning class is not after post-base: target position is after
the first explicit halant glyph between the first post-reph consonant and
last main consonant. If ZWJ or ZWNJ are following this halant, position is
moved after it. If such position is found, this is the target position.
Otherwise, proceed to the next step. Note: in old-implementation fonts,
where classifications were fixed in shaping engine, there was no case where
reph position will be found on this step.
c. If reph should be repositioned after the main consonant: from the first
consonant not ligated with main, or find the first consonant that is not a
potential pre-base reordering Ra.
d. If reph should be positioned before post-base consonant, find first postbase classified consonant not ligated with main. If no consonant is found,

the target position should be before the first matra, syllable modifier sign
or vedic sign.
e. If no consonant is found in steps 3 or 4, move reph to a position
immediately before the first post-base matra, syllable modifier sign or
vedic sign that has a reordering class after the intended reph position. For
example, if the reordering position for reph is post-main, it will skip abovebase matras that also have a post-main position.
f. Otherwise, reorder reph to the end of the syllable.
Reorder pre-base reordering consonants: If a pre-base reordering consonant is
found, reorder it according to the following rules:
a. Only reorder a glyph produced by substitution during application of the
'pref' feature. (Note that a font may shape a Ra consonant with the 'pref'
feature generally but block it in certain contexts.)
b. Try to find a target position the same way as for pre-base matra. If it is
found, reorder pre-base consonant glyph.
c. If position is not found, reorder immediately before main consonant.

Character reordering Classes for Gujarati:
Characters

Reorder Class

0AB0 (reph)

BeforePostscript

0ABF

BeforeHalf

0AC5, 0AC, 0AC8

AfterSubscript

0AC1-0AC4, 0AE2, 0AE3

AfterPostscript

0ABE, 0AC0, 0AC9, 0ACB, 0ACC

AfterPostscript

Shape glyph sequences (GSUB processing)
All characters from a string are first mapped to their nominal glyphs using the cmap
lookup. The shaping engine then proceeds to shape (substitute) the glyphs using GSUB
lookups.
The features for localized forms and basic shaping forms are applied one at a time to the
cluster or a relevant portion of the cluster.
The results after basic shaping forms features have been applied impact the final syllable
analysis in terms of final designation of Ra as a pre-base reordering form and final
reordering positions for reph and matras. Next, the features for presentation forms are

applied to the entire cluster simultaneously. Note: since the presentation form features
are applied simultaneously over the entire cluster, several features are operationally
equivalent to a single feature. Multiple features are provided as an aid for font
developers to organize the lookups they implement.
Note: final reordering occurs after features for basic shaping forms have been applied
and before features for presentation forms are applied. Font developers must consider
the effects of initial reordering (before any features are applied) and final reordering
(after basic shaping forms features have applied) when they create GSUB feature and
lookup tables.
These predefined features are described and illustrated in the Features section and are
applied in the order below.

Shaping features:
Localized forms
1. Apply feature 'locl' to select language-specific forms.
Basic Shaping forms
1. Apply feature 'nukt' to substitute nukta forms of consonants.
2. Apply feature_'akhn'_ to substitute required akhand ligatures, or to substitute
forms that take precedence over forms produced by features applied later.
3. Apply feature 'rphf' to substitute reph glyph (above-base form of 'Ra').
4. Apply feature 'rkrf' to substitute any rakaar ligatures.
5. Apply feature blwf' to substitute below-base forms.
6. Apply feature 'half' to substitute half forms of pre-base consonants.
7. Apply feature 'vatu' to substitute ligature consonant-vattu or conjunct-vattu forms
for sequences of a consonant or conjunct glyph (full or half form) followed by the
below-base rakaar mark. (This feature is not needed if the rkrf feature is used, but
is available for old-behavior implementations).
8. Apply feature 'cjct' to substitute conjunct forms. (This is needed particularly for
ligature conjuct forms when the pre-base consonant does not have a half form).
Presentation forms
1. Apply feature 'pres' to substitute pre-base consonant conjuncts and pre-base
matra conjuncts. (ie. consonant and matra conjuncts to the left of the base glyph).
2. Apply feature 'abvs' to substitute above-base matra conjuncts, reph conjuncts,
above-base vowel modifiers and above-base stress and tone marks.

3. Apply feature 'blws' to substitute below-base consonant conjuncts, below-base
matra conjuncts, below-base vowel modifier forms and below-base stress and tone
mark forms.
4. Apply feature 'psts' to substitute post-base consonant conjuncts, post-base matra
conjuncts and post-base vowel modifiers.
5. Apply feature 'haln' to substitute the halant form of base (or conjunct base) glyph
in syllables ending with a halant.
6. Apply feature 'calt' to substitute the contextual alternate of a consonant.

Position glyph sequences (GPOS processing)
The shaping engine next processes the GPOS (glyph positioning) table, applying
features concerned with positioning. All features are applied simultaneously to the
entire cluster.
The font developer must consider the effects of re-ordering when creating the GPOS
feature and lookup tables (i.e., the glyphs will be in the order they were in after the
GSUB presentation forms features were applied).

Positioning features:
Kerning
1. Apply feature 'kern' to adjust distances (e.g., to provide kerning between post- or
pre-base elements and the base glyph).
2. Apply feature 'dist' to adjust distances. (NOTE - the feature 'dist' can be used in the
same way as the 'kern' feature. The advantage of using the 'dist' feature is that it
does not rely on the application to enable kerning. Therefore, if you want to make
sure certain spacing adjustments will always be displayed, you should use the 'dist'
feature).
Above-base marks
1. Apply feature 'abvm' to position above-base forms, vowel modifiers and or
stress/tone marks (on base glyph or post-base matra).
Bel0w-base marks
1. Apply feature 'blwm' to position below-base forms, vowel modifiers and or
stress/tone marks.

Base elements

Commonly, a feature is required for dealing with the base glyph and one of the postbase, pre-base or above-base elements. Since it is not possible to reorder ALL of these
elements next to the base glyph, we need to skip over the elements "in the middle"
(reordering-wise).
The solution is to assign different mark attachment classes to different elements of the
syllable and positional forms, and in any given lookup work with one mark type only. For
example, in above-base substitutions we need only consider above-base elements most
of the time.
Generally, it is good practice to label as "mark" glyphs that are denoted as marks in the
Unicode Standard as well as below-base/above-base forms of consonants. Then,
different attachment classes should be assigned to different marks depending on their
position with respect to the base.
For example, after the shaping engine has re-ordered elements within the cluster,
matras will always occur before syllable modifier sign such as the candrabindu. In an
actual sequence, though, potentially some other mark glyph, such as nukta, may occur
between the matra and the candrabindu. Thus, when processing the matra and
candrabindu, you may need to allow for the possibility that some other mark glyph(s)
may occur between them. Using lookup flags, you can specify that a lookup should
process only a certain class of marks, such as 'above-base marks', and ignore all other
marks. In that way, a match will occur whether or not a mark from another class is
present. Otherwise, the lookup would fail to apply.
Using Microsoft VOLT, you can assign glyphs to attachment classes.
In the example below this 'abvm' feature was set to process only TopMarks, therefore
the presence of another mark class would be ignored. If Process ALL was used and
another mark glyph followed the matra, this positioning lookup would fail to apply. This
example comes from the Devanagari font Mangal.

Invalid combining marks
Combining marks and signs that do not occur in conjunction with a valid base are
considered invalid. Shaping engine implementations may adopt different strategies for
how invalid marks are handled. For example, a shaping engine implementation might
treat an invalid mark as a separate cluster and display the stand-alone mark positioned
on some default base glyph, such as a dotted circle. (See Fallback Rendering in section
5.13 of the Unicode Standard 4.0.) Shaping engine implementations may vary somewhat
with regard to what sequences are or are not considered valid. For instance, some
implementations may impose a limit of at most one above-base vowel mark while
others may not.
To allow for shaping engine implementations that expect to position an invalid mark on
a dotted circle, it is recommended that a Gujarati OT font contain a glyph for the dotted
circle character, U+25CC. If this character is not supported in the font, such
implementations will display invalid signs on the missing glyph shape (white box).

In addition to the 'dotted circle' other Unicode code points that are recommended for
inclusion in any Gujarati font are the ZWJ (zero width non-joiner; U+200C), the ZWNJ
(zero width joiner; U+200D) and the ZWSP (zero width space; U+200B). For more
information see the Suggested glyphs section of the OpenType Font Development
document.

Effect of ZWJ, ZWNJ and NBSP on Consonant
Shaping
Unicode defines specific behaviors for zwj and zwnj in relation to Indic scripts. The Indicspecific behavior retains the general behavior that zwj requests connection between text
elements while zwnj inhibits connection between text elements.
1. The main intent of using ZWJ in this context is to prevent a ligature-conjunct from
forming (and in Devanagari or Gujuarati, to request a half form, below-base form
or post-base form instead). The Indic engine does not need to take any action to
prevent ligature-conjuct formation: the presence of ZWJ will prevent GSUB
substitution lookups from matching the input glyph sequence. If the first
consonant does not have a half form, an overt-halant form should result, which
would also happen with no particular action by the engine.
2. A secondary intent of using ZWJ in this context is to prevent the display of reph in
the case that the first consonant is RA. If a cluster begins with RA H (halant) ZWJ,
the engine must ensure that the 'rphf' feature is not applied, and that re-ordering
for reph does not take place. Note that use of either joiner in this context should
prevent formation and re-ordering of reph when RA is the first consonant.
3. The main intent of using ZWNJ is to prevent conjunct ligature or half forms from
forming, and to display an explicit halant form instead. The shaping engine must
take specific actions to prevent half forms for a sequence of Consonant + Halant +
ZWNJ.

The following example illustrates these behaviors:

Just as the zwj can be used to display a half form in isolation, it can also be used to
display a mark, sub- or post-base form in isolation. Unlike the stand-alone half form,
however, sequences to display them must begin with a no-break space (NBSP). This is
because marks, sub- and post-base forms have a 'zero-width' so must be placed on the
NBSP. For example, to get a shape of I-matra without the dotted circle one should type
NBSP + I-matra.
In the illustration below the I-matra is displayed without the dotted circle by using the
NBSP.
The combination of NBSP and ZWJ is used to display the below-base form of Ra
(Rakaar) in isolation.

Features
The features listed below have been defined to create the basic forms for the languages
that are supported on Gujarati systems. Regardless of the model an application chooses
for supporting layout of complex scripts, the shaping engine requires a fixed order for
executing features within a run of text to consistently obtain the proper basic form.
The features of the basic shaping forms are applied one at a time to the cluster or
portion of the cluster. The result impacts the analysis in terms of the conjoining behavior
and final reordering. The features of the presentation forms are applied next, to the
entire cluster simultaneously. Mandatory features must always be applied; the
discretionary presentation-forms features listed should be applied by default, but can be
suppressed by a client (normally at the discretion of the user).

The order of the lookups within each feature is also very important. For more
information on lookups and defining features in OpenType fonts, see the Encoding
section of the OpenType Font Development document.
OpenType features used for Gujarati scripts, applied in the following order:
Feature

Feature function

Layout operation

Localized forms:
locl

Localization form substitution

GSUB

Basic shaping forms:
nukt

Nukta form substitution

GSUB

akhn

Akhand ligature substitution

GSUB

rphf

Reph form substitution

GSUB

rkrf

Rakaar form substitution

GSUB

blwf

Below-base form substitution

GSUB

half

Half-form substitution

GSUB

vatu

Vattu variants

GSUB

cjct

Conjunct form substitution

GSUB

Mandatory presentation forms:
pres

Pre-base substitution

GSUB

abvs

Above-base substitution

GSUB

blws

Below-base substitution

GSUB

psts

Post-base substitution

GSUB

haln

Halant form substitution

GSUB

Discretionary presentation forms:
calt

Contextual alternates

GSUB

Positioning features:
kern

Kerning

GPOS

dist

Distances

GPOS

abvm

Above-base mark positioning

GPOS

blwm

Below-base mark positioning

GPOS

[GSUB = glyph substitution, GPOS = glyph positioning]

Feature examples
Many of the registered features described and illustrated in this document are based on
the Microsoft OpenType font Shruti. Shruti contains layout information and glyphs to
support all of the required features for the Gujarati script and language systems
supported.
The illustrations in the following examples show the result of that particular feature
being applied. Features must be written to match glyph sequences after re-ordering has
occurred. Note that the input context for a feature may be the result of a previous
feature having already been applied.

Localized forms
Feature Tag: "locl"
This feature is used in association with OpenType language system tags to trigger
lookups that will select alternate glyphs needed for language-specific typographic
conventions. The 'locl' should not be used in association with the default language
system, but only used with other language system tags. See the Appendix of this
document for language system tags associated with Gujarati script.

Basic shaping forms
Nukta
Feature Tag: "nukt"
The nukta alters the way a preceding consonant is pronounced. Many of the nukta
forms have been defined as separate glyphs in Unicode with their own code points. All
consonants, as well as akhand forms should have an associated nukta form.
Note - Rather than using substitution, nukta forms can also be created by positioning
the nukta as a below-base mark on the base glyph using the 'blwm' positioning feature
The input context for the nukt feature always consists of the full form of the consonant.
The half form of nukta consonants will be substituted using the half feature.

Nukta feature applied substitutes Kha-nukta pre-composed glyph:

Akhand
Feature Tag: "akhn"
An akhand is a required consonant ligatures that may appear anywhere in the syllable,
and may or may not involve the base glyph. Akhand ligatures have the highest priority
and are formed first; some languages include them in their alphabets. There are 2
Akhand ligatures in Gujarati.
The input context for the akhand feature always consists of the full form of the
consonant. The half forms of Akhand ligatures will be called later in the half feature.
Because the akhand feature is applied early in the sequence of features and is applied
over the entire cluster, it can also be used to create certain forms that must take priority
in particular contexts over forms that would be created during subsequent feature
application.
Using the 'akhn' feature, Ka + halant + Ssa is substituted with the KaSsa ligature:

Ja + halant + Nya is substituted with the JaNya ligature:

Reph
Feature Tag: "rphf"
Applying this feature substitutes the Reph glyph. If the first consonant of the cluster
consists of the full form of Ra + Halant, this feature substitutes the combining-mark
form of Reph. In addition, the position of the Reph glyph is adjusted with the 'abvm'
GPOS feature.

The input context for the Reph feature always consists of the full form of Ra + Halant.
Reph feature substitutes the mark glyph form of Ra. Positioning is adjusted in the 'abvm'
GPOS feature:

Reph feature applied with multiple consonants. Note- reph is re-ordered to position on
the 1st main consonant:

Rakaar
Feature Tag: "rkrf"
Applying this feature substitutes a consonant-rakaar (below-base Ra) ligature or an
akhand-rakaar ligature. For consonants that do not form a ligature with the rakaar, the
'rkrf' feature may also be used to substitute a pre-composed glyph for the consonant
plus rakaar.
Note: the rakaar forms feature is required specifically for those scripts in which a halfform of a consonant-rakaar ligature can occur. This includes Devanagari and Gujarati
scripts. It is not used for the other Indic scripts.
The input context for the rakaar feature always consists of the full form consonant +
halant + Ra. The half forms of rakaar ligatures should be substituted using the half
feature.
The 'rkrf' feature applied to substitute the rakaar form of Ka:

Rakaar variants for 'nukta' glyphs as well as 'akhand' ligatures should also be created:

For consonants that do not form a ligature with the rakaar (like the Ddha) the 'rkrf'
feature may also be used to substitute a pre-composed glyph for the consonant plus
rakaar combination:

Below form of consonant
Feature Tag: "blwf"
This feature substitutes the below-base forms of Consonants like the Ra in Gujarati (aka
'rakaar') when the rakaar does not form a ligature with the preceding consonant. If the
rakaar and preceding consonant do form a ligature, it should be created in the previous
feature 'rkrf'.
Halant plus Ra (preceded by a consonant which does not form a 'rkrf' ligature)
substitutes the rakaar form:

Half form of consonant
Feature Tag: "half"
Applying this feature substitutes half forms - forms of consonants used in the pre-base
position. Consonants that have a half form should be listed in the 'half' feature. Gujarati
has distinctly shaped half forms for most of the consonants as well as nukta and Akhand
glyphs. If a consonant does not have a distinct shape for the half form and does not

form any ligature, it will be displayed with an explicit Virama (same shape as the halant
form).
Note - the result of listing a consonant in the half feature (whether it has a true half
form or not) will affect the re-ordering (and positioning) of the reph and pre-pended
matras. See illustration in the Introduction section of this document.
This feature is applied to all consonants preceding the 'main' consonant.
Example 1 - Half feature substitutes half form of Kha:

Example 2 - Half feature applied to multiple consonants:

Example 3 - Half feature used to substitute half form of Ga Nukta:

Example 4 - Half form of Akhand ligature (DaNya):

Example 5 - Half feature applied to Cha, produces 'halant' form of Cha since it has no
distinct half form shape:
(remember listing the Cha in the half feature will cause it to behave like a half form for
purposes of re-ordering)

Vattu variants
Feature Tag: "vatu"

The 'vatu' feature can be used to substitute a ligature of a full (or half) form consonant
plus a below-base vattu (rakaar) mark. This feature was needed in earlier
implementations to combine rakaar with both full and half forms It is not useful,
however, for newer implementations that distinguish consonants that do not have half
forms from other consonants, for purposes of re-ordering the reph and pre-pended
matras. In Gujarati, this feature is not required if the 'rkrf' feature is used, however it is
still supported for backward compatibility with existing fonts.
Example; the 'vatu' feature used in earlier implementations of the shaping engine to
substitute a ligature of consonant (full or half form) plus vattu (rakaar), which now
should be created using the 'rkrf' and 'half' features.

Conjunct forms
Feature Tag: "cjct"
Apply feature 'cjct' to substitute conjunct forms where the first consonant in the
consonant-cluster pair does not have a half form. This feature allows for control over reordering 'Žof reph and pre-pended matras in case of consonants that do not take half
forms yet do form 'Žconjunct ligatures in combination with certain following
consonants.
The 'cjct' feature applied to substitute conjunct form of Da + Ga:

The 'cjct' feature applied to substitute conjunct form of Da + Ma:

The 'cjct' feature applied to substitute conjunct form of Ha + La:

Presentation forms
After the glyphs have been reordered, the presentation lookups are applied to provide
the best typographic rendering of the text. The features of the presentation forms are
applied to the entire cluster simultaneously, executing lookups within each feature in
the order that they are specified in the font.
The pres, abvs, blws, psts and haln features are all mandatory for software
implementations: they are required for correct script behaviour and none should ever be
treated as discretionary. Because of this and because they are all applied simultaneously
over entire clusters, they are not functionally different: a set of lookups could be divided
between these features or grouped together under one of them with no difference in
effect. These multiple features are provided, however, as an aid to the font developer for
organizing lookups based on the combinations of glyphs they apply to. There are no
specific requirements on how each should be used; the examples provided below
illustrate typical usage, however.

Pre-base substitutions
Feature Tag: "pres"
This feature is used to substitute pre-base consonant conjuncts made with half forms,
the type most common in Gujarati. The resulting conjunct can be in full or half form. See
examples 1-4.
This feature is also used to select typographically correct forms of the I-Matra. For
example, a font can have several versions of the I-Matra to be used in context with
different consonant bases or clusters. See example 5. In addition the 'pres' feature can
contain pre-composed ligatures of the I-matra with certain bases. See example 6.
Example 1 - half Nya + full Ca is substituted by the full NyaCa conjunct:

Example 2 - half Sha + full Ca is substituted by the full ShaCa conjunct:

Example 3 - half Nya + full CaRa is substituted by the full NyaCaRa conjunct:

Example 4 - half Sha + full CaRa is substituted by the full ShaCaRa conjunct:

Example 5 - Using MS Volt, different shapes of the I-matra are selected based on the
context. Note; in this example 'glyph groups' listing consonants with similar widths, have
been used for substitution context.

Example 6 - Using MS Volt, conjunct syllables are created using the 'pres' feature:

Above-base substitutions
Feature Tag: "abvs"
This feature is used for glyph substitutions involving above-base marks. Such
substitutions might be used to select contextual forms of marks, to create mark-mark
ligatures, or to create mark-base ligatures. Specific context-dependent forms or belowbase consonants are handled by this lookup as well.
Example 1- contextual 'abvs' substitution; used to select smaller matra-Ai, when
preceded by the Ka:

Example 2- mark to mark 'abvs' substitution; matre Ii + reph substituted with matraIireph ligature:

Example 3- mark to base 'abvs' substitution; vowel I + candrabindu substituted with a
pre-composed ligature:

Below-base substitutions
Feature Tag: "blws"
This feature is used for glyph substitutions involving below-base marks or consonants.
Such substitutions can be used to create conjuncts of base glyphs with below-base
consonants, below mark ligatures or below mark-base ligatures. Specific contextdependent forms are handled by this lookup as well.
Example 1- 'blws' substitution to create base + below base conjunct:

Example 2- 'blws' substitution to create base + below mark conjunct:

Example 3- Using MS Volt, alternate versions of matras are selected based on the
context. Note; in this example 'glyph groups' listing various consonants are used for the
substitution context.

Post-base substitutions
Feature Tag: "psts"
This feature is used to substitute post-base consonants or matras. Such substitutions
can be used to create conjuncts of base glyphs with post-base consonants or post-base
matra ligatures. It can also be used to specify contextual alternates of post-base forms.
Example 1- 'psts' substitution for post-base ligatures; Ja Matra-Ii substituted with a
ligature:

Example 2 - Using MS Volt, different shapes of the vowel Ii are substituted based on the
context. Note; in this example 'glyph groups' listing consonants with similar widths are

used for the substitution context.

Halant form of consonants
Feature Tag: "haln"
This feature is used to substitute a pre-composed halant form of a base (or conjunct
base) glyph in syllables ending with a halant. (Rather than using substitution, halant
forms can also be created by positioning the halant as a below-base mark on the base
glyph using the 'blwm' positioning feature.)
This feature is applied only on the base glyph if the syllable ends with a halant, or in the
case of non-final consonants that do not take a half form and do not form a conjunct
ligature with the following consonant.
Example 1 - 'haln' feature used to substitute halant form of base glyph:

Example 2 - 'haln' feature used to substitute halant form of conjunct base glyph
(ChaNuktaRa):

Example 3 - 'haln' feature used to substitute halant form of conjunct base glyph:

Contextual Alternates
Feature Tag: "calt"
Unlike the previous presentation lookups, the 'calt' feature is optional and is used to
substitute discretionary contextual alternates. It is important to note that an application
may allow users to turn off this feature, therefore should not be used for any obligatory
Gujarati typography.

Positioning features
Distances
Feature Tag: "dist"
This feature covers positioning lookups that adjust distances between glyphs, such as
kerning between pre- and post-base elements and the base glyph. Note; the feature
'dist' can be used in the same way as the 'kern' feature. The advantage of using the 'dist'
feature is that it does not rely on the application to enable kerning.
Example 1 - Using MS Volt, 'dist' feature used to adjust distance of SaRa to align
properly with I-matra:

Above-base marks
Feature Tag: "abvm"
This feature positions all above-base marks on the base glyph or the post-base matra.
The best method for encoding this feature in an OpenType font is to use a chaining
context positioning lookup that triggers mark-to-base and mark-to-mark attachments
for above-base marks.
The 'abvm' lookup in MS Volt using 'Pair Adjustment' for adjusting positions of abovemarks in a certain context:

The 'abvm' lookup in MS Volt using 'Anchor Attachment' for adjusting positions of
above-marks with bases:

Below-base marks
Feature Tag: "blwm"
This feature positions all below-base marks on the base glyph. The best method for
encoding this feature in an OpenType font is to use a chaining context positioning
lookup that triggers mark-to-base and mark-to-mark attachments for below-base
marks.
The 'blwm' lookup in MS Volt using 'Anchor Attachment' for adjusting positions of
below-marks with bases:

Examples of Gujarati syllables
Complex Gujarati syllable formation is possible using the wide range of features
available in OpenType. The following examples show how the shaping engine applies
the OpenType features, one at a time to the input string. These combinations do not
necessarily represent actual syllables or words, but are meant to illustrate the various
OpenType features in a Gujarati font.

Example #1: Input text string and resulting display as OT features are applied.

Example #2: Input text string and resulting display as OT features are applied.

Example #3: Input text string and resulting display as OT features are applied.

Appendices
Appendix A: Writing System Tags
Features are encoded according to both a designated script and language system.
Currently most shaping engine implementations only support the "default" language
system for each script. However, font developers may want to build language specific
features which are supported in other applications and will be supported in future
Microsoft OpenType implementations.
NOTE: It is strongly recommended to include the "dflt" language tag in all OpenType
fonts because it defines the basic script handling for a font. The "dflt" language system
is used as the default if no other language specific features are defined, or if the
application does not support that particular language. If the "dflt" tag is not present for
the script being used, the font may not work in some applications.
The following table lists the registered tag names for script and language systems. Note
for new Indic shaping implementation “gjr2” is used (old-behavior implementations

used “gujr”).
Registered tags for the Gujarati script

Registered tags for Gujarati language
systems

Script tag

Script

Language
system tag

Language

"gjr2"

Gujarati

"dflt"

*default script handling

"GUJ "

Gujarati

Note: both the script and language tags are case sensitive (script tags should be
lowercase, language tags are all caps) and must contain four characters (ie. you must
add a space to the three character language tags).

Developing OpenType Fonts for
Gurmukhi Script
Article • 06/16/2022

Please note: This document reflects the changes made in 2005 for recommendations for
Indic-script OpenType font and shaping-engine implementations. While Indic fonts
made according to the earlier recommendations will still function properly in new
versions of Uniscribe, font developers may wish to update their fonts, particularly if they
wish to avoid certain limitations of the earlier implementation.
This document presents information that will help font developers create or support
OpenType fonts for the Gurmukhi script covered by the Unicode Standard. Gurmukhi is
used to write the Punjabi language in the Punjab in India.

Introduction
This document targets developers implementing Indic shaping behavior compatible
with Microsoft OpenType specification for Indic scripts. It contains information about
terminology, font features and behavior of the Indic shaping engine in regards to the
Gurmukhi script. While it does not contain instructions for creating Gurmukhi fonts, it
will help font developers understand how the Indic shaping engine processes Indic text.
In addition, registered features of the Gurmukhi script are defined and illustrated with
examples.
The new Indic shaping engine allows for variations in typographic conventions, giving a
font developer control over shaping by the choice of designation of glyphs to certain
OpenType features. For example, the location where pre-pended matras and the reph (in
scripts like Devanagari) are re-ordered within a syllable cluster is affected by the
presence of a half form. While there are no half-forms in Gurmukhi, the half feature is
made available for typographic preferences. See illustrations below.

The Indic shaping engine always re-orders a pre-pended matra immediately in front of
the previous base consonant (or half form, if there is one).
Option 1: (default results) because the Ka is not listed in the half feature; the shaping
engine treats the Ka as the first main consonant and re-orders the I-matra immediately
in front of the previous base consonant.
Option 2: While the Ka does not have a true half form in Gurmukhi, it can be listed in the
'half' feature lookup substituting the 'halant form' of Ka. Thus, the shaping engine will
treat it as a half form and the I-matra will be positioned immediately in front of the
"half-form" K(a).

Glossary
The following terms are useful for understanding the layout features and script rules
discussed in this document.
Above-base form of consonants - A variant form of a consonant that appears above
the base glyph.
Akhand ligatures - Required consonant ligatures that may appear anywhere in the
syllable, and may or may not involve the base glyph. Akhand ligatures have the highest
priority and are formed first; some languages include them in their alphabets. Akhand
ligatures may be displayed in either half- or full-form.
Base glyph - The only consonant or consonant conjunct in the orthographic syllable that
is written in its "full" (nominal) form. In Gurmukhi, the last consonant of the syllable
usually forms the base glyph. In "degenerate" syllables that have no vowel (last letter of
a word), the last consonant in halant form serves as the base consonant and is mapped
as the base glyph. Layout operations are defined in terms of a base glyph, not a base
character, since the base can often be a ligature.

Below-base form of consonants - A variant form of a consonant that appears below the
base glyph. In the glyph sequence, the below-base form comes after the consonant(s)
that form the base glyph. Below-base forms are represented by a non-spacing mark
glyph.
Cluster - A group of characters that form an integral unit in Indic scripts, often times a
syllable.
Consonant - Each represents a single consonant sound. Consonants may exist in
different contextual forms and have an inherent vowel (usually, the short vowel "a"). For
example, "Ka" and "Ta", rather than just "K" or "T."
Consonant conjuncts (aka "conjuncts") - Ligatures of two or more consonants.
Consonant conjuncts may have both full and half forms, or only full forms.
Gurmukhi syllable - Effective orthographic "unit" of Gurmukhi writing systems. Syllables
are composed of consonant letters, independent vowels, and dependant vowels. In a
text sequence, these characters are stored in phonetic order (although they may not be
represented in phonetic order when displayed). Once a syllable is shaped, it is
indivisible. The cursor cannot be positioned within the syllable. Transformations
discussed in this document do not cross syllable boundaries.
Halant (Virama) - The character used after a consonant to "strip" it of it's inherent
vowel. A Halant follows all but the last consonant in every Gurmukhi syllable.
NOTE: A syllable containing halant characters may be shaped with no visible halant
signs by using different consonant forms or conjuncts instead.
Halant form of consonants - The form produced by adding the halant (virama) to the
nominal shape. The Halant form is used in syllables that have no vowel or as the half
form when no distinct shape for the half form exists.
Half form of consonants (pre-base form) - A variant form of consonants which appear
to the left of the base consonant, if they do not participate in a ligature. Consonants in
their half form precede the ones forming the base glyph. Some Indic scripts, like
Devanagari have distinctly shaped half forms for most of the consonants. If not distinct
shape exists, the full form will display with an explicit Vrama (same shape as the halant
form).
Matra (Dependent Vowel) - Used to represent a vowel sound that is not inherent to the
consonant. Dependent vowels are referred to as "matras" in Sanskrit. They are always
depicted in combination with a single consonant, or with a consonant cluster. The
greatest variation among different Indian scripts is found in the rules for attaching
dependent vowels to base characters.

New shaping behavior - Shaping behavior defined in this version of the Indic OpenType
Font Specification. Information in this document relates primarily to the new
implementation model. Old behavior may be mentioned in comments about
compatibility.
Nukta - A combining character that alters the way a preceding consonant (or matra) is
pronounced.
Old shaping behavior - Shaping behavior defined in previous versions of the Indic
OpenType Font Specification.
OpenType layout engine - Library responsible for executing OpenType layout features
in a font. In the Microsoft text formatting stack, it is named OTLS (OpenType layout
services).
OpenType tag - 4-byte identifier for script, language system or feature in the font.
Post-base form of consonants - A variant form of a consonant that appears to the right
of the base glyph. A consonant that takes a post-base form is preceded by the
consonant(s) forming the base glyph plus a halant (virama). Post-base forms are usually
spacing glyphs.
Pre-base form of consonants - A variant form of a consonant that appears to the left of
the base glyph. Note that most pre-base consonant forms are logically as well as visually
before the base consonant. Half forms are examples of this kind of pre-base form. In
some scripts, though, a pre-base Ra may logically follow the base consonant (that is, it
follows it phonetically and in the character sequence of the text), even though it is
presented visually before the base. The shaping engine detects such cases dynamically
using the 'pref' feature and re-orders the pre-base-form glyph as needed.
Reph - The above-base form of the letter "Ra" that is used in the Devanagari script,
when "Ra" is the first consonant in the syllable and is not the base consonant.
Shaping Engine - Code responsible for shaping input, classified to a particular script.
Split Matra - A matra that is decomposed into pieces for rendering. Usually the different
pieces appear in different positions relative to the base. For instance, part of the matra
may be placed at the beginning of the cluster and another part at the end of the cluster.
Syllable - A single unit of Indic text processing. Shaping of Indic text is performed
independently for each syllable. Process of identifying boundaries of each syllable is
described below.
Vattu - A below-base form of a consonant.

1. Pre-base form
2. The base consonant
3. Above-base form (reph)
4. Post-base (matra)
5. Below-base form (vattu/rakaar)

Shaping Engine
Analyze the text
Reorder characters
Shape glyph sequences (GSUB processing)
Position glyphs sequences (GPOS processing)
Base elements
Invalid combining marks
Use of ZWJ, ZWNJ and NBSP
The Indic shaping engine processes Gurmukhi text in stages. The stages are:
1. Analyze the text sequence; breaking it into syllable clusters
2. Reorder the characters as necessary
3. Apply OpenType GSUB font features to get the correct glyph shape
4. Apply OpenType GPOS features to position glyphs or marks
The descriptions which follow will help font developers understand the rationale for the
Gurmukhi feature encoding model, and help application developers better understand
how layout clients can divide responsibilities with operating system functions.

Analyze the text
Character properties
The shaping engine divides the text into syllable clusters and identifies character
properties. Character properties are used in parsing syllables and identifying its parts, in
determining proper character or glyph reordering and in OpenType feature application.

Properties for each character are divided into two types: static properties and dynamic
properties.
Static properties define basic characteristics that do not change from font to font:
character type (consonant, matra, vedic sign, etc.) or type of matra reordering. They
differ from script to script, but can't be controlled by font developer.
Dynamic properties are font dependent and are retrieved by the shaping engine as the
font is loaded. These properties affect shaping and reordering behavior.
*Note: in old shaping-engine implementations, all consonant properties were static:
consonants were assumed to have particular conjoining forms. In the new
implementation model, consonant conjoining behavior is a dynamic property.

Retrieving dynamic character properties from Indic fonts
Fonts define dynamic properties for consonants through implementing standard
features. Consonant types (and corresponding feature tags) that the shaping engine
reads from the font are:
Reph 'rphf'
Half forms 'half'
Pre-base-reordering forms of Ra/Rra 'pref'
Below-base forms 'blwf'
Post-base forms 'pstf'
Each of the features above is applied together with 'locl' feature to input sequences
consisting of two characters: for 'rphf' and 'half', features are applied to Consonant +
Halant combinations; for 'pref', 'blwf' and 'pstf', features are applied to Halant +
Consonant combinations. This is done for each consonant. If these two glyphs form a
ligature, with no additional glyphs in context, this means the consonant has the
corresponding form. For instance, if a substitution occurs when the 'half' and 'locl'
features are applied to a sequence Da + Halant, then Da is classified as having a half
form.
Note that a font may be implemented to re-order a Ra to pre-base position only in
certain syllables and display it as a below-base or post-base form otherwise. This means
that the Pre-base-form classification is not mutually exclusive with either Below-baseform or Post-base-form classifications. However, all classifications are determined as
described above using context-free substitutions.
Font-dependent character classification only defines consonant types. Reordering
positions, however, are fixed for each character class.

*Note: for fonts that support the old implementation, all features are applied to
Consonant + Halant sequences.

Indic input processing
The following steps should be repeated while there are characters left in the input
sequence. All shaping operations are done on a syllable-by-syllable basis, independent
from other characters.

Find next syllable in the input
Engine should find the character sequence matching one of the patterns below:
Consonant syllable
{C+[N]+<H+[<ZWNJ|ZWJ>]|<ZWNJ|ZWJ>+H>} +
C+[N]+[A] + [< H+[<ZWNJ|ZWJ>] | {M}+[N]+[H]>]+[SM]+[(VD)]
Vowel-based syllable:
[Ra+H]+V+[N]+[<[<ZWJ|ZWNJ>]+H+C|ZWJ+C>]+[{M}+[N]+[H]]+[SM]+[(VD)]
Stand Alone cluster (at the start of the word only):
[Ra+H]+NBSP+[N]+[<[<ZWJ|ZWNJ>]+H+C>]+[{M}+[N]+[H]]+[SM]+[(VD)]
Where
{}

zero or more occurrences

[]

optional occurrence

<|>

'one of'

()

one or two occurrences

C

consonant

V

independent vowel

N

nukta

H

halant/virama

ZWNJ

zero width non-joiner

ZWJ

zero width joiner

M

matra (up to one of each type: pre-, above-, below- or post- base)

SM

syllable modifier sign

VD

vedic

A

anudatta (U+0952)

NBSP

NO-BREAK SPACE

Identify key positions inside syllable
Syllable structure consists of the following parts:
Reph + HalfConsonant(s) + MainConsonant(s) + BelowBaseConsonant(s) +
PostBaseConsonant(s) + PreBaseReorderingRa + MatrasAndSigns
The consonant parts include all associated halants and nuktas. (For example, an instance
of BelowBaseConsonant consists of a sequence of Halant + Below-base-forming
Consonant.) All parts are optional, except the main consonant.
All parts are shown in the order they would occur within a syllable, with one
qualification: depending on a font implementation, PreBaseReorderingRa may occur
before all BelowBaseConsonants, after BelowBaseConsonants and before
PostBaseConsonants, or after PostBaseConsonants. Also, a font may be implemented to
re-order a Ra to pre-base position only in certain syllables and display it as a belowbase or post-base form otherwise. Thus, final determination of whether an occurrence of
Ra in a specific syllable can be treated as a pre-base reordering Ra can be made only
after the 'pref' feature has been applied to that syllable.
There could be several main consonants in the case where more than one consonant
doesn't have a half-, below-base, post-base or pre-base form. In a case of a cluster
where the first consonant does not have a half form, the shaping engine will recognize it
as the 1st 'full form' and go on to identify the 2nd full form consonant, if there is one.
This information will then be used to determine the reordering behavior of the reph or
any matras, vowel modifiers or stress marks.
All other elements are classified by their position relative to the base: pre-base (half
forms and reordering pre-base Ra forms), below-base, above-base and post-base.

Indic clusters are subject to the following constraints:
Only one reph is allowed per syllable.
Only one pre-base reordering Ra is allowed per syllable.

A nukta can be placed on a consonant, matra or independent vowel. It cannot be
placed on a pre-composed nukta character.
One matra from each positioning class is permitted (exception in the Kannada
script). A composite matra is treated as belonging to all the classes from which its
components belong.
One syllable modifier sign is allowed per cluster.
Vedic signs are combining marks (used for Sanskrit) that should be included in all
Indic scripts.
Danda and Double Danda are punctuation marks that should be included in all
Indic scripts.

Reorder characters
Once the Indic shaping engine has analyzed the cluster as described above, it creates
and manages a buffer of appropriately reordered elements (glyphs) representing the
cluster, according to several rules (described below).
The OpenType lookups in an Indic font must be written to match glyph sequences after
re-ordering has occurred. OpenType fonts should not have substitutions that attempt to
perform the re-ordering. If a font developer attempted to encode such reordering
information in an OpenType font, they would need to add a huge number of many-tomany glyph mappings to cover the general algorithms that a shaping engine will use.
1. Find base consonant: The shaping engine finds the base consonant of the syllable,
using the following algorithm: starting from the end of the syllable, move
backwards until a consonant is found that does not have a below-base or postbase form (post-base forms have to follow below-base forms), or that is not a prebase reordering Ra, or arrive at the first consonant. The consonant stopped at will
be the base.
If the syllable starts with Ra + Halant (in a script that has Reph) and has more
than one consonant, Ra is excluded from candidates for base consonants.
2. Decompose and reorder Matras: Each matra and any syllable modifier sign in the
cluster are moved to the appropriate position relative to the consonant(s) in the
cluster. The shaping engine decomposes two- or three-part matras into their
constituent parts before any repositioning. Matra characters are classified by which
consonant in a conjunct they have affinity for and are reordered to the following
positions:
Before first half form in the syllable
After subjoined consonants

After post-form consonant
After main consonant (for above marks)
3. Reorder marks to canonical order: Adjacent nukta and halant or nukta and vedic
sign are always repositioned if necessary, so that the nukta is first.
4. Final reordering: After the localized forms and basic shaping forms GSUB features
have been applied (see below), the shaping engine performs some final glyph
reordering before applying all the remaining font features to the entire cluster.
Reorder matras: If a pre-base matra character had been reordered before
applying basic features, the glyph can be moved closer to the main
consonant based on whether half-forms had been formed. Actual position for
the matra is defined as 'after last standalone halant glyph, after initial matra
position and before the main consonant'. If ZWJ or ZWNJ follow this halant,
position is moved after it.
Reorder reph: Reph's original position is always at the beginning of the
syllable, (i.e. it is not reordered at the character reordering stage). However, it
will be reordered according to the basic-forms shaping results. Possible
positions for reph, depending on the script, are; after main, before post-base
consonant forms, and after post-base consonant forms.
a. If reph should be positioned after post-base consonant forms, proceed to
step 5.
b. If the reph repositioning class is not after post-base: target position is after
the first explicit halant glyph between the first post-reph consonant and
last main consonant. If ZWJ or ZWNJ are following this halant, position is
moved after it. If such position is found, this is the target position.
Otherwise, proceed to the next step.
Note: in old-implementation fonts, where classifications were fixed in
shaping engine, there was no case where reph position will be found on this
step.
c. If reph should be repositioned after the main consonant: from the first
consonant not ligated with main, or find the first consonant that is not a
potential pre-base reordering Ra.
d. If reph should be positioned before post-base consonant, find first postbase classified consonant not ligated with main. If no consonant is found,
the target position should be before the first matra, syllable modifier sign
or vedic sign.
e. If no consonant is found in steps 3 or 4, move reph to a position
immediately before the first post-base matra, syllable modifier sign or
vedic sign that has a reordering class after the intended reph position. For

example, if the reordering position for reph is post-main, it will skip abovebase matras that also have a post-main position.
f. Otherwise, reorder reph to the end of the syllable.
Reorder pre-base reordering consonants: If a pre-base reordering consonant is
found, reorder it according to the following rules:
a. Only reorder a glyph produced by substitution during application of the
'pref' feature. (Note that a font may shape a Ra consonant with the 'pref'
feature generally but block it in certain contexts.)
b. Try to find a target position the same way as for pre-base matra. If it is
found, reorder pre-base consonant glyph.
c. If position is not found, reorder immediately before main consonant.

Character reordering Classes for Gurmukhi:
Characters

Reorder Class

0A30 (reph)

BeforeSubscript

0A3F

BeforeHalf

0A47, 0A48, 0A4B, 0A4C

AfterSubscript

0A41, 0A42

AfterPostscript

0A3E, 0A40

AfterPostscript

0A01, 0A02, 0A70, 0A71

AfterPostscript

Shape glyph sequences (GSUB processing)
All characters from a string are first mapped to their nominal glyphs using the cmap
lookup. The shaping engine then proceeds to shape (substitute) the glyphs using GSUB
lookups.
The features for localized forms and basic shaping forms are applied one at a time to the
cluster or a relevant portion of the cluster.
The results after basic shaping forms features have been applied impact the final syllable
analysis in terms of final designation of Ra as a pre-base reordering form and final
reordering positions for reph and matras. Next, the features for presentation forms are
applied to the entire cluster simultaneously. Note: since the presentation form features
are applied simultaneously over the entire cluster, several features are operationally

equivalent to a single feature. Multiple features are provided as an aid for font
developers to organize the lookups they implement.
Note: final reordering occurs after features for basic shaping forms have been applied
and before features for presentation forms are applied. Font developers must consider
the effects of initial reordering (before any features are applied) and final reordering
(after basic shaping forms features have applied) when they create GSUB feature and
lookup tables.
These predefined features are described and illustrated in the Features section and are
applied in the order below.

Shaping features:
Localized forms
1. Apply feature 'locl' to select language-specific forms.
Basic Shaping forms
1. Apply feature 'nukt' to substitute nukta forms of consonants.
2. Apply feature 'akhn' to to substitute required akhand ligatures, or to substitute
forms that take precedence over forms produced by features applied later.
3. Apply feature 'rphf' to substitute the reph glyph (above-base form of 'Ra').
4. Apply feature blwf' to substitute below-base forms.
5. Apply feature 'half' to substitute half forms of pre-base consonants.
6. Apply feature 'pstf' to substitute post-base forms.
7. Apply feature 'vatu' to substitute ligature consonant-vattu or conjunct-vattu forms
for sequences of a consonant or conjunct glyph (full or half form) followed by the
below-base rakaar mark. (This feature is not needed if the rkrf feature is used, but
is available for old-behavior implementations).
8. Apply feature 'cjct' to substitute conjunct forms. (This is needed particularly for
ligature conjuct forms when the pre-base consonant does not have a half form).
Presentation forms
1. Apply feature 'pres' to substitute pre-base consonant conjuncts and pre-base
matra conjuncts. (ie. consonant and matra conjuncts to the left of the base glyph).
2. Apply feature 'abvs' to substitute above-base matra conjuncts, above-base vowel
modifiers and above-base stress and tone marks.
3. Apply feature 'blws' to substitute below-base consonant conjuncts, below-base
matra conjuncts, below-base vowel modifier forms and below-base stress and tone
mark forms.

4. Apply feature 'psts' to substitute post-base consonant conjuncts, post-base matra
conjuncts and post-base vowel modifiers.
5. Apply feature 'haln' to substitute the halant form of base (or conjunct base) glyph
in syllables ending with a halant.
6. Apply feature 'calt' to substitute the contextual alternate of a consonant.

Position glyph sequences (GPOS processing)
The shaping engine next processes the GPOS (glyph positioning) table, applying
features concerned with positioning. All features are applied simultaneously to the
entire cluster.
The font developer must consider the effects of re-ordering when creating the GPOS
feature and lookup tables (i.e., the glyphs will be in the order they were in after the
GSUB presentation forms features were applied).

Positioning features:
Kerning
1. Apply feature 'kern' to adjust distances (e.g., to provide kerning between post- or
pre-base elements and the base glyph).
2. Apply feature 'dist' to adjust distances. (NOTE - the feature ' dist' can be used in the
same way as the ' kern' feature. The advantage of using the ' dist' feature is that it
does not rely on the application to enable kerning. Therefore, if you want to make
sure certain spacing adjustments will always be displayed, you should use the 'dist'
feature).
Above-base marks
1. Apply feature 'abvm' to position above-base forms, vowel modifiers and or
stress/tone marks (on base glyph or post-base matra).
Bel0w-base marks
1. Apply feature 'blwm' to position below-base forms, vowel modifiers and or
stress/tone marks.

Base elements
Commonly, a feature is required for dealing with the base glyph and one of the postbase, pre-base, above-base or below-base elements. Since it is not possible to reorder

ALL of these elements next to the base glyph, we need to skip over the elements "in the
middle" (reordering-wise).
The solution is to assign different mark attachment classes to different elements of the
syllable and positional forms, and in any given lookup work with one mark type only. For
example, in above-base substitutions we need only consider above-base elements most
of the time.
Generally, it is good practice to label as "mark" any glyphs that are denoted as
combining marks in the Unicode Standard as well as below-base/above-base forms of
consonants. Then, different attachment classes should be assigned to different marks
depending on their position with respect to the base.
For example, after the shaping engine has re-ordered elements within the cluster,
matras will always occur before syllable modifier sign such as the candrabindu. In an
actual sequence, though, potentially some other mark glyph, such as nukta, may occur
between the matra and the candrabindu. Thus, when processing the matra and
candrabindu, you may need to allow for the possibility that some other mark glyph(s)
may occur between them. Using lookup flags, you can specify that a lookup should
process only a certain class of marks, such as 'above-base marks', and ignore all other
marks. In that way, a match will occur whether or not a mark from another class is
present. Otherwise, the lookup would fail to apply.
Using Microsoft VOLT, you can assign glyphs to attachment classes.
In the example below this 'abvm' feature was set to process only TopMarks, therefore
the presence of another mark class would be ignored. If Process ALL was used and
another mark glyph followed the matra, this positioning lookup would fail to apply. This
example comes from the Devanagari font Mangal.

Invalid combining marks
Combining marks and signs that do not occur in conjunction with a valid base are
considered invalid. Shaping engine implementations may adopt different strategies for
how invalid marks are handled. For example, a shaping engine implementation might
treat an invalid mark as a separate cluster and display the stand-alone mark positioned
on some default base glyph, such as a dotted circle. (See Fallback Rendering in section
5.13 of the Unicode Standard 4.0.) Shaping engine implementations may vary somewhat
with regard to what sequences are or are not considered valid. For instance, some
implementations may impose a limit of at most one above-base vowel mark while
others may not.
To allow for shaping engine implementations that expect to position an invalid mark on
a dotted circle, it is recommended that a Gurmukhi OT font contain a glyph for the
dotted circle character, U+25CC. If this character is not supported in the font, such
implementations will display invalid signs on the missing glyph shape (white box).

In addition to the 'dotted circle' other Unicode code points that are recommended for
inclusion in any Gurmukhi font are the ZWJ (zero width non-joiner; U+200C), the ZWNJ
(zero width joiner; U+200D) and the ZWSP (zero width space; U+200B). For more
information see the Suggested glyphs section of the OpenType Font Development
document.

Effect of ZWJ, ZWNJ and NBSP on Consonant
Shaping
Unicode defines specific behaviors for ZWJ and ZWNJ in relation to Indic scripts. The
Indic-specific behavior retains the general behavior that ZWJ requests connection
between text elements while ZWNJ inhibits connection between text elements.
1. The main intent of using ZWJ in this context is to prevent a ligature-conjunct from
forming (and in Devanagari or Gujuarati, to request a half form, below-base form
or post-base form instead). The Indic engine does not need to take any action to
prevent ligature-conjuct formation: the presence of ZWJ will prevent GSUB
substitution lookups from matching the input glyph sequence. If the first
consonant does not have a half form, an overt-halant form should result, which
would also happen with no particular action by the engine.
2. The main intent of using ZWNJ is to prevent conjunct ligature or half forms from
forming, and to display an explicit halant form instead. The shaping engine must
take specific actions to prevent half forms for a sequence of Consonant + Halant +
ZWNJ.
Just as the ZWJ can be used to display a half form in isolation, it can also be used to
display a mark, sub- or post-base form in isolation. Unlike the stand-alone half form,
however, sequences to display them must begin with a no-break space (NBSP). This is
because mark glyphs must combine with a base glyph: to appear in isolation, a NBSP
must be provided as a base. For example, to get a shape of I-matra without the dotted
circle one should type NBSP + I-matra.
In the illustration below the I-matra is displayed without the dotted circle by using the
NBSP.
The combination of NBSP and ZWJ is used to display the below-base form of Ra in
isolation.

Features
The features listed below have been defined to create the basic forms for the languages
that are supported on Gurmukhi systems. Regardless of the model an application
chooses for supporting layout of complex scripts, the shaping engine requires a fixed
order for executing features within a run of text to consistently obtain the proper basic
form.
The features of the basic shaping forms are applied one at a time to the cluster or
portion of the cluster. The result impacts the analysis in terms of the conjoining behavior
and final reordering. The features of the presentation forms are applied next, to the
entire cluster simultaneously. Mandatory features must always be applied; the
discretionary presentation-forms features listed should be applied by default, but can be
suppressed by a client (normally at the discretion of the user).
The order of the lookups within each feature is also very important. For more
information on lookups and defining features in OpenType fonts, see the Encoding
section of the OpenType Font Development document.
OpenType features used for Gurmukhi scripts, applied in the following order:
Feature

Feature function

Layout operation

Localized forms:
locl

Localization form substitution

GSUB

Basic shaping forms:
nukt

Nukta form substitution

GSUB

akhn

Akhand ligature substitution

GSUB

rphf

Reph form substitution

GSUB

blwf

Below-base form substitution

GSUB

half

Half-form substitution

GSUB

pstf

Post-base form substitution

GSUB

vatu

Vattu variants

GSUB

cjct

Conjunct form substitution

GSUB

Mandatory presentation forms:
pres

Pre-base substitution

GSUB

abvs

Above-base substitution

GSUB

blws

Below-base substitution

GSUB

psts

Post-base substitution

GSUB

haln

Halant form substitution

GSUB

Discretionary presentation forms:
calt

Contextual alternates

GSUB

Positioning features:
kern

Kerning

GPOS

dist

Distances

GPOS

abvm

Above-base mark positioning

GPOS

blwm

Below-base mark positioning

GPOS

[GSUB = glyph substitution, GPOS = glyph positioning]

Feature examples
Many of the registered features described and illustrated in this document are based on
the Microsoft OpenType font Raavi. Raavi contains layout information and glyphs to
support all of the required features for the Gurmukhi script and language systems
supported.
The illustrations in the following examples show the result of that particular feature
being applied. Features must be written to match glyph sequences after re-ordering has
occurred. Note that the input context for a feature may be the result of a previous
feature having already been applied.

Localized forms
Feature Tag: "locl"
This feature is used in association with OpenType language system tags to trigger
lookups that will select alternate glyphs needed for language-specific typographic
conventions. The 'locl' should not be used in association with the default language
system, but only used with other language system tags. See the Appendix of this
document for language system tags associated with the Gurmukhi script.

Basic shaping forms

Nukta
Feature Tag: "nukt"
The nukta alters the way a preceding consonant or vowel is pronounced. The most
common nukta forms have been defined as separate characters in Unicode with their
own code points. All consonants, as well as akhand forms should have an associated
nukta form.
Note - Rather than using substitution, nukta forms can also be created by positioning
the nukta as a below-base mark on the base glyph using the 'blwm' positioning feature
The input context for the nukt feature always consists of the full form of the consonant.
The half form of nukta consonants will be substituted using the half feature.
Nukta feature applied substitutes Ka-nukta pre-composed glyph:

Nukta form of the independent vowel A substituted with 'nukt' feature:

Akhand
Feature Tag: "akhn"
An Akhand is a required consonant ligatures that may appear anywhere in the syllable,
and may or may not involve the base glyph. Akhand ligatures have the highest priority
and are formed first; some languages include them in their alphabets.
The input context for the akhand feature always consists of the full form of the
consonant. The half forms of Akhand ligatures will be called later in the half feature.
Because the akhand feature is applied early in the sequence of features and is applied
over the entire cluster, it can also be used to create certain forms that must take priority
in particular contexts over forms that would be created during subsequent feature
application.

Reph

Feature Tag: "rphf"
Applying this feature substitutes the Reph glyph. If the first consonant of the cluster
consists of the full form of Ra + Halant, this feature substitutes the combining-mark
form of Reph. In addition, the position of the Reph glyph is adjusted with the 'abvm'
GPOS feature.
The input context for the Reph feature always consists of the full form of Ra + Halant.
Note - While Gurmukhi typically does not have a Reph glyph, this feature is made
available for typographic preference.

Below form of consonant
Feature Tag: "blwf"
This feature substitutes the below-base forms of Consonants ( in Gurmukhi; Ra, Ha and
Va), when the below-base form does not form a ligature with the preceding consonant.
If a ligature is required between the below-base (vattu) glyph and the preceding base,
then the base and below-base glyphs can be substituted by the ligature glyph in the
'vatu' feature.
Example 1 - Halant + Ra (preceded by a consonant which does not form a ligature)
substitutes below-base Ra:

Example 2 - Halant + Ha (preceded by a consonant which does not form a ligature)
substitutes below-base Ha:

Example 3 - Halant + Va (preceded by a consonant which does not form a ligature)
substitutes below-base Va:

Half form of consonant
Applying this feature substitutes half forms - forms of consonants used in the pre-base
position. Consonants that have a half form should be listed in the ' half' feature. Some
scripts, like Devanagari have distinctly shaped half forms for most of the consonants
however, if a consonant does not have a distinct shape for the half form and does not
form any ligature, it will be displayed with an explicit Virama (same shape as the halant
form).
Note - the result of listing a consonant in the half feature (whether it has a true half
form or not) will affect the re-ordering (and positioning) of the reph and pre-pended
matras. See illustration in the Introduction section of this document.
This feature is applied to all consonants preceding the 'main' consonant.
Note - While Gurmukhi typically does not use half forms, this feature is made available
for typographic preference.

Post-base form of consonant
Feature Tag: "pstf"
This feature is used to substitute post-base forms, such as the 'Gurmukhi Ya'.
The post-base form of the Ya is substituted, when it is the last consonant in a syllable:

Vattu variants
Feature Tag: "vatu"
The ' vatu' feature can be used to substitute a ligature of a full (or half) form consonant
plus a below-base mark.

Conjunct forms
Feature Tag: "cjct"
Apply feature 'cjct' to substitute conjunct forms where the first consonant in the
consonant-cluster pair does not have a half form. This feature allows for control over reordering 'Žof reph and pre-pended matras in case of consonants that do not take half

forms yet do form 'Žconjunct ligatures in combination with certain following
consonants.

Presentation forms
After the glyphs have been reordered, the presentation lookups are applied to provide
the best typographic rendering of the text. The features of the presentation forms are
applied to the entire cluster simultaneously, executing lookups within each feature in
the order that they are specified in the font.
The pres, abvs, blws, psts and haln features are all mandatory for software
implementations: they are required for correct script behaviour and none should ever be
treated as discretionary. Because of this and because they are all applied simultaneously
over entire clusters, they are not functionally different: a set of lookups could be divided
between these features or grouped together under one of them with no difference in
effect. These multiple features are provided, however, as an aid to the font developer for
organizing lookups based on the combinations of glyphs they apply to. There are no
specific requirements on how each should be used; the examples provided below
illustrate typical usage, however.

Pre-base substitutions
Feature Tag: "pres"
This feature is used to substitute pre-base consonant conjuncts made with half forms,
the type most common in Devanagari. The resulting conjunct can be in full or half form.
This feature can also be used to select variant forms of Matras, or pre-composed
ligatures of Matras with certain bases.

Above-base substitutions
Feature Tag: "abvs"
This feature is used for glyph substitutions involving above-base marks. Such
substitutions might be used to select contextual forms of marks, to create mark-mark
ligatures, or to create mark-base ligatures. Specific context-dependent forms or belowbase consonants are handled by this lookup as well.
Example 1- contextual 'abvs' substitution; used to select an alternate vowel sign E, when
preceded by a Ttha:

Example 2- mark to mark 'abvs' substitution; 'matre-E' + 'bindi' substituted with ligature:

Below-base substitutions
Feature Tag: "blws"
This feature is used for glyph substitutions involving below-base marks or consonants.
Such substitutions can be used to create conjuncts of base glyphs with below-base
consonants, below mark ligatures or below mark-base ligatures. Specific contextdependent forms are handled by this lookup as well.
The 'blws' substitution used to create a matra conjunct:

Post-base substitutions
Feature Tag: "psts"

This feature is used to substitute post-base consonants or matras. Such substitutions
can be used to create conjuncts of base glyphs with post-base consonants or post-base
matra ligatures. It can also be used to specify contextual alternates of post-base forms.

Halant form of consonants
Feature Tag: "haln"
This feature is used to substitute a pre-composed halant form of a base (or conjunct
base) glyph in syllables ending with a halant. (Rather than using substitution, halant
forms can also be created by positioning the halant as a below-base mark on the base
glyph using the 'blwm' positioning feature.)
This feature is applied only on the base glyph if the syllable ends with a halant, or in the
case of non-final consonants that do not take a half form and do not form a conjunct
ligature with the following consonant.
Example 1 - 'haln' feature used to substitute halant form of base glyph:

Example 2 - 'haln' feature used to substitute halant form of conjunct-nukta base glyph:

Contextual Alternates
Feature Tag: "calt"
Unlike the previous presentation lookups, the ' calt' feature is optional and is used to
substitute discretionary contextual alternates. It is important to note that an application
may allow users to turn off this feature, therefore should not be used for any obligatory
Gurmukhi typography.

Positioning features
Distances

Feature Tag: "dist"
This feature covers positioning lookups that adjust distances between glyphs, such as
kerning between pre- and post-base elements and the base glyph. Note; the feature
'dist' can be used in the same way as the 'kern' feature. The advantage of using the 'dist'
feature is that it does not rely on the application to enable kerning.

Above-base marks
Feature Tag: "abvm"
This feature positions all above-base marks on the base glyph or the post-base matra.
The best method for encoding this feature in an OpenType font is to use a chaining
context positioning lookup that triggers mark-to-base and mark-to-mark attachments
for above-base marks.
The 'abvm' lookup in MS Volt using 'Anchor Attachment' for adjusting positions of
above-marks over bases:

The 'abvm' lookup in MS Volt using 'Pair Adjustment' for adjusting positions of abovemarks with post-base vowel:

Below-base marks
Feature Tag: "blwm"
This feature positions all below-base marks on the base glyph. The best method for
encoding this feature in an OpenType font is to use a chaining context positioning
lookup that triggers mark-to-base and mark-to-mark attachments for below-base
marks.
The 'blwm' lookup in MS Volt using 'Anchor Attachment' for adjusting positions of
below-base marks:

The 'blwm' lookup in MS Volt using 'Anchor Attachment' for adjusting positions of
below-base consonants:

Examples of Gurmukhi syllables
Complex Gurmukhi syllable formation is possible using the wide range of features
available in OpenType. The following examples show how the shaping engine applies
the OpenType features, one at a time to the input string. These combinations do not

necessarily represent actual syllables or words, but are meant to illustrate the various
OpenType features in a Gurmukhi font.
Example #1:

Example #2:

Appendices
Appendix A: Writing System Tags

Appendix A: Writing System Tags
Features are encoded according to both a designated script and language system.
Currently most shaping engine implementations only support the "default" language
system for each script. However, font developers may want to build language specific
features which are supported in other applications and will be supported in future
Microsoft OpenType implementations.
NOTE: It is strongly recommended to include the "dflt" language tag in all OpenType
fonts because it defines the basic script handling for a font. The "dflt" language system
is used as the default if no other language specific features are defined, or if the
application does not support that particular language. If the "dflt" tag is not present for
the script being used, the font may not work in some applications.

The following table lists the registered tag names for script and language systems. Note
for new Indic shaping implementation 'gur2' is used (old-behavior implementations
used 'guru').
Registered tags for the Gurmukhi script

Registered tags for Bengali language
systems

**Script tag**

**Script**

**Language

**Language**

system tag**
"gur2"

Gurmukhi

"dflt"

*default script handling

"PAN "

Punjabi

Note: both the script and language tags are case sensitive (script tags should be
lowercase, language tags are all caps) and must contain four characters (ie. you must
add a space to the three character language tags).

Developing OpenType Fonts for
Kannada Script
Article • 06/16/2022

Please note: This document reflects the changes made in 2005 for recommendations for
Indic-script OpenType font and shaping-engine implementations. While Indic fonts
made according to the earlier recommendations will still function properly in new
versions of Uniscribe, font developers may wish to update their fonts, particularly if they
wish to avoid certain limitations of the earlier implementation.
This document presents information that will help font developers create or support
OpenType fonts for Kannada script languages covered by the Unicode Standard. The
Kannada script is used to write the Kannadu language and is closely related to the Telugu
script.

Introduction
This document targets developers implementing Indic shaping behavior compatible
with Microsoft OpenType specification for Indic scripts. It contains information about
terminology, font features and behavior of the Indic shaping engine in regards to the
Kannada script. While it does not contain instructions for creating Kannada fonts, it will
help font developers understand how the Indic shaping engine processes Indic text. In
addition, registered features of the Kannada script are defined and illustrated with
examples.
The new Indic shaping engine allows for variations in typographic conventions, giving a
font developer control over shaping by the choice of designation of glyphs to certain
OpenType features. For example, the location where the reph and pre-pended matra are
re-ordered within a syllable cluster is affected by the presence of a half form. See
illustrations below.

Glossary
The following terms are useful for understanding the layout features and script rules
discussed in this document.
Above-base form of consonants - A variant form of a consonant that appears above
the base glyph.

Akhand ligatures - Required consonant ligatures that may appear anywhere in the
syllable, and may or may not involve the base glyph. Akhand ligatures have the highest
priority and are formed first; some languages include them in their alphabets. Akhand
ligatures may be displayed in either half- or full-form.
Base glyph - The only consonant or consonant conjunct in the syllable that is written in
its "full" (nominal) form. In Kannada, the last consonant of the syllable (except for
syllables ending with letter "Ra") usually forms the base glyph. In "degenerate" syllables
that have no vowel (last letter of a word), the last consonant in halant form serves as the
base consonant and is mapped as the base glyph. Layout operations are defined in
terms of a base glyph, not a base character, since the base can often be a ligature.
Below-base form of consonants - A variant form of a consonant that appears below the
base glyph. In the glyph sequence, the below-base form comes after the consonant(s)
that form the base glyph. Below-base forms are represented by a non-spacing mark
glyph.
Cluster – A group of characters that form an integral unit in Indic scripts, often times a
syllable.
Consonant - Each represents a single consonant sound. Consonants may exist in
different contextual forms and have an inherent vowel (usually, the short vowel "a"). For
example, "Ka" and "Ta", rather than just "K" or "T."
Consonant conjuncts (aka “conjuncts”) - Ligatures of two or more consonants.
Consonant conjuncts may have both full and half forms, or only full forms.
Halant (Virama) - The character used after a consonant to "strip" it of it’s inherent
vowel. A Halant follows all but the last consonant in every Kannada syllable.
NOTE: A syllable containing halant characters may be shaped with no visible halant
signs by using different consonant forms or conjuncts instead.
Halant form of consonants - The form produced by adding the halant (virama) to the
nominal shape. The Halant form is used in syllables that have no vowel or as the half
form when no distinct shape for the half form exists.
Half form of consonants (pre-base form) - A variant form of consonants which appear
to the left of the base consonant, if they do not participate in a ligature. Consonants in
their half form precede the ones forming the base glyph. Some Indic scripts, like
Devanagari have distinctly shaped half forms for most of the consonants. If not distinct
shape exists, the full form will display with an explicit Virama (same shape as the halant
form).

Kannada syllable - Effective orthographic "unit" of Kannada writing systems. Syllables
are composed of consonant letters, independent vowels, and dependant vowels. In a
text sequence, these characters are stored in phonetic order (although they may not be
represented in phonetic order when displayed). Once a syllable is shaped, it is
indivisible. The cursor cannot be positioned within the syllable. Transformations
discussed in this document do not cross syllable boundaries.
Matra (Dependent Vowel) - Used to represent a vowel sound that is not inherent to the
consonant. Dependent vowels are referred to as "matras" in Sanskrit. They are always
depicted in combination with a single consonant, or with a consonant cluster. The
greatest variation among different Indian scripts is found in the rules for attaching
dependent vowels to base characters.
New shaping behavior - Shaping behavior defined in this version of the Indic OpenType
Font Specification. Information in this document relates primarily to the new
implementation model. Old behavior may be mentioned in comments about
compatibility.
Nukta - A combining character that alters the way a preceding consonant (or matra) is
pronounced.
Old shaping behavior - Shaping behavior defined in previous versions of the Indic
OpenType Font Specification.
OpenType layout engine – Library responsible for executing OpenType layout features
in a font. In the Microsoft text formatting stack, it is named OTLS (OpenType layout
services).
OpenType tag – 4-byte identifier for script, language system or feature in the font.
Post-base form of consonants – A variant form of a consonant that appears to the right
of the base glyph. A consonant that takes a post-base form is preceded by the
consonant(s) forming the base glyph plus a halant (virama). Post-base forms are usually
spacing glyphs.
Pre-base form of consonants - A variant form of a consonant that appears to the left of
the base glyph. Note that most pre-base consonant forms are logically as well as visually
before the base consonant. Half forms are examples of this kind of pre-base form. In
some scripts, though, a pre-base Ra may logically follow the base consonant (that is, it
follows it phonetically and in the character sequence of the text), even though it is
presented visually before the base. The shaping engine detects such cases dynamically
using the 'pref' feature and re-orders the pre-base-form glyph as needed.

Reph – The above-base form of the letter "Ra", when"Ra" is the first consonant in the
syllable and is not the base consonant.
Shaping Engine –Code responsible for shaping input, classified to a particular script.
Split Matra - A matra that is decomposed into pieces for rendering. Usually the different
pieces appear in different positions relative to the base. For instance, part of the matra
may be placed at the beginning of the cluster and another part at the end of the cluster.
Syllable - A single unit of Indic text processing. Shaping of Indic text is performed
independently for each syllable. Process of identifying boundaries of each syllable is
described below.
Vattu - A below-base form of a consonant.

Example in Devanagari script
1. Pre-base form
2. The base consonant
3. Above-base form (reph)
4. Post-base (matra)
5. Below-base form (vattu/rakaar)

Shaping Engine
Analyze the text
Reorder characters
Shape glyph sequences (GSUB processing)
Position glyphs sequences (GPOS processing)
Base elements
Invalid combining marks
Use of ZWJ, ZWNJ and NBSP
The Indic shaping engine processes Kannada text in stages. The stages are:
1. Analyze the text sequence; breaking it into syllable clusters
2. Reorder the characters as necessary

3. Apply OpenType GSUB font features to get the correct glyph shape
4. Apply OpenType GPOS features to position glyphs or marks
The descriptions which follow will help font developers understand the rationale for the
Kannada feature encoding model, and help application developers better understand
how layout clients can divide responsibilities with operating system functions.

Analyze the text
Character properties
The shaping engine divides the text into syllable clusters and identifies character
properties. Character properties are used in parsing syllables and identifying its parts, in
determining proper character or glyph reordering and in OpenType feature application.
Properties for each character are divided into two types: static properties and dynamic
properties.
Static properties define basic characteristics that do not change from font to font:
character type (consonant, matra, vedic sign, etc.) or type of matra reordering. They
differ from script to script, but can't be controlled by font developer.
Dynamic properties are font dependent and are retrieved by the shaping engine as the
font is loaded. These properties affect shaping and reordering behavior.
*Note: in old shaping-engine implementations, all consonant properties were static:
consonants were assumed to have particular conjoining forms. In the new
implementation model, consonant conjoining behavior is a dynamic property.

Retrieving dynamic character properties from Indic fonts
Fonts define dynamic properties for consonants through implementing standard
features. Consonant types (and corresponding feature tags) that the shaping engine
reads from the font are:
Reph 'rphf'
Half forms 'half'
Pre-base-reordering forms of Ra/Rra 'pref'
Below-base forms 'blwf'
Post-base forms 'pstf'
Each of the features above is applied together with 'locl' feature to input sequences
consisting of two characters: for 'rphf' and 'half', features are applied to Consonant +

Halant combinations; for 'pref', 'blwf' and 'pstf', features are applied to Halant +
Consonant combinations. This is done for each consonant. If these two glyphs form a
ligature, with no additional glyphs in context, this means the consonant has the
corresponding form. For instance, if a substitution occurs when the 'half' and 'locl'
features are applied to a sequence Da + Halant, then Da is classified as having a half
form.
Note that a font may be implemented to re-order a Ra to pre-base position only in
certain syllables and display it as a below-base or post-base form otherwise. This means
that the Pre-base-form classification is not mutually exclusive with either Below-baseform or Post-base-form classifications. However, all classifications are determined as
described above using context-free substitutions.
Font-dependent character classification only defines consonant types. Reordering
positions, however, are fixed for each character class.
*Note: for fonts that support the old implementation, all features are applied to
Consonant + Halant sequences.

Indic input processing
The following steps should be repeated while there are characters left in the input
sequence. All shaping operations are done on a syllable-by-syllable basis, independent
from other characters.

Find next syllable in the input
Engine should find the character sequence matching one of the patterns below:
Consonant syllable
{C+[N]+<H+[<ZWNJ|ZWJ>]|<ZWNJ|ZWJ>+H>} +
C+[N]+[A] + [< H+[<ZWNJ|ZWJ>] | {M}+[N]+[H]>]+[SM]+[(VD)]
Vowel-based syllable:
[Ra+H]+V+[N]+[<[<ZWJ|ZWNJ>]+H+C|ZWJ+C>]+[{M}+[N]+[H]]+[SM]+[(VD)]
Stand Alone cluster (at the start of the word only):
[Ra+H]+NBSP+[N]+[<[<ZWJ|ZWNJ>]+H+C>]+[{M}+[N]+[H]]+[SM]+[(VD)]
Where

{}

zero or more occurrences

[]

optional occurrence

<|>

'one of'

()

one or two occurrences

C

consonant

V

independent vowel

N

nukta

H

halant/virama

ZWNJ

zero width non-joiner

ZWJ

zero width joiner

M

matra (up to one of each type: pre-, above-, below- or post- base)

SM

syllable modifier signs

VD

vedic

A

anudatta (U+0952)

NBSP

NO-BREAK SPACE

Identify key positions inside syllable
Syllable structure consists of the following parts:
Reph + HalfConsonant(s) + MainConsonant(s) + BelowBaseConsonant(s) +
PostBaseConsonant(s) + PreBaseReorderingRa + MatrasAndSigns
The consonant parts include all associated halants and nuktas. (For example, an instance
of BelowBaseConsonant consists of a sequence of Halant + Below-base-forming
Consonant.) All parts are optional, except the main consonant.
All parts are shown in the order they would occur within a syllable, with one
qualification: depending on a font implementation, PreBaseReorderingRa may occur
before all BelowBaseConsonants, after BelowBaseConsonants and before
PostBaseConsonants, or after PostBaseConsonants. Also, a font may be implemented to
re-order a Ra to pre-base position only in certain syllables and display it as a belowbase or post-base form otherwise. Thus, final determination of whether an occurrence of
Ra in a specific syllable can be treated as a pre-base reordering Ra can be made only
after the 'pref' feature has been applied to that syllable.

There could be several main consonants in the case where more than one consonant
doesn't have a half-, below-base, post-base or pre-base form. In a case of a cluster
where the first consonant does not have a half form, the shaping engine will recognize it
as the 1st 'full form' and go on to identify the 2nd full form consonant, if there is one.
This information will then be used to determine the reordering behavior of the reph or
any matras, vowel modifiers or stress marks.
All other elements are classified by their position relative to the base: pre-base (half
forms and reordering pre-base Ra forms), below-base, above-base and post-base.

Indic clusters are subject to the following constraints:
Only one reph is allowed per syllable.
Only one pre-base reordering Ra is allowed per syllable.
A nukta can be placed on a consonant, matra or independent vowel. It cannot be
placed on a pre-composed nukta character.
One matra from each positioning class is permitted (exception in the Kannada
script). A composite matra is treated as belonging to all the classes from which its
components belong.
One syllable modifier sign is allowed per cluster.
Vedic signs are combining marks (used for Sanskrit) that should be included in all
Indic scripts.
Danda and Double Danda are punctuation marks that should be included in all
Indic scripts.

Reorder characters
Once the Indic shaping engine has analyzed the cluster as described above, it creates
and manages a buffer of appropriately reordered elements (glyphs) representing the
cluster, according to several rules (described below).
The OpenType lookups in an Indic font must be written to match glyph sequences after
re-ordering has occurred. OpenType fonts should not have substitutions that attempt to
perform the re-ordering. If a font developer attempted to encode such reordering
information in an OpenType font, they would need to add a huge number of many-tomany glyph mappings to cover the general algorithms that a shaping engine will use.
1. Find base consonant: The shaping engine finds the base consonant of the syllable,
using the following algorithm: starting from the end of the syllable, move
backwards until a consonant is found that does not have a below-base or postbase form (post-base forms have to follow below-base forms), or that is not a pre-

base reordering Ra, or arrive at the first consonant. The consonant stopped at will
be the base.
If the syllable starts with Ra + Halant (in a script that has Reph) and has more
than one consonant, Ra is excluded from candidates for base consonants.
2. Decompose and reorder Matras: Each matra and any syllable modifier sign in the
cluster are moved to the appropriate position relative to the consonant(s) in the
cluster. The shaping engine decomposes two- or three-part matras into their
constituent parts before any repositioning. Matra characters are classified by which
consonant in a conjunct they have affinity for and are reordered to the following
positions:
Before first half form in the syllable
After subjoined consonants
After post-form consonant
After main consonant (for above marks)
3. Reorder marks to canonical order: Adjacent nukta and halant or nukta and vedic
sign are always repositioned if necessary, so that the nukta is first.
4. Final reordering: After the localized forms and basic shaping forms GSUB features
have been applied (see below), the shaping engine performs some final glyph
reordering before applying all the remaining font features to the entire cluster.
Reorder matras: If a pre-base matra character had been reordered before
applying basic features, the glyph can be moved closer to the main
consonant based on whether half-forms had been formed. Actual position for
the matra is defined as 'after last standalone halant glyph, after initial matra
position and before the main consonant'. If ZWJ or ZWNJ follow this halant,
position is moved after it.
Reorder reph: Reph's original position is always at the beginning of the
syllable, (i.e. it is not reordered at the character reordering stage). However, it
will be reordered according to the basic-forms shaping results. Possible
positions for reph, depending on the script, are; after main, before post-base
consonant forms, and after post-base consonant forms.
a. If reph should be positioned after post-base consonant forms, proceed to
step 5.
b. If the reph repositioning class is not after post-base: target position is after
the first explicit halant glyph between the first post-reph consonant and
last main consonant. If ZWJ or ZWNJ are following this halant, position is
moved after it. If such position is found, this is the target position.
Otherwise, proceed to the next step.

Note: in old-implementation fonts, where classifications were fixed in
shaping engine, there was no case where reph position will be found on this
step.
c. If reph should be repositioned after the main consonant: from the first
consonant not ligated with main, or find the first consonant that is not a
potential pre-base reordering Ra.
d. If reph should be positioned before post-base consonant, find first postbase classified consonant not ligated with main. If no consonant is found,
the target position should be before the first matra, syllable modifier sign
or vedic sign.
e. If no consonant is found in steps 3 or 4, move reph to a position
immediately before the first post-base matra, syllable modifier sign or
vedic sign that has a reordering class after the intended reph position. For
example, if the reordering position for reph is post-main, it will skip abovebase matras that also have a post-main position.
f. Otherwise, reorder reph to the end of the syllable.
Reorder pre-base reordering consonants: If a pre-base reordering consonant is
found, reorder it according to the following rules:
a. Only reorder a glyph produced by substitution during application of the
'pref' feature. (Note that a font may shape a Ra consonant with the 'pref'
feature generally but block it in certain contexts.)
b. Try to find a target position the same way as for pre-base matra. If it is
found, reorder pre-base consonant glyph.
c. If position is not found, reorder immediately before main consonant.

Character reordering Classes for Kannada:
Characters

Reorder Class

0CB0

After Postscript

0CBF, 0CC6, 0CCC

BeforeSubscript

0CBE

BeforeSubscript

0CE2, 0CE3

BeforeSubscript

0CC1, 0CC2

BeforeSubscript

0CC3, 0CC4, 0CD5, 0CD6

AfterSubscript

Shape glyph sequences (GSUB processing)

All characters from a string are first mapped to their nominal glyphs using the cmap
lookup. The shaping engine then proceeds to shape (substitute) the glyphs using GSUB
lookups.
The features for localized forms and basic shaping forms are applied one at a time to the
cluster or a relevant portion of the cluster.
The results after basic shaping forms features have been applied impact the final syllable
analysis in terms of final designation of Ra as a pre-base reordering form and final
reordering positions for reph and matras. Next, the features for presentation forms are
applied to the entire cluster simultaneously. Note: since the presentation form features
are applied simultaneously over the entire cluster, several features are operationally
equivalent to a single feature. Multiple features are provided as an aid for font
developers to organize the lookups they implement.
Note: final reordering occurs after features for basic shaping forms have been applied
and before features for presentation forms are applied. Font developers must consider
the effects of initial reordering (before any features are applied) and final reordering
(after basic shaping forms features have applied) when they create GSUB feature and
lookup tables.
These predefined features are described and illustrated in the Features section and are
applied in the order below.

Shaping features:
Localized forms
1. Apply feature 'locl' to select language-specific forms.
Basic Shaping forms
1. Apply feature 'nukt' to substitute nukta forms of consonants.
2. Apply feature 'akhn' to substitute required akhand ligatures, or to substitute forms
that take precedence over forms produced by features applied later.
3. Apply feature 'rphf' to substitute reph glyph (above-base form of 'Ra').
4. Apply feature 'pref' to substitute pre-base forms.
5. Apply feature 'blwf' to substitute below-base forms.
6. Apply feature 'half' to substitute half forms of pre-base consonants.
7. Apply feature 'pstf' to substitute post-base forms of consonants
8. Apply feature 'cjct' to substitute conjunct forms. (This is needed particularly for
ligature conjuct forms when the pre-base consonant does not have a half form).

Presentation forms
1. Apply feature 'pres' to substitute pre-base consonant conjuncts and pre-base
matra conjuncts. (ie. consonant and matra conjuncts to the left of the base glyph).
2. Apply feature 'abvs' to substitute above-base matra conjuncts, reph conjuncts,
above-base vowel modifiers and above-base stress and tone marks.
3. Apply feature 'blws' to substitute below-base consonant conjuncts, below-base
matra conjuncts, below-base vowel modifier forms and below-base stress and tone
mark forms.
4. Apply feature 'psts' to substitute post-base consonant conjuncts, post-base matra
conjuncts and post-base vowel modifiers.
5. Apply feature 'haln' to substitute the halant form of base (or conjunct base) glyph
in syllables ending with a halant.
6. Apply feature 'calt' to substitute the contextual alternate of a consonant.

Position glyph sequences (GPOS processing)
The shaping engine next processes the GPOS (glyph positioning) table, applying
features concerned with positioning. All features are applied simultaneously to the
entire cluster.
The font developer must consider the effects of re-ordering when creating the GPOS
feature and lookup tables (i.e., the glyphs will be in the order they were in after the
GSUB presentation forms features were applied).

Positioning features:
Kerning
1. Apply feature 'kern' to adjust distances (e.g., to provide kerning between post- or
pre-base elements and the base glyph).
2. Apply feature 'dist' to adjust distances. (NOTE - the feature 'dist' can be used in the
same way as the 'kern' feature. The advantage of using the 'dist' feature is that it
does not rely on the application to enable kerning. Therefore, if you want to make
sure certain spacing adjustments will always be displayed, you should use the 'dist'
feature).
Above-base marks
1. Apply feature 'abvm' to position above-base forms, vowel modifiers and or
stress/tone marks (on base glyph or post-base matra).

Below-base marks
1. Apply feature 'blwm' to position below-base forms, vowel modifiers and or
stress/tone marks.

Base elements
Commonly, a feature is required for dealing with the base glyph and one of the postbase, pre-base, above-base or below-base elements. Since it is not possible to reorder
ALL of these elements next to the base glyph, we need to skip over the elements "in the
middle" (reordering-wise).
The solution is to assign different mark attachment classes to different elements of the
syllable and positional forms, and in any given lookup work with one mark type only. For
example, in above-base substitutions we need only consider above-base elements most
of the time.
Generally, it is good practice to label as "mark" any glyphs that are denoted as
combining marks in the Unicode Standard as well as below-base/above-base forms of
consonants. Then, different attachment classes should be assigned to different marks
depending on their position with respect to the base.
For example, after the shaping engine has re-ordered elements within the cluster,
matras will always occur before syllable modifier sign such as the candrabindu. In an
actual sequence, though, potentially some other mark glyph, such as nukta, may occur
between the matra and the candrabindu. Thus, when processing the matra and
candrabindu, you may need to allow for the possibility that some other mark glyph(s)
may occur between them. Using lookup flags, you can specify that a lookup should
process only a certain class of marks, such as 'above-base marks', and ignore all other
marks. In that way, a match will occur whether or not a mark from another class is
present. Otherwise, the lookup would fail to apply.
Using Microsoft VOLT, you can assign glyphs to attachment classes.
In the example below this 'abvm' feature was set to process only TopMarks, therefore
the presence of another mark class would be ignored. If Process ALL was used and
another mark glyph followed the matra, this positioning lookup would fail to apply. This
example comes from the Devanagari font Mangal.

Invalid combining marks
Combining marks and signs that do not occur in conjunction with a valid base are
considered invalid. Shaping engine implementations may adopt different strategies for
how invalid marks are handled. For example, a shaping engine implementation might
treat an invalid mark as a separate cluster and display the stand-alone mark positioned
on some default base glyph, such as a dotted circle. (See Fallback Rendering in section
5.13 of the Unicode Standard 4.0.) Shaping engine implementations may vary somewhat
with regard to what sequences are or are not considered valid. For instance, some
implementations may impose a limit of at most one above-base vowel mark while
others may not.
To allow for shaping engine implementations that expect to position an invalid mark on
a dotted circle, it is recommended that a Kannada OT font contain a glyph for the
dotted circle character, U+25CC. If this character is not supported in the font, such
implementations will display invalid signs on the missing glyph shape (white box).

In addition to the 'dotted circle' other Unicode code points that are recommended for
inclusion in any Kannada font are the ZWJ (zero width non-joiner; U+200C), the ZWNJ
(zero width joiner; U+200D) and the ZWSP (zero width space; U+200B). For more
information see the Suggested glyphs section of the OpenType Font Development
document.

Effect of ZWJ, ZWNJ and NBSP on Consonant
Shaping
Unicode defines specific behaviors for ZWJ and ZWNJ in relation to Indic scripts. The
Indic-specific behavior retains the general behavior that ZWJ requests connection
between text elements while ZWNJ inhibits connection between text elements.
1. The main intent of using ZWJ in this context is to prevent a ligature-conjunct from
forming (and in Devanagari or Gujuarati, to request a half form, below-base form
or post-base form instead). The Indic engine does not need to take any action to
prevent ligature-conjuct formation: the presence of ZWJ will prevent GSUB
substitution lookups from matching the input glyph sequence. If the first
consonant does not have a half form, an overt-halant form should result, which
would also happen with no particular action by the engine.
2. A secondary intent of using ZWJ in this context is to prevent the display of reph in
the case that the first consonant is RA. If a cluster begins with RA H (halant) ZWJ,
the engine must ensure that the 'rphf' feature is not applied, and that re-ordering
for reph does not take place. Note that use of either joiner in this context should
prevent formation and re-ordering of reph when RA is the first consonant.
3. The main intent of using ZWNJ is to prevent conjunct ligature or half forms from
forming, and to display an explicit halant form instead. The shaping engine must
take specific actions to prevent half forms for a sequence of Consonant + Halant +
ZWNJ.
The following example illustrates these behaviors:

Just as the ZWJ can be used to display a half form in isolation, it can also be used to
display a mark, sub- or post-base form in isolation. Unlike the stand-alone half form,
however, sequences to display them must begin with a no-break space (NBSP). This is
because mark glyphs must combine with a base glyph: to appear in isolation, a NBSP
must be provided as a base.
In the illustration below the I-matra is displayed without the dotted circle by using the
NBSP. The combination of NBSP and ZWJ is used to display the below-base form of Ra
in isolation.

Features
The features listed below have been defined to create the basic forms for the languages
that are supported on Kannada systems. Regardless of the model an application
chooses for supporting layout of complex scripts, the shaping engine requires a fixed
order for executing features within a run of text to consistently obtain the proper basic
form.
The features of the basic shaping forms are applied one at a time to the cluster or
portion of the cluster. The result impacts the analysis in terms of the conjoining behavior
and final reordering. The features of the presentation forms are applied next, to the
entire cluster simultaneously. Mandatory features must always be applied; the
discretionary presentation-forms features listed should be applied by default, but can be
suppressed by a client (normally at the discretion of the user).
The order of the lookups within each feature is also very important. For more
information on lookups and defining features in OpenType fonts, see the Encoding
section of the OpenType Font Development document.
OpenType features used for Kannada scripts, applied in the following order:
**Feature**

**Feature function**

**Layout
operation**

Localized forms:
locl

Localization form substitution

Basic shaping forms:

GSUB

**Feature**

**Feature function**

**Layout
operation**

nukt

Nukta form substitution

GSUB

akhn

Akhand ligature substitution

GSUB

rphf

Reph form substitution

GSUB

pref

Pre-base form substitution

GSUB

blwf

Below-base form substitution

GSUB

half

Half-form substitution

GSUB

pstf

Post-base form substitution

GSUB

cjct

Conjunct form substitution

GSUB

Mandatory presentation forms:
pres

Pre-base substitution

GSUB

abvs

Above-base substitution

GSUB

blws

Below-base substitution

GSUB

psts

Post-base substitution

GSUB

haln

Halant form substitution

GSUB

Discretionary presentation forms:
calt

Contextual alternates

GSUB

Positioning features:
kern

Kerning

GPOS

dist

Distances

GPOS

abvm

Above-base mark positioning

GPOS

blwm

Below-base mark positioning

GPOS

[GSUB = glyph substitution, GPOS = glyph positioning]

Feature examples
Many of the registered features described and illustrated in this document are based on
the Microsoft OpenType font Tunga. 'Tunga' contains layout information and glyphs to

support all of the required features for the Kannada script and language systems
supported.
The illustrations in the following examples show the result of that particular feature
being applied. Features must be written to match glyph sequences after re-ordering has
occurred. Note that the input context for a feature may be the result of a previous
feature having already been applied.

Localized forms
Feature Tag: "locl"
This feature is used in association with OpenType language system tags to trigger
lookups that will select alternate glyphs needed for language-specific typographic
conventions. The 'locl' should not be used in association with the default language
system, but only used with other language system tags. See the Appendix of this
document for language system tags associated with the Kannada script.

Basic shaping forms
Nukta
Feature Tag: "nukt"
The nukta alters the way a preceding consonant or vowel is pronounced. The most
common nukta forms have been defined as separate characters in Unicode with their
own code points. All consonants, as well as akhand forms should have an associated
nukta form.
Note - Rather than using substitution, nukta forms can also be created by positioning
the nukta as a below-base mark on the base glyph using the 'blwm' positioning feature
The input context for the nukt feature always consists of the full form of the consonant.
The half form of nukta consonants will be substituted using the half feature.

Akhand
Feature Tag: "akhn"
An akhand is a required consonant ligatures that may appear anywhere in the syllable,
and may or may not involve the base glyph. Akhand ligatures have the highest priority

and are formed first; some languages include them in their alphabets. There are 2
Akhand ligatures in Kannada.
The input context for the akhand feature always consists of the full form of the
consonant. The half forms of Akhand ligatures will be called later in the half feature.
Because the akhand feature is applied early in the sequence of features and is applied
over the entire cluster, it can also be used to create certain forms that must take priority
in particular contexts over forms that would be created during subsequent feature
application.
Using the 'akhn' feature; Ka + halant + Ssa is substituted with the KaSsa ligature:

Ja + halant + Nya is substituted with the JaNya Ligature using 'akhn':

Reph
Feature Tag: "rphf"
Applying this feature substitutes the Reph glyph. If the first consonant of the cluster
consists of the full form of Ra + Halant, this feature substitutes the combining-mark
form of Reph. In addition, the position of the Reph glyph is adjusted with the 'abvm'
GPOS feature.
The input context for the Reph feature always consists of the full form of Ra + Halant.
The 'rphf' feature substitutes the mark glyph form of Ra and is positioned after the final
base or below-base glyph:

Pre-base form of consonant

Feature Tag: "pref"
This feature substitutes the pre-base forms of Consonants.

Below form of consonant
Feature Tag: "blwf"
This feature substitutes the below-base forms of Consonants that follow the base
consonant. All characters encoded in Unicode v3.0 for Kannada, have a below base form.
If a ligature is required between the below-base glyph and the preceding consonant, it
will be handled by the feature 'blwf' (below-base substitutions).
Example 1 - Halant plus Ra (preceded by a base consonant) will be substituted by the
below-base Ra:

Example 2- In 'Ba + halant + Ka', the below-base form of Ka will be substituted using
the blwf feature:

Half form of consonant
Feature Tag: "half"
Applying this feature substitutes half forms - forms of consonants used in the pre-base
position. Consonants that have a half form should be listed in the 'half' feature. Some
scripts, like Devanagari have distinctly shaped half forms for most of the consonants
however, if a consonant does not have a distinct shape for the half form and does not
form any ligature, it will be displayed with an explicit Virama (same shape as the halant
form).
Note - the result of listing a consonant in the half feature (whether it has a true half
form or not) will affect the re-ordering (and positioning) of the reph and pre-pended
matras. See illustration in the Introduction section of this document.

This feature is applied to all consonants preceding the 'main' consonant.
Note - While Kannada typically does not use half forms, this feature is made available
for typographic preference.

Post-base form of consonant
Feature Tag: "pstf"
The 'pstf' feature can be applied to substitute the post-base form of a consonant.

Conjunct forms
Feature Tag: "cjct"
Apply feature 'cjct' to substitute conjunct forms where the first consonant in the
consonant-cluster pair does not have a half form. This feature allows for control over reordering 'Žof reph and pre-pended matras in case of consonants that do not take half
forms yet do form 'Žconjunct ligatures in combination with certain following
consonants.

Presentation forms
After the glyphs have been reordered, the presentation lookups are applied to provide
the best typographic rendering of the text. The features of the presentation forms are
applied to the entire cluster simultaneously, executing lookups within each feature in
the order that they are specified in the font.
The abvs, blws, psts and haln features are all mandatory for software implementations:
they are required for correct script behaviour and none should ever be treated as
discretionary. Because of this and because they are all applied simultaneously over
entire clusters, they are not functionally different: a set of lookups could be divided
between these features or grouped together under one of them with no difference in
effect. These multiple features are provided, however, as an aid to the font developer for
organizing lookups based on the combinations of glyphs they apply to. There are no
specific requirements on how each should be used; the examples provided below
illustrate typical usage, however.

Pre-base substitutions
Feature Tag: "pres"

This feature is used to substitute pre-base consonant conjuncts made with half forms,
the type most common in Devanagari. The resulting conjunct can be in full or half form.
This feature can also be used to select variant forms of Matras, or pre-composed
ligatures of Matras with certain bases.

Above-base substitutions
Feature Tag: "abvs"
This feature is used for glyph substitutions involving above-base marks. Such
substitutions might be used to select contextual forms of marks, to create mark-mark
ligatures, or to create mark-base ligatures. Specific context-dependent forms or belowbase consonants are handled by this lookup as well.
Example 1 - 'abvs' ligature substitution; Ka + vowel I substituted with pre-composed
ligature:

Example 2 - 'abvs' ligature substitution; Ta + vowel I substituted with pre-composed
ligature:

Example 3 - 'abvs' contextual substitution; variation of vowel E is substituted when
preceded by Nya:

Example 4 - 'abvs' contextual substitution; Using MS Volt, different consonant forms are
substituted when followed by certain above base matras:

Below-base substitutions
Feature Tag: "blws"
This feature is used for glyph substitutions involving below-base marks or consonants.
Such substitutions can be used to create conjuncts of base glyphs with below-base
consonants, below mark ligatures or below mark-base ligatures. Specific contextdependent forms are handled by this lookup as well.
Example 1- below-base conjunct substitution; KaSsa + below-base Nna:

Example 2- below-base consonant conjuncts; below-base Ta + below-base Ya form a
conjunct:

Example 3- 'blws' contextual substitution; Using MS Volt, different below-base
consonant forms are substituted when pre-ceded by certain below- base consonants:

Post-base substitutions
Feature Tag: "psts"
This feature is used to substitute post-base consonants or matras. Such substitutions
can be used to create conjuncts of base glyphs with post-base consonants or post-base
matra ligatures. It can also be used to specify contextual alternates of post-base forms.
Example 1- contextual 'psts' substitution; used to select alternate form of vowel Uu,
when preceded by Pa.

Example 2 - contextual 'psts' substitution; using MS Volt, variant shapes of matras are
substituted based on the context:

Halant form of consonants
Feature Tag: "haln"
This feature is used to substitute a pre-composed halant form of a base (or conjunct
base) glyph in syllables ending with a halant. (Rather than using substitution, halant
forms can also be created by positioning the halant as a below-base mark on the base
glyph using the 'blwm' positioning feature.)
This feature is applied only on the base glyph if the syllable ends with a halant, or in the
case of non-final consonants that do not take a half form and do not form a conjunct
ligature with the following consonant.
Example 1 - 'haln' feature used to substitute halant form of base glyph:

Example 2 - 'haln' feature used to substitute halant form of conjunct base glyph:

Contextual Alternates
Feature Tag: "calt"
Unlike the previous presentation lookups, the 'calt' feature is optional and is used to
substitute discretionary contextual alternates. It is important to note that an application
may allow users to turn off this feature, therefore should not be used for any obligatory
Kannada typography.

Positioning features
Distances
Feature Tag: "dist"
This feature covers positioning lookups that adjust distances between glyphs, such as
kerning between pre- and post-base elements and the base glyph. Note; the feature
'dist' can be used in the same way as the 'kern' feature. The advantage of using the 'dist'
feature is that it does not rely on the application to enable kerning.
Example 1 - 'dist' feature created using MS Volt; pair adjustments made based on
context:

Above-base marks
Feature Tag: "abvm"
This feature positions all above-base marks on the base glyph or the post-base matra.
The best method for encoding this feature in an OpenType font is to use a chaining
context positioning lookup that triggers mark-to-base and mark-to-mark attachments
for above-base marks.
The 'abvm' feature using MS Volt 'Pair Adjustment' to move positions of above-marks
over bases:

Below-base marks
Feature Tag: "blwm"
This feature positions all below-base marks on the base glyph. The best method for
encoding this feature in an OpenType font is to use a chaining context positioning
lookup that triggers mark-to-base and mark-to-mark attachments for below-base
marks.
The 'blwm' feature shown in MS Volt, using 'Anchor Attachment' to position below-base
marks:

Examples of Kannada syllables
Complex Kannada syllable formation is possible using the wide range of features
available in OpenType. The following examples show how the shaping engine applies
the OpenType features, one at a time to the input string. These combinations do not
necessarily represent actual syllables or words, but are meant to illustrate the various
OpenType features in a Kannada font.

Appendices
Appendix A: Writing System Tags
Features are encoded according to both a designated script and language system.
Currently most shaping engine implementations only support the "default" language
system for each script. However, font developers may want to build language specific
features which are supported in other applications and will be supported in future
Microsoft OpenType implementations.
NOTE: It is strongly recommended to include the "dflt" language tag in all OpenType
fonts because it defines the basic script handling for a font. The "dflt" language system
is used as the default if no other language specific features are defined, or if the
application does not support that particular language. If the "dflt" tag is not present for
the script being used, the font may not work in some applications.
The following table lists the registered tag names for script and language systems. Note
for new Indic shaping implementation “knd2” is used (old-behavior implementations

used “knda”).
**Registered tags for the Kannada script**

**Registered tags for Kannada language
systems**

**Script tag**

**Script**

**Language

**Language**

system tag**
"knd2"

Kannada

"dflt"

*default script handling

"KAN "

Kannada

Note: both the script and language tags are case sensitive (script tags should be
lowercase, language tags are all caps) and must contain four characters (ie. you must
add a space to the three character language tags).

Developing OpenType Fonts for
Malayalam Script
Article • 06/16/2022

Please note: This document reflects the changes made in 2005 recommendations for
Indic-script OpenType font and shaping-engine implementations. While Indic fonts
made according to the earlier recommendations will still function properly in the new
versions of Uniscribe, font developers may choose to update their fonts, particularly if
they wish to avoid certain limitations of the earlier implementation.
This document presents information that will help font developers create or support
OpenType fonts for the Malayalam script covered by the Unicode Standard. The
Malayalam script is used to write the Malayalam language spoken in the Kerala state of
South India. While the shapes of the letters resemble the Tamil script, Malayalam has a full
set of consonant conjuncts.

Introduction
This document targets developers implementing Indic shaping behavior compatible
with Microsoft OpenType specification for Indic scripts. It contains information about
terminology, font features and behavior of the Indic shaping engine in regards to the
Malayalam script. While it does not contain instructions for creating Malayalam fonts, it
will help font developers understand how the Indic shaping engine processes Indic text.
In addition, registered features of the Malayalam script are defined and illustrated with
examples.
The new Indic shaping engine allows for variations in typographic conventions, giving a
font developer control over shaping by the choice of designation of glyphs to certain
OpenType features. For example, the location where the reph and pre-pended matra are
re-ordered within a syllable cluster is affected by the presence of a half form. See
illustrations below.
In this specification, font developers will learn how to encode complex script features in
their fonts, choose character sets, organize font information and use existing tools to
produce Malayalam fonts. Registered features of Malayalam script are defined and
illustrated, encodings are listed and templates are included for compiling Malayalam
layout tables for OpenType fonts.
In the example below using the Devanagari script, (Ra + halant + Da+ halant + Ma + Imatra), Ra + halant will form the reph, but how the Da is classified will determine the

position of the reph as well as the location of the pre-pended matra.

Glossary
The following terms are useful for understanding the layout features and script rules
discussed in this document.
Above-base form of consonants - A variant form of a consonant that appears above
the base glyph.
Akhand ligatures - Required consonant ligatures that may appear anywhere in the
syllable, and may or may not involve the base glyph. Akhand ligatures have the highest
priority and are formed first; some languages include them in their alphabets.
Malayalam has several Akhand ligatures.
Base glyph - The only consonant or consonant conjunct in the syllable that is written in
its "full" (nominal) form. In Malayalam, the last consonant of the syllable (except for
syllables ending with letter "Ra") usually forms the base glyph. In "degenerate" syllables
that have no vowel (last letter of a word), the last consonant in halant form serves as the
base consonant and is mapped as the base glyph. Layout operations are defined in
terms of a base glyph, not a base character, since the base can often be a ligature.
Below-base form of consonants – The below-base form comes after the consonant(s)
that form the base glyph. (Malayalam consonant La) Below-base forms are represented
by the non-spacing mark glyph.
Chandrakala (Virama) - The character used after a consonant to "strip" it of the inherent
vowel. This is also known Halant.
Chillaksaram – Consonants that appear in the final position of a syllable and merge with
Halant (Virama) are known as Chillaksaram in Malayalam.

Cluster – A group of characters that form an integral unit in Indic scripts, often times a
syllable.
Consonant - Each represents a single consonant sound. Consonants may exist in
different contextual forms and have an inherent vowel (usually, the short vowel "a"). For
example, "Ka" and "Ta", rather than just "K" or "T."
Consonant conjuncts (aka “conjuncts”) - Ligatures of two or more consonants.
Consonant conjuncts may have both full and half forms, or only full forms.
Halant (Virama) - The character used after a consonant to "strip" it of its inherent vowel.
This is known as chandrakala in Malayalam.
NOTE: A syllable containing halant characters may be shaped with no visible halant
signs by using different consonant forms or conjuncts instead.
Halant form of consonants - The form produced by adding the halant (virama) to the
nominal shape. The Halant form is used in syllables that have no vowel or as the half
form when no distinct shape for the half form exists.
Half form of consonants (pre-base form) - A variant form of consonants which appear
to the left of the base consonant, if they do not participate in a ligature. Consonants in
their half form precede the ones forming the base glyph. Some Indic scripts, like
Devanagari have distinctly shaped half forms for most of the consonants. If not distinct
shape exists, the full form will display with an explicit Virama (same shape as the halant
form).
Matra (Dependent Vowel) - Used to represent a vowel sound that is not inherent to the
consonant. Dependent vowels are referred to as "matras" in Sanskrit. They are always
depicted in combination with a single consonant, or with a consonant cluster. The
greatest variation among different Indian scripts is found in the rules for attaching
dependent vowels to base characters.
New shaping behavior - Shaping behavior defined in this version of the Indic OpenType
Font Specification. Information in this document relates primarily to the new
implementation model. Old behavior may be mentioned in comments about
compatibility.
Nukta - A combining character that alters the way a preceding consonant (or matra) is
pronounced.
Old shaping behavior - Shaping behavior defined in previous versions of the Indic
OpenType Font Specification.

OpenType layout engine – Library responsible for executing OpenType layout features
in a font. In the Microsoft text formatting stack, it is named OTLS (OpenType layout
services).
OpenType tag – 4-byte identifier for script, language system or feature in the font.
Post-base form of consonants – A variant form of a consonant that appears to the right
of the base glyph. A consonant that takes a post-base form is preceded by the
consonant(s) forming the base glyph plus a halant (virama). Post-base forms are usually
spacing glyphs.
Pre-base form of consonants - A variant form of a consonant that appears to the left of
the base glyph. Note that most pre-base consonant forms are logically as well as visually
before the base consonant. Half forms are examples of this kind of pre-base form. In
some scripts, though, a pre-base Ra may logically follow the base consonant (that is, it
follows it phonetically and in the character sequence of the text), even though it is
presented visually before the base. The shaping engine detects such cases dynamically
using the 'pref' feature and re-orders the pre-base-form glyph as needed.
Reph – The above-base form of the letter "Ra" that is used in Devanagari when "Ra" is
the first consonant in the syllable and is not the base consonant.
Shaping Engine – Code responsible for shaping input, classified to a particular script.
Split Matra - A matra that is decomposed into pieces for rendering. Usually the different
pieces appear in different positions relative to the base. For instance, part of the matra
may be placed at the beginning of the cluster and another part at the end of the cluster.
Syllable - A single unit of Indic text processing. Shaping of Indic text is performed
independently for each syllable. Process of identifying boundaries of each syllable is
described below.
Vattu - A below-base form of a consonant.

Example in Devanagari script
1. Pre-base form
2. The base consonant

3. Above-base form (reph)
4. Post-base (matra)
5. Below-base form (vattu/rakaar)

Shaping Engine
The Indic shaping engine processes Malayalam text in stages. The stages are:
1. Analyze the text sequence; breaking it into syllable clusters
2. Reorder the characters as necessary
3. Apply OpenType GSUB font features to get the correct glyph shape
4. Apply OpenType GPOS features to position glyphs or marks
The descriptions which follow will help font developers understand the rationale for the
Malayalam feature encoding model and help application developers better understand
how layout clients can divide responsibilities with operating system functions.

Analyze the text
Character properties
The shaping engine divides the text into syllable clusters and identifies character
properties.
Character properties are used in parsing syllables and identifying its parts, in
determining proper character or glyph reordering and in OpenType feature application.
Properties for each character are divided into two types: static properties and dynamic
properties.
Static properties define basic characteristics that do not change from font to font:
character type (consonant, matra, vedic sign, etc.) or type of matra reordering. They
differ from script to script, but can't be controlled by font developer.
Dynamic properties are font dependent and are retrieved by the shaping engine as the
font is loaded. These properties affect shaping and reordering behavior.
*Note: in old shaping-engine implementations, all consonant properties were static:
consonants were assumed to have particular conjoining forms. In the new
implementation model, consonant conjoining behavior is a dynamic property.

Retrieving dynamic character properties from Indic fonts

Fonts define dynamic properties for consonants through implementing standard
features. Consonant types (and corresponding feature tags) that the shaping engine
reads from the font are:
Reph 'rphf'
Half forms 'half'
Pre-base-reordering forms of Ra/Rra 'pref'
Below-base forms 'blwf'
Post-base forms 'pstf'
Each of the features above is applied together with 'locl' feature to input sequences
consisting of two characters: for 'rphf' and 'half', features are applied to Consonant +
Halant combinations; for 'pref', 'blwf' and 'pstf', features are applied to Halant +
Consonant combinations. This is done for each consonant. If these two glyphs form a
ligature, with no additional glyphs in context, this means the consonant has the
corresponding form. For instance, if a substitution occurs when the 'half' and 'locl'
features are applied to a sequence Da + Halant, then Da is classified as having a half
form.
Note that a font may be implemented to re-order a Ra to pre-base position only in
certain syllables and display it as a below-base or post-base form otherwise. This means
that the Pre-base-form classification is not mutually exclusive with either Below-baseform or Post-base-form classifications. However, all classifications are determined as
described above using context-free substitutions.
Font-dependent character classification only defines consonant types. Reordering
positions, however, are fixed for each character class.
*Note: for fonts that support the old implementation, all features are applied to
Consonant + Halant sequences.

Indic input processing
The following steps should be repeated while there are characters left in the input
sequence. All shaping operations are done on a syllable-by-syllable basis, independent
from other characters.

Find next syllable in the input
Engine should find the character sequence matching one of the patterns below:
Consonant syllable:

{C+[N]+<H+[<ZWNJ|ZWJ>]|<ZWNJ|ZWJ>+H>} +
C+[N]+[A] + [< H+[<ZWNJ|ZWJ>] | {M}+[N]+[H]>]+[SM]+[(VD)]

Vowel-based syllable:

[Ra+H]+V+[N]+[<[<ZWJ|ZWNJ>]+H+C|ZWJ+C>]+[{M}+[N]+[H]]+[SM]+[(VD)]

Stand Alone cluster (at the start of the word only):

\#[Ra+H]+NBSP+[N]+[<[<ZWJ|ZWNJ>]+H+C>]+[{M}+[N]+[H]]+[SM]+[(VD)]

Where
{}

zero or more occurrences

[]

optional occurrence

<|>

"one of"

()

one or two occurrences

C

consonant

V

independent vowel

N

nukta

H

halant/virama

ZWNJ

zero width non-joiner

ZWJ

zero width joiner

M

matra (up to one of each type: pre-, above-, below- or post- base)

SM

syllable modifier signs

VD

vedic

A

anudatta (U+0952)

NBSP

NO-BREAK SPACE

Identify key positions inside syllable
Syllable structure consists of the following parts:
Reph + HalfConsonant(s) + MainConsonant(s) + BelowBaseConsonant(s) +
PostBaseConsonant(s) + PreBaseReorderingRa + MatrasAndSigns
The consonant parts include all associated halants and nuktas. (For example, an instance
of BelowBaseConsonant consists of a sequence of Halant + Below-base-forming
Consonant.) All parts are optional, except the main consonant.
All parts are shown in the order they would occur within a syllable, with one
qualification: depending on a font implementation, PreBaseReorderingRa may occur
before all BelowBaseConsonants, after BelowBaseConsonants and before
PostBaseConsonants, or after PostBaseConsonants. Also, a font may be implemented to
re-order a Ra to pre-base position only in certain syllables and display it as a belowbase or post-base form otherwise. Thus, final determination of whether an occurrence of
Ra in a specific syllable can be treated as a pre-base reordering Ra can be made only
after the 'pref' feature has been applied to that syllable.
There could be several main consonants in the case where more than one consonant
doesn't have a half-, below-base, post-base or pre-base form. In a case of a cluster
where the first consonant does not have a half form, the shaping engine will recognize it
as the 1st 'full form' and go on to identify the 2nd full form consonant, if there is one.
This information will then be used to determine the reordering behavior of the reph or
any matras, vowel modifiers or stress marks.
All other elements are classified by their position relative to the base: pre-base (half
forms and reordering pre-base Ra forms), below-base, above-base and post-base.

Indic clusters are subject to the following constraints:
Only one reph is allowed per syllable.
Only one pre-base reordering Ra is allowed per syllable.
A nukta can be placed on a consonant, matra or independent vowel. It cannot be
placed on a pre-composed nukta character.
One matra from each positioning class is permitted (exception in the Kannada
script). A composite matra is treated as belonging to all the classes from which its
components belong.
One syllable modifier sign is allowed per cluster.
Vedic signs are combining marks (used for Sanskrit) that should be included in all
Indic scripts.

Danda and Double Danda are punctuation marks that should be included in all
Indic scripts.

Reorder characters
Once the Indic shaping engine has analyzed the cluster as described above, it creates
and manages a buffer of appropriately reordered elements (glyphs) representing the
cluster, according to several rules (described below).
The OpenType lookups in an Indic font must be written to match glyph sequences after
re-ordering has occurred. OpenType fonts should not have substitutions that attempt to
perform the re-ordering. If a font developer attempted to encode such reordering
information in an OpenType font, they would need to add a huge number of many-tomany glyph mappings to cover the general algorithms that a shaping engine will use.
1. Find base consonant: The shaping engine finds the base consonant of the syllable,
using the following algorithm: starting from the end of the syllable, move
backwards until a consonant is found that does not have a below-base or postbase form (post-base forms have to follow below-base forms), or that is not a prebase reordering Ra, or arrive at the first consonant. The consonant stopped at will
be the base.
If the syllable starts with Ra + Halant (in a script that has Reph) and has more
than one consonant, Ra is excluded from candidates for base consonants.
2. Decompose and reorder Matras: Each matra and any syllable modifier sign in the
cluster are moved to the appropriate position relative to the consonant(s) in the
cluster. The shaping engine decomposes two- or three-part matras into their
constituent parts before any repositioning. Matra characters are classified by which
consonant in a conjunct they have affinity for and are reordered to the following
positions:
Before first half form in the syllable
After subjoined consonants
After post-form consonant
After main consonant (for above marks)
3. Reorder marks to canonical order: Adjacent nukta and halant or nukta and vedic
sign are always repositioned if necessary, so that the nukta is first.
4. Final reordering: After the localized forms and basic shaping forms GSUB features
have been applied (see below), the shaping engine performs some final glyph
reordering before applying all the remaining font features to the entire cluster.

Reorder matras: If a pre-base matra character had been reordered before
applying basic features, the glyph can be moved closer to the main
consonant based on whether half-forms had been formed. Actual position for
the matra is defined as "after last standalone halant glyph, after initial matra
position and before the main consonant". If ZWJ or ZWNJ follow this halant,
position is moved after it.
Reorder reph: Reph's original position is always at the beginning of the
syllable, (i.e. it is not reordered at the character reordering stage). However, it
will be reordered according to the basic-forms shaping results. Possible
positions for reph, depending on the script, are; after main, before post-base
consonant forms, and after post-base consonant forms.
a. If reph should be positioned after post-base consonant forms, proceed to
sub step 'e'.
b. If the reph repositioning class is not after post-base: target position is after
the first explicit halant glyph between the first post-reph consonant and
last main consonant. If ZWJ or ZWNJ are following this halant, position is
moved after it. If such position is found, this is the target position.
Otherwise, proceed to the next step.
Note: in old-implementation fonts, where classifications were fixed in
shaping engine, there was no case where reph position will be found on this
step.
c. If reph should be repositioned after the main consonant: from the first
consonant not ligated with main, or find the first consonant that is not a
potential pre-base reordering Ra.
d. If reph should be positioned before post-base consonant, find first postbase classified consonant not ligated with main. If no consonant is found,
the target position should be before the first matra, syllable modifier sign
or vedic sign.
e. If no consonant is found in steps 'c' or 'd', move reph to a position
immediately before the first post-base matra, syllable modifier sign or
vedic sign that has a reordering class after the intended reph position. For
example, if the reordering position for reph is post-main, it will skip abovebase matras that also have a post-main position.
f. Otherwise, reorder reph to the end of the syllable.
Reorder pre-base reordering consonants: If a pre-base reordering consonant is
found, reorder it according to the following rules:
a. Only reorder a glyph produced by substitution during application of the
'pref' feature. (Note that a font may shape a Ra consonant with the 'pref'
feature generally but block it in certain contexts.)

b. Try to find a target position the same way as for pre-base matra. If it is
found, reorder pre-base consonant glyph.
c. If position is not found, reorder immediately before main consonant.

Character reordering Classes for Malayalam:
Characters

Reorder Class

0D30

AfterMain

0D46, 0D47, 0D48

BeforeMain

0D3E-0D43, 0D57

AfterPostscript

Shape glyph sequences (GSUB processing)
All characters from a string are first mapped to their nominal glyphs using the cmap
lookup. The shaping engine proceeds to shape (substitute) the glyphs using GSUB
lookups. The features of the basic shaping forms are applied one at a time to the cluster
or portion of the cluster. The result impacts the analysis in terms of the conjoining
behavior.
The features of the presentation forms are applied next to the entire cluster
simultaneously. These predefined features are described and illustrated in the Features
section.
Once the basic consonant types and parts of a cluster have been identified, the
following OpenType features are applied in the order outlined below.

Shaping features:
Localized forms
1. Apply feature 'locl' to select language-specific forms.
Basic Shaping forms
1. Apply feature 'nukt' to substitute nukta forms of consonants.
2. Apply feature 'akhn' to substitute required akhand ligatures, or to substitute forms
that take precedence over forms produced by features applied later.
3. Apply feature 'rphf' to substitute the reph glyph (above-base form of 'Ra').
4. Apply feature 'pref' to substitute pre-base forms.
5. Apply feature 'blwf' to substitute below-base forms.

6. Apply feature 'half' to substitute half forms of pre-base consonants.
7. Apply feature 'pstf' to substitute post-base forms.
8. Apply feature 'cjct' to substitute conjunct forms. (This is needed particularly for
ligature conjuct forms when the pre-base consonant does not have a half form).
Presentation forms
1. Apply feature 'pres' to substitute pre-base consonant conjuncts and pre-base
matra conjuncts. (i.e. consonant and matra conjuncts to the left of the base glyph).
2. Apply feature 'abvs' to substitute above-base matra conjuncts, reph conjuncts,
above-base vowel modifiers and above-base stress and tone marks.
3. Apply feature 'blws' to substitute below-base consonant conjuncts, below-base
matra conjuncts, below-base vowel modifier forms and below-base stress and tone
mark forms.
4. Apply feature 'psts' to substitute post-base consonant conjuncts, post-base matra
conjuncts and post-base vowel modifiers.
5. Apply feature 'haln' to substitute the halant form of base (or conjunct base) glyph
in syllables ending with a halant.
6. Apply feature 'calt' to substitute the contextual alternate of a consonant.

Position glyph sequences (GPOS processing)
The shaping engine next processes the GPOS (glyph positioning) table, applying
features concerned with positioning. All features are applied simultaneously to the
entire cluster.
The font developer must consider the effects of re-ordering when creating the GPOS
feature and lookup tables (i.e., the glyphs will be in the order they were in after the
GSUB presentation forms features were applied).

Positioning features:
Kerning
1. Apply feature 'kern' to adjust distances (e.g., to provide kerning between post- or
pre-base elements and the base glyph).
2. Apply feature 'dist' to adjust distances. (NOTE - the feature 'dist' can be used in the
same way as the 'kern' feature. The advantage of using the 'dist' feature is that it
does not rely on the application to enable kerning. Therefore, if you want to make
sure certain spacing adjustments will always be displayed, you should use the 'dist'
feature).

Above-base marks
1. Apply feature 'abvm' to position above-base marks (above-base consonant forms,
matras, vowel modifiers or stress/tone marks) on base glyphs or post-base matra).
Below-base marks
1. Apply feature 'blwm' to position below-base marks (below-base consonant forms,
matras, vowel modifiers or stress/tone marks) on base glyphs or post-base matra).

Base elements
Commonly, a feature is required for dealing with the base glyph and one of the postbase, pre-base, above-base or below-base elements. Since it is not possible to reorder
ALL of these elements next to the base glyph, we need to skip over the elements "in the
middle" (reordering-wise).
The solution is to assign different mark attachment classes to different elements of the
syllable and positional forms, and in any given lookup work with one mark type only. For
example, in above-base substitutions we need only consider above-base elements most
of the time.
Generally, it is good practice to label as "mark" any glyphs that are denoted as
combining marks in the Unicode Standard as well as below-base/above-base forms of
consonants. Then, different attachment classes should be assigned to different marks
depending on their position with respect to the base.
For example, after the shaping engine has re-ordered elements within the cluster,
matras will always occur before syllable modifier sign such as the candrabindu. In an
actual sequence, though, potentially some other mark glyph, such as nukta, may occur
between the matra and the candrabindu. Thus, when processing the matra and
candrabindu, you may need to allow for the possibility that some other mark glyph(s)
may occur between them. Using lookup flags, you can specify that a lookup should
process only a certain class of marks, such as 'above-base marks', and ignore all other
marks. In that way, a match will occur whether or not a mark from another class is
present. Otherwise, the lookup would fail to apply.
Using Microsoft VOLT, you can assign glyphs to attachment classes.
In the example below this 'abvm' feature was set to process only TopMarks, therefore
the presence of another mark class would be ignored. If Process ALL was used and
another mark glyph followed the matra, this positioning lookup would fail to apply. This
example comes from the Devanagari font Mangal.

Invalid combining marks
Combining marks and signs that do not occur in conjunction with a valid base are
considered invalid. Shaping engine implementations may adopt different strategies for
how invalid marks are handled. For example, a shaping engine implementation might
treat an invalid mark as a separate cluster and display the stand-alone mark positioned
on some default base glyph, such as a dotted circle. (See Fallback Rendering in section
5.13 of the Unicode Standard 4.0.) Shaping engine implementations may vary somewhat
with regard to what sequences are or are not considered valid. For instance, some
implementations may impose a limit of at most one above-base vowel mark while
others may not.
To allow for shaping engine implementations that expect to position an invalid mark on
a dotted circle, it is recommended that a Malayalam OT font contain a glyph for the
dotted circle character, U+25CC. If this character is not supported in the font, such
implementations will display invalid signs on the missing glyph shape (white box).

In addition to the 'dotted circle' other Unicode code points that are recommended for
inclusion in any Malayalam font are the ZWJ (zero width non-joiner; U+200C), the ZWNJ
(zero width joiner; U+200D) and the ZWSP (zero width space; U+200B). For more
information see the Suggested glyphs section of the OpenType Font Development
document.

Effect of ZWJ, ZWNJ and NBSP on Consonant
Shaping
Unicode defines specific behaviors for ZWJ and ZWNJ in relation to Indic scripts. The
Indic-specific behavior retains the general behavior that ZWJ requests connection
between text elements while ZWNJ inhibits connection between text elements.
1. The main intent of using ZWJ in this context is to prevent a ligature-conjunct from
forming (and in Devanagari or Gujarati, to request a half form, below-base form or
post-base form instead). The Indic engine does not need to take any action to
prevent ligature-conjuct formation: the presence of ZWJ will prevent GSUB
substitution lookups from matching the input glyph sequence. If the first
consonant does not have a half form, an overt-halant form should result, which
would also happen with no particular action by the engine.
2. A secondary intent of using ZWJ in this context is to prevent the display of reph in
the case that the first consonant is RA. If a cluster begins with RA H (halant) ZWJ,
the engine must ensure that the 'rphf' feature is not applied, and that re-ordering
for reph does not take place. Note that use of either joiner in this context should
prevent formation and re-ordering of reph when RA is the first consonant.
3. The main intent of using ZWNJ is to prevent conjunct ligature or half forms from
forming, and to display an explicit halant form instead. The shaping engine must
take specific actions to prevent half forms for a sequence of Consonant + Halant +
ZWNJ.
The following example illustrates some of these behaviors:

Just as the zwj can be used to display a form in isolation, it can also be used to display a
mark, sub- or post-base form in isolation. Unlike the stand-alone Chillaksaram form,
however, sequences to display them must begin with a no-break space (NBSP). This is
because marks, sub- and post-base forms have a 'zero-width' so must be placed on the
NBSP. For example, to get a shape of I-matra without the dotted circle one should type
NBSP + I-matra.
In the illustration below the I-matra is displayed without the dotted circle by using the
NBSP. The combination of NBSP and ZWJ is used to display the below-base form of La
in isolation.

Features
The features listed below have been defined to create the basic forms for the languages
that are supported on Malayalam systems. Regardless of the model an application
chooses for supporting layout of complex scripts, the shaping engine requires a fixed
order for executing features within a run of text to consistently obtain the proper basic
form.
The features of the basic shaping forms are applied one at a time to the cluster or
portion of the cluster. The result impacts the analysis in terms of the conjoining behavior
and final reordering. The features of the presentation forms are applied next, to the
entire cluster simultaneously. Mandatory features must always be applied; the
discretionary presentation-forms features listed should be applied by default, but can be
suppressed by a client (normally at the discretion of the user).
The order of the lookups within each feature is also very important. For more
information on lookups and defining features in OpenType fonts, see the Encoding
section of the OpenType Font Development document.
OpenType features used for Malayalam scripts, applied in the following order:
**Feature**

**Feature function**

**Layout
operation**

Localized forms:
locl

Localization form substitution

GSUB

Basic shaping forms:
nukt

Nukta form substitution

GSUB

akhn

Akhand ligature substitution

GSUB

rphf

Reph form substitution

GSUB

pref

Pre-base form substitution

GSUB

blwf

Below-base form substitution

GSUB

half

Half-form substitution

GSUB

pstf

Post-base form substitution

GSUB

cjct

Conjunct form substitution

GSUB

Mandatory presentation forms:
pres

Pre-base substitution

GSUB

abvs

Above-base substitution

GSUB

blws

Below-base substitution

GSUB

psts

Post-base substitution

GSUB

haln

Halant form substitution

GSUB

Discretionary presentation forms:
calt

Contextual alternates

GSUB

Positioning features:
kern

Kerning

GPOS

dist

Distances

GPOS

abvm

Above-base mark positioning

GPOS

blwm

Below-base mark positioning

GPOS

[GSUB = glyph substitution, GPOS = glyph positioning]

Feature examples
Many of the registered features described and illustrated in this document are based on
the Microsoft OpenType font Kartika. 'Kartika' contains layout information and glyphs to

support all of the required features for the Malayalam script and language systems
supported.
The illustrations in the following examples show the result of that particular feature
being applied. Features must be written to match glyph sequences after re-ordering has
occurred. Note that the input context for a feature may be the result of a previous
feature having already been applied.

Localized forms
Feature Tag: "locl"
This feature is used in association with OpenType language system tags to trigger
lookups that will select alternate glyphs needed for language-specific typographic
conventions. The 'locl' should not be used in association with the default language
system, but only used with other language system tags. See the Appendix of this
document for language system tags associated with the Malayalam script.

Basic shaping forms
Nukta
Feature Tag: "nukt"
The nukta alters the way a preceding consonant or vowel is pronounced. The most
common nukta forms have been defined as separate characters in Unicode with their
own code points. All consonants, as well as akhand forms should have an associated
nukta form.
Note - Rather than using substitution, nukta forms can also be created by positioning
the nukta as a below-base mark on the base glyph using the 'blwm' positioning feature
The input context for the nukt feature always consists of the full form of the consonant.
The half form of nukta consonants will be substituted using the half feature.

Akhand
Feature Tag: "akhn"
An akhand is a required consonant ligatures that may appear anywhere in the syllable,
and may or may not involve the base glyph. Akhand ligatures have the highest priority
and are formed first; some languages include them in their alphabets.

The input context for the akhand feature always consists of the full form of the
consonant. The half forms of Akhand ligatures will be called later in the half feature.
Because the akhand feature is applied early in the sequence of features and is applied
over the entire cluster, it can also be used to create certain forms that must take priority
in particular contexts over forms that would be created during subsequent feature
application.
Example 1- Ka + halant + Ka is substituted with the KaKa ligature:

Example 2- Da + halant + Dha is substituted with the DaDha Ligature:

Reph
Feature Tag: "rphf"
Applying this feature substitutes the Reph glyph. If the first consonant of the cluster
consists of the full form of Ra + Halant, this feature substitutes the combining-mark
form of Reph. In addition, the position of the Reph glyph is adjusted with the 'abvm'
GPOS feature.
The input context for the Reph feature always consists of the full form of Ra + Halant.

Pre-base form of consonant
Feature Tag: "pref"
This feature substitutes the pre-base forms of Consonants.

Below form of consonant
Feature Tag: "blwf"

This feature substitutes the below-base form of consonants (Malayalam La). The input
context for the below-base feature consists of Halant + La, preceded by a consonant. If
the below-base form and the preceding consonant form a ligature, it will be substituted
later using the feature 'blws'.
The blwf feature substitutes the below-base form of La, when Halant + La is preceded
by a consonant:

Half form of consonant
Feature Tag: "half"
Applying this feature substitutes half forms - forms of consonants used in the pre-base
position. Consonants that have a half form should be listed in the 'half' feature. Some
scripts, like Devanagari have distinctly shaped half forms for most of the consonants
however, if a consonant does not have a distinct shape for the half form and does not
form any ligature, it will be displayed with an explicit Virama (same shape as the halant
form).
Note - the result of listing a consonant in the half feature (whether it has a true half
form or not) will affect the re-ordering (and positioning) of the reph and pre-pended
matras. See illustration in the Introduction section of this document.
This feature is applied to all consonants preceding the 'main' consonant.
Note - While Malayalam typically does not use half forms, this feature is made available
for typographic preference.

Post-base form of consonant
Feature Tag: "pstf"
This feature substitutes the post-base form of consonants (Malayalam Ya, Ra + Va). The
input context for the post-base feature consists of Halant + Consonant, preceded by the
base glyph. If the post-base form and the preceding base consonant form a ligature, it
should be substituted using the feature 'psts'.

Example 1 - The post-base form of the Ya is substituted, when it is the last consonant in
a syllable:

Example 2 - The post-base form of the Ra is substituted, when it is the last consonant in
a syllable:

Example 3 - The post-base form of the Va is substituted, when it is the last consonant in
a syllable:

Conjunct forms
Feature Tag: "cjct"
Apply feature 'cjct' to substitute conjunct forms where the first consonant in the
consonant-cluster pair does not have a half form. This feature allows for control over reordering 'Žof reph and pre-pended matras in case of consonants that do not take half
forms yet do form 'Žconjunct ligatures in combination with certain following
consonants.

Presentation forms
After the glyphs have been reordered, the presentation lookups are applied to provide
the best typographic rendering of the text. The features of the presentation forms are
applied to the entire cluster simultaneously, executing lookups within each feature in
the order that they are specified in the font.
The pres, abvs, blws, psts and haln features are all mandatory for software
implementations: they are required for correct script behaviour and none should ever be
treated as discretionary. Because of this and because they are all applied simultaneously

over entire clusters, they are not functionally different: a set of lookups could be divided
between these features or grouped together under one of them with no difference in
effect. These multiple features are provided, however, as an aid to the font developer for
organizing lookups based on the combinations of glyphs they apply to. There are no
specific requirements on how each should be used; the examples provided below
illustrate typical usage, however.

Pre-base substitutions
Feature Tag: "pres"
This feature is used to substitute pre-base consonant conjuncts made with half forms,
the type most common in Devanagari. The resulting conjunct can be in full or half form.
This feature can also be used to select variant forms of Matras, or pre-composed
ligatures of Matras with certain bases.

Above-base substitutions
Feature Tag: "abvs"
This feature is used for glyph substitutions involving above-base marks. Such
substitutions might be used to select contextual forms of marks, to create mark-mark
ligatures, or to create mark-base ligatures. Specific context-dependent forms or belowbase consonants are handled by this lookup as well.

Below-base substitutions
Feature Tag: "blws"
This feature is used for glyph substitutions involving below-base marks or consonants.
Such substitutions can be used to create conjuncts of base glyphs with below-base
consonants, below mark ligatures or below mark-base ligatures. Specific contextdependent forms are handled by this lookup as well.

Post-base substitutions
Feature Tag: "psts"
This feature is used to substitute post-base consonants or matras. Such substitutions
can be used to create conjuncts of base glyphs with post-base consonants or post-base
matra ligatures. It can also be used to specify contextual alternates of post-base forms.

Example 1- 'psts' ligature substitution; Ya + post-base Ya is substituted with a ligature:

Example 2- 'psts' ligature substitution; Va + post-base Va is substituted with a ligature:

Example 3 - contextual 'psts' substitution; Using MS Volt, different shapes of the postbase forms are substituted based on the context. Note; in this example 'glyph groups'
listing similar below-base forms are used:

Halant form of consonants
Feature Tag: "haln"
This feature is used to substitute a pre-composed halant form of a base (or conjunct
base) glyph in syllables ending with a halant. (Rather than using substitution, halant

forms can also be created by positioning the halant as a below-base mark on the base
glyph using the 'blwm' positioning feature.)
This feature is applied only on the base glyph if the syllable ends with a halant, or in the
case of non-final consonants that do not take a half form and do not form a conjunct
ligature with the following consonant.
Example - 'haln' feature used to substitute halant form of base glyph:

Contextual Alternates
Feature Tag: "calt"
Unlike the previous presentation lookups, the 'calt' feature is optional and is used to
substitute discretionary contextual alternates. It is important to note that an application
may allow users to turn off this feature, therefore should not be used for any obligatory
Malayalam typography.

Positioning features
Distances
Feature Tag: "dist"
This feature covers positioning lookups that adjust distances between glyphs, such as
kerning between pre- and post-base elements and the base glyph. Note; the feature
'dist' can be used in the same way as the 'kern' feature. The advantage of using the 'dist'
feature is that it does not rely on the application to enable kerning.

Above-base marks
Feature Tag: "abvm"
This feature positions all above-base marks on the base glyph or the post-base matra.
The best method for encoding this feature in an OpenType font is to use a chaining
context positioning lookup that triggers mark-to-base and mark-to-mark attachments
for above-base marks.

The 'abvm' lookup shown in MS Volt using 'Pair Adjustment' for adjusting positions of
above-marks with post-base forms in a certain context:

Below-base marks
Feature Tag: "blwm"
This feature positions all below-base marks on the base glyph. The best method for
encoding this feature in an OpenType font is to use a chaining context positioning
lookup that triggers mark-to-base and mark-to-mark attachments for below-base
marks.

Examples of Malayalam syllables
Complex Malayalam syllable formation is possible using the wide range of features
available in OpenType. The following examples show how the shaping engine applies
the OpenType features, one at a time to the input string. These combinations do not
necessarily represent actual syllables or words, but are meant to illustrate the various
OpenType features in a Malayalam font.

Example #1:

Example #2:

Appendices
Appendix A: Writing System Tags
Features are encoded according to both a designated script and language system.
Currently most shaping engine implementations only support the "default" language
system for each script. However, font developers may want to build language specific

features which are supported in other applications and will be supported in future
Microsoft OpenType implementations.
NOTE: It is strongly recommended to include the "dflt" language tag in all OpenType
fonts because it defines the basic script handling for a font. The "dflt" language system
is used as the default if no other language specific features are defined, or if the
application does not support that particular language. If the "dflt" tag is not present for
the script being used, the font may not work in some applications.
The following table lists the registered tag names for script and language systems. Note
for new Indic shaping implementation 'mlm2' is used (old-behavior implementations
used 'mlym').
**Registered tags for the Malayalam
script**

**Registered tags for Malayalam language
systems**

**Script tag**

**Script**

**Language system
tag**

**Language**

"mlm2"

Malayalam

'dflt'

*default script handling

'MAL '

Malayalam

'MLR '

Malayalam, reformed
orthography

Note: both the script and language tags are case sensitive (script tags should be
lowercase, language tags are all caps) and must contain four characters (ie. you must
add a space to the three character language tags).

Developing OpenType Fonts for Odia
Script
Article • 06/16/2022

Please note: This document reflects the changes made in 2005 recommendations for
Indic-script OpenType font and shaping-engine implementations. While Indic fonts
made according to the earlier recommendations will still function properly in the new
versions of Uniscribe, font developers may choose to update their fonts, particularly if
they wish to avoid certain limitations of the earlier implementation. Also note that the
Unicode script block name remains Oriya, which probably can't be changed for stability
reasons.
This document presents information that will help font developers create or support
OpenType fonts for all Odia script languages covered by the Unicode Standard. Odia is
similarly structured to Devanagari and is used to write the Odia language in Indian state
of Odisha. It is also used to write minority languages such as Khondi and Santali.

Introduction
This document targets developers implementing Indic shaping behavior compatible
with Microsoft OpenType specification for Indic scripts. It contains information about
terminology, font features and behavior of the Indic shaping engine in regards to the
Odia script. While it does not contain instructions for creating Odia fonts, it will help font
developers understand how the Indic shaping engine processes Indic text. In addition,
registered features of the Odia script are defined and illustrated with examples.
The new Indic shaping engine allows for variations in typographic conventions, giving a
font developer control over shaping by the choice of designation of glyphs to certain
OpenType features. For example, the location where the reph and pre-pended matra are
re-ordered within a syllable cluster is affected by the presence of a half form. See
illustrations below.
In the example below using the Devanagari script, (Ra + halant + Da+ halant + Ma + Imatra), Ra + halant will form the reph, but how the Da is classified will determine the
position of the reph as well as the location of the pre-pended matra.

Option 1: While the Da does not have a true half form in Devanagari, it can be listed in
the ‘half’ feature lookup substituting the ‘halant form’ of Da. Thus, the shaping engine
will treat it as a half form and the reph will be positioned on the first main consonant;
and the I-matra will be positioned immediately in front of the "half-form" D(a).
Option 2: By not listing Da in the ‘half’ feature lookup, the halant form will display and
the shaping engine will treat it as the first main consonant on which to position the
reph. And the I-matra will be positioned immediately in front of the base (or half-form)
preceding it, which in this case is the Ma.

Glossary
The following terms are useful for understanding the layout features and script rules
discussed in this document.
Above-base form of consonants – A variant form of a consonant that appears above
the base glyph.
Akhand ligatures - Required consonant ligatures that may appear anywhere in the
syllable and may or may not involve the base glyph. Akhand ligatures have the highest
priority and are formed first; some languages include them in their alphabets. Although
there are some 27 pairs of consonant conjuncts in Odia, not all of them are required or
considered Akhands. These ligatures are typically shown in ‘full-form’, but they may also
occur as below-base forms appearing below the base glyph.
Base glyph - The only consonant or consonant conjunct in the syllable that is written in
its "full" (nominal) form. In Odia, the last consonant of the syllable (except for syllables
ending with letter "Ra") usually forms the base glyph. In "degenerate" syllables that have
no vowel (last letter of a word), the last consonant in halant form serves as the base
consonant and is mapped as the base glyph. Layout operations are defined in terms of a
base glyph, not a base character, since the base can often be a ligature.

Below-base form of consonants – In Odia, the below-base form comes after the
consonant(s) that form the base glyph. Below-base forms are represented by the nonspacing mark glyph.
Cluster – A group of characters that form an integral unit in Indic scripts, often times a
syllable.
Consonant - Each represents a single consonant sound. Consonants may exist in
different contextual forms and have an inherent vowel (usually, the short vowel "a"). For
example, "Ka" and "Ta", rather than just "K" or "T."
Consonant conjuncts (aka “conjuncts”) - Ligatures of two or more consonants.
Consonant conjuncts may have both full and half forms, or only full forms.
Halant (Virama) - The character used after a consonant to "strip" it of it’s inherent
vowel. A Halant follows all but the last consonant in every Odia syllable.
NOTE: A syllable containing halant characters may be shaped with no visible halant
signs by using different consonant forms or conjuncts instead.
Halant form of consonants - The form produced by adding the halant (virama) to the
nominal shape. The Halant form is used in syllables that have no vowel or as the half
form when no distinct shape for the half form exists.
Half form of consonants (pre-base form) - A variant form of consonants which appear
to the left of the base consonant, if they do not participate in a ligature. Consonants in
their half form precede the ones forming the base glyph. Some Indic scripts, like
Devanagari have distinctly shaped half forms for most of the consonants. If not distinct
shape exists, the full form will display with an explicit Virama (same shape as the halant
form).
Matra (Dependent Vowel) - Used to represent a vowel sound that is not inherent to the
consonant. Dependent vowels are referred to as "matras" in Sanskrit. They are always
depicted in combination with a single consonant, or with a consonant cluster. The
greatest variation among different Indian scripts is found in the rules for attaching
dependent vowels to base characters.
Nukta - A combining character that alters the way a preceding consonant (or matra) is
pronounced.
Old shaping behavior - Shaping behavior defined in previous versions of the Indic
OpenType Font Specification.
OpenType layout engine – Library responsible for executing OpenType layout features
in a font. In the Microsoft text formatting stack, it is named OTLS (OpenType layout

services).
OpenType tag – 4-byte identifier for script, language system or feature in the font.
Odia syllable - Effective orthographic "unit" of Odia writing systems. Syllables are
composed of consonant letters, independent vowels and dependant vowels. In a text
sequence, these characters are stored in phonetic order (although they may not be
represented in phonetic order when displayed). Once a syllable is shaped, it is
indivisible. The cursor cannot be positioned within the syllable. Transformations
discussed in this document do not cross syllable boundaries.
Post-base form of consonants – A variant form of a consonant that appears to the right
of the base glyph. A consonant that takes a post-base form is preceded by the
consonant(s) forming the base glyph plus a halant (virama). Post-base forms are usually
spacing glyphs.
Pre-base form of consonants - A variant form of a consonant that appears to the left of
the base glyph. Note that most pre-base consonant forms are logically as well as visually
before the base consonant. Half forms are examples of this kind of pre-base form. In
some scripts, though, a pre-base Ra may logically follow the base consonant (that is, it
follows it phonetically and in the character sequence of the text), even though it is
presented visually before the base. The shaping engine detects such cases dynamically
using the 'pref' feature and re-orders the pre-base-form glyph as needed.
Reph – The above-base form of the letter "Ra" that is used in Devanagari when "Ra" is
the first consonant in the syllable and is not the base consonant.
Shaping Engine –Code responsible for shaping input, classified to a particular script.
Split Matra - A matra that is decomposed into pieces for rendering. Usually the different
pieces appear in different positions relative to the base. For instance, part of the matra
may be placed at the beginning of the cluster and another part at the end of the cluster.
Syllable - A single unit of Indic text processing. Shaping of Indic text is performed
independently for each syllable. Process of identifying boundaries of each syllable is
described below.
Vattu - A below-base form of a consonant. In Devanagari, "Ra" can take a vattu form
within a cluster; this "Vattu-Ra" is also known as Rakaar.

Example in Devanagari script
1. Pre-base form
2. The base consonant
3. Above-base form (reph)
4. Post-base (matra)
5. Below-base form (vattu/rakaar)

Shaping Engine
Analyze the text
Reorder characters
Shape glyph sequences (GSUB processing)
Position glyphs sequences (GPOS processing)
Base elements
Invalid combining marks
Use of ZWJ, ZWNJ and NBSP
The Indic shaping engine processes Odia text in stages. The stages are:
1. Analyze the text sequence; breaking it into syllable clusters
2. Reorder the characters as necessary
3. Apply OpenType GSUB font features to get the correct glyph shape
4. Apply OpenType GPOS features to position glyphs or marks
The descriptions which follow will help font developers understand the rationale for the
Odia feature encoding model and help application developers better understand how
layout clients can divide responsibilities with operating system functions.

Analyze the text
Character properties
The shaping engine divides the text into syllable clusters and identifies character
properties.

Character properties are used in parsing syllables and identifying its parts, in
determining proper character or glyph reordering and in OpenType feature application.
Properties for each character are divided into two types: static properties and dynamic
properties.
Static properties define basic characteristics that do not change from font to font:
character type (consonant, matra, vedic sign, etc.) or type of matra reordering. They
differ from script to script, but can't be controlled by font developer.
Dynamic properties are font dependent and are retrieved by the shaping engine as the
font is loaded. These properties affect shaping and reordering behavior.
Note: In old Indic shaping-engine implementations, all consonant properties were
static: consonants were assumed to have particular conjoining forms. This
approach could not work for Odia due to variation in typographic conventions that
have been in use. In the new Indic implementation model, consonant conjoining
behavior is a dynamic property.

Retrieving dynamic character properties from Indic fonts
Fonts define dynamic properties for consonants through implementing standard
features. Consonant types (and corresponding feature tags) that the shaping engine
reads from the font are:
Reph 'rphf'
Half forms 'half'
Pre-base-reordering forms of Ra/Rra 'pref'
Below-base forms 'blwf'
Post-base forms 'pstf'
Each of the features above is applied together with 'locl' feature to input sequences
consisting of two characters: for 'rphf' and 'half', features are applied to Consonant +
Halant combinations; for 'pref', 'blwf' and 'pstf', features are applied to Halant +
Consonant combinations. This is done for each consonant. If these two glyphs form a
ligature, with no additional glyphs in context, this means the consonant has the
corresponding form. For instance, if a substitution occurs when the 'half' and 'locl'
features are applied to a sequence Da + Halant, then Da is classified as having a half
form.
Note that a font may be implemented to re-order a Ra to pre-base position only in
certain syllables and display it as a below-base or post-base form otherwise. This means
that the Pre-base-form classification is not mutually exclusive with either Below-base-

form or Post-base-form classifications. However, all classifications are determined as
described above using context-free substitutions.
Font-dependent character classification only defines consonant types. Reordering
positions, however, are fixed for each character class.
Note: For Indic fonts that support the old Indic shaping implementation, all
features were applied to Consonant + Halant sequences. This is not applicable to
Odia, which was not supported in the old Indic shaping model.

Indic input processing
The following steps should be repeated while there are characters left in the input
sequence. All shaping operations are done on a syllable-by-syllable basis, independent
from other characters.

Find next syllable in the input
Engine should find the character sequence matching one of the patterns below:
Consonant syllable:
{C+[N]+<H+[<ZWNJ|ZWJ>]|<ZWNJ|ZWJ>+H>} +
C+[N]+[A] + [< H+[<ZWNJ|ZWJ>] | {M}+[N]+[H]>]+[SM]+[(VD)]
Vowel-based syllable:
[Ra+H]+V+[N]+[<[<ZWJ|ZWNJ>]+H+C|ZWJ+C>]+[{M}+[N]+[H]]+[SM]+[(VD)]
Stand Alone cluster (at the start of the word only):
[Ra+H]+NBSP+[N]+[<[<ZWJ|ZWNJ>]+H+C>]+[{M}+[N]+[H]]+[SM]+[(VD)]
Where
{}

zero or more occurrences

[]

optional occurrence

<|>

"one of"

()

one or two occurrences

C

consonant

V

independent vowel

N

nukta

H

halant/virama

ZWNJ

zero width non-joiner

ZWJ

zero width joiner

M

matra (up to one of each type: pre-, above-, below- or post- base)

SM

syllable modifier signs

VD

vedic

A

anudatta (U+0952)

NBSP

NO-BREAK SPACE

Identify key positions inside syllable
Syllable structure consists of the following parts:
Reph + HalfConsonant(s) + MainConsonant(s) + BelowBaseConsonant(s) +
PostBaseConsonant(s) + PreBaseReorderingRa + MatrasAndSigns
The consonant parts include all associated halants and nuktas. (For example, an instance
of BelowBaseConsonant consists of a sequence of Halant + Below-base-forming
Consonant.) All parts are optional, except the main consonant.
All parts are shown in the order they would occur within a syllable, with one
qualification: depending on a font implementation, PreBaseReorderingRa may occur
before all BelowBaseConsonants, after BelowBaseConsonants and before
PostBaseConsonants, or after PostBaseConsonants. Also, a font may be implemented to
re-order a Ra to pre-base position only in certain syllables and display it as a belowbase or post-base form otherwise. Thus, final determination of whether an occurrence of
Ra in a specific syllable can be treated as a pre-base reordering Ra can be made only
after the 'pref' feature has been applied to that syllable.
There could be several main consonants in the case where more than one consonant
doesn't have a half-, below-base, post-base or pre-base form. In a case of a cluster
where the first consonant does not have a half form, the shaping engine will recognize it
as the 1st 'full form' and go on to identify the 2nd full form consonant, if there is one.
This information will then be used to determine the reordering behavior of the reph or
any matras, vowel modifiers or stress marks.

All other elements are classified by their position relative to the base: pre-base (half
forms and reordering pre-base Ra forms), below-base, above-base and post-base.

Indic clusters are subject to the following constraints:
Only one reph is allowed per syllable.
Only one pre-base reordering Ra is allowed per syllable.
A nukta can be placed on a consonant, matra or independent vowel. It cannot be
placed on a pre-composed nukta character.
One matra from each positioning class is permitted (exception in the Kannada
script). A composite matra is treated as belonging to all the classes from which its
components belong.
One syllable modifier sign is allowed per cluster.
Vedic signs are combining marks (used for Sanskrit) that should be included in all
Indic scripts.
Danda and Double Danda are punctuation marks that should be included in all
Indic scripts.

Reorder characters
Once the Indic shaping engine has analyzed the cluster as described above, it creates
and manages a buffer of appropriately reordered elements (glyphs) representing the
cluster, according to several rules (described below).
The OpenType lookups in an Indic font must be written to match glyph sequences after
re-ordering has occurred. OpenType fonts should not have substitutions that attempt to
perform the re-ordering. If a font developer attempted to encode such reordering
information in an OpenType font, they would need to add a huge number of many-tomany glyph mappings to cover the general algorithms that a shaping engine will use.
1. Find base consonant: The shaping engine finds the base consonant of the syllable,
using the following algorithm: starting from the end of the syllable, move
backwards until a consonant is found that does not have a below-base or postbase form (post-base forms have to follow below-base forms), or that is not a prebase reordering Ra, or arrive at the first consonant. The consonant stopped at will
be the base.
If the syllable starts with Ra + Halant (in a script that has Reph) and has more
than one consonant, Ra is excluded from candidates for base consonants.
2. Decompose and reorder Matras: Each matra and any syllable modifier sign in the
cluster are moved to the appropriate position relative to the consonant(s) in the

cluster. The shaping engine decomposes two- or three-part matras into their
constituent parts before any repositioning. Matra characters are classified by which
consonant in a conjunct they have affinity for and are reordered to the following
positions:
Before first half form in the syllable
After subjoined consonants
After post-form consonant
After main consonant (for above marks)
3. Reorder marks to canonical order: Adjacent nukta and halant or nukta and vedic
sign are always repositioned if necessary, so that the nukta is first.
4. Final reordering: After the localized forms and basic shaping forms GSUB features
have been applied (see below), the shaping engine performs some final glyph
reordering before applying all the remaining font features to the entire cluster.
Reorder matras: If a pre-base matra character had been reordered before
applying basic features, the glyph can be moved closer to the main
consonant based on whether half-forms had been formed. Actual position for
the matra is defined as 'after last standalone halant glyph, after initial matra
position and before the main consonant'. If ZWJ or ZWNJ follow this halant,
position is moved after it.
Reorder reph: Reph's original position is always at the beginning of the
syllable, (i.e. it is not reordered at the character reordering stage). However, it
will be reordered according to the basic-forms shaping results. Possible
positions for reph, depending on the script, are; after main, before post-base
consonant forms, and after post-base consonant forms.
a. If reph should be positioned after post-base consonant forms, proceed to
step 5.
b. If the reph repositioning class is not after post-base: target position is after
the first explicit halant glyph between the first post-reph consonant and
last main consonant. If ZWJ or ZWNJ are following this halant, position is
moved after it. If such position is found, this is the target position.
Otherwise, proceed to the next step.
c. If reph should be repositioned after the main consonant: from the first
consonant not ligated with main, or find the first consonant that is not a
potential pre-base reordering Ra.
d. If reph should be positioned before post-base consonant, find first postbase classified consonant not ligated with main. If no consonant is found,
the target position should be before the first matra, syllable modifier sign
or vedic sign.

e. If no consonant is found in steps 3 or 4, move reph to a position
immediately before the first post-base matra, syllable modifier sign or
vedic sign that has a reordering class after the intended reph position. For
example, if the reordering position for reph is post-main, it will skip abovebase matras that also have a post-main position.
f. Otherwise, reorder reph to the end of the syllable.
Reorder pre-base reordering consonants: If a pre-base reordering consonant is
found, reorder it according to the following rules:
a. Only reorder a glyph produced by substitution during application of the
'pref' feature. (Note that a font may shape a Ra consonant with the 'pref'
feature generally but block it in certain contexts.)
b. Try to find a target position the same way as for pre-base matra. If it is
found, reorder pre-base consonant glyph.
c. If position is not found, reorder immediately before main consonant.

Character reordering Classes for Odia:
_Characters_

_Reorder Class_

0B30 (reph)

AfterMain

0B47

BeforeHalf

0B3F, 0B56

AfterMain

0B41-0B43

AfterSubscript

0B3E, 0B40

AfterPostscript

0B57

AfterPostscript

0B01

BeforeSub

Shape glyph sequences (GSUB processing)
All characters from a string are first mapped to their nominal glyphs using the cmap
lookup. The shaping engine then proceeds to shape (substitute) the glyphs using GSUB
lookups.
The features for localized forms and basic shaping forms are applied one at a time to the
cluster or a relevant portion of the cluster.
The results after basic shaping forms features have been applied impact the final syllable
analysis in terms of final designation of Ra as a pre-base reordering form and final

reordering positions for reph and matras. Next, the features for presentation forms are
applied to the entire cluster simultaneously.
Note: Since the presentation form features are applied simultaneously over the
entire cluster, several features are operationally equivalent to a single feature.
Multiple features are provided as an aid for font developers to organize the
lookups they implement.
Note: Final reordering occurs after features for basic shaping forms have been
applied and before features for presentation forms are applied. Font developers
must consider the effects of initial reordering (before any features are applied) and
final reordering (after basic shaping forms features have applied) when they create
GSUB feature and lookup tables.
These predefined features are described and illustrated in the Features section and are
applied in the order below.

Shaping features:
Localized forms
1. Apply feature 'locl' to select language-specific forms.
Basic Shaping forms
1. Apply feature 'nukt' to substitute nukta forms of consonants.
2. Apply feature 'akhn' to substitute required akhand ligatures, or to substitute forms
that take precedence over forms produced by features applied later.
3. Apply feature 'rphf' to substitute the reph glyph (above-base form of 'Ra').
4. Apply feature blwf' to substitute below-base forms.
5. Apply feature 'pstf' to substitute post-base forms.
6. Apply feature 'cjct' to substitute conjunct forms. (This is needed particularly for
ligature conjuct forms when the pre-base consonant does not have a half form).
Presentation forms
1. Apply feature 'pres' to substitute pre-base consonant conjuncts and pre-base
matra conjuncts. (ie. consonant and matra conjuncts to the left of the base glyph).
2. Apply feature 'abvs' to substitute above-base matra conjuncts, reph conjuncts,
above-base vowel modifiers and above-base stress and tone marks.
3. Apply feature 'blws' to substitute below-base consonant conjuncts, below-base
matra conjuncts, below-base vowel modifier forms and below-base stress and tone
mark forms.

4. Apply feature 'psts' to substitute post-base consonant conjuncts, post-base matra
conjuncts and post-base vowel modifiers.
5. Apply feature 'haln' to substitute the halant form of base (or conjunct base) glyph
in syllables ending with a halant.
6. Apply feature 'calt' to substitute the contextual alternate of a consonant.

Position glyph sequences (GPOS processing)
The shaping engine next processes the GPOS (glyph positioning) table, applying
features concerned with positioning. All features are applied simultaneously to the
entire cluster.
The font developer must consider the effects of re-ordering when creating the GPOS
feature and lookup tables (i.e., the glyphs will be in the order they were in after the
GSUB presentation forms features were applied).

Positioning features:
Kerning
1. Apply feature 'kern' to adjust distances (e.g., to provide kerning between post- or
pre-base elements and the base glyph).
2. Apply feature 'dist' to adjust distances. (NOTE - the feature 'dist' can be used in the
same way as the 'kern' feature. The advantage of using the 'dist' feature is that it
does not rely on the application to enable kerning. Therefore, if you want to make
sure certain spacing adjustments will always be displayed, you should use the 'dist'
feature).
Above-base marks
1. Apply feature 'abvm' to position above-base marks (above-base consonant forms,
matras, vowel modifiers or stress/tone marks) on base glyphs or post-base matra).
Below-base marks
1. Apply feature 'blwm' to position below-base marks (below-base consonant forms,
matras, vowel modifiers or stress/tone marks) on base glyphs or post-base matra).

Base elements
Commonly, a feature is required for dealing with the base glyph and one of the postbase, pre-base, above-base or below-base elements. Since it is not possible to reorder

ALL of these elements next to the base glyph, we need to skip over the elements "in the
middle" (reordering-wise).
The solution is to assign different mark attachment classes to different elements of the
syllable and positional forms, and in any given lookup work with one mark type only. For
example, in above-base substitutions we need only consider above-base elements most
of the time.
Generally, it is good practice to label as "mark" any glyphs that are denoted as
combining marks in the Unicode Standard as well as below-base/above-base forms of
consonants. Then, different attachment classes should be assigned to different marks
depending on their position with respect to the base.
For example, after the shaping engine has re-ordered elements within the cluster,
matras will always occur before syllable modifier sign such as the candrabindu. In an
actual sequence, though, potentially some other mark glyph, such as nukta, may occur
between the matra and the candrabindu. Thus, when processing the matra and
candrabindu, you may need to allow for the possibility that some other mark glyph(s)
may occur between them. Using lookup flags, you can specify that a lookup should
process only a certain class of marks, such as 'above-base marks', and ignore all other
marks. In that way, a match will occur whether or not a mark from another class is
present. Otherwise, the lookup would fail to apply.
Using Microsoft VOLT, you can assign glyphs to attachment classes.
In the example below this 'abvm' feature was set to process only TopMarks, therefore
the presence of another mark class would be ignored. If Process ALL was used and
another mark glyph followed the matra, this positioning lookup would fail to apply. This
example comes from the Devanagari font Mangal.

Invalid combining marks
Combining marks and signs that do not occur in conjunction with a valid base are
considered invalid. Shaping engine implementations may adopt different strategies for
how invalid marks are handled. For example, a shaping engine implementation might
treat an invalid mark as a separate cluster and display the stand-alone mark positioned
on some default base glyph, such as a dotted circle. (See Fallback Rendering in section
5.13 of the Unicode Standard 4.0.) Shaping engine implementations may vary somewhat
with regard to what sequences are or are not considered valid. For instance, some
implementations may impose a limit of at most one above-base vowel mark while
others may not.
To allow for shaping engine implementations that expect to position an invalid mark on
a dotted circle, it is recommended that Odia OT fonts contain a glyph for the dotted
circle character, U+25CC. If this character is not supported in the font, such
implementations will display invalid signs on the missing glyph shape (white box).

In addition to the 'dotted circle' other Unicode code points that are recommended for
inclusion in any Odia font are the ZWJ (zero width non-joiner; U+200C), the ZWNJ (zero
width joiner; U+200D) and the ZWSP (zero width space; U+200B). For more information
see the Suggested glyphs section of the OpenType Font Development document.

Effect of ZWJ, ZWNJ and NBSP on Consonant
Shaping
Unicode defines specific behaviors for ZWJ and ZWNJ in relation to Indic scripts. The
Indic-specific behavior retains the general behavior that ZWJ requests connection
between text elements while ZWNJ inhibits connection between text elements.
1. The main intent of using ZWJ in this context is to prevent a ligature-conjunct from
forming (and in Devanagari or Gujuarati, to request a half form, below-base form
or post-base form instead). The Indic engine does not need to take any action to
prevent ligature-conjuct formation: the presence of ZWJ will prevent GSUB
substitution lookups from matching the input glyph sequence. If the first
consonant does not have a half form, an overt-halant form should result, which
would also happen with no particular action by the engine.
2. A secondary intent of using ZWJ in this context is to prevent the display of reph in
the case that the first consonant is RA. If a cluster begins with RA H (halant) ZWJ,
the engine must ensure that the 'rphf' feature is not applied, and that re-ordering
for reph does not take place. Note that use of either joiner in this context should
prevent formation and re-ordering of reph when RA is the first consonant.
3. The main intent of using ZWNJ is to prevent conjunct ligature or half forms from
forming, and to display an explicit halant form instead. The shaping engine must
take specific actions to prevent half forms for a sequence of Consonant + Halant +
ZWNJ.

ZWJ can also be used to display a mark, sub- or post-base form in isolation however,
sequences to display them must begin with a no-break space (NBSP). This is because
marks, sub- and post-base forms have a 'zero-width' so must be placed on the NBSP.
For example, to get a shape of E-matra without the dotted circle one should type NBSP
+ E-matra.

In the illustration below the E-matra is displayed without the dotted circle by using the
NBSP.
The combination of NBSP and ZWJ is used to display the below-base form of Ra in
isolation.

Features
The features listed below have been defined to create the basic forms for the languages
that are supported on Devanagari systems. Regardless of the model an application
chooses for supporting layout of complex scripts, the shaping engine requires a fixed
order for executing features within a run of text to consistently obtain the proper basic
form.
The features of the basic shaping forms are applied one at a time to the cluster or
portion of the cluster. The result impacts the analysis in terms of the conjoining behavior
and final reordering. The features of the presentation forms are applied next, to the
entire cluster simultaneously. Mandatory features must always be applied; the
discretionary presentation-forms features listed should be applied by default, but can be
suppressed by a client (normally at the discretion of the user).
The order of the lookups within each feature is also very important. For more
information on lookups and defining features in OpenType fonts, see the Encoding
section of the OpenType Font Development document.
OpenType features used for Odia scripts, applied in the following order:
**Feature**

**Feature function**

**Layout
operation**

Localized forms:
locl

Localization form substitution

GSUB

Basic shaping forms:
nukt

Nukta form substitution

GSUB

akhn

Akhand ligature substitution

GSUB

rphf

Reph form substitution

GSUB

**Feature**

**Feature function**

**Layout
operation**

blwf

Below-base form substitution

GSUB

pstf

Post-base form substitution

GSUB

cjct

Conjunct form substitution

GSUB

Mandatory presentation forms:
pres

Pre-base substitution

GSUB

abvs

Above-base substitution

GSUB

blws

Below-base substitution

GSUB

psts

Post-base substitution

GSUB

haln

Halant form substitution

GSUB

Discretionary presentation forms:
calt

Contextual alternates

GSUB

Positioning features:
kern

Kerning

GPOS

dist

Distances

GPOS

abvm

Above-base mark positioning

GPOS

blwm

Below-base mark positioning

GPOS

[GSUB = glyph substitution, GPOS = glyph positioning]

Feature examples
Many of the registered features described and illustrated in this document are based on
the Microsoft OpenType font Kalinga. 'Kalinga' contains layout information and glyphs
to support all of the required features for the Malayalam script and language systems
supported.
The illustrations in the following examples show the result of that particular feature
being applied. Features must be written to match glyph sequences after re-ordering has
occurred. Note that the input context for a feature may be the result of a previous
feature having already been applied.

Localized forms
Feature Tag: "locl"
This feature is used in association with OpenType language system tags to trigger
lookups that will select alternate glyphs needed for language-specific typographic
conventions. The 'locl' should not be used in association with the default language
system, but only used with other language system tags. See the Appendix of this
document for language system tags associated with the Odia script.

Basic shaping forms
Nukta
Feature Tag: "nukt"
The nukta alters the way a preceding consonant or vowel is pronounced. The most
common nukta forms have been defined as separate characters in Unicode with their
own code points. All consonants, as well as akhand forms should have an associated
nukta form.
Note: Rather than using substitution, nukta forms can also be created by
positioning the nukta as a below-base mark on the base glyph using the 'blwm'
positioning feature
The input context for the nukt feature always consists of the full form of the consonant.
The half form of nukta consonants will be substituted using the half feature.
Nukta feature applied substitutes Dda + nukta with a pre-composed glyph (Rra):

Akhand
Feature Tag: "akhn"
An akhand is a required consonant ligatures that may appear anywhere in the syllable,
and may or may not involve the base glyph. Akhand ligatures have the highest priority
and are formed first; some languages include them in their alphabets.

The input context for the akhand feature always consists of the full form of the
consonant. The half forms of Akhand ligatures will be called later in the half feature.
Because the akhand feature is applied early in the sequence of features and is applied
over the entire cluster, it can also be used to create certain forms that must take priority
in particular contexts over forms that would be created during subsequent feature
application.
Using the 'akhn' feature; Ja + halant + Nya is substituted with the ligature JaNya:

Reph
Feature Tag: "rphf"
Applying this feature substitutes the Reph glyph. If the first consonant of the cluster
consists of the full form of Ra + Halant, this feature substitutes the combining-mark
form of Reph. In addition, the position of the Reph glyph can be adjusted with the
'abvm' GPOS feature.
The input context for the Reph feature always consists of the full form of Ra + Halant.
The 'rphf' feature substitutes the mark glyph form of Ra, when Ra is the first consonant
in a syllable:

Below form of consonant
Feature Tag: "blwf"
This feature substitutes the below-base form of consonants in Odia. The input context
for the below-base feature consists of Halant + Consonant, preceded by a consonant. If
the below-base consonant and the preceding consonant form a ligature, it will be
substituted later using the feature 'blws'.

Note: If the preceding consonant has a 'nukta' the resulting glyph will be in halantform and not below-base form. See Example 3.
Example 1- Halant + Ra (following a consonant) is substituted with the below-base form
of Ra (Ra-phala):

Example 2- The 'blwf' feature substitutes the below-base form of Ka in the sequence;
Gha + Halant + Ka:

Example 3- If the Ka is followed by a nukta the below-form of Ka is NOT substituted.
Instead the full-form Ka with nukta is displayed along with the Halant-form of Gha:

Post-base form of consonant
Feature Tag: "pstf"
Applying this feature substitutes post-base forms, such as the 'Odia Yya'.
The post-base form of the Yya is substituted, when it is the last consonant in a syllable:

Conjunct forms
Feature Tag: "cjct"
Apply feature 'cjct' to substitute conjunct forms where the first consonant in the
consonant-cluster pair does not have a half form. This feature allows for control over re-

ordering of reph and pre-pended matras in case of consonants that do not take half
forms yet do form conjunct ligatures in combination with certain following consonants.

Presentation forms
After the glyphs have been reordered, the presentation lookups are applied to provide
the best typographic rendering of the text. The features of the presentation forms are
applied to the entire cluster simultaneously, executing lookups within each feature in
the order that they are specified in the font.
The pres, abvs, blws, psts and haln features are all mandatory for software
implementations: they are required for correct script behaviour and none should ever be
treated as discretionary. Because of this and because they are all applied simultaneously
over entire clusters, they are not functionally different: a set of lookups could be divided
between these features or grouped together under one of them with no difference in
effect. These multiple features are provided, however, as an aid to the font developer for
organizing lookups based on the combinations of glyphs they apply to. There are no
specific requirements on how each should be used; the examples provided below
illustrate typical usage, however.

Pre-base substitutions
Feature Tag: "pres"
This feature is used to substitute pre-base consonant conjuncts made with half forms,
the type most common in Devanagari. The resulting conjunct can be in full or half form.
While there are no half-forms in Odia, this feature is made available to allow font
developers options for typographic preferences
This feature can also be used to select variant forms of Matras, or pre-composed
ligatures of Matras with certain bases.

Above-base substitutions
Feature Tag: "abvs"
This feature is used for glyph substitutions involving above-base marks. Such
substitutions might be used to select contextual forms of marks, to create mark-mark
ligatures, or to create mark-base ligatures. Specific context-dependent forms or belowbase consonants are handled by this lookup as well.

Example 1- 'abvs' mark ligatures; ikaar + reph + candrabindu substituted with a
conjunct:

Below-base substitutions
Feature Tag: "blws"
This feature is used for glyph substitutions involving below-base marks or consonants.
Such substitutions can be used to create conjuncts of base glyphs with below-base
consonants, below mark ligatures or below mark-base ligatures. Specific contextdependent forms are handled by this lookup as well.
Example 1- 'blws' substitution to create below-base consonant conjuncts (Ka + Taphala):

Example 2- 'blws' substitution to create below-base mark conjuncts (Ra-phala + Ukaar):

Example 3 - contextual 'blws' substitution; Using MS Volt, alternate below-base forms
are substituted based on the context. Note; in this example 'glyph groups' are used for

the context:

Post-base substitutions
Feature Tag: "psts"
This feature is used to substitute post-base consonants or matras. Such substitutions
can be used to create conjuncts of base glyphs with post-base consonants or post-base
matra ligatures. It can also be used to specify contextual alternates of post-base forms.
Example 1 - 'psts' substitution to create post-base conjuncts (Dha + Yya-phala):

Example 2 - 'psts' substitution to create post-base matra conjuncts (reph + candrabindu
+ Au-length mark):

Halant form of consonants
Feature Tag: "haln"
This feature is used to substitute the halant form of a base (or conjunct base) glyph in
syllables ending with a halant. Halant forms can also be created by positioning the
halant as a below-base mark on the base glyph using the 'blwm' positioning feature.
This feature is applied only on the base glyph if the syllable ends with a halant.
Example 1 - 'haln' feature used to substitute halant form of base glyph:

Contextual Alternates
Feature Tag: "calt"
Unlike the previous presentation lookups, the 'calt' feature is optional and is used to
substitute discretionary contextual alternates. It is important to note that an application
may allow users to turn off this feature, therefore should not be used for any obligatory
Odia typography.

Positioning features
Distances
Feature Tag: "dist"
This feature covers positioning lookups that adjust distances between glyphs, such as
kerning between pre- and post-base elements and the base glyph. Note; the feature
'dist' can be used in the same way as the 'kern' feature. The advantage of using the 'dist'
feature is that it does not rely on the application to enable kerning.

Above-base marks
Feature Tag: "abvm"
This feature positions all above-base marks on the base glyph or the post-base matra.
The best method for encoding this feature in an OpenType font is to use a chaining

context positioning lookup that triggers mark-to-base and mark-to-mark attachments
for above-base marks.
'abvm' lookup in MS Volt using 'Anchor Attachment' for adjusting positions of abovemarks over bases:

Below-base marks
Feature Tag: "blwm"
This feature positions all below-base marks on the base glyph. The best method for
encoding this feature in an OpenType font is to use a chaining context positioning
lookup that triggers mark-to-base and mark-to-mark attachments for below-base
marks.
Example 1 - 'blwm' lookup in MS Volt using 'Anchor Attachment' for positioning belowmarks with bases:

Example 2 - - contextual 'blwm' positioning in MS Volt using 'Anchor Attachment' for
positioning nukta when followed by certain below-base matras:

Examples of Odia syllables
Complex Odia syllable formation is possible using the wide range of features available in
OpenType. The following examples show how the shaping engine applies the OpenType
features, one at a time to the input string. These combinations do not necessarily

represent actual syllables or words, but are meant to illustrate the various OpenType
features in a Odia font.
Example #1:

Example #2:

Appendices
Appendix A: Writing System Tags
Features are encoded according to both a designated script and language system.
Currently most shaping engine implementations only support the "default" language
system for each script. However, font developers may want to build language specific
features which are supported in other applications and will be supported in future
Microsoft OpenType implementations.
NOTE: It is strongly recommended to include the "dflt" language tag in all OpenType
fonts because it defines the basic script handling for a font. The "dflt" language system
is used as the default if no other language specific features are defined, or if the
application does not support that particular language. If the "dflt" tag is not present for
the script being used, the font may not work in some applications.
The following table lists the registered tag names for script and language systems.
Note: Odia script is supported only using new Indic shaping behavior, for which
the script tag 'ory2' is used. The script tag “orya” was registered for use with the

old Indic shaping behavior, but the old shaping behavior was incompatible with
requirements of Odia script. Hence, the script tag “orya” is never used.
Registered tags for the Odia script

Registered tags for Odia language systems

**Script tag**

**Script**

**Language system
tag**

**Language**

"ory2"

Odia

'dflt'

*default script handling

'SAT '

Santali

'KUI '

Kui

'SAN '

Sanskrit

Note: both the script and language tags are case sensitive (script tags should be
lowercase, language tags are all caps) and must contain four characters (ie. you must
add a space to the three character language tags).

Developing OpenType Fonts for Tamil
Script
Article • 06/16/2022

Please note: This document reflects the changes made in 2005 recommendations for
Indic-script OpenType font and shaping-engine implementations. While Indic fonts
made according to the earlier recommendations will still function properly in the new
versions of Uniscribe, font developers may choose to update their fonts, particularly if
they wish to avoid certain limitations of the earlier implementation.
This document presents information that will help font developers create or support
OpenType fonts for Tamil script languages covered by the Unicode Standard. The Tamil
script is used to write the Tamil language of the southern Indian state of Tamil Nadu, as
well as minority languages like Badaga. Tamil is also used in Sri Lanka, Singapore and
parts of Malaysia. The Tamil script has fewer consonants than other Indic scripts and has
only one consonant conjunct.

Introduction
This document targets developers implementing Indic shaping behavior compatible
with Microsoft OpenType specification for Indic scripts. It contains information about
terminology, font features and behavior of the Indic shaping engine in regards to the
Tamil script. While it does not contain instructions for creating Tamil fonts, it will help
font developers understand how the Indic shaping engine processes Indic text. In
addition, registered features of the Tamil script are defined and illustrated with
examples.
The new Indic shaping engine allows for variations in typographic conventions, giving a
font developer control over shaping by the choice of designation of glyphs to certain
OpenType features. For example, the location where the reph and pre-pended matra are
re-ordered within a syllable cluster is affected by the presence of a half form. See
illustrations below.

Glossary
The following terms are useful for understanding the layout features and script rules
discussed in this document.

Above-base form of consonants – A variant form of a consonant that appears above
the base glyph.
Akhand ligatures - Required consonant ligatures that may appear anywhere in the
syllable, and may or may not involve the base glyph. Akhand ligatures have the highest
priority and are formed first; some languages include them in their alphabets. Akhand
ligatures may be displayed in either half- or full-form.
Base glyph - The only consonant or consonant conjunct in the orthographic syllable that
is written in its "full" (nominal) form. In Tamil, the last consonant of the syllable forms the
base glyph. In "degenerate" syllables that have no vowel (last letter of a word), the last
consonant in halant form serves as the base consonant and is mapped as the base
glyph. Layout operations are defined in terms of a base glyph, not a base character,
since the base can often be a ligature.
Below-base form of consonants - A variant form of a consonant that appears below the
base glyph. In the glyph sequence, the below-base form comes after the consonant(s)
that form the base glyph. Below-base forms are represented by a non-spacing mark
glyph.
Cluster – A group of characters that form an integral unit in Indic scripts, often times a
syllable.
Consonant - Each represents a single consonant sound. Consonants may exist in
different contextual forms and have an inherent vowel (usually, the short vowel "a"). For
example, "Ka" and "Ta", rather than just "K" or "T."
Consonant conjuncts (aka “conjuncts”) - Ligatures of two or more consonants.
Consonant conjuncts may have both full and half forms, or only full forms.
Halant (Virama) - The character used after a consonant to "strip" it of it’s inherent
vowel.
NOTE: A syllable containing halant characters may be shaped with no visible halant
signs by using different consonant forms or conjuncts instead.
Halant form of consonants - The form produced by adding the halant (virama) to the
nominal shape. The Halant form is used in syllables that have no vowel or as the half
form when no distinct shape for the half form exists.
Half form of consonants (pre-base form) - A variant form of consonants which appear
to the left of the base consonant, if they do not participate in a ligature. Consonants in
their half form precede the ones forming the base glyph. Some Indic scripts, like
Devanagari have distinctly shaped half forms for most of the consonants. If not distinct

shape exists, the full form will display with an explicit Virama (same shape as the halant
form).
Matra (Dependent Vowel) - Used to represent a vowel sound that is not inherent to the
consonant. Dependent vowels are referred to as "matras" in Sanskrit. They are always
depicted in combination with a single consonant, or with a consonant cluster. The
greatest variation among different Indian scripts is found in the rules for attaching
dependent vowels to base characters.
New shaping behavior - Shaping behavior defined in this version of the Indic OpenType
Font Specification. Information in this document relates primarily to the new
implementation model. Old behavior may be mentioned in comments about
compatibility.
Nukta - A combining character that alters the way a preceding consonant (or matra) is
pronounced.
Old shaping behavior - Shaping behavior defined in previous versions of the Indic
OpenType Font Specification.
OpenType layout engine – Library responsible for executing OpenType layout features
in a font. In the Microsoft text formatting stack, it is named OTLS (OpenType layout
services).
OpenType tag – 4-byte identifier for script, language system or feature in the font.
Post-base form of consonants – A variant form of a consonant that appears to the right
of the base glyph. A consonant that takes a post-base form is preceded by the
consonant(s) forming the base glyph plus a halant (virama). Post-base forms are usually
spacing glyphs.
Pre-base form of consonants - A variant form of a consonant that appears to the left of
the base glyph. Note that most pre-base consonant forms are logically as well as visually
before the base consonant. Half forms are examples of this kind of pre-base form. In
some scripts, though, a pre-base Ra may logically follow the base consonant (that is, it
follows it phonetically and in the character sequence of the text), even though it is
presented visually before the base. The shaping engine detects such cases dynamically
using the 'pref' feature and re-orders the pre-base-form glyph as needed.
Reph – The above-base form of the letter "Ra" that is used in Devanagari when "Ra" is
the first consonant in the syllable and is not the base consonant.
Shaping Engine –Code responsible for shaping input, classified to a particular script.

Split Matra - A matra that is decomposed into pieces for rendering. Usually the different
pieces appear in different positions relative to the base. For instance, part of the matra
may be placed at the beginning of the cluster and another part at the end of the cluster.
Syllable - A single unit of Indic text processing. Shaping of Indic text is performed
independently for each syllable. Process of identifying boundaries of each syllable is
described below.
Vattu - A below-base form of a consonant.

Example in Devanagari script
1. Pre-base form
2. The base consonant
3. Above-base form (reph)
4. Post-base (matra)
5. Below-base form (vattu/rakaar)

Shaping Engine
Analyze the text
Reorder characters
Shape glyph sequences (GSUB processing)
Position glyphs sequences (GPOS processing)
Base elements
Invalid combining marks
Use of ZWJ, ZWNJ and NBSP
The Indic shaping engine processes Tamil text in stages. The stages are:
1. Analyze the text sequence; breaking it into syllable clusters
2. Reorder the characters as necessary
3. Apply OpenType GSUB font features to get the correct glyph shape
4. Apply OpenType GPOS features to position glyphs or marks

The descriptions which follow will help font developers understand the rationale for the
Tamil feature encoding model and help application developers better understand how
layout clients can divide responsibilities with operating system functions.

Analyze the syllables
Character properties
The shaping engine divides the text into syllable clusters and identifies character
properties.
Character properties are used in parsing syllables and identifying its parts, in
determining proper character or glyph reordering and in OpenType feature application.
Properties for each character are divided into two types: static properties and dynamic
properties.
Static properties define basic characteristics that do not change from font to font:
character type (consonant, matra, vedic sign, etc.) or type of matra reordering. They
differ from script to script, but can't be controlled by font developer.
Dynamic properties are font dependent and are retrieved by the shaping engine as the
font is loaded. These properties affect shaping and reordering behavior.
*Note: in old shaping-engine implementations, all consonant properties were static:
consonants were assumed to have particular conjoining forms. In the new
implementation model, consonant conjoining behavior is a dynamic property.

Retrieving dynamic character properties from Indic fonts
Fonts define dynamic properties for consonants through implementing standard
features. Consonant types (and corresponding feature tags) that the shaping engine
reads from the font are:
Reph 'rphf'
Half forms 'half'
Pre-base-reordering forms of Ra/Rra 'pref'
Below-base forms 'blwf'
Post-base forms 'pstf'
Each of the features above is applied together with 'locl' feature to input sequences
consisting of two characters: for 'rphf' and 'half', features are applied to Consonant +
Halant combinations; for 'pref', 'blwf' and 'pstf', features are applied to Halant +

Consonant combinations. This is done for each consonant. If these two glyphs form a
ligature, with no additional glyphs in context, this means the consonant has the
corresponding form. For instance, if a substitution occurs when the 'half' and 'locl'
features are applied to a sequence Da + Halant, then Da is classified as having a half
form.
Note that a font may be implemented to re-order a Ra to pre-base position only in
certain syllables and display it as a below-base or post-base form otherwise. This means
that the Pre-base-form classification is not mutually exclusive with either Below-baseform or Post-base-form classifications. However, all classifications are determined as
described above using context-free substitutions.
Font-dependent character classification only defines consonant types. Reordering
positions, however, are fixed for each character class.
*Note: for fonts that support the old implementation, all features are applied to
Consonant + Halant sequences.

Indic input processing
The following steps should be repeated while there are characters left in the input
sequence. All shaping operations are done on a syllable-by-syllable basis, independent
from other characters.

Find next syllable in the input
Engine should find the character sequence matching one of the patterns below:
Consonant syllable:
{C+[N]+<H+[<ZWNJ|ZWJ>]|<ZWNJ|ZWJ>+H>} +
C+[N]+[A] + [< H+[<ZWNJ|ZWJ>] | {M}+[N]+[H]>]+[SM]+[(VD)]
Vowel-based syllable:
[Ra+H]+V+[N]+[<[<ZWJ|ZWNJ>]+H+C|ZWJ+C>]+[{M}+[N]+[H]]+[SM]+[(VD)]
Stand Alone cluster (at the start of the word only):
[Ra+H]+NBSP+[N]+[<[<ZWJ|ZWNJ>]+H+C>]+[{M}+[N]+[H]]+[SM]+[(VD)]
Where
{}

zero or more occurrences

[]

optional occurrence

<|>

"one of"

()

one or two occurrences

C

consonant

V

independent vowel

N

nukta

H

halant/virama

ZWNJ

zero width non-joiner

ZWJ

zero width joiner

M

matra (up to one of each type: pre-, above-, below- or post- base)

SM

syllable modifier signs

VD

vedic

A

anudatta (U+0952)

NBSP

NO-BREAK SPACE

Identify key positions inside syllable
Syllable structure consists of the following parts:
Reph + HalfConsonant(s) + MainConsonant(s) + BelowBaseConsonant(s) +
PostBaseConsonant(s) + PreBaseReorderingRa + MatrasAndSigns
The consonant parts include all associated halants and nuktas. (For example, an instance
of BelowBaseConsonant consists of a sequence of Halant + Below-base-forming
Consonant.) All parts are optional, except the main consonant.
All parts are shown in the order they would occur within a syllable, with one
qualification: depending on a font implementation, PreBaseReorderingRa may occur
before all BelowBaseConsonants, after BelowBaseConsonants and before
PostBaseConsonants, or after PostBaseConsonants. Also, a font may be implemented to
re-order a Ra to pre-base position only in certain syllables and display it as a belowbase or post-base form otherwise. Thus, final determination of whether an occurrence of
Ra in a specific syllable can be treated as a pre-base reordering Ra can be made only
after the 'pref' feature has been applied to that syllable.

There could be several main consonants in the case where more than one consonant
doesn't have a half-, below-base, post-base or pre-base form. In a case of a cluster
where the first consonant does not have a half form, the shaping engine will recognize it
as the 1st 'full form' and go on to identify the 2nd full form consonant, if there is one.
This information will then be used to determine the reordering behavior of the reph or
any matras, vowel modifiers or stress marks.
All other elements are classified by their position relative to the base: pre-base (half
forms and reordering pre-base Ra forms), below-base, above-base and post-base.

Indic clusters are subject to the following constraints:
Only one reph is allowed per syllable.
Only one pre-base reordering Ra is allowed per syllable.
A nukta can be placed on a consonant, matra or independent vowel. It cannot be
placed on a pre-composed nukta character.
One matra from each positioning class is permitted (exception in the Kannada
script). A composite matra is treated as belonging to all the classes from which its
components belong.
One syllable modifier sign is allowed per cluster.
Vedic signs are combining marks (used for Sanskrit) that should be included in all
Indic scripts.
Danda and Double Danda are punctuation marks that should be included in all
Indic scripts.

Reorder characters
Once the Indic shaping engine has analyzed the cluster as described above, it creates
and manages a buffer of appropriately reordered elements (glyphs) representing the
cluster, according to several rules (described below).
The OpenType lookups in an Indic font must be written to match glyph sequences after
re-ordering has occurred. OpenType fonts should not have substitutions that attempt to
perform the re-ordering. If a font developer attempted to encode such reordering
information in an OpenType font, they would need to add a huge number of many-tomany glyph mappings to cover the general algorithms that a shaping engine will use.
1. Find base consonant: The shaping engine finds the base consonant of the syllable,
using the following algorithm: starting from the end of the syllable, move
backwards until a consonant is found that does not have a below-base or postbase form (post-base forms have to follow below-base forms), or that is not a pre-

base reordering Ra, or arrive at the first consonant. The consonant stopped at will
be the base.
If the syllable starts with Ra + Halant (in a script that has Reph) and has more
than one consonant, Ra is excluded from candidates for base consonants.
2. Decompose and reorder Matras: Each matra and any syllable modifier sign in the
cluster are moved to the appropriate position relative to the consonant(s) in the
cluster. The shaping engine decomposes two- or three-part matras into their
constituent parts before any repositioning. Matra characters are classified by which
consonant in a conjunct they have affinity for and are reordered to the following
positions:
Before first half form in the syllable
After subjoined consonants
After post-form consonant
After main consonant (for above marks)
3. Reorder marks to canonical order: Adjacent nukta and halant or nukta and vedic
sign are always repositioned if necessary, so that the nukta is first.
4. Final reordering: After the localized forms and basic shaping forms GSUB features
have been applied (see below), the shaping engine performs some final glyph
reordering before applying all the remaining font features to the entire cluster.
a. Reorder matras: If a pre-base matra character had been reordered before
applying basic features, the glyph can be moved closer to the main consonant
based on whether half-forms had been formed. Actual position for the matra is
defined as 'after last standalone halant glyph, after initial matra position and
before the main consonant'. If ZWJ or ZWNJ follow this halant, position is
moved after it.
b. Reorder reph: Reph's original position is always at the beginning of the syllable,
(i.e. it is not reordered at the character reordering stage). However, it will be
reordered according to the basic-forms shaping results. Possible positions for
reph, depending on the script, are; after main, before post-base consonant
forms, and after post-base consonant forms.
i. If reph should be positioned after post-base consonant forms, proceed to
step 5.
ii. If the reph repositioning class is not after post-base: target position is after
the first explicit halant glyph between the first post-reph consonant and last
main consonant. If ZWJ or ZWNJ are following this halant, position is moved
after it. If such position is found, this is the target position. Otherwise,
proceed to the next step.

Note: in old-implementation fonts, where classifications were fixed in shaping
engine, there was no case where reph position will be found on this step.
iii. If reph should be repositioned after the main consonant: from the first
consonant not ligated with main, or find the first consonant that is not a
potential pre-base reordering Ra.
iv. If reph should be positioned before post-base consonant, find first post-base
classified consonant not ligated with main. If no consonant is found, the
target position should be before the first matra, syllable modifier sign or
vedic sign.
v. If no consonant is found in steps 3 or 4, move reph to a position immediately
before the first post-base matra, syllable modifier sign or vedic sign that has
a reordering class after the intended reph position. For example, if the
reordering position for reph is post-main, it will skip above-base matras that
also have a post-main position.
vi. Otherwise, reorder reph to the end of the syllable.
c. Reorder pre-base reordering consonants: If a pre-base reordering consonant is
found, reorder it according to the following rules:
i. Only reorder a glyph produced by substitution during application of the
'pref' feature. (Note that a font may shape a Ra consonant with the 'pref'
feature generally but block it in certain contexts.)
ii. Try to find a target position the same way as for pre-base matra. If it is found,
reorder pre-base consonant glyph.
iii. If position is not found, reorder immediately before main consonant.

Character reordering Classes for Tamil:
Characters

Reorder Class

0BB0 (reph)

After Postscript

0BC6-0BC8

BeforeMain

0BC0

AfterSubscript

0BBF

AfterPostscript

0BC1, 0BC2

AfterPostscript

0BBE, 0BD7

AfterPostscript

Shape glyph sequences (GSUB processing)

All characters from a string are first mapped to their nominal glyphs using the cmap
lookup. The shaping engine then proceeds to shape (substitute) the glyphs using GSUB
lookups.
The features for localized forms and basic shaping forms are applied one at a time to the
cluster or a relevant portion of the cluster.
The results after basic shaping forms features have been applied impact the final syllable
analysis in terms of final designation of Ra as a pre-base reordering form and final
reordering positions for reph and matras. Next, the features for presentation forms are
applied to the entire cluster simultaneously. Note: since the presentation form features
are applied simultaneously over the entire cluster, several features are operationally
equivalent to a single feature. Multiple features are provided as an aid for font
developers to organize the lookups they implement.
Note: final reordering occurs after features for basic shaping forms have been applied
and before features for presentation forms are applied. Font developers must consider
the effects of initial reordering (before any features are applied) and final reordering
(after basic shaping forms features have applied) when they create GSUB feature and
lookup tables.
These predefined features are described and illustrated in the Features section and are
applied in the order below.

Shaping features:
Localized forms
1. Apply feature 'locl' to select language-specific forms.
Basic Shaping forms
1. Apply feature 'nukt' to substitute nukta forms of consonants.
2. Apply feature 'akhn' to substitute required akhand ligatures, or to substitute forms
that take precedence over forms produced by features applied later.
3. Apply feature 'rphf' to substitute the reph glyph (above-base form of 'Ra').
4. Apply feature 'pref' to substitute pre-base forms.
5. Apply feature 'half' to substitute half forms of pre-base consonants.
Presentation forms
1. Apply feature 'pres' to substitute pre-base consonant conjuncts and pre-base
matra conjuncts. (ie. consonant and matra conjuncts to the left of the base glyph).

2. Apply feature 'abvs' to substitute above-base matra conjuncts; reph conjuncts;
above-base vowel modifiers; and above-base stress and tone marks.
3. Apply feature 'blws' to substitute below-base consonant conjuncts; below-base
matra conjuncts; below-base vowel modifier forms; and below-base stress and
tone mark forms.
4. Apply feature 'psts' to substitute post-base consonant conjuncts, post-base matra
conjuncts and post-base vowel modifiers.
5. Apply feature 'haln' to substitute the halant form of base (or conjunct base) glyph
in syllables ending with a halant.
6. Apply feature 'calt' to substitute the contextual alternate of a consonant.

Position glyph sequences (GPOS processing)
The shaping engine next processes the GPOS (glyph positioning) table, applying
features concerned with positioning. All features are applied simultaneously to the
entire cluster.
The font developer must consider the effects of re-ordering when creating the GPOS
feature and lookup tables (i.e., the glyphs will be in the order they were in after the
GSUB presentation forms features were applied).

Positioning features:
Kerning
1. Apply feature 'kern' to adjust distances (e.g., to provide kerning between post- or
pre-base elements and the base glyph).
2. Apply feature 'dist' to adjust distances. (NOTE - the feature 'dist' can be used in the
same way as the 'kern' feature. The advantage of using the 'dist' feature is that it
does not rely on the application to enable kerning. Therefore, if you want to make
sure certain spacing adjustments will always be displayed, you should use the 'dist'
feature).
Above-base marks
1. Apply feature 'abvm' to position above-base marks (above-base consonant forms,
matras, vowel modifiers or stress/tone marks) on base glyphs or post-base matra).
Below-base marks
1. Apply feature 'blwm' to position below-base marks (below-base consonant forms,
matras, vowel modifiers or stress/tone marks) on base glyphs or post-base matra).

Base elements
Commonly, a feature is required for dealing with the base glyph and one of the postbase, pre-base, above-base or below-base elements. Since it is not possible to reorder
ALL of these elements next to the base glyph, we need to skip over the elements "in the
middle" (reordering-wise).
The solution is to assign different mark attachment classes to different elements of the
syllable and positional forms, and in any given lookup work with one mark type only. For
example, in above-base substitutions we need only consider above-base elements most
of the time.
Generally, it is good practice to label as "mark" any glyphs that are denoted as
combining marks in the Unicode Standard as well as below-base/above-base forms of
consonants. Then, different attachment classes should be assigned to different marks
depending on their position with respect to the base.
For example, after the shaping engine has re-ordered elements within the cluster,
matras will always occur before syllable modifier sign such as the candrabindu. In an
actual sequence, though, potentially some other mark glyph, such as nukta, may occur
between the matra and the candrabindu. Thus, when processing the matra and
candrabindu, you may need to allow for the possibility that some other mark glyph(s)
may occur between them. Using lookup flags, you can specify that a lookup should
process only a certain class of marks, such as 'above-base marks', and ignore all other
marks. In that way, a match will occur whether or not a mark from another class is
present. Otherwise, the lookup would fail to apply.
Using Microsoft VOLT, you can assign glyphs to attachment classes.
In the example below this 'abvm' feature was set to process only TopMarks, therefore
the presence of another mark class would be ignored. If Process ALL was used and
another mark glyph followed the matra, this positioning lookup would fail to apply. This
example comes from the Devanagari font Mangal.

Invalid combining marks
Combining marks and signs that do not occur in conjunction with a valid base are
considered invalid. Shaping engine implementations may adopt different strategies for
how invalid marks are handled. For example, a shaping engine implementation might
treat an invalid mark as a separate cluster and display the stand-alone mark positioned
on some default base glyph, such as a dotted circle. (See Fallback Rendering in section
5.13 of the Unicode Standard 4.0.) Shaping engine implementations may vary somewhat
with regard to what sequences are or are not considered valid. For instance, some
implementations may impose a limit of at most one above-base vowel mark while
others may not.
To allow for shaping engine implementations that expect to position an invalid mark on
a dotted circle, it is recommended that a Tamil OT font contain a glyph for the dotted
circle character, U+25CC. If this character is not supported in the font, such
implementations will display invalid signs on the missing glyph shape (white box).

In addition to the 'dotted circle' other Unicode code points that are recommended for
inclusion in any Tamil font are the ZWJ (zero width joiner; U+200D), the ZWNJ (zero
width non-joiner; U+200C) and the ZWSP (zero width space; U+200B). For more
information see the Suggested glyphs section of the OpenType Font Development
document.

Effect of ZWJ, ZWNJ and NBSP on Consonant
Shaping
Unicode defines specific behaviors for ZWJ and ZWNJ in relation to Indic scripts. The
Indic-specific behavior retains the general behavior that ZWJ requests connection
between text elements while ZWNJ inhibits connection between text elements.
1. 1. The main intent of using ZWJ in this context is to prevent a ligature-conjunct
from forming (and in Devanagari or Gujuarati, to request a half form, below-base
form or post-base form instead). The Indic engine does not need to take any
action to prevent ligature-conjuct formation: the presence of ZWJ will prevent
GSUB substitution lookups from matching the input glyph sequence. If the first
consonant does not have a half form, an overt-halant form should result, which
would also happen with no particular action by the engine.
2. 2. A secondary intent of using ZWJ in this context is to prevent the display of reph
in the case that the first consonant is RA. If a cluster begins with RA H (halant) ZWJ,
the engine must ensure that the 'rphf' feature is not applied, and that re-ordering
for reph does not take place. Note that use of either joiner in this context should
prevent formation and re-ordering of reph when RA is the first consonant.
3. 3. The main intent of using ZWNJ is to prevent conjunct ligature or half forms from
forming, and to display an explicit halant form instead. The shaping engine must
take specific actions to prevent half forms for a sequence of Consonant + Halant +
ZWNJ.

Just as the ZWJ can be used to display a half form in isolation, it can also be used to
display a mark, sub- or post-base form in isolation. Unlike the stand-alone half form,
however, sequences to display them must begin with a no-break space (NBSP). This is
because mark glyphs must combine with a base glyph: to appear in isolation, a NBSP
must be provided as a base. For example, to get a shape of I-matra without the dotted
circle one should type NBSP + I-matra.

The illustration below uses the Devanagari script, and shows the I-matra displayed
without the dotted circle by using the NBSP. The combination of NBSP and ZWJ is used
to display the below-base form of Ra (Rakaar) in isolation.

Features
The features listed below have been defined to create the basic forms for the languages
that are supported on Tamil systems. Regardless of the model an application chooses for
supporting layout of complex scripts, the shaping engine requires a fixed order for
executing features within a run of text to consistently obtain the proper basic form.
The features of the basic shaping forms are applied one at a time to the cluster or
portion of the cluster. The result impacts the analysis in terms of the conjoining behavior
and final reordering. The features of the presentation forms are applied next, to the
entire cluster simultaneously. Mandatory features must always be applied; the
discretionary presentation-forms features listed should be applied by default, but can be
suppressed by a client (normally at the discretion of the user).
The order of the lookups within each feature is also very important. For more
information on lookups and defining features in OpenType fonts, see the Encoding
section of the OpenType Font Development document.
OpenType features used for Tamil scripts, applied in the following order:
**Feature**

**Feature function**

**Layout
operation**

Localized forms:
locl

Localization form substitution

GSUB

Basic shaping forms:
nukt

Nukta form substitution

GSUB

akhn

Akhand ligature substitution

GSUB

rphf

Reph form substitution

GSUB

pref

Pre-base form substitution

GSUB

**Feature**

**Feature function**

**Layout
operation**

half

Half-form substitution

GSUB

Mandatory presentation forms:
pres

Pre-base substitution

GSUB

abvs

Above-base substitution

GSUB

blws

Below-base substitution

GSUB

psts

Post-base substitution

GSUB

haln

Halant form substitution

GSUB

Discretionary presentation forms:
calt

Contextual alternates

GSUB

Positioning features:
kern

Kerning

GPOS

dist

Distances

GPOS

abvm

Above-base mark positioning

GPOS

blwm

Below-base mark positioning

GPOS

[GSUB = glyph substitution, GPOS = glyph positioning]

Feature examples
Many of the registered features described and illustrated in this document are based on
the Microsoft OpenType font Latha. 'Latha' contains layout information and glyphs to
support all of the required features for the Tamil script and language systems supported.
The illustrations in the following examples show the result of that particular feature
being applied. Features must be written to match glyph sequences after re-ordering has
occurred. Note that the input context for a feature may be the result of a previous
feature having already been applied.

Localized forms
Feature Tag: "locl"

This feature is used in association with OpenType language system tags to trigger
lookups that will select alternate glyphs needed for language-specific typographic
conventions. The 'locl' should not be used in association with the default language
system, but only used with other language system tags. See the Appendix of this
document for language system tags associated with the Tamil script.

Basic shaping forms
Nukta
Feature Tag: "nukt"
The nukta alters the way a preceding consonant or vowel is pronounced. The most
common nukta forms have been defined as separate characters in Unicode with their
own code points. All consonants, as well as akhand forms should have an associated
nukta form.
Note - Rather than using substitution, nukta forms can also be created by positioning
the nukta as a below-base mark on the base glyph using the 'blwm' positioning feature
The input context for the nukt feature always consists of the full form of the consonant.
The half form of nukta consonants will be substituted using the half feature.

Akhand
Feature Tag: "akhn"
An akhand is a required consonant ligatures that may appear anywhere in the syllable,
and may or may not involve the base glyph. Akhand ligatures have the highest priority
and are formed first; some languages include them in their alphabets.
The input context for the akhand feature always consists of the full form of the
consonant. The half forms of Akhand ligatures will be called later in the half feature.
Because the akhand feature is applied early in the sequence of features and is applied
over the entire cluster, it can also be used to create certain forms that must take priority
in particular contexts over forms that would be created during subsequent feature
application.

Ka + halant + Ssa are substituted with the KaSsa ligature:

Reph
Feature Tag: "rphf"
Applying this feature substitutes the Reph glyph. If the first consonant of the cluster
consists of the full form of Ra + Halant, this feature substitutes the combining-mark
form of Reph. In addition, the position of the Reph glyph is adjusted with the 'abvm'
GPOS feature.
The input context for the Reph feature always consists of the full form of Ra + Halant.

Pre-base form of consonant
Feature Tag: "pref"
This feature substitutes the pre-base forms of Consonants.

Half form of consonant
Feature Tag: "half"
Applying this feature substitutes half forms - forms of consonants used in the pre-base
position. Consonants that have a half form should be listed in the 'half' feature. Some
scripts, like Devanagari have distinctly shaped half forms for most of the consonants
however, if a consonant does not have a distinct shape for the half form and does not
form any ligature, it will be displayed with an explicit Virama (same shape as the halant
form).
Note - the result of listing a consonant in the half feature (whether it has a true half
form or not) will affect the re-ordering (and positioning) of the reph and pre-pended
matras. See illustration in the Introduction section of this document.
This feature is applied to all consonants preceding the 'main' consonant.
Note - While Tamil typically does not use half forms, this feature is made available for
typographic preference.

Presentation forms
After the glyphs have been reordered, the presentation lookups are applied to provide
the best typographic rendering of the text. The features of the presentation forms are
applied to the entire cluster simultaneously, executing lookups within each feature in
the order that they are specified in the font.
The pres, abvs, blws, psts and haln features are all mandatory for software
implementations: they are required for correct script behaviour and none should ever be
treated as discretionary. Because of this and because they are all applied simultaneously
over entire clusters, they are not functionally different: a set of lookups could be divided
between these features or grouped together under one of them with no difference in
effect. These multiple features are provided, however, as an aid to the font developer for
organizing lookups based on the combinations of glyphs they apply to. There are no
specific requirements on how each should be used; the examples provided below
illustrate typical usage, however.

Pre-base substitutions
Feature Tag: "pres"
This feature is used to substitute pre-base consonant conjuncts made with half forms,
the type most common in Devanagari. The resulting conjunct can be in full or half form.
This feature can also be used to select variant forms of Matras, or pre-composed
ligatures of Matras with certain bases.

Above-base substitutions
Feature Tag: "abvs"
This feature is used for glyph substitutions involving above-base marks. Such
substitutions might be used to select contextual forms of marks, to create mark-mark
ligatures, or to create mark-base ligatures. Specific context-dependent forms or belowbase consonants are handled by this lookup as well.
The "abvs" feature used to substitute Above-base Matra ligature:

Using MS Volt, different shapes of the vowel Ii are substituted based on the context.
Note; in this example 'glyph groups' listing consonants with similar widths are used for
the substitution context.

Below-base substitutions
Feature Tag: "blws"
This feature is used for glyph substitutions involving below-base marks or consonants.
Such substitutions can be used to create conjuncts of base glyphs with below-base
consonants, below mark ligatures or below mark-base ligatures. Specific contextdependent forms are handled by this lookup as well.

Post-base substitutions
Feature Tag: "psts"
This feature is used to substitute post-base consonants or matras. Such substitutions
can be used to create conjuncts of base glyphs with post-base consonants or post-base
matra ligatures. It can also be used to specify contextual alternates of post-base forms.

Example 1- "psts" feature used to substitute consonant Tta and vowel I with a ligature:

Example 2- "psts" feature used to substitute consonant Ka and vowel U with a ligature:

Example 3- "psts" feature used to substitute consonant Nya and vowel Uu with a
ligature:

Example 4 - Using MS Volt, variations of the vowel I are substituted based on the
context. In the below example 'glyph groups' listing consonants with similar shapes are
used for the substitution context.

Halant form of consonants
Feature Tag: "haln"

This feature is used to substitute a pre-composed halant form of a base (or conjunct
base) glyph in syllables ending with a halant. (Rather than using substitution, halant
forms can also be created by positioning the halant as a below-base mark on the base
glyph using the 'blwm' positioning feature.)
This feature is applied only on the base glyph if the syllable ends with a halant, or in the
case of non-final consonants that do not take a half form and do not form a conjunct
ligature with the following consonant.
Example 1 - 'haln' feature used to substitute halant form of base glyph:

Example 2 - 'haln' feature used to substitute halant form of conjunct base glyph:

Contextual Alternates
Feature Tag: "calt"
Unlike the previous presentation lookups, the 'calt' feature is optional and is used to
substitute discretionary contextual alternates. It is important to note that an application
may allow users to turn off this feature, therefore should not be used for any obligatory
Tamil typography.

Positioning features
Distances
Feature Tag: "dist"
This feature covers positioning lookups that adjust distances between glyphs, such as
kerning between pre- and post-base elements and the base glyph. Note; the feature
'dist' can be used in the same way as the 'kern' feature. The advantage of using the 'dist'
feature is that it does not rely on the application to enable kerning.
The 'dist' lookup in MS Volt using 'Single Adjustment' for adjusting positions of the
anusvar:

Above-base marks
Feature Tag: "abvm"
This feature positions all above-base marks on the base glyph or the post-base matra.
The best method for encoding this feature in an OpenType font is to use a chaining
context positioning lookup that triggers mark-to-base and mark-to-mark attachments
for above-base marks.
The 'abvm' feature shown in MS Volt using 'Anchor Attachment' for adjusting positions
of above-marks over bases.

Below-base marks
Feature Tag: "blwm"
This feature positions all below-base marks on the base glyph. The best method for
encoding this feature in an OpenType font is to use a chaining context positioning
lookup that triggers mark-to-base and mark-to-mark attachments for below-base
marks.

Examples of Tamil syllables
Complex Tamil syllable formation is possible using the wide range of features available
in OpenType. The following examples show how the shaping engine applies the
OpenType features, one at a time to the input string. These combinations do not
necessarily represent actual syllables or words, but are meant to illustrate the various
OpenType features in a Tamil font.

Example #1:

Appendices
Appendix A: Writing System Tags
Features are encoded according to both a designated script and language system. There
are different language systems defined for the Hindi, Sanskrit, and Marathi languages,
although they all use the Tamil script.
Currently most shaping engine implementations only support the "default" language
system for each script. However, font developers may want to build language specific
features which are supported in other applications and will be supported in future
Microsoft OpenType implementations.
NOTE: It is strongly recommended to include the "dflt" language tag in all OpenType
fonts because it defines the basic script handling for a font. The "dflt" language system
is used as the default if no other language specific features are defined, or if the
application does not support that particular language. If the "dflt" tag is not present for
the script being used, the font may not work in some applications.
The following table lists the registered tag names for script and language systems. Note
for new Indic shaping implementation 'tml2' is used (old-behavior implementations
used 'taml').
**Registered tags for the Tamil script**

**Registered tags for Tamil language systems**

**Script tag**

**Script**

**Language system
tag**

**Language**

"tml2"

Tamil

"dflt"

*default script handling

"TAM "

Tamil

Note: both the script and language tags are case sensitive (script tags should be
lowercase, language tags are all caps) and must contain four characters (ie. you must
add a space to the three character language tags).

Developing OpenType Fonts for Telugu
Script
Article • 06/16/2022

Please note: This document reflects the changes made in 2005 recommendations for
Indic-script OpenType font and shaping-engine implementations. While Indic fonts
made according to the earlier recommendations will still function properly in the new
versions of Uniscribe, font developers may choose to update their fonts, particularly if
they wish to avoid certain limitations of the earlier implementation.
This document presents information that will help font developers create or support
OpenType fonts for the Telugu script covered by the Unicode Standard. The Telugu script is
used to write the Telugu language of Andhra Pradesh, India, as well as the minority
languages Gondi and Lambadi.

Introduction
This document targets developers implementing Indic shaping behavior compatible
with Microsoft OpenType specification for Indic scripts. It contains information about
terminology, font features and behavior of the Indic shaping engine in regards to the
Telugu script. While it does not contain instructions for creating Telugu fonts, it will help
font developers understand how the Indic shaping engine processes Indic text. In
addition, registered features of the Telugu script are defined and illustrated with
examples.
The new Indic shaping engine allows for variations in typographic conventions, giving a
font developer control over shaping by the choice of designation of glyphs to certain
OpenType features. For example, the location where the reph and pre-pended matra are
re-ordered within a syllable cluster is affected by the presence of a half form. See
illustrations below.
In the example below using the Devanagari script, (Ra + halant + Da+ halant + Ma + Imatra), Ra + halant will form the reph, but how the Da is classified will determine the
position of the reph as well as the location of the pre-pended matra.

Option 1: While the Da does not have a true half form in Devanagari, it can be listed in
the ‘half’ feature lookup substituting the ‘halant form’ of Da. Thus, the shaping engine
will treat it as a half form and the reph will be positioned on the first main consonant;
and the I-matra will be positioned immediately in front of the “half-form” D(a).
Option 2: By not listing Da in the ‘half’ feature lookup, the halant form will display and
the shaping engine will treat it as the first main consonant on which to position the
reph. And the I-matra will be positioned immediately in front of the base (or half-form)
preceding it, which in this case is the Ma.

Glossary
The following terms are useful for understanding the layout features and script rules
discussed in this document.
Above-base form of consonants – A variant form of a consonant that appears above
the base glyph.
Akhand ligatures - Required consonant ligatures that may appear anywhere in the
syllable, and may or may not involve the base glyph. Akhand ligatures have the highest
priority and are formed first; some languages include them in their alphabets.
Base glyph - The only consonant or consonant conjunct in the orthographic syllable that
is written in its "full" (nominal) form. In Devanagari, the last consonant of the syllable
(except for syllables ending with letter "Ra") usually forms the base glyph. In
"degenerate" syllables that have no vowel (last letter of a word), the last consonant in
halant form serves as the base consonant and is mapped as the base glyph. Layout
operations are defined in terms of a base glyph, not a base character, since the base can
often be a ligature.
Below-base form of consonants - A variant form of a consonant that appears below the
base glyph. In Devanagari, only the consonant Ra has a below-base form. In the glyph

sequence, the below-base form comes after the consonant(s) that form the base glyph.
Below-base forms are represented by a non-spacing mark glyph.
Cluster – A group of characters that form an integral unit in Indic scripts, often times a
syllable.
Consonant - Each represents a single consonant sound. Consonants may exist in
different contextual forms and have an inherent vowel (usually, the short vowel "a"). For
example, "Ka" and "Ta", rather than just "K" or "T."
Consonant conjuncts (aka “conjuncts”) - Ligatures of two or more consonants.
Consonant conjuncts may have both full and half forms, or only full forms.
Halant (Virama) - The character used after a consonant to "strip" it of it’s inherent
vowel. A Halant follows all but the last consonant in every Telugu syllable.
NOTE: A syllable containing halant characters may be shaped with no visible halant
signs by using different consonant forms or conjuncts instead.
Halant form of consonants - The form produced by adding the Virama to the nominal
shape. The Halant form is used in syllables that have no vowel or as the half form when
no distinct shape for the half form exists.
Halant form of consonants - The form produced by adding the halant (virama) to the
nominal shape. The Halant form is used in syllables that have no vowel or as the half
form when no distinct shape for the half form exists.
Half form of consonants (pre-base form) - A variant form of consonants which appear
to the left of the base consonant, if they do not participate in a ligature. Consonants in
their half form precede the ones forming the base glyph. Some Indic scripts, like
Devanagari have distinctly shaped half forms for most of the consonants. If not distinct
shape exists, the full form will display with an explicit Virama (same shape as the halant
form).
Matra (Dependent Vowel) - Used to represent a vowel sound that is not inherent to the
consonant. Dependent vowels are referred to as "matras" in Sanskrit. They are always
depicted in combination with a single consonant, or with a consonant cluster. The
greatest variation among different Indian scripts is found in the rules for attaching
dependent vowels to base characters.
New shaping behavior - Shaping behavior defined in this version of the Indic OpenType
Font Specification. Information in this document relates primarily to the new
implementation model. Old behavior may be mentioned in comments about
compatibility.

Nukta - A combining character that alters the way a preceding consonant (or matra) is
pronounced.
Old shaping behavior - Shaping behavior defined in previous versions of the Indic
OpenType Font Specification.
OpenType layout engine – Library responsible for executing OpenType layout features
in a font. In the Microsoft text formatting stack, it is named OTLS (OpenType layout
services).
OpenType tag – 4-byte identifier for script, language system or feature in the font.
Post-base form of consonants – A variant form of a consonant that appears to the right
of the base glyph. A consonant that takes a post-base form is preceded by the
consonant(s) forming the base glyph plus a halant (virama). Post-base forms are usually
spacing glyphs.
Pre-base form of consonants - A variant form of a consonant that appears to the left of
the base glyph. Note that most pre-base consonant forms are logically as well as visually
before the base consonant. Half forms are examples of this kind of pre-base form. In
some scripts, though, a pre-base Ra may logically follow the base consonant (that is, it
follows it phonetically and in the character sequence of the text), even though it is
presented visually before the base. The shaping engine detects such cases dynamically
using the 'pref' feature and re-orders the pre-base-form glyph as needed.
Reph – The above-base form of the letter "Ra" that is used in Devanagari when "Ra" is
the first consonant in the syllable and is not the base consonant.
Shaping Engine – Code responsible for shaping input, classified to a particular script.
Split Matra - A matra that is decomposed into pieces for rendering. Usually the different
pieces appear in different positions relative to the base. For instance, part of the matra
may be placed at the beginning of the cluster and another part at the end of the cluster.
Syllable - A single unit of Indic text processing. Shaping of Indic text is performed
independently for each syllable. Process of identifying boundaries of each syllable is
described below.
Telugu syllable - Effective orthographic "unit" of Telugu writing systems, consisting of a
consonant and a vowel core, and optionally preceded by one or more consonants.
Syllables are composed of consonant letters, independent vowels, and dependant
vowels. In a text sequence, these characters are stored in phonetic order (although they
may not be represented in phonetic order when displayed). Once a syllable is shaped, it

is indivisible. The cursor cannot be positioned within the syllable. Transformations
discussed in this document do not cross syllable boundaries.
Vattu - A below-base form of a consonant. In Devanagari, "Ra" can take a vattu form
within a cluster; this "Vattu-Ra" is also known as Rakaar.

Example in Devanagari script
1. Pre-base form
2. The base consonant
3. Above-base form (reph)
4. Post-base (matra)
5. Below-base form (vattu/rakaar)

Shaping Engine
Analyze the text
Reorder characters
Shape glyph sequences (GSUB processing)
Position glyphs sequences (GPOS processing)
Base elements
Invalid combining marks
Use of ZWJ, ZWNJ and NBSP
The Indic shaping engine processes Telugu text in stages. The stages are:
1. Analyze the text sequence; breaking it into syllable clusters
2. Reorder the characters as necessary
3. Apply OpenType GSUB font features to get the correct glyph shape
4. Apply OpenType GPOS features to position glyphs or marks
The descriptions which follow will help font developers understand the rationale for the
Telugu feature encoding model and help application developers better understand how
layout clients can divide responsibilities with operating system functions.

Analyze the text
Character properties
The shaping engine divides the text into syllable clusters and identifies character
properties.
Character properties are used in parsing syllables and identifying its parts, in
determining proper character or glyph reordering and in OpenType feature application.
Properties for each character are divided into two types: static properties and dynamic
properties.
Static properties define basic characteristics that do not change from font to font:
character type (consonant, matra, vedic sign, etc.) or type of matra reordering. They
differ from script to script, but can't be controlled by font developer.
Dynamic properties are font dependent and are retrieved by the shaping engine as the
font is loaded. These properties affect shaping and reordering behavior.
*Note: in old shaping-engine implementations, all consonant properties were static:
consonants were assumed to have particular conjoining forms. In the new
implementation model, consonant conjoining behavior is a dynamic property.

Retrieving dynamic character properties from Indic fonts
Fonts define dynamic properties for consonants through implementing standard
features. Consonant types (and corresponding feature tags) that the shaping engine
reads from the font are:
Reph 'rphf'
Half forms 'half'
Pre-base-reordering forms of Ra/Rra 'pref'
Below-base forms 'blwf'
Post-base forms 'pstf'
Each of the features above is applied together with 'locl' feature to input sequences
consisting of two characters: for 'rphf' and 'half', features are applied to Consonant +
Halant combinations; for 'pref', 'blwf' and 'pstf', features are applied to Halant +
Consonant combinations. This is done for each consonant. If these two glyphs form a
ligature, with no additional glyphs in context, this means the consonant has the
corresponding form. For instance, if a substitution occurs when the 'half' and 'locl'

features are applied to a sequence Da + Halant, then Da is classified as having a half
form.
Note that a font may be implemented to re-order a Ra to pre-base position only in
certain syllables and display it as a below-base or post-base form otherwise. This means
that the Pre-base-form classification is not mutually exclusive with either Below-baseform or Post-base-form classifications. However, all classifications are determined as
described above using context-free substitutions.
Font-dependent character classification only defines consonant types. Reordering
positions, however, are fixed for each character class.
*Note: for fonts that support the old implementation, all features are applied to
Consonant + Halant sequences.

Indic input processing
The following steps should be repeated while there are characters left in the input
sequence. All shaping operations are done on a syllable-by-syllable basis, independent
from other characters.

Find next syllable in the input
Engine should find the character sequence matching one of the patterns below:
Consonant syllable:
{C+[N]+<H+[<ZWNJ|ZWJ>]|<ZWNJ|ZWJ>+H>} +
C+[N]+[A] + [< H+[<ZWNJ|ZWJ>] | {M}+[N]+[H]>]+[SM]+[(VD)]
Vowel-based syllable:
[Ra+H]+V+[N]+[<[<ZWJ|ZWNJ>]+H+C|ZWJ+C>]+[{M}+[N]+[H]]+[SM]+[(VD)]
Stand Alone cluster (at the start of the word only):
[Ra+H]+NBSP+[N]+[<[<ZWJ|ZWNJ>]+H+C>]+[{M}+[N]+[H]]+[SM]+[(VD)]
Where
{}

zero or more occurrences

[]

optional occurrence

<|>

"one of"

()

one or two occurrences

C

consonant

V

independent vowel

N

nukta

H

halant/virama

ZWNJ

zero width non-joiner

ZWJ

zero width joiner

M

matra (up to one of each type: pre-, above-, below- or post- base)

SM

syllable modifier signs

VD

vedic

A

anudatta (U+0952)

NBSP

NO-BREAK SPACE

Identify key positions inside syllable
Syllable structure consists of the following parts:
Reph + HalfConsonant(s) + MainConsonant(s) + BelowBaseConsonant(s) +
PostBaseConsonant(s) + PreBaseReorderingRa + MatrasAndSigns
The consonant parts include all associated halants and nuktas. (For example, an instance
of BelowBaseConsonant consists of a sequence of Halant + Below-base-forming
Consonant.) All parts are optional, except the main consonant.
All parts are shown in the order they would occur within a syllable, with one
qualification: depending on a font implementation, PreBaseReorderingRa may occur
before all BelowBaseConsonants, after BelowBaseConsonants and before
PostBaseConsonants, or after PostBaseConsonants. Also, a font may be implemented to
re-order a Ra to pre-base position only in certain syllables and display it as a belowbase or post-base form otherwise. Thus, final determination of whether an occurrence of
Ra in a specific syllable can be treated as a pre-base reordering Ra can be made only
after the 'pref' feature has been applied to that syllable.
There could be several main consonants in the case where more than one consonant
doesn't have a half-, below-base, post-base or pre-base form. In a case of a cluster
where the first consonant does not have a half form, the shaping engine will recognize it

as the 1st 'full form' and go on to identify the 2nd full form consonant, if there is one.
This information will then be used to determine the reordering behavior of the reph or
any matras, vowel modifiers or stress marks.
All other elements are classified by their position relative to the base: pre-base (half
forms and reordering pre-base Ra forms), below-base, above-base and post-base.

Indic clusters are subject to the following constraints:
Only one reph is allowed per syllable.
Only one pre-base reordering Ra is allowed per syllable.
A nukta can be placed on a consonant, matra or independent vowel. It cannot be
placed on a pre-composed nukta character.
One matra from each positioning class is permitted (exception in the Kannada
script). A composite matra is treated as belonging to all the classes from which its
components belong.
One syllable modifier sign is allowed per cluster.
Vedic signs are combining marks (used for Sanskrit) that should be included in all
Indic scripts.
Danda and Double Danda are punctuation marks that should be included in all
Indic scripts.

Reorder characters
Once the Indic shaping engine has analyzed the cluster as described above, it creates
and manages a buffer of appropriately reordered elements (glyphs) representing the
cluster, according to several rules (described below).
The OpenType lookups in an Indic font must be written to match glyph sequences after
re-ordering has occurred. OpenType fonts should not have substitutions that attempt to
perform the re-ordering. If a font developer attempted to encode such reordering
information in an OpenType font, they would need to add a huge number of many-tomany glyph mappings to cover the general algorithms that a shaping engine will use.
1. Find base consonant: The shaping engine finds the base consonant of the syllable,
using the following algorithm: starting from the end of the syllable, move
backwards until a consonant is found that does not have a below-base or postbase form (post-base forms have to follow below-base forms), or that is not a prebase reordering Ra, or arrive at the first consonant. The consonant stopped at will
be the base.

If the syllable starts with Ra + Halant (in a script that has Reph) and has more
than one consonant, Ra is excluded from candidates for base consonants.
2. Decompose and reorder Matras: Each matra and any syllable modifier sign in the
cluster are moved to the appropriate position relative to the consonant(s) in the
cluster. The shaping engine decomposes two- or three-part matras into their
constituent parts before any repositioning. Matra characters are classified by which
consonant in a conjunct they have affinity for and are reordered to the following
positions:
Before first half form in the syllable
After subjoined consonants
After post-form consonant
After main consonant (for above marks)
3. Reorder marks to canonical order: Adjacent nukta and halant or nukta and vedic
sign are always repositioned if necessary, so that the nukta is first.
4. Final reordering: After the localized forms and basic shaping forms GSUB features
have been applied (see below), the shaping engine performs some final glyph
reordering before applying all the remaining font features to the entire cluster.
Reorder matras: If a pre-base matra character had been reordered before
applying basic features, the glyph can be moved closer to the main
consonant based on whether half-forms had been formed. Actual position for
the matra is defined as 'after last standalone halant glyph, after initial matra
position and before the main consonant'. If ZWJ or ZWNJ follow this halant,
position is moved after it.
Reorder reph: Reph's original position is always at the beginning of the
syllable, (i.e. it is not reordered at the character reordering stage). However, it
will be reordered according to the basic-forms shaping results. Possible
positions for reph, depending on the script, are; after main, before post-base
consonant forms, and after post-base consonant forms.
a. If reph should be positioned after post-base consonant forms, proceed to
step 5.
b. If the reph repositioning class is not after post-base: target position is after
the first explicit halant glyph between the first post-reph consonant and
last main consonant. If ZWJ or ZWNJ are following this halant, position is
moved after it. If such position is found, this is the target position.
Otherwise, proceed to the next step.
Note: in old-implementation fonts, where classifications were fixed in

shaping engine, there was no case where reph position will be found on this
step.
c. If reph should be repositioned after the main consonant: from the first
consonant not ligated with main, or find the first consonant that is not a
potential pre-base reordering Ra.
d. If reph should be positioned before post-base consonant, find first postbase classified consonant not ligated with main. If no consonant is found,
the target position should be before the first matra, syllable modifier sign
or vedic sign.
e. If no consonant is found in steps 3 or 4, move reph to a position
immediately before the first post-base matra, syllable modifier sign or
vedic sign that has a reordering class after the intended reph position. For
example, if the reordering position for reph is post-main, it will skip abovebase matras that also have a post-main position.
f. Otherwise, reorder reph to the end of the syllable.
Reorder pre-base reordering consonants: If a pre-base reordering consonant is
found, reorder it according to the following rules:
a. Only reorder a glyph produced by substitution during application of the
'pref' feature. (Note that a font may shape a Ra consonant with the 'pref'
feature generally but block it in certain contexts.)
b. Try to find a target position the same way as for pre-base matra. If it is
found, reorder pre-base consonant glyph.
c. If position is not found, reorder immediately before main consonant.

Character reordering Classes for Telugu:
_Characters_

_Reorder Class_

0C30 (reph)

AfterPostscript

0C3E

BeforeSubscript

0C3F, 0C40, 0C46, 0C47, 0C4A-0C4C, 0C55

BeforeSubscript/

0C56

BeforeSubscript

0C41, 0C42

BeforeSubscript

0C43, 0C44

AfterSubscript

Shape glyph sequences (GSUB processing)

All characters from a string are first mapped to their nominal glyphs using the cmap
lookup. The shaping engine then proceeds to shape (substitute) the glyphs using GSUB
lookups.
The features for localized forms and basic shaping forms are applied one at a time to the
cluster or a relevant portion of the cluster.
The results after basic shaping forms features have been applied impact the final syllable
analysis in terms of final designation of Ra as a pre-base reordering form and final
reordering positions for reph and matras. Next, the features for presentation forms are
applied to the entire cluster simultaneously. Note: since the presentation form features
are applied simultaneously over the entire cluster, several features are operationally
equivalent to a single feature. Multiple features are provided as an aid for font
developers to organize the lookups they implement.
Note: final reordering occurs after features for basic shaping forms have been applied
and before features for presentation forms are applied. Font developers must consider
the effects of initial reordering (before any features are applied) and final reordering
(after basic shaping forms features have applied) when they create GSUB feature and
lookup tables.
These predefined features are described and illustrated in the Features section and are
applied in the order below.

Shaping features:
Localized forms
1. Apply feature 'locl' to select language-specific forms.
Basic Shaping forms
1. Apply feature 'nukt' to substitute nukta forms of consonants.
2. Apply feature 'akhn' to substitute required akhand ligatures, or to substitute forms
that take precedence over forms produced by features applied later.
3. Apply feature 'rphf' to substitute the reph glyph (above-base form of 'Ra').
4. Apply feature 'pref' to substitute pre-base forms.
5. Apply feature 'blwf' to substitute below-base forms.
6. Apply feature 'half' to substitute half forms of pre-base consonants.
7. Apply feature 'pstf' to substitute post-base forms.
8. Apply feature 'cjct' to substitute conjunct forms. (This is needed particularly for
ligature conjuct forms when the pre-base consonant does not have a half form).

Presentation forms
1. Apply feature 'pres' to substitute pre-base consonant conjuncts and pre-base
matra conjuncts. (ie. consonant and matra conjuncts to the left of the base glyph).
2. Apply feature 'abvs' to substitute above-base matra conjuncts; reph conjuncts;
above-base vowel modifiers; and above-base stress and tone marks.
3. Apply feature 'blws' to substitute below-base consonant conjuncts; below-base
matra conjuncts; below-base vowel modifier forms; and below-base stress and
tone mark forms.
4. Apply feature 'psts' to substitute post-base consonant conjuncts, post-base matra
conjuncts and post-base vowel modifiers.
5. Apply feature 'haln' to substitute the halant form of base (or conjunct base) glyph
in syllables ending with a halant.
6. Apply feature 'calt' to substitute the contextual alternate of a consonant.

Position glyph sequences (GPOS processing)
The shaping engine next processes the GPOS (glyph positioning) table, applying
features concerned with positioning. The font developer must consider the effects of reordering when creating the GPOS feature tables. The shaping engine next processes the
GPOS (glyph positioning) table, applying features concerned with positioning. All
features are applied simultaneously to the entire cluster.
The font developer must consider the effects of re-ordering when creating the GPOS
feature and lookup tables (i.e., the glyphs will be in the order they were in after the
GSUB presentation forms features were applied).

Positioning features:
Kerning
1. Apply feature 'kern' to adjust distances (e.g., to provide kerning between post- or
pre-base elements and the base glyph).
2. Apply feature 'dist' to adjust distances. (NOTE - the feature 'dist' can be used in the
same way as the 'kern' feature. The advantage of using the 'dist' feature is that it
does not rely on the application to enable kerning. Therefore, if you want to make
sure certain spacing adjustments will always be displayed, you should use the 'dist'
feature).
Above-base marks

1. Apply feature 'abvm' to position above-base marks (above-base consonant forms,
matras, vowel modifiers or stress/tone marks) on base glyphs or post-base matra).
Below-base marks
1. Apply feature 'blwm' to position below-base marks (below-base consonant forms,
matras, vowel modifiers or stress/tone marks) on base glyphs or post-base matra).

Base elements
Commonly, a feature is required for dealing with the base glyph and one of the postbase, pre-base, above-base or below-base elements. Since it is not possible to reorder
ALL of these elements next to the base glyph, we need to skip over the elements "in the
middle" (reordering-wise).
The solution is to assign different mark attachment classes to different elements of the
syllable and positional forms, and in any given lookup work with one mark type only. For
example, in above-base substitutions we need only consider above-base elements most
of the time.
Generally, it is good practice to label as "mark" any glyphs that are denoted as
combining marks in the Unicode Standard as well as below-base/above-base forms of
consonants. Then, different attachment classes should be assigned to different marks
depending on their position with respect to the base.
For example, after the shaping engine has re-ordered elements within the cluster,
matras will always occur before syllable modifier sign such as the candrabindu. In an
actual sequence, though, potentially some other mark glyph, such as nukta, may occur
between the matra and the candrabindu. Thus, when processing the matra and
candrabindu, you may need to allow for the possibility that some other mark glyph(s)
may occur between them. Using lookup flags, you can specify that a lookup should
process only a certain class of marks, such as 'above-base marks', and ignore all other
marks. In that way, a match will occur whether or not a mark from another class is
present. Otherwise, the lookup would fail to apply.
Using Microsoft VOLT, you can assign glyphs to attachment classes.
In the example below this 'abvm' feature was set to process only TopMarks, therefore
the presence of another mark class would be ignored. If Process ALL was used and
another mark glyph followed the matra, this positioning lookup would fail to apply. This
example comes from the Devanagari font Mangal.

Invalid combining marks
Combining marks and signs that do not occur in conjunction with a valid base are
considered invalid. Shaping engine implementations may adopt different strategies for
how invalid marks are handled. For example, a shaping engine implementation might
treat an invalid mark as a separate cluster and display the stand-alone mark positioned
on some default base glyph, such as a dotted circle. (See Fallback Rendering in section
5.13 of the Unicode Standard 4.0.) Shaping engine implementations may vary somewhat
with regard to what sequences are or are not considered valid. For instance, some
implementations may impose a limit of at most one above-base vowel mark while
others may not.
To allow for shaping engine implementations that expect to position an invalid mark on
a dotted circle, it is recommended that a Telugu OT font contain a glyph for the dotted
circle character, U+25CC. If this character is not supported in the font, such
implementations will display invalid signs on the missing glyph shape (white box).

In addition to the 'dotted circle' other Unicode code points that are recommended for
inclusion in any Telugu font are the ZWJ (zero width non-joiner; U+200C), the ZWNJ
(zero width joiner; U+200D) and the ZWSP (zero width space; U+200B). For more
information see the Suggested glyphs section of the OpenType Font Development
document.

Effect of ZWJ, ZWNJ and NBSP on Consonant
Shaping
Unicode defines specific behaviors for zwj and zwnj in relation to Indic scripts. The Indicspecific behavior retains the general behavior that zwj requests connection between text
elements while zwnj inhibits connection between text elements.
1. The main intent of using ZWJ in this context is to prevent a ligature-conjunct from
forming (and in Devanagari or Gujuarati, to request a half form, below-base form
or post-base form instead). The Indic engine does not need to take any action to
prevent ligature-conjuct formation: the presence of ZWJ will prevent GSUB
substitution lookups from matching the input glyph sequence. If the first
consonant does not have a half form, an overt-halant form should result, which
would also happen with no particular action by the engine.
2. A secondary intent of using ZWJ in this context is to prevent the display of reph in
the case that the first consonant is RA. If a cluster begins with RA H (halant) ZWJ,
the engine must ensure that the 'rphf' feature is not applied, and that re-ordering
for reph does not take place. Note that use of either joiner in this context should
prevent formation and re-ordering of reph when RA is the first consonant.
3. The main intent of using ZWNJ is to prevent conjunct ligature or half forms from
forming, and to display an explicit halant form instead. The shaping engine must
take specific actions to prevent half forms for a sequence of Consonant + Halant +
ZWNJ.
The following example illustrates some of these behaviors:

Just as the ZWJ can be used to display a half form in isolation, it can also be used to
display a mark, sub- or post-base form in isolation. Unlike the stand-alone half form,
however, sequences to display them must begin with a no-break space (NBSP). This is
because marks, sub- and post-base forms have a 'zero-width' so must be placed on the

NBSP. For example, to get a shape of I-matra without the dotted circle one should type
NBSP + I-matra.
In the illustration below the I-matra is displayed without the dotted circle by using the
NBSP. The combination of NBSP and ZWJ is used to display the below-base form of Ka
in isolation.

Features
The features listed below have been defined to create the basic forms for the languages
that are supported on Telugu systems. Regardless of the model an application chooses
for supporting layout of complex scripts, the shaping engine requires a fixed order for
executing features within a run of text to consistently obtain the proper basic form.
The features of the basic shaping forms are applied one at a time to the cluster or
portion of the cluster. The result impacts the analysis in terms of the conjoining behavior
and final reordering. The features of the presentation forms are applied next, to the
entire cluster simultaneously. Mandatory features must always be applied; the
discretionary presentation-forms features listed should be applied by default, but can be
suppressed by a client (normally at the discretion of the user).
The order of the lookups within each feature is also very important. For more
information on lookups and defining features in OpenType fonts, see the Encoding
section of the OpenType Font Development document.
OpenType features used for Telugu scripts, applied in the following order:
**Feature**

**Feature function**

**Layout
operation**

Localized forms:
locl

Localization form substitution

GSUB

Basic shaping forms:
nukt

Nukta form substitution

GSUB

akhn

Akhand ligature substitution

GSUB

**Feature**

**Feature function**

**Layout
operation**

rphf

Reph form substitution

GSUB

pref

Pre-base form substitution

GSUB

blwf

Below-base form substitution

GSUB

half

Half-form substitution

GSUB

pstf

Post-base form substitution

GSUB

cjct

Conjunct form substitution

GSUB

Mandatory presentation forms:
pres

Pre-base substitution

GSUB

abvs

Above-base substitution

GSUB

blws

Below-base substitution

GSUB

psts

Post-base substitution

GSUB

haln

Halant form substitution

GSUB

Discretionary presentation forms:
calt

Contextual alternates

GSUB

Positioning features:
kern

Kerning

GPOS

dist

Distances

GPOS

abvm

Above-base mark positioning

GPOS

blwm

Below-base mark positioning

GPOS

[GSUB = glyph substitution, GPOS = glyph positioning]

Feature examples
Many of the registered features described and illustrated in this document are based on
the Microsoft OpenType font Gautami. 'Gautami' contains layout information and glyphs
to support all of the required features for the Telugu script and language systems
supported.

The illustrations in the following examples show the result of that particular feature
being applied. Features must be written to match glyph sequences after re-ordering has
occurred. Note that the input context for a feature may be the result of a previous
feature having already been applied.

Localized forms
Feature Tag: "locl"
This feature is used in association with OpenType language system tags to trigger
lookups that will select alternate glyphs needed for language-specific typographic
conventions. The 'locl' should not be used in association with the default language
system, but only used with other language system tags. See the Appendix of this
document for language system tags associated with the Telugu script.

Basic shaping forms
Nukta
Feature Tag: "nukt"
The nukta alters the way a preceding consonant or vowel is pronounced. The most
common nukta forms have been defined as separate characters in Unicode with their
own code points. All consonants, as well as akhand forms should have an associated
nukta form.
Note - Rather than using substitution, nukta forms can also be created by positioning
the nukta as a below-base mark on the base glyph using the 'blwm' positioning feature
The input context for the nukt feature always consists of the full form of the consonant.
The half form of nukta consonants will be substituted using the half feature.

Akhand
Feature Tag: "akhn"
An akhand is a required consonant ligatures that may appear anywhere in the syllable,
and may or may not involve the base glyph. Akhand ligatures have the highest priority
and are formed first; some languages include them in their alphabets.
The input context for the akhand feature always consists of the full form of the
consonant. The half forms of Akhand ligatures will be called later in the half feature.

Because the akhand feature is applied early in the sequence of features and is applied
over the entire cluster, it can also be used to create certain forms that must take priority
in particular contexts over forms that would be created during subsequent feature
application.
Example 1 - Ka + halant + Ssa is substituted with the KaSsa ligature in the 'akhn' feature:

Example 2 - Ssa + halant + Ja is substituted with the SsaJa ligature in the 'akhn' feature:

Reph
Feature Tag: "rphf"
Applying this feature substitutes the Reph glyph. If the first consonant of the cluster
consists of the full form of Ra + Halant, this feature substitutes the combining-mark
form of Reph. In addition, the position of the Reph glyph is adjusted with the 'abvm'
GPOS feature.
The input context for the Reph feature always consists of the full form of Ra + Halant.

Pre-base form of consonant
Feature Tag: "pref"
This feature substitutes the pre-base forms of Consonants

Below form of consonant
Feature Tag: "blwf"
This feature substitutes the below-base forms of Consonants that follow the base
consonant. If a ligature is required between the below-base glyph and the preceding
consonant, it will be handled by the feature 'Below base substitutions' (blws).

Example: Halant plus Pa (preceded by a base consonant) will be substituted by the
below-base Pa:

Result: Ka + halant + Pa substitutes the below-base Pa:

Half form of consonant
Feature Tag: "half"
Applying this feature substitutes half forms - forms of consonants used in the pre-base
position. Consonants that have a half form should be listed in the 'half' feature. Some
scripts, like Devanagari have distinctly shaped half forms for most of the consonants
however, if a consonant does not have a distinct shape for the half form and does not
form any ligature, it will be displayed with an explicit Virama (same shape as the halant
form).
Note - the result of listing a consonant in the half feature (whether it has a true half
form or not) will affect the re-ordering (and positioning) of the reph and pre-pended
matras. See illustration in the Introduction section of this document.
This feature is applied to all consonants preceding the 'main' consonant.
Note - While Telugu typically does not use half forms, this feature is made available for
typographic preference.

Post-base form of consonant
Feature Tag: "pstf"
The 'pstf' feature can be applied to substitute the post-base form of a consonant.

Conjunct forms

Feature Tag: "cjct"
Apply feature 'cjct' to substitute conjunct forms where the first consonant in the
consonant-cluster pair does not have a half form. This feature allows for control over reordering 'Žof reph and pre-pended matras in case of consonants that do not take half
forms yet do form 'Žconjunct ligatures in combination with certain following
consonants.

Presentation forms
After the glyphs have been reordered, the presentation lookups are applied to provide
the best typographic rendering of the text. The features of the presentation forms are
applied to the entire cluster simultaneously, executing lookups within each feature in
the order that they are specified in the font.
The pres, abvs, blws, psts and haln features are all mandatory for software
implementations: they are required for correct script behaviour and none should ever be
treated as discretionary. Because of this and because they are all applied simultaneously
over entire clusters, they are not functionally different: a set of lookups could be divided
between these features or grouped together under one of them with no difference in
effect. These multiple features are provided, however, as an aid to the font developer for
organizing lookups based on the combinations of glyphs they apply to. There are no
specific requirements on how each should be used; the examples provided below
illustrate typical usage, however.

Pre-base substitutions
Feature Tag: "pres"
This feature is used to substitute pre-base consonant conjuncts made with half forms,
the type most common in Devanagari. The resulting conjunct can be in full or half form.
This feature can also be used to select variant forms of Matras, or pre-composed
ligatures of Matras with certain bases.

Above-base substitutions
Feature Tag: "abvs"
This feature is used for glyph substitutions involving above-base marks. Such
substitutions might be used to select contextual forms of marks, to create mark-mark

ligatures, or to create mark-base ligatures. Specific context-dependent forms or belowbase consonants are handled by this lookup as well.
Example 1 - 'abvs' ligature substitution; Kha + vowel I substituted with pre-composed
ligature:

Example 2 - 'abvs' ligature substitution; Jha + vowel Oo substituted with pre-composed
ligature:

Example 3 - 'abvs' contextual substitution; partial forms of the base glyphs are
substituted when followed by certain above-base matras:

Example 4 - 'abvs' contextual substitution; Using MS Volt, alternate matra shapes are
substituted when preceded by certain base consonants:

Below-base substitutions
Feature Tag: "blws"
This feature is used for glyph substitutions involving below-base marks or consonants.
Such substitutions can be used to create conjuncts of base glyphs with below-base
consonants, below mark ligatures or below mark-base ligatures. Specific contextdependent forms are handled by this lookup as well.
Example 1- 'blws' ligature substitution for below-base conjuncts; below-base Ka +
below-base Ssa form a ligature:

Example 2- 'blws' ligature substitution for base and below-base conjuncts; Ta + belowbase Ka + below-base Ra form a conjunct:

Example 3- 'blws' contextual substitution; Using MS Volt, alternate below forms of Ra
are substituted when preceded by certain base consonants:

Post-base substitutions
Feature Tag: "psts"
This feature is used to substitute post-base consonants or matras. Such substitutions
can be used to create conjuncts of base glyphs with post-base consonants or post-base
matra ligatures. It can also be used to specify contextual alternates of post-base forms.
Example 1- 'psts' ligature substitution for base and matra conjuncts; Ja + matra U form a
conjunct:

Example 2 - contextual 'psts' substitution; using MS Volt, variant shapes of matras are
substituted based on the context:

Halant form of consonants
Feature Tag: "haln"
This feature is used to substitute the halant form of a base (or conjunct base) glyph in
syllables ending with a halant. Halant forms can also be created by positioning the
halant as a below-base mark on the base glyph using the 'blwm' positioning feature.
This feature is applied only on the base glyph if the syllable ends with a halant.
Example 1 - 'haln' feature used to substitute halant form ligature of base glyph Ja:

Example 2 - 'haln' feature used to substitute halant form of conjunct base glyph KaSsa:

Contextual Alternates
Feature Tag: "calt"
Unlike the previous presentation lookups, the 'calt' feature is optional and is used to
substitute discretionary contextual alternates. It is important to note that an application
may allow users to turn off this feature, therefore should not be used for any obligatory
Telugu typography.

Positioning features
Distances
Feature Tag: "dist"
This feature covers positioning lookups that adjust distances between glyphs, such as
kerning between pre- and post-base elements and the base glyph. Note; the feature
'dist' can be used in the same way as the 'kern' feature. The advantage of using the 'dist'
feature is that it does not rely on the application to enable kerning.
Using MS Volt, the kerning for the anuswar was put in the 'dist' feature using 'Single
Adjustment' and positioning based on a set context:

Above-base marks
Feature Tag: "abvm"
This feature positions all above-base marks on the base glyph or the post-base matra.
The best method for encoding this feature in an OpenType font is to use a chaining
context positioning lookup that triggers mark-to-base and mark-to-mark attachments
for above-base marks.
The 'abvm' lookup shown in MS Volt uses 'Anchor Attachment' for adjusting positions of
above-marks over bases:

Below-base marks
Feature Tag: "blwm"
This feature positions all below-base marks on the base glyph. The best method for
encoding this feature in an OpenType font is to use a chaining context positioning
lookup that triggers mark-to-base and mark-to-mark attachments for below-base
marks.
The 'blwm' lookup shown in MS Volt uses 'Anchor Attachment' for adjusting positions of
below-base consonants with bases:

Examples of Telugu syllables
Complex Telugu syllable formation is possible using the wide range of features available
in OpenType. The following examples show how the shaping engine applies the
OpenType features, one at a time to the input string. These combinations do not
necessarily represent actual syllables or words, but are meant to illustrate the various
OpenType features in a Telugu font.

Example #1:

Example #2:

Example 3

Appendices
Appendix A: Writing System Tags
Features are encoded according to both a designated script and language system.
Currently most shaping engine implementations only support the "default" language
system for each script. However, font developers may want to build language specific
features which are supported in other applications and will be supported in future
Microsoft OpenType implementations.
NOTE: It is strongly recommended to include the "dflt" language tag in all OpenType
fonts because it defines the basic script handling for a font. The "dflt" language system
is used as the default if no other language specific features are defined, or if the
application does not support that particular language. If the "dflt" tag is not present for
the script being used, the font may not work in some applications.
The following table lists the registered tag names for script and language systems. Note
for new Indic shaping implementation 'tel2' is used (old-behavior implementations used
'telu').
Registered tags for the Telugu script

Registered tags for Telugu language systems

Script tag

Language
system tag

Script

Language

"telu"

Telugu

"dflt"

*default script handling

"TEL "

Telugu

Note: both the script and language tags are case sensitive (script tags should be
lowercase, language tags are all caps) and must contain four characters (ie. you must
add a space to the three character language tags)

Creating and Supporting OpenType
Fonts for the Javanese Script
Article • 06/11/2022

Introduction
This document targets developers implementing shaping behavior compatible with the
Microsoft OpenType specification for the Javanese script. It contains information about
terminology, font features and behavior of the Javanese shaping engine. While it does
not contain instructions for creating Javanese fonts, it will help font developers
understand how the Javanese shaping engine processes Javanese text.
This document presents information that will help font developers in creating OpenType
fonts for Javanese script as covered by the Unicode Standard 6.3. The Javanese script is
used to write the Javanese language. It is also used to write other languages including
Sanskrit, Sasak, and Sundanese.
NOTE: Starting in Windows 10, Javanese will be supported by the Universal Shaping
Engine rather than a stand-alone shaping engine. Moving forward, developers should
refer to this new specification.

Terms
The following terms are useful for understanding the layout features and script rules
discussed in this document.
Base glyph – Any glyph that can have a diacritic mark attached to it. Layout operations
are defined in terms of a base glyph, not a base character, as a ligature may act as a
base
Character – Each character represents a Unicode character code point. A character may
have multiple glyph forms
Cluster – A group of characters that form an integral unit in Brahmi-derived scripts,
oftentimes this corresponds to a syllable
Consonant – Javanese consonants have an inherent vowel (the short vowel /a/). For
example, “Ka” and “Ta”, rather than just “K” or “T”
Consonant conjunct (aka ‘conjunct’) – A ligature of two or more consonants

Format controls – special formatting characters used in the shaping process of Javanese
scripts (U+200c and U+200D). These characters have no visual appearance, except when
an application chooses to display zero width glyphs
Glyph – A glyph represents a form of one or more characters
Halant – The character used after a consonant to “strip” it of its inherent vowel
Ligature – A combination of glyphs that join to form a single glyph
Matra (dependent vowel) – Used to represent a vowel sound that is not inherent to the
consonant. Dependent vowels are referred to as “matras” in Sanskrit. They are always
depicted in combination with a single consonant, or with a consonant cluster
OpenType layout engine – The library responsible for executing OpenType layout
features in a font. In the Microsoft text formatting stack, it is named OTLS (OpenType
layout services)
OpenType tag – A 4-byte identifier for script, language system or feature in the font
Shaping engine - Code responsible for shaping input, classified to a particular script

How the Javanese shaping engine works
Analyzing the characters
Reordering pre-base vowels (VPre)
Apply OpenType GSUB features for localized forms and basic shaping forms
Reordering Medial Ra (MR)
Applying OpenType GSUB presentation features
Applying OpenType GPOS features to position glyphs or marks
The Uniscribe Javanese shaping engine processes text in stages. The stages are:
1. Analyzing the characters
2. Reordering pre-base vowels (VPre)
3. Apply OpenType GSUB features for localized forms and basic shaping forms
4. Reordering Medial Ra (MR)
5. Applying OpenType GSUB presentation features
6. Applying OpenType GPOS features to position glyphs or marks
The descriptions which follow will help font developers understand the rationale for the
Javanese feature encoding model, and help application developers better understand
how layout clients can divide responsibilities with operating system functions.

Analyzing the characters
The run of text that the shaping engine receives for the purpose of shaping is a
sequence of Unicode characters. The shaping engine divides the text into syllable
clusters and identifies character properties. Character properties are used in parsing
syllables and identifying their parts as well as determining whether any contextual
reordering is required.
In the diagrams below, the rules for forming clusters are given in terms of the classes of
characters in the character stream. The meanings of the symbols are:
C

Consonants (A984, A989–A98B, A98F–A9B2)

D

Javanese digits (A9D0–A9D9)

GB

Generic base characters (00A0, 00D7, 2012–2015, 2022, 25CC, 25FB–25FE)

H

Halant/virama (A9C0)

IV

Independent vowel (A985–A988, A98C–A98E)

J

Joiners (200C, 200D)

M

Modifiers (A980–A983)

MR

Medial consonants Ra (A9BF)

MY

Medial consonant Ya (A9BE)

N

Nukta/Cecak Telu (A9B3)

O

SCRIPT_COMMON characters in a Javanese run

P

Punctuation (A9C1–A9CD)

R

Reserved characters from the Javanese block (A9CE, A9DA–A9DD)

S

Symbols (A9CF, A9DE, A9DF)

VAbv

Above base dependent vowel (A9B6, A9B7, A9BC)

VBlw

Below base dependent vowel (A9B8, A9B9)

VPre

Pre base dependent vowel (A9BA, A9BB)

VPst

Post base dependent vowel (A9B4, A9B5, A9BD)

VS

Variation selectors (FE00–FE0F)

WJ

Word joiner (2060)

WS

White space (any white space character including ZWSP)

X*

sequence of zero or more occurrences of X. Since this could extend a cluster indefinitely
an arbitrary limit of 31 characters in a sequence has been used

X+

Below base dependent vowel (102F, 1030, 1058, 1059)

VPre

Pre base dependent vowel (1031, 1084)

VPst

Post base dependent vowel (102B, 102C, 1056, 1057, 1062, 1067, 1068, 1083)

VS

Variation selectors (FE00–FE0F)

WJ

Word joiner (2060)

WS

White space (any white space character including ZWSP)

X*

sequence of zero or more occurrences of X. Since this could extend a cluster indefinitely
an arbitrary limit of 31 characters in a sequence has been used

X+

sequence of one or more occurrences of X

<X |

disjunction of elements: X or Y

Y>
[X]

optional (zero or one) occurrence of X

#

occurrence of a boundary

×

no boundary allowed at indicated position

÷

boundary allowed at indicated position

^

Except

The shaping engine inserts a placeholder glyph (U+25CC) wherever combining marks
occur without a valid base. The character U+25CC belongs to the class of generic bases
(GB). Well-formed Javanese character clusters are defined as follows:
Simple non-compounding cluster
< IV | P | D | S | R | WS | O | WJ >
Independent vowels (IV), punctuation (P), digits (D), symbols (S), reserved characters
from the Javanese block (R), white space (WS), other SCRIPT_COMMON characters (O),
and word joiner (WJ) contain one character per cluster.
Cluster terminating in Halant
< C | GB > [VS] [N] (H C [VS] [N])* H

A consonant or generic base and optional variation selector and optional nukta. When
Halant follows a base or stack it will form a cluster. Any character other than C following
the Halant will terminate the cluster after the Halant.
Complex cluster
< C | GB > [VS] [N] (H C [VS] [N]) [MCR] [MCY] (VPre) (VAbv) (VBlw) (M)*
A consonant or generic base and optional variation selector and optional nukta. Zero or
more stacked consonants and optional variation selector and optional nukta. Zero or
one of each medial consonant. Zero or more dependent pre-base and above-base
vowels. Zero or more dependent below-base and post-base vowels. Zero or more
modifiers.
The cluster rules need to permit this level of complexity in order to be able to handle
the full range of possible encoded sequences. However, only test cases will try to
exercise more than a few of these positions in a single cluster.

Reordering pre-base vowels (VPre)
Once the Javanese shaping engine has analyzed the run into clusters as described
above, it performs any required reordering. Pre-base vowels (VPre) are reordered to the
start of the syllable cluster. A sequence of multiple pre-base vowels is permitted. Such
sequences are moved as a block to the beginning of the cluster. In the following
example, the run of code points represents a single cluster.
INPUT
A98F A9C0 A98F A9BF A9BE A9BA A9BA A9B7
Base Medial Ra Pre-base vowels
REORDERED
A9BA A9BA A98F A9C0 A98F A9BF A9BE A9B7
Note: Medial Ra (U+A9BF) does not reorder until later in the shaping process.
Note: the OpenType lookups in a Javanese font must be written to match glyph
sequences after re-ordering has occurred. OpenType fonts should not have substitutions
that attempt to perform the re-ordering. If a font developer attempted to encode such
reordering information in an
OpenType font, they would need to add a huge number of many-to-many glyph
mappings to cover the general algorithms that a shaping engine will use.

Apply OpenType GSUB features for localized
forms and basic shaping forms
Uniscribe calls OTLS to apply the features. OTL processing is divided into a sets of
predefined features (described and illustrated in the Features section of this document).
The first application of GSUB features are applied per cluster in the following order.
A. Localized forms
Apply feature ‘locl’ to preprocess any localized forms for the current language
B. Basic Shaping forms
Apply feature ‘pref’ to get pre-base glyph forms
Apply feature ‘abvf’ to get above-base glyph forms
Apply feature ‘blwf’ to get below-base glyph forms
Apply feature ‘pstf’ to get post-base forms
Note: not all of the features listed here need to be used when defining a font for the
Javanese script.

Reorder Medial Ra
Medial Ra reorders in a given syllable depending on the context and the font. The
shaping engine uses the following logic to determine whether to reorder Medial Ra:

In the Javanese shaping engine, the ‘pref’ feature should only be used to substitute a
Medial Ra glyph for the pre-base form of Medial Ra. That pre-base form should consist
of a single glyph.

Ligatures of Medial Ra are treated as marks that positioned relative to the base
character. Therefore, any ligatures with Medial Ra should not reorder before the base.
INPUT
A9BA A9BA A98F A9C0 A98F A9BF A9BE A9B7
Pre-base vowels Base Medial Ra
REORDERED
A9BA A9BA A9BF A98F A9C0 A98F A9BE A9B7

Apply OpenType GSUB features for
presentation forms
The presentation form features are applied simultaneously over the entire run.
Therefore, several features are operationally equivalent to a single feature. The order of
application, therefore, is the order of features defined in the font.
C. Presentation forms
Apply feature ‘pres’ to substitute pre-base glyph forms
Apply feature ‘abvs’ to substitute above-base glyph forms
Apply feature ‘blws’ to substitute below-base glyph forms
Apply feature ‘psts’ to substitute post-base glyph forms
Apply feature ‘ccmp’ to substitute glyph composition/decomposition glyph forms
Apply feature ‘rlig’ to substitute required ligature glyph forms
Apply feature ‘liga’ to substitute standard ligature glyph forms
Apply feature ‘clig’ to substitute contextual ligature glyph forms
•Apply feature ‘calt’ to substitute contextual alternate glyph forms

Apply OpenType GPOS features
The shaping engine next processes the GPOS (glyph positioning) table, applying
features concerned with positioning. All features are applied simultaneously to the
entire run.
The font developer must consider the effects of re-ordering when creating the GPOS
feature and lookup tables.
D. Kerning

Apply feature ‘dist’ to make any required distance adjustments
Apply feature ‘kern’ to provide pair kerning between glyphs for better typographic
quality. Note this feature may be disabled by some applications
E. Mark Placement
Apply feature ‘mark’ to position diacritic glyphs relative to the base glyph
Apply feature ‘mkmk’ to position diacritic glyphs relative to each other

Features of the Javanese Script
The features listed below have been defined to create the basic forms for languages that
use the Javanese script. Regardless of the model an application chooses for supporting
layout of complex scripts, Uniscribe requires a fixed order for executing localized and
basic shaping form features within a run of text to consistently obtain the proper basic
form. This is achieved by calling features one-by-one in the standard order listed below.
The order of the lookups within each feature is also very important. For more
information on lookups and defining features in OpenType fonts, see Encoding feature
information in the OpenType font development section.
The standard order for applying Javanese features encoded in OpenType fonts:
Feature

Feature function

Layout
operation

Required

Localized forms
locl

GSUB

Basic shaping forms
pref

Pre-base forms

GSUB

X

abvf

Above-base forms

GSUB

X

blwf

Below-base forms

GSUB

X

pstf

Post-base forms

GSUB

X

Presentation forms
pres

Pre-base substitutions

GSUB

X

abvs

Above-base substitutions

GSUB

X

blws

Below-base substitutions

GSUB

X

psts

Post-base substitutions

GSUB

X

ccmp

Glyph composition/decomposition

GSUB

X

rlig

Required ligatures

GSUB

X

liga

Standard ligatures

GSUB

clig

Contextual ligatures

GSUB

calt

Contextual alternates

GSUB

kern

Pair kerning

GPOS

dist

Distance adjustments

GPOS

Kerning

X

Mark placement
mark

Mark positioning

GPOS

mkmk

Mark to mark positioning

GPOS

[GSUB = glyph substitution, GPOS = glyph positioning]

Feature examples
The registered features described and illustrated in this document are based on the
Microsoft OpenType font Javanese Text (javatext.ttf). Javanese Text contains layout
information and glyphs to support all of the required features of the Javanese script.
The illustrations in the following examples show the result of that particular feature
being applied. Features must be written to match glyph sequences after re-ordering has
occurred. Note that the input context for a feature may be the result of a previous
feature having already been applied.

Localized forms
Feature Tag: “locl”
This feature is used in association with OpenType language system tags to trigger
lookups that will select alternate glyphs needed for language-specific typographic
conventions. The ‘locl’ should not be used in association with the default language
system, but only used with other language system tags. See the Appendix of this
document for language system tags associated with the Javanese script.

Basic shaping forms
Feature Tag: “pref”
This feature should only be used to substitute the fallback pre-base form of the medial
consonant Ra (MR).

Feature Tag: “abvf”
This feature is used to substitute the above-base forms. The Javanese Text font does not
use this feature.

Feature Tag: “blwf”
This feature is used to substitute the below-base forms. For example, the Javanese Text
font uses this feature to form stacked consonant glyphs.

Feature Tag: “pstf”
This feature is used to substitute the post-base forms. For example, the Javanese Text
font uses this feature to substitute post-base stacked consonant glyphs.

Presentation forms
Feature Tag: “pres”

This feature is used to substitute presentation forms involving pre-base elements. For
example, the Javanese Text font uses this feature to process ligatures of stacked
consonants.

Feature Tag: “abvs”
This feature is used to substitute presentation forms relating to above-base elements.
For example, the Javanese Text font uses this feature to form ligatures of above-base
marks.

Feature Tag: “blws”

This feature is used to substitute presentation forms relating to below-base elements.
For example, the Javanese Text font uses this feature to substitute ligatures with belowbase vowels.

Feature Tag: “psts”
This feature is used to substitute presentation forms relating to post-base elements. For
example, the Javanese Text font uses this feature to substitute presentation forms for
combinations of medial consonant Ya with a below-base vowel.

Feature Tag: “ccmp”
This feature may be used to do glyph composition and decompositions. The Javanese
Text font does not use this feature.

Feature Tag: “rlig”
This feature may be used to form required ligatures. The Javanese Text font does not use
this feature.

Feature Tag: “liga”
This feature may be used to form standard ligatures. The Javanese Text font does not
use this feature.

Feature Tag: “clig”
This feature may be used to form contextual ligatures. The Javanese Text font does not
use this feature.

Feature Tag: “calt”
This feature may be used to substitute contextual alternates. The Javanese Text font
does not use this feature.

Kerning
Feature Tag: “kern”
This feature may be used to adjust the positioning of glyph pairs. The Javanese Text font
does not use this feature.

Feature Tag: “dist”
This feature may be used to adjust distances. The Javanese Text font uses this feature
adjust bases to add space required to accommodate the extended swash of the below
base Medial Ra mark.

Note that mark glyphs have their width set to zero by OTLS. If a mark glyph must have
width, it is necessary to add back lost width for correct display. The dist feature is a
required feature and should be used for this purpose as well as other required distance
adjustments.

Mark placement
Feature Tag: “mark”
This feature is used to position marks relative to a base glyph. The Javanese Text font
uses this feature to position above and below marks on bases.
Note that the mark feature is a required feature and will always be triggered by the
shaping engine.

Feature Tag: “mkmk”
This feature is used to position marks relative to each other. The Javanese Text font uses
this feature to position a sequence of below-base marks.
Note that the mkmk feature is a required feature and will always be triggered by the
shaping engine.

Other encoding issues
Handling invalid combining marks
Combining marks and signs that do not occur in conjunction with a valid base are
considered invalid. Shaping engine implementations may adopt different strategies for
how invalid marks are handled. For example, a shaping engine implementation might
treat an invalid mark as a separate cluster and display the stand-alone mark positioned
on some default base glyph, such as a dotted circle (U+25CC). (See Fallback Rendering
in section 5.13 of the Unicode Standard 4.0.) Shaping engine implementations may vary
somewhat with regard to what sequences are or are not considered valid. For instance,
some implementations may impose a limit of at most one above-base vowel mark while
others may not.
To allow for shaping engine implementations that expect to position an invalid mark on
a dotted circle, it is recommended that a Javanese OT font contain a glyph for the
dotted circle character, U+25CC, and that appropriate mark positioning lookups are
written to position marks relative to it. If this character is not supported in the font, such
implementations will display invalid signs on the missing glyph shape (white box).

Recommended Glyphs
Unicode code points that are strongly recommended for inclusion in any Javanese font
are:
Code
point

Description

U+200B

Zero Width Space

U+200C

Zero Width Non-Joiner

U+200D

Zero Width Joiner

U+25CC

Dotted Circle

U+002D

Hyphen-minus

U+00A0

No-break space

U+00D7

Multiplication sign

U+2012

Figure dash

U+2013

En dash

U+2014

Em dash

U+2015

Horizontal bar

U+2022

Bullet

U+25FB

White medium square

U+25FC

Black medium square

U+25FD

White medium small square

U+25FE

Black medium small square

These glyphs may be used in text as generic bases and so should be enabled in mark
positioning lookups supported by the font. The glyphs are used with shaping engines
that recognise them as legitimate bases, and hence not insert the dotted circle base.
Due to this a number of characters result in being recommended inclusions in fonts.

Appendix
Writing system and language tags
Features are encoded according to both a designated script and language system. The
language system tag specifies a typographic convention associated with a language or
linguistic subgroup. For example, there are different language systems defined for the
Javanese script: Javanese, Sanskrit, Sasak, and Sundanese.
Not all software applications support specific language tags for use when rendering text
runs.
NOTE:It is strongly recommended to include the “dflt” language tag in all OpenType
fonts because it defines the basic script handling for a font. The “dflt” language system
is used as the default if no other language specific features are defined or if the
application does not support that particular language. If the “dflt” tag is not present for
the script being used, the font may not work in some applications.
NOTE: It is strongly recommended to include the “dflt” language tag in all
OpenType fonts because it defines the basic script handling for a font. The “dflt”
language system is used as the default if no other language specific features are
defined or if the application does not support that particular language. If the “dflt”
tag is not present for the script being used, the font may not work in some
applications.

The following tables list the registered tag names for scripts and language systems.
Registered tags for the Javanese script

Registered tags for Javanese language
systems

Script tag

Script

Language
system tag

Language

“java”

Javanese

“dflt”

*default script handling

JAV

Javanese

SAN

Sanskrit

SUN

Sundanese

SAS

Sasak

Note: both the script and language tags are case sensitive (script tags should be
lowercase, language tags are all caps) and must contain four characters (ie. you must
add a space to the three character language tags).

Developing OpenType Fonts for Khmer
Script
Article • 06/24/2022

This document presents information that will help font developers create or support
OpenType fonts for the Khmer script languages covered by the Unicode Standard.

Introduction
In this specification, font developers will learn how to encode complex script features in
their fonts, choose character sets, organize font information, and use existing tools to
produce Khmer fonts. Registered features of the Khmer script are defined and
illustrated, encodings are listed, and templates are included for compiling Khmer layout
tables for OpenType fonts.
This document also presents information about the Khmer OpenType shaping engine of
Uniscribe, the Windows component responsible for text layout.
In addition to being a primer and specification for the creation and support of Khmer
fonts, this document is intended to more broadly illustrate the OpenType Layout
architecture, feature schemes, and operating system support for shaping and
positioning text.

Glossary
The following terms are useful for understanding the layout features and script rules
discussed in this document.
Base Glyph – The one and only consonant, independent vowel, or number in the syllable
that is written in its “full” (nominal) form. In Khmer, the first consonant or independent
vowel of the syllable usually forms the base glyph. Layout operations are defined in
terms of a base glyph, not a base character, since the results of the shaping process are
a series of glyphs.
U+17D2 (COENG) – Code point before a consonant or independent vowel, which causes
the formation of the subscript form of that letter. The COENG is always tied to the letter
following it and is always handled as a unit with the following letter. NOTE: The shape of
the COENG is arbitrary and is not rendered.

Consonant - Represents a single consonant sound. Consonants may exist in different
contextual forms, and have an inherent vowel (usually, the long vowel “A”). Therefore,
those illustrated in the examples to follow are named, for example, “KA” and “TA,” rather
than just “K” or “T.”
Consonant Shifters – Used to shift the base consonant between registers (U+17C9,
U+17CA).
Khmer Syllable – Effective orthographic “unit” of Khmer writing systems, consisting of a
consonant and a vowel core, and optionally with one or two subscripts inserted between
the two, and followed by signs. Syllables are composed of consonant letters,
independent vowels, dependant or inherent vowels, and signs. In a text sequence, these
characters are stored in phonetic order, although they may not be represented in
phonetic order when displayed. Once a syllable is shaped, it is indivisible (but deletions
of its characters may take place starting from the end). The cursor cannot be positioned
within the syllable. Transformations discussed in this document do not cross syllable
boundaries.
ROBAT (U+17CC) – Above-base or combining form of the letter RO, used in most scripts
if RO is the first consonant in the syllable and is not the base consonant. It is ordered as
one would write the text. For example, the word KARMA would be encoded as KA + MA
+ ROBAT.
Subscript Glyph – Subscript form of a consonant or independent vowel. An example of
this is COENG KA. Subscripts are formed by a combination of COENG glyph, followed by
a consonant or independent vowel. COENG does not have a conventional visual form in
Khmer, as it is a control character to cause the formation of a subscript. An implementer
of Khmer should never allow the entry of the COENG character by itself.
There are three types of subscript glyphs: Type 1 is positioned below the base glyph;
Type 2 is the form (currently only COENG RO) that has an “arm” for spacing the left side
of the base glyph; and Type 3 is the subscript form with an “arm” for spacing the right
side of the base glyph.
There may be up to two subscript glyphs per base glyph, which may be of different
subscript types. The ordering of subscripts must be in the order of: Type 1 (may be
doubled), Type 2, and then Type 3 (may be doubled). Exceptions to this ordering are
invalid, and will cause a new cluster to be formed that has the dotted circle glyph as the
base glyph.
Vowel - A Khmer syllable is permitted to have only one vowel. In the notation, four
different types are indicated, based on the position when rendered. There are five
vowels (U+17BE, U+17BF, U+17C0, U+17C4, U+17C5), composed of two glyph pieces,

although these two pieces are treated as one vowel in the backing store. The shaping
engine will take care of pre-pending the syllable, with the glyph piece shaped like
U+17C1.

Notation
The following notation is used in this document to illustrate layout operations:
Cons – Consonant character
IndV – Independent vowel character
COENG – The COENG code
PreV – Vowel that is positioned before the base glyph; it is not possible to have both a
PreV and a PstV in the same syllable; vowels that have both prebase and postbase
glyphs (U+17BF, U+17C0, U+17C4, U+17C5) are classified as PstV; the shaping engine
will take care of prepending the U+17C1 glyph to the syllable
BlwV – Vowel that is positioned below the base glyph; a base glyph cannot have both a
BlwV and an AbvV (the combination U+17BB + U+17C6 is of a vowel and a sign)
RegShift – Triisap or Muusikatoan character that is normally situated immediately above
the Base glyph, but often changes to an ambiguous glyph at the extreme below position
when there is an above-base vowel/vowel-part glyph
AbvV - Vowel that is positioned above the base glyph; a base glyph cannot have both a
BlwV and an AbvV; note as above: the combination U+17BB + U+17C6 is of a vowel and
a sign; the vowel with pre and above glyphs (U+17BE) is considered an AbvV; in this
case, the shaping engine prepends the U+17C1 to the beginning of the syllable
AbvS – A sign character that is positioned above the base glyph
Robat – The Robat glyph
PstV – Vowel that is positioned after the base glyph; in some cases, the PstV has a part
(U+17C1) that is prepended to the the syllable; therefore, a PreV and a PstV cannot exist
in the same syllable
PstS – Sign character that is positioned after the base glyph
Nikahit – Sign which on its own or in combination with vowel characters creates a
constructed vowel; it adds an ‘m’ or ‘n’ sound; this is classified as an AbvS

Reahmuk – Sign which on its own or in combination with vowel characters creates a
constructed vowel; it adds an ‘h’ aspiration; this is classified as a PstS
{ } – Indicates 0 to 2 occurrences
[ ] – Indicates 0 or 1 occurrence
| – Exclusive OR
+ - Cumulative AND

Shaping Engine
Analyze syllables and reorder characters
Shape glyphs with OTLS
Position glyphs with OTLS
Base elements
Invalid combining marks
The Uniscribe Khmer shaping engine processes text in stages. The stages are:
1. Analyze syllables and reorder characters
2. Shape (substitute) glyphs with OTLS (OpenType Library Services)
3. Position glyphs with OTLS
The descriptions which follow will help font developers understand the rationale for the
Khmerf feature encoding model, and help application developers better understand
how layout clients can divide responsibilities with operating system functions.

Analyze syllables and reorder characters
All Khmer syllables begin with a consonant, independent vowel, or number. The
following should be considered as canonical ordering for Khmer Unicode input. The
ordering is in the same order that the Khmer syllable is formed and produces the correct
sort/search order. Any device using Khmer Unicode should use this input sequence
order to correctly handle Khmer text. One complex and two simple constructs are
elaborated below.

Canonical ordering
It is important for the user inputting the text to remember that although it is possible to
input some of the formed sequences by using individual glyphs, the Unicode characters

that are input must be in a correctly defined and consistent order for sorting and
searching mechanisms to work. For example, a person might try to enter a syllable with
U+17C1 and U+17B6. A user might think that they look the same as inserting U+17C4.
However, the meaning is very different. Any devices, like text-to-speech, that require
correct characters for correct output would not consider these the same. More
importantly, the user's attempt to incorrectly use U+17C1 and U+17B6 in the same
syllable would result in breaking the rule of having only one vowel character per syllable.

Syllables beginning with consonants
Consonant based syllables are formed in the following order:
Cons + {COENG + (Cons | IndV)} + [PreV | BlwV] + [RegShift] + [AbvV] + {AbvS} + [PstV]
+ [PstS]

RegShift case
The RegShift glyphs automatically take positioning based on the context of the vowel
above. Normally, the RegShift will be rendered immediately above the base glyph. In the
event that the RegShift character precedes an AbvV, the RegShift is normally rendered
as a vertical stroke at the lowest extreme of the syllable. In some cases it is necessary to
force the RegShift to be placed above the base glyph. In this case a ZERO WIDTH NONJOINER (ZWNJ) is inserted between the RegShift and the AbvV to prevent the context
rule of the shaping engine from being applied.
U+179F U+17CA U+17B8 (for a child or animal 'to eat') is an example where the below
base form of TRIISAP is used.
U+1784 17C9 U+17B7 U+1780 U+1784 U+17C9 U+1780 U+17CB ('sulky') is an example
where the first MUUSIKATOAN is in a below base form and the second in an above base
form.
U+17A2 U+200C(ZWNJ) U+17CA U+17B7 U+17A2 U+17BB U+17CA U+17C7 is an
interesting case where the first TRIISAP needs to be escaped, but the second does not
(as there is a below base vowel)
An overview of the logic used when analyzing and reordering characters in the shaping
engine looks something like the following;
1. Khmer shaping assumes that a syllable will begin with a Cons, IndV, or Number.
2. When a COENG + (Cons | IndV) combination are found (and subscript count is less
than two) the character combination is handled according to the subscript type of
the character following the COENG.

a. Subscript Type 1 - The COENG + (Cons | IndV) characters are assigned to have
the 'blwf' OpenType feature applied to them.
b. Subscript Type 2 - The COENG + RO characters are reordered to immediately
before the base glyph. Then the COENG + RO characters are assigned to have
the 'pref' OpenType feature applied to them.
c. Subscript Type 3 - The COENG + Cons characters are assigned to have the 'pstf'
OpenType feature applied to them.
3. When a RegShift character is followed by an AbvV character, the RegShift character
is assigned have the 'blwf' OpenType feature applied to change the shape to the
below base form of the RegShift glyph (like U+17BB).
4. When a AbvV character with KHF_ABVSPLIT assigned is found, the pre-base vowel
part (U+17C1) is prepended to the beginning of the cluster. The AbvV character is
then assigned to have the 'abvf' OpenType feature applied so the glyph form is
changed to the shape of the above vowel ( like U+17B8).
5. When a PstV character with KHF_PSTSPLIT assigned is found, the pre-base vowel
part (U+17C1) is prepended to the beginning of the cluster. The PstV character is
then assigned to have the 'pstf' OpenType feature applied so the glyph form is
changed to the shape of the second half.

Shape Glyphs with OTLS
The first step Uniscribe takes in shaping the reordered character string is to apply the
assigned layout features to the glyph string during the shaping process. These features,
described and illustrated later in this document, are always applied in the order in which
they are listed below.
Next, Uniscribe calls OTLS to apply the features. All OTL processing is divided into a set
of predefined features (described and illustrated in the Features section). Each feature is
applied, one by one, to the appropriate glyphs in the syllable and OTLS processes them.
Uniscribe makes as many calls to the OTL Services as there are features. This ensures
that the features are executed in the desired order.
The steps of the shaping process are outlined below.

Shaping features:
1. Language forms
a. Apply feature 'pref' to get pre based ligatures
b. Apply feature 'blwf' to get below based ligatures or below base RegShift.
c. Apply feature 'abvf' to Ro and the following COENG to get the Robat glyph, or
to the AbvV that has KHF_ABVSPLIT to get the above glyph.

d. Apply feature 'pstf' to get post base ligatures.
2. Conjuncts and Typographical forms
a. Apply feature 'pres' to get pre-base substitutions on the COENG RO glyph when
there is a subscript type 1 on the syllable.
b. Apply feature 'blws' to get below base substitutions that might be required for
typographical correctness.
c. Apply feature 'abvs' to get above base substitutions that might be required for
typographical correctness.
d. Apply feature 'psts' to get post base substations that might be required for
typographical correctness. For example, a subscript type 3 glyph that needs to
have a lower descent when a subscript type 1 glyph is on the syllable.
e. Apply feature 'clig' to form ligatures that are desired for typographical
correctness. For example, a subscript type 3 glyph that is followed by the OO
glyph (U+17C4.secondhalf).

Position Glyphs with OTLS
Uniscribe next applies features concerned with positioning, calling functions of OTLS to
position glyphs.

Positioning features:
1. Distances
a. Apply feature 'dist' to adjust other distances, e.g. to provide kerning between
post- and pre-base elements and the base glyph.
2. Below-base marks
a. Apply feature 'blwm' to position below-base forms, vowel modifiers and or
stress/tone marks on base glyph.
3. Above-base marks
a. Apply feature 'abvm' to position above-base forms, vowel modifiers and or
stress/tone marks on base glyph.
4. Mark to mark
a. Apply feature 'mkmk' to position AbvS glyphs above AbvV glyphs or BlwV
glyphs below subscript glyphs.

Base elements
Commonly, a feature is required for dealing with the base glyph and one of the postbase, pre-base or above-base elements. Since it is not possible to reorder ALL of these

elements next to the base glyph, we need to skip over the elements "in the middle"
(reordering-wise).
The solution is to assign different mark attachment classes to different elements of the
syllable and positional forms, and in any given lookup work with one mark type only. For
example, in above-base substitutions we need only consider above-base elements most
of the time.
Generally, it is good practice to mark as "mark" glyphs that are denoted as marks in the
Unicode standard as well as below-base/above-base forms of consonants. Then,
different attachment classes should be assigned to different marks depending on their
position with respect to the base.

Invalid Combining Marks
Combining marks and signs that appear in text not in conjunction with a valid
consonant base are considered invalid. Uniscribe displays these marks using the fallback
rendering mechanism defined in the Unicode standard (section 5.12, 'Rendering NonSpacing Marks' of Unicode Standard 3.1), i.e. positioned on a dotted circle.
Please note that to render a sign standalone (in apparent isolation from any base) one
should apply it on a space (see section 2.5 'Combining Marks' of Unicode Standard 3.1).
For the fallback mechanism to work properly, a Khmer OTL font should contain a glyph
for the dotted circle (U+25CC). In case this glyph is missing form the font, the invalid
signs will be displayed on the missing glyph shape (white box).

In addition to the "dotted circle" other Unicode code points that are recommended for
inclusion in any Khmer font are the ZWJ (zero width joiner; U+200D), the ZWNJ (zero
width non-joiner; U+200C) and the ZWSP (zero width space; U+200B) which can be
used for word boundaries.
If an invalid combination is found; more than one vowel character in a syllable, more
than two subscripts on the same base character, or the incorrect ordering of subscripts,
a new cluster will be formed that has the dotted circle as the base glyph. The shaping
engine for non-OpenType fonts will cause invalid mark combinations to overstrike. This
is the problem that inserting the dotted circle for the invalid base solves. It should also

be noted that the dotted circle is not inserted into the application's backing store. This is
a run-time insertion into the glyph array that is returned from the ScriptShape function.
Following is a chart of character classes for the Khmer script.
Class

Subclass

Member Characters

Consonant

SubscriptType1

U+1780-U+1782, U+1784-U+1787,
U+1789-U+178C, U+178E-U+1793,
U+1795-U+1798, U+179B-U+179D,
U+17A0, U+17A2

Consonant

SubscriptType2

U+179A

Consonant

SubscriptType2

U+1783, U+1788, U+178D, U+1794,
U+1799, U+179E-U+179F, U+17A1

Independent
Vowel

(No Subscript)

U+17B4-U+17B5

SubscriptType1

U+17A3-U+17B3

Coeng
Dependent
Vowel

U+17D2
Above-base

U+17B7-U+17BA, U+17BE (split)

Below-base

U+17BB-U+17BD

Pre-base

U+17C1-U+17C3

Post-base

U+17B6, U+17BF-U+17C0 (split), U+17C4U+17C5 (split)

Register
Shifter

U+17C9-U+17CA

Robat

U+17CC

Sign

Above-base

U+17C6, U+17CB, U+17CD-U+17D1,
U+17DD

Post-base

U+17C7-U+17C8

Above numbers

U+17D3

Punctuation

U+17D4-U+17DA, U+17DC, U+19E0U+19FF

Currency

U+17DB

Number

U+17E0-U+17E9, U+17F0-U+17F9

Reserved

U+17DE-U+17DF, U+17EA-U+17EF,
U+17FA-U+17FF

Features
The features listed below have been defined to create the basic forms for the languages
that are supported on Khmer systems. Regardless of the model an application chooses
for supporting layout of complex scripts, Uniscribe requires a fixed order for executing
features within a run of text to consistently obtain the proper basic form. This is
achieved by calling features one-by-one in the standard order listed below.
The order of the lookups within each feature is also very important. For more
information on lookups and defining features in OpenType fonts, see the Encoding
section of the OpenType Font Development document.
The standard order for applying Khmer features encoded in OpenType fonts:
Feature

Feature function

Layout
operation

Required

Language based forms:
pref

Pre-base forms

GSUB

X

blwf

Below-base forms

GSUB

X

abvf

Above-base forms

GSUB

X

pstf

Post-base forms

GSUB

X

Conjuncts & typographical forms:
pres

Pre-base substitution

GSUB

X

blws

Below-base substitution

GSUB

X

abvs

Above-base substitution

GSUB

X

psts

Post-base substitution

GSUB

X

clig

Contextual ligature substitution

GSUB

X

Positioning features:
dist

Distances

GPOS

blwm

Below-base mark positioning

GPOS

abvm

Above-base mark positioning

GPOS

mkmk

Mark to mark positioning

GPOS

[GSUB = glyph substitution, GPOS = glyph positioning]

Feature examples
Pre-base form
Feature Tag: "pref"
The 'pref' feature is used to substitute the pre-base form of a consonant in conjuncts.
(GSUB lookup type 4).

Example: the COENG typed before a consonant will substitute the subscript form.

Below-base form
Feature Tag: "blwf"
The 'blwf' feature is used to substitute the below-base form of a consonant in conjuncts
or the below-base RegShift. (GSUB lookup type 4).

Example: the below-base form of the letter Ka is formed when it is preceded by COENG.

Above-base form
Feature Tag: "abvf"
The 'abvf' feature is applied to the glyph to substitute the Unicode defined shape to the
portion of the glyph that is located above the base glyph (GSUB lookup type 1). This is

possible because the piece of the letter which is displayed before the letter has been
inserted into the glyph store in front of the base glyph by the Uniscribe engine.

Post-base form
Feature Tag: "pstf"
The 'pstf' feature is used to substitute the post-base form with a post-base ligature.
(GSUB lookup type 4).

Conjuncts and typographical forms
Feature Tags: "pres", "blws", "abvs", "psts"
All previous features have dealt with language features only, dedicated to forming glyph
shapes dictated by the languages. The remaining shaping features cover optional
features. Although it is hard to imagine a Khmer font without any consonant conjuncts
encoded within it, almost none are, strictly speaking, required. In fact, different fonts
may contain different subsets. Thus the range of features covered here spans from those
that will exist in every font to rare typographical ornaments. It is important to stress
once more however that all features discussed here operate only within one
orthographic syllable.
Since the language features do not limit typographical processing here, Uniscribe passes
the entire syllable to the OTL Services library. Uniscribe does not strictly specify the
format of lookup tables to use or their inputs, allowing for context-dependent
processing of any of the conjuncts and forms below.

OTL Services library processes the syllable "left to right", executing lookups in the order
they are specified in the font. First, pre-base substitutions will be handled, then belowbase, above-base and post-base ones.
Thus a font developer should first take care of all ligatures to the left of the base glyph
and then work your way to the right, substituting below-bases, above-bases and then
finally post-base elements. The lookups in the font should be ordered in the same way.
With every new element and feature, the following operations should be considered, as
appropriate, in this order:
Ligatures with the base glyph
Ligatures with preceding (in the canonical syllable form below) elements, and
Contextual forms of the element
At every feature step, one should take into account all ligatures and forms that were
produced by previous steps.

Pre-base substitutions
Feature Tag: "pres"
The 'pres' feature is used to produce the pre-base form of conjuncts.

Below-base substitutions
Feature Tag: "blws"
The 'blws' feature is used to produce the below-base substitutions that may be required
for typographical correctness.

Above-base substitutions
Feature Tag: "abvs"
The 'abvs' feature is used to substitute the above-base substitutions that may be
required for typographical correctness.

Post-base substitutions
Feature Tag: "psts"
The 'psts' feature is used to substitute the post-base substitutions that may be required
for typographical correctness. For example, a subscript type 3 glyph that needs to have
a lower descent when a subscript type 1 glyph is on the syllable.

Contextual ligatures
Feature Tag: "clig"
The 'clig' feature is used to map glyphs to their contextual ligated form. Unlike other
ligature features, 'clig' specifies the context in which the ligature is recommended. This
capability is important in some script designs and for swash ligatures. The 'clig' table
maps sequences of glyphs to corresponding ligatures in a chained context (GSUB
lookup type 8). Ligatures with more components must be stored ahead of those with
fewer components in order to be found.

Distances
Feature Tag: "dist"
The 'dist' feature is used to provide a means to control distance between glyphs. The
'dist' table provides distances by which a glyph needs to move towards or away from
another glyph (GPOS lookup type 2). This feature covers all other positioning lookups
defining various distances between glyphs, such as kerning between pre- and post-base
elements and the base glyph.
NOTE: The 'dist' feature is a theoretically possible item for which examples of usage are
not currently available.

Below-base mark positioning
Feature Tag: "blwm"
The 'blwm' feature is used to position all below-base marks on base glyphs. The best
method for encoding this feature in an OpenType font is to use a chaining context
positioning lookup that triggers mark-to-base and mark-to-mark attachments for
below-base marks. The 'blwm' table provides positioning information (x,y) to enable
mark positioning (GPOS lookup type 4, 5).

positioning marks below base glyphs using Microsoft VOLT

Above-base mark positioning
Feature Tag: "abvm"
The 'abvm' feature is used to position all above-base marks on base glyphs. The best
method for encoding this feature in an OpenType font is to use a chaining context
positioning lookup that triggers mark-to-base and mark-to-mark attachments for
below-base marks. The 'abvm' table provides positioning information (x,y) to enable
mark positioning (GPOS lookup type 4, 5).

positioning marks above base glyphs using Microsoft VOLT

Mark to mark positioning
Feature Tag: "mkmk"
The 'mkmk' feature positions mark glyphs in relation to another mark glyph. This feature
may be implemented as a MarkToMark Attachment lookup (GPOS LookupType = 6).

positioning mark to mark using Microsoft VOLT

Appendix
Appendix A: Writing System Tags
Features are encoded according to both a designated script and language system. The
language system tag specifies a typographic convention associated with a language or
linguistic subgroup
Currently, the Uniscribe engine only supports the "default" language for each script.
However, font developers may want to build language specific features which are
supported in other applications and will be supported in future Microsoft OpenType
implementations.
NOTE: It is strongly recommended to include the "dflt" language tag in all
OpenType fonts because it defines the basic script handling for a font. The "dflt"
language system is used as the default if no other language specific features are
defined or if the application does not support that particular language. If the "dflt"

tag is not present for the script being used, the font may not work in some
applications.
The following tables list the registered tag names for scripts and language systems.
Registered tags for the Khmer script

Registered tags for Khmer language systems

Script tag

Script

Language
system tag

Language

"khmr"

Khmer

"dflt"

*default script handling

"KHM "

Khmer

Note: both the script and language tags are case sensitive (script tags should be
lowercase, language tags are all caps) and must contain four characters (ie. you must
add a space to the three character language tags).

Developing OpenType Fonts for Lao
Script
Article • 06/11/2022

This document presents information that will help font developers create or support
OpenType fonts for Lao script languages covered by the Unicode Standard.

Introduction
Font developers will learn how to encode script features in their fonts, choose character
sets, organize font information, and use existing tools to produce Lao script fonts.
Registered features of Lao scripts are defined and illustrated, encodings are listed, and
templates are included for compiling layout tables for OpenType fonts.
This document also presents information about the Lao OpenType shaping engine of
Uniscribe, an operating system component responsible for text layout.
In addition to being a primer and specification for the creation and support of Lao script
fonts, this document is intended to more broadly illustrate the OpenType Layout
architecture, feature schemes, and operating system support for shaping and
positioning text.

Glossary
The following terms are useful for understanding the layout features and script rules
discussed in this document.
Base Glyph - Any glyph that can have a diacritic mark above or below it. Layout
operations are defined in terms of a base glyph, not a base character, as a ligature may
act as the base.
Character - Each character represents a Unicode character code point. For example, the
'ko' character is U+0E81.
Glyph - A glyph represents the displayed form of one or more characters.
Combining Mark - A vowel sign or tone mark positioned above or below a character to
provide pronunciation guidance.
Cluster - The effective "unit" of Lao writing systems, consisting of a consonant, vowel
signs and combining tone marks, or independent vowel letters.

Shaping Engine
Analyze Characters
Shape Glyphs with OTLS
Position Glyphs with OTLS
Invalid Combining Marks
The Uniscribe Lao shaping engine processes text in stages. The stages are:
1. Analyze characters for valid diacritic combinations
2. Shape (substitute) glyphs with OTLS (OpenType Library Services)
3. Position glyphs with OTLS
The following sections will help font developers understand the rationale for the Lao
feature encoding model, and help application developers better understand how layout
clients can divide responsibilities with operating system functions.

Analyze Characters
The unit that the shaping engine receives for the purpose of shaping is a string of
Unicode characters, in a sequence. The contextual analysis engine verifies valid diacritic
combinations. For additional information, see Invalid Combining Marks.
The handling of the AM in the analysis phase is special. In the case where an above mark
does not exist on the preceding base consonant, the 'ccmp' feature will be used to
decompose the AM into the NIGGAHITA and AA glyphs. This allows the NIGGAHITA
glyph to be positioned correctly above the preceding base consonant. If there is a tone
mark on the base consonant already, the analysis engine will decompose the AM and
reorder the NIGGAHITA to between the base consonant and the tone mark. This allows
the NIGGAHITA glyph to be positioned correctly above the base consonant, and the
tone mark to be positioned correctly above the NIGGAHITA. This behavior cannot be
tested in VOLT, as this logic is not in VOLT.

Shape Glyphs with OTLS
The first step Uniscribe takes in shaping the character string is to map all characters to
their nominal form glyphs.
Next, Uniscribe calls OTLS to apply the features. All OTL processing is divided into a set
of predefined features (described and illustrated in the Features section). Each feature is
applied, one by one, to the appropriate glyphs in the syllable and OTLS processes them.

Uniscribe makes as many calls to the OTL Services as there are features. This ensures
that the features are executed in the desired order.
The steps of the shaping process are outlined below.

Shaping features:
1. Language forms
a. Apply feature 'ccmp' to preprocess any glyphs that require composition or
decomposition

Position Glyphs with OTLS
Uniscribe next applies features concerned with positioning, calling functions of OTLS to
position glyphs.

Positioning features:
1. Kerning
a. Apply feature 'kern' to provide pair kerning between base glyphs requiring
adjustment for better typographical quality
2. Mark to base
a. Apply feature 'mark' to position diacritic glyphs to the base glyph
3. Mark to Mark
a. Apply feature 'mkmk' to position diacritic glyphs to other diacritic glyphs

Invalid Combining Marks
Combining marks and signs that appear in text not in conjunction with a valid
consonant base are considered invalid. Uniscribe displays these marks using the fallback
rendering mechanism defined in the Unicode Standard (section 5.12, 'Rendering NonSpacing Marks' of the Unicode Standard 3.0), i.e. positioned on a dotted circle.
For the fallback mechanism to work properly, a Lao OTL font should contain a glyph for
the dotted circle (U+25CC). In case this glyph is missing from the font, the invalid signs
will be displayed on the missing glyph shape (white box).

In addition to the 'dotted circle', other Unicode code points that are recommended for
inclusion in any Lao font is the ZWSP (zero width space; U+200B). Lao words are not
separated by spaces, so the ZWSP can be used for word boundaries since it will allow for
word wrapping at the end of a line. Some applications will use a lexical lookup to do
word wrapping without needing ZWSP characters.
If an invalid combination is found, the diacritic that causes the invalid state is placed on
a dotted circle to indicate to the user the invalid combination. The shaping engine for
non-OpenType fonts will cause invalid mark combinations to overstrike. This is the
problem that inserting the dotted circle for the invalid base solves. It should also be
noted that the dotted circle is not inserted into the application's backing store; this is a
run-time insertion into the glyph array that is returned from the ScriptShape function.
The invalid diacritic logic for Lao is based on the classes listed below. There is a check to
make sure more than one mark of a class is not placed on the same base.
Class

Description

Code points

ABOVE1

Above mark closest to base

U+0EB1, U+0EB4, U+0EB5,
U+0EB6, U+0EB7, U+0EBB,
U+0ECD

ABOVE2

Second level above mark

U+0EC8, U+0EC9, U+0ECA,
U+0ECB, U+0ECC

BELOW1

Below mark closest to base

U+0EBC

BELOW2

Second level below mark

U+0EB8, U+0EB9

AM

The AM character is decomposed into two
glyphs (NIGGAHITA and AA). The NIGGAHITA is

U+0EB3

of class ABOVE1.

Features
The features listed below have been defined to create the basic forms for the languages
that are supported on Lao systems. Regardless of the model an application chooses for
supporting layout of complex scripts, Uniscribe requires a fixed order for executing

features within a run of text to consistently obtain the proper basic form. This is
achieved by calling features one-by-one in the standard order listed below.
The order of the lookups within each feature is also very important. For more
information on lookups and defining features in OpenType fonts, see the Encoding
section of the OpenType Font Development document.
The standard order for applying Lao features encoded in OpenType fonts:
Feature

Feature function

Layout
operation

Required

GSUB

X

Language based forms:
ccmp

Character composition/decomposition substitution

Positioning features:
kern

Pair kerning

GPOS

mark

Mark to base positioning

GPOS

X

mkmk

Mark to mark positioning

GPOS

X

[GSUB = glyph substitution, GPOS = glyph positioning]

Feature examples
Character composition (and decomposition)
Feature Tag: "ccmp"
The 'ccmp' feature is used to compose a number of glyphs into one glyph, or
decompose one glyph into a number of glyphs. This feature is implemented before any
other features because there may be times when a font vender wants to control certain
shaping of glyphs. An example of using this table is seen below. The 'ccmp' table maps
default alphabetic forms to both a composed form (essentially a ligature, GSUB lookup
type 4), and decomposed forms (GSUB lookup type 2).

Example: use the 'ccmp' feature to decompose the Sara Am for correct mark positioning.

Kerning
Feature Tag: "kern"
The 'kern' feature is used to adjust amount of space between glyphs, generally to
provide optically consistent spacing between glyphs. Although a well-designed typeface
has consistent inter-glyph spacing overall, some glyph combinations require adjustment
for improved legibility. Besides standard adjustment in either horizontal or vertical
direction, this feature can supply size-dependent kerning data via device tables, "crossstream" kerning in the Y text direction, and adjustment of glyph placement independent
of the advance adjustment. Note that this feature would not be used in monospaced
fonts.
The font stores a set of adjustments for pairs of glyphs (GPOS lookup type 2 or 8). These
may be stored as one or more tables matching left and right classes, and/or as
individual pairs. If both forms are used, the classes should be listed last, so as to provide
a means to replace any non-ideal values that may result from the class tables. Additional
adjustments may be provided for larger sets of glyphs (e.g., triplets, quadruplets, etc.) to
overwrite the results of pair kerns in particular combinations. These should precede the
pairs.

Kerning by pair adjustment using Microsoft VOLT

Mark to base positioning
Feature Tag: "mark"
The 'mark' feature positions mark glyphs in relation to a base glyph, or a ligature glyph.
This feature may be implemented as a MarkToBase Attachment lookup (GPOS
LookupType = 4) or a MarkToLigature Attachment lookup (GPOS LookupType = 5).

Positioning mark to base using Microsoft VOLT

Mark to mark positioning
Feature Tag: "mkmk"
The 'mkmk' feature feature positions mark glyphs in relation to another mark glyph. This
feature may be implemented as a MarkToMark Attachment lookup (GPOS LookupType =
6).

Positioning mark to mark using Microsoft VOLT

Appendix
Appendix A: Writing System Tags
Features are encoded according to both a designated script and language system. The
language system tag specifies a typographic convention associated with a language or
linguistic subgroup.
Currently, the Uniscribe engine only supports the "default" language for each script.
However, font developers may want to build language specific features which are
supported in other applications and will be supported in future Microsoft OpenType
implementations.
NOTE: It is strongly recommended to include the "dflt" language tag in all
OpenType fonts because it defines the basic script handling for a font. The "dflt"
language system is used as the default if no other language specific features are
defined or if the application does not support that particular language. If the "dflt"
tag is not present for the script being used, the font may not work in some
applications.
The following tables list the registered tag names for scripts and language systems.
Registered tags for the Lao script

Registered tags for Lao language systems

Script tag

Script

Language
system tag

Language

"lao "

Lao

"dflt"

*default script handling

"LAO "

Lao

Note: both the script and language tags are case sensitive (script tags should be
lowercase, language tags are all caps) and must contain four characters (ie. you must
add a space to the three character language tags).

Creating and Supporting OpenType
Fonts for Myanmar Script
Article • 06/17/2022

This document presents information that will help font developers in creating OpenType
fonts for Myanmar script as covered by the Unicode Standard 6.0. The Myanmar script is
used to write the Myanmar language. It is also used to write other languages including
Pali and Sanskrit.

Introduction
This document targets developers implementing shaping behavior compatible with the
Microsoft OpenType specification for the Myanmar script. It contains information about
terminology, font features and behavior of the Myanmar shaping engine. While it does
not contain instructions for creating Myanmar fonts, it will help font developers
understand how the Myanmar shaping engine processes Myanmar text.

Terms
The following terms are useful for understanding the layout features and script rules
discussed in this document.
Base glyph – Any glyph that can have a diacritic mark attached to it. Layout operations
are defined in terms of a base glyph, not a base character, as a ligature may act as a
base
Character – Each character represents a Unicode character code point. A character may
have multiple glyph forms
Cluster – A group of characters that form an integral unit in Brahmi-derived scripts,
oftentimes this corresponds to a syllable
Consonant – Myanmar consonants have an inherent vowel (the short vowel /a/). For
example, “Ka” and “Ta”, rather than just “K” or “T”
Consonant conjunct (aka ‘conjunct’) – A ligature of two or more consonants
Format controls – special formatting characters used in the shaping process of
Myanmar scripts (U+200c and U+200D). These characters have no visual appearance,
except when an application chooses to display zero width glyphs

Glyph – A glyph represents a form of one or more characters
Kinzi – A reduced form of certain consonant signs that is written as an above base mark
on a following base. This corresponds to a reph in other Brahmi-derived scripts.
Ligature – A combination of glyphs that join to form a single glyph
Matra (dependent vowel) – Used to represent a vowel sound that is not inherent to the
consonant. Dependent vowels are referred to as “matras” in Sanskrit. They are always
depicted in combination with a single consonant, or with a consonant cluster
OpenType layout engine – The library responsible for executing OpenType layout
features in a font. In the Microsoft text formatting stack, it is named OTLS (OpenType
layout services)
OTLS – OpenType Layout Services
OpenType tag – A 4-byte identifier for script, language system or feature in the font
Shaping engine - Code responsible for shaping input, classified to a particular script

Shaping Engine
The Uniscribe Myanmar shaping engine processes text in stages. The stages are:
1. Analyzing the characters
2. Well-formed Clusters
3. Reordering characters
4. Apply OpenType GSUB features
5. Apply OpenType GPOS features
The descriptions which follow will help font developers understand the rationale for the
Myanmar feature encoding model, and help application developers better understand
how layout clients can divide responsibilities with operating system functions.

Analyzing the characters
The run of text that the shaping engine receives for the purpose of shaping is a
sequence of Unicode characters. The shaping engine divides the text into syllable
clusters and identifies character properties. Character properties are used in parsing
syllables and identifying their parts as well as determining whether any contextual
reordering is required.

Additionally, the engine verifies that the run consists of valid clusters and inserts a
placeholder glyph (U+25CC) wherever combining marks occur without a valid base.
In the Myanmar engine, OpenType features are applied in two stages, first GSUB
features are applied to the logical cluster. Then, GSUB and GPOS features are applied to
the entire run.
In the diagrams below, the rules for forming clusters are given in terms of the classes of
characters in the character stream. The meanings of the symbols are:
A

Anusvara class (1032, 1036)

As

Asat (103A)

C

Consonants and Independent vowels (1000-1020, 103F, 104E, 1050, 1051, 105A-105D,
1061, 1065, 1066, 106E-1070, 1075-1081, 108E, AA60-AA6F, AA71-AA76, AA7A)

D

Myanmar digits except zero (1041-1049, 1090-1099)

D0

Myanmar digit zero (1040)

DB

Dot below (1037)

GB

Generic base characters (00A0, 00D7, 2012–2015, 2022, 25CC, 25FB–25FE)

H

Halant/virama (1039)

IV

Independent vowel (1021-102A, 1052-1055)

J

Joiners (200C, 200D)

K

A special sequence of three characters (<1004 | 101B | 105A>, 103A, 1039)

MH

Medial consonants Ha, Mon La (103E, 1060)

MR

Medial consonants Ra (103C)

MW

Medial consonants Wa, Shan Wa (103D, 1082)

MY

Medial consonants Ya, Mon Na, Mon Ma (103B, 105E, 105F)

O

SCRIPT_COMMON characters in a Myanmar run

P

Punctuation (104A, 104B)

PT

Pwo and other tones (1063, 1064, 1069-106D, AA7B)

R

Reserved characters from the Myanmar Extended-A block (AA7C-AA7F)

S

Symbols (104C, 104D, 104F, 109E, 109F, AA70, AA77-AA79)

V

Visarga and Shan tones (1038, 1087-108D, 108F, 109A-109C)

VAbv

Above base dependent vowel (102D, 102E, 1033-1035, 1071-1074, 1085, 1086, 109D)

VBlw

Below base dependent vowel (102F, 1030, 1058, 1059)

VPre

Pre base dependent vowel (1031, 1084)

VPst

Post base dependent vowel (102B, 102C, 1056, 1057, 1062, 1067, 1068, 1083)

VS

Variation selectors (FE00–FE0F)

WJ

Word joiner (2060)

WS

White space (any white space character including ZWSP)

X*

sequence of zero or more occurrences of X. Since this could extend a cluster indefinitely
an arbitrary limit of 31 characters in a sequence has been used

X+

sequence of one or more occurrences of X

<X |
Y>

disjunction of elements: X or Y

[X]

optional (zero or one) occurrence of X

#

occurrence of a boundary

×

no boundary allowed at indicated position

÷

boundary allowed at indicated position

^

Except

Well-formed Clusters
Well-formed Myanmar character clusters can have combinations of groups as defined
below. There are three options:
Simple non-compounding cluster
<P | S | R | WJ| WS | O | D0 >
Punctuation (P), symbols (S), reserved characters from the Myanmar block (R), word
joiner (WJ), white space (WS), and other SCRIPT_COMMON charcters (O) contain one
character per cluster.
Cluster terminating in Halant
[K] <C | IV | D | GB>[VS] (H <C | IV> [VS])* H

Optional Kinzi with a required base sign and optional variation selector. Zero or more
stacked consonants or full vowel forms and optional variation selector. A halant
character terminates the cluster.
Complex cluster
[K] <C | IV | D | GB>[VS] (H <C | IV> [VS]) (As) [MY [As]] [MR] [<MW [As] | [MW] MH
[As]>] (VPre) (VAbv)* (VBlw) (A) [DB [As]] (VPst [MH] (As)* (VAbv)* (A)* [DB [As]]) (PT <
[A] [DB] [As] | [As] [A] > ) (V)* [J]
Optional Kinzi with a required base sign and optional variation selector. Zero or more
stacked consonants or full vowel forms and optional variation selector followed by Zero
or more Asat signs. Zero or one of each medial consonant, a single Asat may follow MY,
MW and MH. Zero or more dependent pre-base and above-base vowels. Zero or more
below-base vowels. Zero or more Anusvara and zero or one dots below, if there is a dot
below, a single Asat is permitted. Zero or more sequences of a post-base vowel,
followed by zero or one medial H, zero or more Asat, zero or more vowels above, and
zero or one dots below, if there is a dot below, a single Asat is permitted. Zero or more
sequences of a Pwo tone mark each of which may either be followed by optional
Anusavara, optional dot below, optional Asat; or be followed by optional Asat, optional
Anusvara. Zero or more visargas. Zero-width joiner and zero-width non joiner will be the
last item in any cluster in which they occur.

The cluster rules need to permit this level of complexity in order to be able to handle
the full range of possible encoded sequences. However, only test cases will try to
exercise more than a few of these positions in a single cluster:

င်္က္ကျြွှေို့်ာှီ့ၤဲံ့းႍ

Reordering characters
Once the Myanmar shaping engine has analyzed the run as described above, it creates a
buffer of appropriately reordered elements (glyphs) representing the cluster according
to the rules given below.
Kinzi sequences (K) are reordered directly after the cluster base
The medial ra (MR) is reordered before the base consonant
Pre-base vowels (VPre) are reordered to the start of the syllable cluster. A
sequence of multiple prebase vowels is permitted. Such sequences are moved as a
block to the beginning of the cluster
Anusvara (A) coming immediately after one or more below-base vowels (VBlw) will
reorder immediately before them

Pathological Reordering Example
A run containing many of the possible items in a single syllable would reorder as
follows:
Key
Kinzi Base Medial Ra Prebase vowel Anusvara
INPUT
1004 103A 1039 1000 1039 1000 103B 103C 103D 1031 1031 102D 102F 1036 102C
1036
REORDERED
1031 1031 103C 1000 1004 103A 1039 1039 1000 103B 103D 102D 1036 102F 102C
1036
The OpenType lookups in a Myanmar font must be written to match glyph sequences
after re-ordering has occurred. OpenType fonts should not have substitutions that
attempt to perform the re-ordering. If a font developer attempted to encode such

reordering information in an OpenType font, they would need to add a huge number of
many-to-many glyph mappings to cover the general algorithms that a shaping engine
will use.

Apply OpenType GSUB features
Uniscribe calls OTLS to apply the features. All OTL processing is divided into a set of
predefined features (described and illustrated in the Features section of this document).
Each feature is applied to the entire run and OTLS processes them. Uniscribe makes as
many calls to the OTL Services as there are features. This ensures that the features are
executed in the desired order.
The steps of the shaping process are outlined below. Not all of the features listed must
be used by all languages using the Myanmar script.
Shaping features:
1. Localized forms
a. Apply feature ‘locl’ to preprocess any localized forms for the current language
2. Basic shaping forms
a. Apply feature ‘rphf’ to get kinzi glyph forms
b. Apply feature ‘pref’ to get pre-base glyph forms
c. Apply feature ‘blwf’ to get below-base glyph forms
d. Apply feature ‘pstf’ to get post-base forms
3. Presentation forms
a. Apply feature ‘pres’ to substitute pre-base glyph forms
b. Apply feature ‘abvs’ to substitute above-base glyph forms
c. Apply feature ‘blws’ to substitute below-base glyph forms
d. Apply feature ‘psts’ to substitute post-base glyph forms
Note: since the presentation form features are applied simultaneously over the entire
cluster, several features are operationally equivalent to a single feature. Multiple features
are provided as an aid for font developers to organize the lookups they implement.

Apply OpenType GPOS features
The shaping engine next processes the GPOS (glyph positioning) table, applying
features concerned with positioning. All features are applied simultaneously to the
entire cluster.
The font developer must consider the effects of re-ordering when creating the GPOS
feature and lookup tables.

1. Kerning
a. Apply feature ‘kern’ to provide pair kerning between glyphs for better
typographic quality. Note this feature may be disabled by some applications
b. Apply feature ‘dist’ to make any required distance adjustments
2. Mark placement
a. Apply feature ‘mark’ to position diacritic glyphs relative to the base glyph
b. Apply feature ‘mkmk’ to position diacritic glyphs relative to each other

Features
The features listed below have been defined to create the basic forms for languages that
use the Myanmar script. Regardless of the model an application chooses for supporting
layout of complex scripts, Uniscribe requires a fixed order for executing features within a
run of text to consistently obtain the proper basic form. This is achieved by calling
features one-by-one in the standard order listed below.
The order of the lookups within each feature is also very important. For more
information on lookups and defining features in OpenType fonts, see Encoding feature
information in the OpenType font development section.
The standard order for applying Myanmar features encoded in OpenType fonts:
Feature

Feature function

Layout
operation

Required

Localized forms
locl

GSUB

Basic shaping forms
rphf

Kinzi substitution

GSUB

X

pref

Pre-base substitution

GSUB

X

blwf

Below-base substitution

GSUB

X

pstf

Post-base form substitution

GSUB

X

Presentation forms
pres

Pre-base substitution

GSUB

abvs

Above-base substitution

GSUB

blws

Below-base substitution

GSUB

psts

Post-base substitution

GSUB

kern

Pair kerning

GPOS

dist

Distance adjustments

GPOS

Kerning:

X

Mark placement
mark

Mark positioning

GPOS

mkmk

Mark to mark positioning

GPOS

[GSUB = glyph substitution, GPOS = glyph positioning]

Feature examples
The registered features described and illustrated in this document are based on the
Microsoft OpenType font Myanmar Text (mmrtext.ttf). Myanmar Text contains layout
information and glyphs to support all of the required features of the Myanmar script.
The illustrations in the following examples show the result of that particular feature
being applied. Features must be written to match glyph sequences after re-ordering has
occurred. Note that the input context for a feature may be the result of a previous
feature having already been applied.

Localized forms
Feature Tag: “locl”
This feature is used in association with OpenType language system tags to trigger
lookups that will select alternate glyphs needed for language-specific typographic
conventions. The ‘locl’ should not be used in association with the default language
system, but only used with other language system tags. See the Appendix of this
document for language system tags associated with the Myanmar script.

Basic shaping forms
Feature Tag: “rphf”
This feature is used to substitute the kinzi forms. Kinzi sequences are reordered after
valid base, see above. If there is no valid base, a dotted circle glyph is inserted by the
shaping engine to serve as the base. Kinzi sequences should be substituted with a mark
glyph so that it can be positioned above the preceding base character after reordering.
The kinzi substitution must be done with the rphf feature.

Feature Tag: “pref”
This feature is used to substitute the pre-base forms. For example, the Myanmar Text
font uses this feature to substitute different width forms of the medial consonant Ra
(MR).

Feature Tag: “blwf”
This feature is used to substitute the below-base forms. For example, the Myanmar Text
font uses this feature to form stacked consonant glyphs.

Feature Tag: “pstf”
This feature is used to substitute the post-base forms. For example, the Myanmar Text
font uses this feature to substitute the combination of the vowel sign tall Aa and a
following Asat.

Presentation forms
Feature Tag: “pres”
This feature is used to substitute presentation forms involving pre-base elements. For
example, the Myanmar Text font substitutes the clipped forms of the medial consonant
Ra using the pres feature.

Feature Tag: “abvs”
This feature is used to substitute presentation forms relating to above-base elements.
For example, the Myanmar Text font uses this feature to form ligatures of above-base
marks.

Feature Tag: “blws”
This feature is used to substitute presentation forms relating to below-base elements.
For example, the Myanmar Text font uses this feature to substitute spacing forms of
below-base marks vowels.

Feature Tag: “psts”
This feature is used to substitute presentation forms relating to post-base elements. For
example, the Myanmar Text font uses this feature to substitute a presentation form for
medial consonant Ya.

Kerning
Feature Tag: “kern”
This feature may be used to adjust the positioning of glyph pairs. The Myanmar Text
font does not use this feature.

Feature Tag: “dist”
This feature may be used to adjust distances. The Myanmar Text font uses this feature
add back width to spacing marks.
Note that mark glyphs have their width set to zero by OTLS. If a mark glyph must have
width, it is necessary to add back lost width for correct display. The dist feature is a
required feature and should be used for this purpose as well as other required distance
adjustments.

Mark placement
Feature Tag: “mark”
This feature is used to position marks relative to a base glyph. The Myanmar Text font
uses this feature to position above and below marks relative to the base glyph.
Note that the mark feature is a required feature and will always be triggered by the
shaping engine. Fonts may use other mark positioning features such as abvm or blwm,
but these are not required features.

Feature Tag: “mkmk”
This feature is used to position marks relative to each other. The Myanmar Text font uses
this feature to position a sequence of marks.
Note that the mkmk feature is a required feature and will always be triggered by the
shaping engine.

Handling invalid combining marks
Combining marks and signs that do not occur in conjunction with a valid base are
considered invalid. Shaping engine implementations may adopt different strategies for
how invalid marks are handled. For example, a shaping engine implementation might
treat an invalid mark as a separate cluster and display the stand-alone mark positioned
on some default base glyph, such as a dotted circle (U+25CC). (See Fallback Rendering
in section 5.13 of the Unicode Standard 4.0.) Shaping engine implementations may vary
somewhat with regard to what sequences are or are not considered valid. For instance,
some implementations may impose a limit of at most one above-base vowel mark while
others may not.
To allow for shaping engine implementations that expect to position an invalid mark on
a dotted circle, it is recommended that a Myanmar OT font contain a glyph for the
dotted circle character, U+25CC. If this character is not supported in the font, such
implementations will display invalid signs on the missing glyph shape (white box).

Recommended Glyphs
Unicode code points that are strongly recommended for inclusion in any Myanmar font
are:
Code
point

Description

U+200B

Zero Width Space

U+200C

Zero Width Non-Joiner

U+200D

Zero Width Joiner

U+25CC

Dotted Circle

U+002D

Hyphen-minus

U+00A0

No-break space

U+00D7

Multiplication sign

U+2012

Figure dash

U+2013

En dash

U+2014

Em dash

U+2015

Horizontal bar

U+2022

Bullet

U+25FB

White medium square

U+25FC

Black medium square

U+25FD

White medium small square

U+25FE

Black medium small square

Appendix
Appendix: Writing system and language tags
Features are encoded according to both a designated script and language system. The
language system tag specifies a typographic convention associated with a language or
linguistic subgroup. For example, there are different language systems defined for the
Myanmar script; Burmese, Pali, and Sanskrit.
NOTE: The script tag for Myanmar script for use with the Myanmar shaping engine is
mym2 and not mymr. The script tag mymr has limited support and should not be used.
Not all software applications support specific language tags for use when rendering text
runs.

NOTE: It is strongly recommended to include the “dflt” language tag in all
OpenType fonts because it defines the basic script handling for a font. The “dflt”
language system is used as the default if no other language specific features are
defined or if the application does not support that particular language. If the “dflt”
tag is not present for the script being used, the font may not work in some
applications.
The following tables list the registered tag names for scripts and language systems.
Registered tags for the Myanmar script

Registered tags for Myanmar language
systems

Script tag

Script

Language
system tag

Language

“mym2”

Myanmar

“dflt”

*default script handling

ARK

Rakhine-Marma
(Arakanese)

BRM

Burmese

MON

Mon

KRN

Karen

QIN

Chin

SHN

Shan

PLG

Palaung

SAN

Sanskrit

PAL

Pali

Note: both the script and language tags are case sensitive (script tags should be
lowercase, language tags are all caps) and must contain four characters (ie. you must
add a space to the three character language tags).

Creating and Supporting OpenType
Fonts for Sinhala Script
Article • 06/09/2022

This document presents information that will help font developers in creating OpenType
fonts for Sinhala script as covered by the Unicode Standard 6.0. The Sinhala script is used
to write the Sinhala language. It is also used to write Pali and Sanskrit.
NOTE: Starting in Windows 10, Sinhala will be supported by the Universal Shaping
Engine rather than a stand-alone shaping engine. Moving forward, developers should
refer to this new specification.

Introduction
This document targets developers implementing shaping behavior compatible with the
Microsoft OpenType specification for the Sinhala script. It contains information about
terminology, font features and behavior of the Sinhala shaping engine. While it does not
contain instructions for creating Sinhala fonts, it will help font developers understand
how the Sinhala shaping engine processes Sinhala text.

Terms
The following terms are useful for understanding the layout features and script rules
discussed in this document.
Akhand ligature – A required consonant ligature that may appear anywhere in the
syllable and may or may not involve the base glyph. Akhand ligatures have the highest
priority and are formed first; some languages include them in their alphabets
Al-lakuna (halant/virama) – The character used after a consonant to suppress its
inherent vowel
Base glyph – Any glyph that can have a diacritic mark attached to it. Layout operations
are defined in terms of a base glyph, not a base character, as a ligature may act as a
base
Character – Each character represents a Unicode character code point. For example the
Sinhala letter Ayanna (අ) is U+0D85. A character may have multiple forms of glyphs

Cluster – A group of characters that form an integral unit in Indic scripts, oftentimes this
corresponds to a syllable
Consonant – Sinhala consonants have an inherent vowel (the short vowel /a/ called
ayanna). For example, “Ka” and “Ta”, rather than just “K” or “T”
Consonant conjunct (aka ‘conjunct’) – A ligature of two or more consonants
Format controls – special formatting characters used in the shaping process of Sinhala
scripts (U+200c and U+200D). These characters have no visual appearance, except when
an application chooses to display zero width glyphs
Glyph – A glyph represents a form of one or more characters
Halant – See Al-lakuna.
Ligature – A combination of glyphs that join to form a single glyph. For example the
touching-letter sequence of alpapraana kayanna and vayanna (U+0D9A, U+0DCA,
U+200D, U+0DC0)
Matra (dependent vowel) – Used to represent a vowel sound that is not inherent to the
consonant. Dependent vowels are referred to as “matras” in Sanskrit. They are always
depicted in combination with a single consonant, or with a consonant cluster. The
greatest variation among different Indian scripts is found in the rules for attaching
dependent vowels to base characters
OpenType layout engine – The library responsible for executing OpenType layout
features in a font. In the Microsoft text formatting stack, it is named OTLS (OpenType
layout services)
OpenType tag – A 4-byte identifier for script, language system or feature in the font
Rakaaraansaya (rakar) – The below-base form of “Ra” which forms a ligature with most
preceding consonant(s)
Repaya (reph) – The above-base form of the letter “Ra” that is used if “Ra” is the first
consonant in the syllable and is not the base consonant
Shaping engine - Code responsible for shaping input, classified to a particular script
Split matra – A matra that is decomposed into pieces for rendering. Usually the different
pieces appear in different positions relative to the base. For instance, part of the matra
may be placed at the beginning of the cluster and another part at the end of the cluster
Touching letters – A pure consonant written touching a following letter instead of using
al-lakuna. Used in classical and Buddhist texts.

Yansaya – The post-base form of “Ya” which goes with a preceding consonant(s)

Shaping Engine
Analyzing the characters
Processing split matras
Reordering characters
Apply OpenType GSUB features
Apply OpenType GPOS features
The Uniscribe Sinhala shaping engine processes text in stages. The stages are:
1. Analyzing the characters
2. Processing split matras
3. Reordering characters
4. Applying OpenType GSUB features to get the correct glyph shape
5. Applying OpenType GPOS features to position glyphs or marks
The descriptions which follow will help font developers understand the rationale for the
Sinhala feature encoding model, and help application developers better understand how
layout clients can divide responsibilities with operating system functions.

Analyzing the characters
The run of text that the shaping engine receives for the purpose of shaping is a
sequence of Unicode characters. The shaping engine divides the text into syllable
clusters and identifies character properties. Character properties are used in parsing
syllables and identifying their parts as well as determining whether any contextual
reordering is required.
Additionally, the engine verifies that the run consists of valid clusters and inserts a
placeholder glyph (U+25CC) wherever combining marks occur without a valid base.
In the Sinhala engine, OpenType features are applied to the entire run after any
reordering has been completed.
In the diagrams below, the rules for forming clusters are given in terms of the types of
characters in the character stream. The meanings of the symbols are:
C

Consonant (U+0D9A–U+0DB1, U+0DB3–U+0DBB, U+0DBD, U+0DC0–U+0DC6)

IV

Independent vowel (U+0D85–U+0D96)

H

Halant/Al-lakuna (U+0DCA)

VM

Vowel modifier (U+0D82, U+0D83)

DV

Dependent vowel (U+0DCF–U+0DD1, U+0DD4, U+0DD6, U+0DD8, U+0DDF, U+0DF2–
U+0DF3, U+0DD9, U+0DDB, U+0DD2–U+0DD3, U+0DDA, U+0DDC–U+0DDE)

ZWJ

Zero width joiner (U+200D)

{}

Zero to many occurrences. Because this could theoretically go on forever, an arbitrary
limit of eight occurrences has been set.

[]

Optional occurrence

<x|y>

Choice of x or y

There are two types of clusters:
Consonant Cluster
{C + H + ZWJ } + C + [< H | DV >] + [VM]

Used for semivowel and ligature clusters

{C + ZWJ + H} + C + [< H | DV >] + [VM]

Used for clusters of touching letters

Independent Vowel Cluster
IV + [VM]

Processing split matras
The shaping engine inserts the prebase component of the split matras into the glyph
sequence. The following split matras are defined for Sinhala:
Code point

Glyph

Description

U+0DDA

Sinhala vowel sign diga kombuva

U+0DDC

Sinhala vowel sign kombuva haa aela-pilla

U+0DDD

Sinhala vowel sign kombuva haa diga aela-pilla

U+0DDE

Sinhala vowel sign kombuva haa gayanukitta

The shaping engine will insert the glyph for U+0DD9 into the glyph sequence to serve
as the prebase component for subsequent reordering. The second component of the
split matras should be substituted appropriately by the font using the pstf feature, see
Basic shaping forms.

Reordering characters
Once the Sinhala shaping engine has analyzed the run as described above, it creates a
buffer of appropriately reordered elements (glyphs) representing the cluster according
to the following rules:
Prebase vowels and prebase vowel-components of split matras reorder to start of
a cluster
Yansaya fuses with a preceding base glyph
Repaya reorders after the base glyph or after yansaya if also present
The OpenType lookups in a Sinhala font must be written to match glyph sequences after
re-ordering has occurred. OpenType fonts should not have substitutions that attempt to
perform the re-ordering. If a font developer attempted to encode such reordering
information in an OpenType font, they would need to add a huge number of many-tomany glyph mappings to cover the general algorithms that a shaping engine will use.

Apply OpenType GSUB features
Uniscribe calls OTLS to apply the features. All OTL processing is divided into a set of
predefined features (described and illustrated in the Feature section of this document).
Each feature is applied to the entire run and OTLS processes them. Uniscribe makes as
many calls to the OTL Services as there are features. This ensures that the features are
executed in the desired order.
The steps of the shaping process are outlined below. Not all of the features listed must
be used by all languages using the Sinhala script.

Shaping features:
1. Localized forms
a. Apply feature ‘locl’ to preprocess any localized forms for the current language
2. Basic shaping forms
a. Apply feature ‘ccmp’ to preprocess any glyphs that require composition or
decomposition

b. Apply feature ‘akhn’ to get akhand ligature forms
c. Apply feature ‘rphf’ to get repaya glyph forms
d. Apply feature ‘vatu’ to get rakaaraansaya and yansaya glyph forms
e. Apply feature ‘pstf’ to get post-base forms of split-matra glyphs
3. Presentation forms
a. Apply feature ‘pres’ to substitute prebase glyph forms
b. Apply feature ‘abvs’ to substitute above-base glyph forms
c. Apply feature ‘blws’ to substitute below-base glyph forms
d. Apply feature ‘psts’ to substitute postbase glyph forms
Note: since the presentation form features are applied simultaneously over the entire
cluster, several features are operationally equivalent to a single feature. Multiple features
are provided as an aid for font developers to organize the lookups they implement.

Apply OpenType GPOS features
The shaping engine next processes the GPOS (glyph positioning) table, applying
features concerned with positioning. All features are applied simultaneously to the
entire cluster.
The font developer must consider the effects of re-ordering when creating the GPOS
feature and lookup tables (i.e., the glyphs will be in the order they were in after the
GSUB presentation forms features were applied).
1. Kerning
a. Apply feature ‘kern’ to provide pair kerning between glyphs for better
typographic quality. Note this feature may be disabled by some applications
b. Apply feature ‘dist’ to make any required distance adjustments
2. Mark placement
a. Apply feature ‘abvm’ to position diacritic glyphs above the base glyph
b. Apply feature ‘blwm’ to position diacritic glyphs below the base glyph

Features
The features listed below have been defined to create the basic forms for the scripts and
languages that are supported on Sinhala systems. Regardless of the model an
application chooses for supporting layout of complex scripts, Uniscribe requires a fixed
order for executing features within a run of text to consistently obtain the proper basic
form. This is achieved by calling features one-by-one in the standard order listed below.

The order of the lookups within each feature is also very important. For more
information on lookups and defining features in OpenType fonts, see Encoding feature
information in the OpenType font development section.
The standard order for applying Sinhala features encoded in OpenType fonts:
Feature

Feature function

Layout
operation

Required

Localized forms
locl

GSUB

Basic shaping forms
ccmp

Character composition/decomposition substitution

GSUB

akhn

Akhand ligature substitution

GSUB

X

rphf

Repaya substitution

GSUB

X

vatu

Rakaaraansaya and yansaya substitution

GSUB

X

pstf

Post-base form substitution

GSUB

X

Presentation forms
pres

Pre-base substitution

GSUB

abvs

Above-base substitution

GSUB

blws

Below-base substitution

GSUB

psts

Post-base substitution

GSUB

kern

Pair kerning

GPOS

dist

Distance adjustments

GPOS

Kerning:

Mark placement
abvm

Above-base mark positioning

GPOS

blwm

Below-base mark positioning

GPOS

[GSUB = glyph substitution, GPOS = glyph positioning]

Feature examples

The registered features described and illustrated in this document are based on the
Microsoft OpenType font Iskoola Pota (iskpota.ttf). Iskoola Pota contains layout
information and glyphs to support all of the required features for the Sinhala script.
The illustrations in the following examples show the result of that particular feature
being applied. Features must be written to match glyph sequences after re-ordering has
occurred. Note that the input context for a feature may be the result of a previous
feature having already been applied.

Localized forms
Feature Tag: 'locl'
This feature is used in association with OpenType language system tags to trigger
lookups that will select alternate glyphs needed for language-specific typographic
conventions. The ‘locl’ should not be used in association with the default language
system, but only used with other language system tags. See the Appendix of this
document for language system tags associated with the Sinhala script. The Iskoola Pota
font does not use this feature.

Basic shaping forms
Feature Tag: 'ccmp'
The composition/decomposition feature may be used to trigger lookups to form
particular composed or decomposed forms. It should not be used to create
decompositions of the split matras as this is done by the shaping engine before any
features are applied. The Iskoola Pota font does not use this feature.

Feature Tag: 'akhn'
The akhand ligature feature is used to create all required ligatures including touching
consonants used in Pali and Sanskrit.
Ligatures that are used in Sinhala text are encoded using the sequence Halant ZWJ
(U+0DCA U+200D) between the two components that are to be joined.

Lookup example:
Sequence

Result
ක්‍ව

U+0D9A U+0DCA U+200D U+0DC0

Image

Text

Touching consonants that are used in Pali and Sanskrit are encoded with the sequence
ZWJ Halant (U+200D U+0DCA) between the two components that are to be joined.

Lookup example:
Sequence

Result
ක‍්ක

U+0D9A U+200D U+0DCA U+0D9A

Image

Feature Tag: 'rphf'
This feature is used to substitute the repaya form.

Text

Example:
Sequence

Result
ර්‍ක

U+0DBB U+0DCA U+200D U+0D9A

Image

Text

Feature Tag: 'vatu'
This feature is used to substitute the rakaaraansaya and yansaya forms.

Rakaaraansaya example:
Sequence

Result
ක්‍ර

U+0D9A U+0DCA U+200D U+0DBB

Image

Text

Yansaya example:
Sequence

Result
ක්‍ය

U+0D9A U+0DCA U+200D U+0DBA

Image

Text

Feature Tag: 'pstf'
This feature is used to convert a split matra into the corresponding second half of the
split matra.

Lookup example:
Sequence

Result
කො

U+0D9A U+0DDC

Image

Text

Presentation forms
Feature Tag: 'pres'
This feature may be used to substitute presentation forms involving pre-base elements.
The Iskoola Pota font does not use this feature.

Feature Tag: 'abvs'
This feature is used to substitute ligatures involving a base glyph and an above mark.

Lookup example:
Sequence

Result
කි

U+0D9A U+0DD2

Image

Text

This should also include marks that are the outcome of previous lookups and reordering
such as rakaaraansaya and yansaya.

Rakaaraansaya + yansaya example:
Sequence

Result
ර්‍ය්‍ය

U+0DBB (rakaaraansaya) U+0DCA U+200D U+0DBA

Image

Text

U+0DCA (yansaya) U+200D U+0DBA

Feature Tag: 'blws'
This feature is used to substitute ligatures involving a base glyph and a below mark.

Lookup example:
Sequence

Result
ඛු

U+0D9B U+0DD4

Image

Text

Feature Tag: 'psts'
This feature is used to substitute ligatures involving a base glyph and a post-base
element.

Lookup example:
Sequence

Result
රැ

U+0DBB U+0DD0

Image

Text

Kerning
Feature Tag: 'kern'
This feature may be used to adjust the positioning of glyph pairs. The Iskoola Pota font
does not use this feature.

Feature Tag: 'dist'
This feature may be used to adjust distances. The Iskoola Pota font does not use this
feature.

Mark placement

Feature Tag: 'abvm'
This feature is used to position marks above base glyphs. The Iskoola Pota font uses this
feature to position marks relative to the dotted circle placeholder glyph.

Feature Tag: 'blwm'
This feature is used to position marks below base glyphs. The Iskoola Pota font uses this
feature to position marks relative to the dotted circle placeholder glyph.

Handling invalid combining marks
Combining marks and signs that do not occur in conjunction with a valid base are
considered invalid. Shaping engine implementations may adopt different strategies for
how invalid marks are handled. For example, a shaping engine implementation might
treat an invalid mark as a separate cluster and display the stand-alone mark positioned
on some default base glyph, such as a dotted circle (U+25CC). (See Fallback Rendering
in section 5.13 of the Unicode Standard 4.0.) Shaping engine implementations may vary
somewhat with regard to what sequences are or are not considered valid. For instance,
some implementations may impose a limit of at most one above-base vowel mark while
others may not.
To allow for shaping engine implementations that expect to position an invalid mark on
a dotted circle, it is recommended that a Sinhala OT font contain a glyph for the dotted
circle character, U+25CC. If this character is not supported in the font, such
implementations will display invalid signs on the missing glyph shape (white box).

Recommended Glyphs
Unicode code points that are strongly recommended for inclusion in any Sinhala font
are:

Code
point

Description

U+200B

Zero Width Space

U+200C

Zero Width Non-Joiner

U+200D

Zero Width Joiner

U+25CC

Dotted Circle

Appendix
Appendix: Writing system and language tags
Features are encoded according to both a designated script and language system. The
language system tag specifies a typographic convention associated with a language or
linguistic subgroup. For example, there are different language systems defined for the
Sinhala script; Sinhala, Pali, and Sanskrit.
Currently, the Uniscribe engine only supports the “default” language for each script.
However, font developers may want to build language specific features which are
supported in other applications and will be supported in future Microsoft OpenType
implementations.
NOTE: It is strongly recommended to include the “dflt” language tag in all
OpenType fonts because it defines the basic script handling for a font. The “dflt”
language system is used as the default if no other language specific features are
defined or if the application does not support that particular language. If the “dflt”
tag is not present for the script being used, the font may not work in some
applications.
The following tables list the registered tag names for scripts and language systems.
Registered tags for the Sinhala script

Registered tags for Sinhala language
systems

Script tag

Script

Language

Language

system tag
'sinh'

Sinhala

'dflt'

*default script handling

'SNH '

Sinhala

'PAL '

Pali

“SAN”

Sanskrit

Note: both the script and language tags are case sensitive (script tags should be
lowercase, language tags are all caps) and must contain four characters (ie. you must
add a space to the three character language tags).

Developing OpenType Fonts for Syriac
Script
Article • 06/09/2022

Introduction
This document presents information that will help font developers create or support
OpenType fonts for all Syriac script languages covered by the Unicode Standard. The three
styles of Syriac in use today — Estrangelo, Serto and East Syriac — all use the same Syriac
encoding.
Font developers will learn how to encode script features in their fonts, choose character
sets, organize font information, and use existing tools to produce Syriac script fonts.
Registered features of Syriac scripts are defined and illustrated, encodings are listed, and
templates are included for compiling layout tables for OpenType fonts.
This document also presents information about the Syriac OpenType shaping engine of
Uniscribe, an operating system component responsible for text layout.
In addition to being a primer and specification for the creation and support of Syriac
script fonts, this document is intended to more broadly illustrate the OpenType Layout
architecture, feature schemes, and operating system support for shaping and
positioning text.

Glossary
The following terms are useful for understanding the layout features and script rules
discussed in this document.
Base Glyph - Any glyph that can have a diacritic mark above or below it. Layout
operations are defined in terms of a base glyph, not a base character, as a ligature may
act as the base.
Character - Each character represents a Unicode character code point. For example, the
'alaph' character is U+0710. A character may have multiple forms of glyphs.
Diacritic Mark - A character that is positioned above or below a character to provide
pronunciation guidance.

Glyph - A glyph represents the displayed form of one or more characters. For example,
the final, initial and medial 'beth' glyphs are all forms of the 'beth' character (U+0712).
Kashida - Also known as the 'tatweel' character (U+0640). This character is used for
elongation between connecting characters, and for justification.
Ligature - A combination of glyphs that join to form a single glyph. For example, the
'rish seyame' (U072a + U0308) combinations of glyphs are mandatory ligatures for
Syriac. Other ligatures are optional.
Nominal form - The glyph that is represented by the Unicode character value.

Shaping Engine
Analyze syllables and reorder characters
Shape glyphs with OTLS
Position glyphs with OTLS
Invalid combining marks
The Uniscribe Syriac shaping engine processes text in stages. The stages are:
1. Analyze characters for contextual shape
2. Shape (substitute) glyphs with OTLS (OpenType Library Services)
3. Position glyphs with OTLS
The descriptions which follow will help font developers understand the rationale for the
Syriacfeature encoding model, and help application developers better understand how
layout clients can divide responsibilities with operating system functions.

Analyze Characters
The unit that the shaping engine receives for the purpose of shaping is a string of
Unicode characters, in a sequence. The contextual analysis engine determines the
correct contextual form the character should take based on the character before and
after it. The contextual shape maps to an OTL feature for that form (isol, init, medi,
med2, fina, fin2, fin3).
Additionally, during the analysis process, the engine also verifies valid diacritic
combinations. For additional information, see Invalid Combining Marks.

Shape Glyphs with OTLS

The first step Uniscribe takes in shaping the character string is to map all characters to
their nominal form glyphs (e.g. the glyph for U+0627). Then, Uniscribe applies
contextual shape features to the glyph string.
Next, Uniscribe calls OTLS to apply the features. All OTL processing is divided into a set
of predefined features (described and illustrated in the Features section). Each feature is
applied, one by one, to the appropriate glyphs in the syllable and OTLS processes them.
Uniscribe makes as many calls to the OTL Services as there are features. This ensures
that the features are executed in the desired order.
The steps of the shaping process are outlined below.

Shaping features:
1. Language forms
a. Apply feature 'ccmp' to preprocess any glyphs that require composition or
decomposition.
b. Apply feature 'isol' to get the isolated form of characters.
c. Apply feature 'fina' to get final form glyphs.
d. Apply feature 'fin2' to replace the 'Alaph' glyph at the end of Syriac words with
its appropriate form, when the preceding base character cannot be joined to,
and that preceding base character is not a 'Dalath', 'Rish', or dotless 'DalathRish'.
e. Apply feature 'fin3' to replace the 'Alaph' glyph at the end of Syriac words when
the preceding base character is a 'Dalath', 'Rish', or dotless 'Dalath-Rish'.
f. Apply feature 'medi' to get medial form glyphs.
g. Apply feature 'med2' to replace the 'Alaph' glyph in the middle of Syriac words
when the preceding base character can be joined to it.
h. Apply feature 'init' to get initial form glyphs.
i. Apply feature 'rlig' to compose any mandatory ligatures, like 'resh seyame'.
j. Apply feature 'calt' to apply any desired alternative forms of connections. This
can provide type designers with the capability to contextually exchange a glyph
to give a better calligraphic presentation.
2. Typographical forms
a. Apply feature 'liga' to compose any optional ligatures, like 'lam alaph'.
b. Apply feature 'dlig' to compose any discretionary ligatures.

Position Glyphs with OTLS
Uniscribe next applies features concerned with positioning, calling functions of OTLS to
position glyphs.

Positioning features:
1. Kerning
a. Apply feature 'kern' to provide pair kerning between base glyphs requiring
adjustment for better typographical quality.
2. Mark to base
a. Apply feature 'mark' to position diacritic glyphs to the base glyph.
3. Mark to mark
a. Apply feature 'mkmk' to position diacritic glyphs to other diacritic glyphs.

Invalid Combining Marks
Combining marks and signs that appear in text not in conjunction with a valid
consonant base are considered invalid. Uniscribe displays these marks using the fallback
rendering mechanism defined in the Unicode Standard (section 5.12, 'Rendering NonSpacing Marks' of the Unicode Standard 3.1), i.e. positioned on a dotted circle.
Please note that to render a sign standalone (in apparent isolation from any base) one
should apply it on a space (see section 2.5 'Combining Marks' of Unicode Standard 3.1).
Uniscribe requires a ZWJ to be placed between the space and a mark for them to
combine into a standalone sign.
For the fallback mechanism to work properly, a Syriac OTL font should contain a glyph
for the dotted circle (U+25CC). In case this glyph is missing form the font, the invalid
signs will be displayed on the missing glyph shape (white box).
In addition to the 'dotted circle' other Unicode code points that are recommended for
inclusion in any Syriac font are; ZWJ (zero width joiner U+200C), ZWNJ (zero width nonjoiner; U+200D), LTR (left to right mark; U+200E), and RTL (right to left mark; U+200F).
The ZWNJ can be used between two letters to prevent them from forming a cursive
connection.

If an invalid combination is found, like two 'pthahas' on the same base character, the
diacritic that causes the invalid state is placed on a dotted circle to indicate to the user
the invalid combination. The shaping engine for non-OpenType fonts will cause invalid
mark combinations to overstrike. This is the problem that inserting the dotted circle for
the invalid base solves. It should also be noted that the dotted circle is not inserted into

the application's backing store. This is a run-time insertion into the glyph array that is
returned from the ScriptShape function.
The invalid diacritic logic for Syriac is based on the classes listed below. There is a check
to make sure more than one mark of a class is not placed on the same base.
Class

Description

Code points

DIAC1

Syriac above Greek

U+0730, U+0733, U+0736, U+073A, U+073D

DIAC2

Syriac below Greek

U+0731, U+0734 U+0737, U+073B, U+073E

DIAC3

Syriac other

U+0740, U+0749, U+074A

DIAC4

Syriac dotted class above

U+0732, U+0735, U+073F

DIAC5

Syriac dotted class below

U+0738, U+0739, U+073C

DIAC6

Syriac qushshaya

U+0741, U+030A

DIAC7

Syriac rukkakha

U+0742, U+0325

DIAC8

Syriac line type above

U+0747, U+0303, U+0304

DIAC9

Syriac line type below

U+0748, U+032D, U+032E, U+0330, U+0331

DIAC10

Syriac seyame above

U+0308

DIAC11

Syriac seyame below

U+0304

DIAC12

Syriac dot above

U+0307

DIAC13

Syriac dot below

U+0323

DIAC14

Syriac two dots above

U+0743

DIAC15

Syriac two dots below

U+0744

DIAC16

Syriac three dots above

U+0745

DIAC17

Syriac three dots below

U+0746

Features
The features listed below have been defined to create the basic forms for the languages
that are supported on Syriac systems. Regardless of the model an application chooses
for supporting layout of complex scripts, Uniscribe requires a fixed order for executing
features within a run of text to consistently obtain the proper basic form. This is
achieved by calling features one-by-one in the standard order listed below.

The order of the lookups within each feature is also very important. For more
information on lookups and defining features in OpenType fonts, see the Encoding
section of the OpenType Font Development document.
The standard order for applying Syriac features encoded in OpenType fonts:
Feature

Feature function

Layout

Required

operation
Language based forms:
stch

Stretching glyph decomposition

GSUB

ccmp

Character composition/decomposition substitution

GSUB

isol

Isolated character form substitution

GSUB

fina

Final character form substitution

GSUB

X

fin2

Final character form # 2 substitution

GSUB

X

fin3

Final character form # 3 substitution

GSUB

X

medi

Medial character form substitution

GSUB

X

med2

Medial character form #2 substitution

GSUB

X

init

Initial character form substitution

GSUB

X

rlig

Required ligature substitution

GSUB

X

calt

Connection form substitution

GSUB

Typographical forms:
liga

Standard ligature substitution

GSUB

dlig

Discretionary ligature substitution

GSUB

Positioning features:
kern

Pair kerning

GPOS

mark

Mark to base positioning

GPOS

mkmk

Mark to mark positioning

GPOS

[GSUB = glyph substitution, GPOS = glyph positioning]

Feature examples

X

Stretching Glyph Decomposition
Feature Tag: "stch"
The ‘stch’ feature is used to render the Syriac Abbreviation Mark (U+070F) which has the
special property of enclosing other Syriac letters and so needs to be able to stretch in
order to dynamically adapt to the width of the enclosed text. There are three phases to
rendering this feature:
Decomposition
The feature defines a decomposition from a single glyph into an odd number of
glyphs which describe the stretching glyph.
Reordering
The shaping engine reorders the glyphs output by the stch feature so that all
glyphs in the decomposition sequence come at the start of the enclosed sequence
except for the final glyph of the decomposition. The final glyph is reordered so
that it comes after the final glyph of the enclosed sequence.
Positioning
The odd numbered glyphs in the decomposition are fixed reference points which
are distributed evenly from the start to the end of the enclosed text. The even
numbered glyphs are repeated as necessary to fill the space between the fixed
glyphs. All decomposition glyphs used for the Syriac Abbreviation Mark must be
defined as mark glyphs.
For example, the sequence U+070F U+072B U+0718 U+0712 (‫ܫܘܒ‬
܏) may be rendered
using the stch feature as follows:

Note that in the above example the tan background has been used to illustrate the
widths used to render each glyph. All glyphs are rendered with full height.
This feature may be used with contextual rules in order to control details of the
stretched form. For example, when the target width is narrow, a narrower substitution
may be used:

Using the stch feature in the context of a single character in Microsoft VOLT
In other cases, the standard substitution may be used:

Using the stch feature in the context of a two characters in Microsoft VOLT

Character composition (and decomposition)
Feature Tag: "ccmp"
The 'ccmp' feature is used to compose a number of glyphs into one glyph, or
decompose one glyph into a number of glyphs. This feature is implemented before any
other features because there may be times when a font vender wants to control certain
shaping of glyphs. An example of using this table is seen below. The 'ccmp' table maps
default alphabetic forms to both a composed form (essentially a ligature, GSUB lookup
type 4), and decomposed forms (GSUB lookup type 2).

Splitting the character into two glyphs, a dot above and a dot below, allows the dots to
correctly float above and below any glyph without having to make many forms of the
U+0732 character.

Isolated form
Feature Tag: "isol"

The 'isol' feature is used to map the Unicode character value to its isolated form. This is
usually the same glyph form. (GSUB lookup type 1).

Estrangelo style font

Final form
Feature Tag: "fina"
The 'fina' feature is used to map the Unicode character value to its final form. (GSUB
lookup type 1).

Final form #2
Feature Tag: "fin2"
The 'fin2' feature is used to replaces the 'Alaph' glyph at the end of Syriac words with its
appropriate form, when the preceding base character cannot be joined to, and that
preceding base character is not a 'Dalath', 'Rish', or dotless 'Dalath-Rish'. The 'fin2' table
maps default alphabetic forms to corresponding final forms (GSUB lookup type 5).
This feature is used only for the Syriac script 'Alaph' character.

Example: When an 'Alaph' is preceded by a He (one of Syriac's right-joining only
characters), the 'Alaph' would be replaced by the 'fin2' non-joining form (instead of the
joining 'fina' form).

Final form #3
Feature Tag: "fin3"
The 'fin3' feature is used to replaces 'Alaph' glyphs at the end of Syriac words when the
preceding base character is a 'Dalath', 'Rish', or dotless 'Dalath-Rish'. The 'fin3' table
maps default alphabetic forms to corresponding final forms (GSUB lookup type 5).
This feature is used only for the Syriac script 'Alaph' character.

Example: When an 'Alaph' is preceded by a 'Dalath', the 'Alaph' would be replaced by
the 'fin3' non-joining form (instead of the joining 'fina' form).

Medial form
Feature Tag: "medi"
The 'medi' feature is used to map the Unicode character value to its medial form. (GSUB
lookup type 1). The 'Alaph' glyph should not be included in this lookup. Joining forms of
'Alaph' are created with the med2 lookup.

Estrangelo style font

Medial form #2
Feature Tag: "med2"
The 'med2' feature is used to replace the 'Alaph' glyph in the middle of Syriac words
when the preceding base character can be joined to. The 'med2' table maps default
alphabetic forms to corresponding medial forms (GSUB lookup type 5).
This feature is used only for the Syriac script 'Alaph' character.

Example: When an 'Alaph' is preceded by a 'Waw', the 'Alaph' would be replaced by the
'med2' non-joining form (instead of the joining 'medi' form).

Initial form
Feature Tag: "init"
The 'init' feature is used to map the Unicode character value to its initial form. (GSUB
lookup type 1).

Estrangelo style font

Required ligatures
Feature Tag: "rlig"
The 'rlig' feature is used to map glyph values to their correct ligated form. Font
developers should use this table for all ligatures that they want to map as such all of the
time. Ligatures that should be optional, based on user preferences should not be
included in this table. Optional ligatures are defined in the 'liga' table.

The 'rlig' feature maps sequences of glyphs to corresponding ligatures (GSUB lookup
type 4). Ligatures with more components must be stored ahead of those with fewer
components in order to be found. See Ordering ligatures in the Encoding section of the
OpenType Font Development document. The set of required ligatures will vary by design
and script.

Estrangelo style font

Connection forms
Feature Tag: "calt"
In specified situations, replaces default glyphs with alternate forms that provide better
joining behavior. Used in script typefaces which are designed to have some or all of
their glyphs join. The 'calt' table specifies the context in which each substitution occurs,
and maps one or more default glyphs to replacement glyphs (GSUB lookup type 6).
"Example: If a Gamal is preceded by a Teth, a short expansion glyph is inserted between
the glyphs for a better connection (to prevent the characters from crashing). In the
picture, uni0713.fina is substituted with uni0640.short + uni0713.fina when the context
of the letter before is uni071B.init.

Serto style font

Standard ligatures
Feature Tag: "liga"
The 'liga' feature is used to map glyphs to their optional ligated form. Font developers
should use this table for all ligatures that they want the user to be able to control by
user preference. Uniscribe has a flag that will allow this type of feature to be

deactivated. The 'liga' feature maps sequences of glyphs to corresponding ligatures
(GSUB lookup type 4). Ligatures with more components must be stored ahead of those
with fewer components in order to be found. See Ordering ligatures in the Encoding
section of the OpenType Font Development document. The set of optional ligatures will
vary by typeface design and script.
Note: Ligatures that should be formed all of the time should not be included in this
feature type. Required ligatures are defined in the 'rlig' table.

Estrangelo style font. Note that if Alaph has been replaced with a joining form under
med2, then the joining form will need to be specified as the source of the liga/rlig
replacement for Lamadh + Alaph.

Discretionary ligatures
Feature Tag: "dlig"
The 'dlig' feature is also used to map glyphs to their optional ligated form. Font
developers should use this table for all ligatures that they want the user to be able to
control by user preference. Uniscribe has a flag that will allow this type of feature to be
deactivated. The 'dlig' feature maps sequences of glyphs to corresponding ligatures
(GSUB lookup type 4). Ligatures with more components must be stored ahead of those
with fewer components in order to be found. See Ordering ligatures in the Encoding
section of the OpenType Font Development document. The set of optional ligatures will
vary by typeface design and script.

Serto style font

Kerning

Feature Tag: "kern"
The 'kern' feature is used to adjust amount of space between glyphs, generally to
provide optically consistent spacing between glyphs. Although a well-designed typeface
has consistent inter-glyph spacing overall, some glyph combinations require adjustment
for improved legibility. Besides standard adjustment in either horizontal or vertical
direction, this feature can supply size-dependent kerning data via device tables, "crossstream" kerning in the Y text direction, and adjustment of glyph placement independent
of the advance adjustment. Note that this feature would not be used in monospaced
fonts.
The font stores a set of adjustments for pairs of glyphs (GPOS lookup type 2 or 8). These
may be stored as one or more tables matching left and right classes, and/or as
individual pairs. If both forms are used, the classes should be listed last, so as to provide
a means to replace any non-ideal values that may result from the class tables. Additional
adjustments may be provided for larger sets of glyphs (e.g., triplets, quadruplets, etc.) to
overwrite the results of pair kerns in particular combinations. These should precede the
pairs.

Creating kern table using Microsoft VOLT

Mark to base positioning

Feature Tag: "mark"
The 'mark' feature positions mark glyphs in relation to a base glyph, or a ligature glyph.
This feature may be implemented as a MarkToBase Attachment lookup (GPOS
LookupType = 4) or a MarkToLigature Attachment lookup (GPOS LookupType = 5).

Positioning mark to base using Microsoft VOLT

Mark to mark positioning
Feature Tag: "mkmk"
The 'mkmk' feature positions mark glyphs in relation to another mark glyph. This feature
may be implemented as a MarkToMark Attachment lookup (GPOS LookupType = 6).

Positioning mark to mark using Microsoft VOLT

Appendix
Appendix A: Writing System Tags
Features are encoded according to both a designated script and language system. The
language system tag specifies a typographic convention associated with a language or
linguistic subgroup.
Currently, the Uniscribe engine only supports the "default" language for each script.
However, font developers may want to build language specific features which are
supported in other applications and will be supported in future Microsoft OpenType
implementations.
*** NOTE:** It is strongly recommended to include the "dflt" language tag in all
OpenType fonts because it defines the basic script handling for a font. The "dflt"
language system is used as the default if no other language specific features are defined
or if the application does not support that particular language. If the "dflt" tag is not
present for the script being used, the font may not work in some applications.

The following tables list the registered tag names for scripts and language systems.
Registered tags for the Syriac script

Registered tags for Syriac language systems

Script tag

Language

Script

Language

system tag
"syrc"

Syriac

"dflt"

*default script handling

"SYR "

Syriac

Note: both the script and language tags are case sensitive (script tags should be
lowercase, language tags are all caps) and must contain four characters (ie. you must
add a space to the three character language tags).

Developing OpenType Fonts for Thaana
Script
Article • 06/16/2022

This document presents information that will help font developers create or support
OpenType fonts for the Thaana script covered by the Unicode Standard. Thaana script is
used to write the Dhivehi language and consists of base glyphs, vowels and a set of dotted
letters used to transcribe Arabic.

Introduction
Font developers will learn how to encode complex script features in their fonts, choose
character sets, organize font information, and use existing tools to produce Thaana
fonts. Registered features of the Thaana script are defined and illustrated, encodings are
listed, and templates are included for compiling Thaana layout tables for OpenType
fonts.
This document also presents information about the Thaana OpenType shaping engine of
Uniscribe, the Windows component responsible for text layout.
In addition to being a primer and specification for the creation and support of Thaana
fonts, this document is intended to more broadly illustrate the OpenType Layout
architecture, feature schemes, and operating system support for shaping and
positioning text.

Glossary
The following terms are useful for understanding the layout features and script rules
discussed in this document.
Base Glyph - Any glyph that can have a diacritic mark above or below it. Layout
operations are defined in terms of a base glyph, not a base character, as a ligature may
act as the base.
Character - Each character represents a Unicode character code point. For example, the
'haa' character is U+0780. A character may have multiple forms of glyphs.
Diacritic Mark (e.g. Fili) - A character that is positioned above or below a character to
provide pronunciation guidance.

Glyph - A glyph represents a form of one or more characters.
Ligature - A combination of glyphs that join to form a single glyph. It is up to the font
designer to create the ligatures appropriate for any particular font.

Shaping Engine
Analyze Characters
Shape Glyphs with OTLS
Position Glyphs with OTLS
Invalid Combining Marks
The Uniscribe Thaana shaping engine processes text in stages. The stages are:
1. Analyze characters for valid diacritic (fili) combinations
2. Shape (substitute) glyphs with OTLS (OpenType Library Services)
3. Position glyphs with OTLS
The following descriptions will help font developers understand the rationale for the
Thaana feature encoding model, and help application developers better understand
how layout clients can divide responsibilities with operating system functions.

Analyze Characters
The unit that the shaping engine receives for the purpose of shaping is a string of
Unicode characters, in a sequence. The contextual analysis engine verifies valid diacritic
combinations. For additional information, see Invalid combining marks.

Shape Glyphs with OTLS
The first step Uniscribe takes in shaping the character string is to map all characters to
their nominal form glyphs.
Next, Uniscribe calls OTLS to apply the features. All OTL processing is divided into a set
of predefined features (described and illustrated in the Features section). Each feature is
applied, one by one, to the appropriate glyphs in the syllable and OTLS processes them.
Uniscribe makes as many calls to the OTL Services as there are features. This ensures
that the features are executed in the desired order.

Position Glyphs with OTLS

Uniscribe next applies features concerned with positioning, calling functions of OTLS to
position glyphs.

Positioning features:
1. Kerning
a. Apply feature 'kern' to provide pair kerning between base glyphs requiring
adjustment for better typographical quality
2. Mark to base
a. Apply feature 'mark' to position diacritic glyphs to the base glyph

Invalid Combining Marks
Combining marks and signs that appear in text not in conjunction with a valid
consonant base are considered invalid. Uniscribe displays these marks using the fallback
rendering mechanism defined in the Unicode Standard (section 5.12, 'Rendering NonSpacing Marks' of the Unicode Standard 3.1), i.e. positioned on a dotted circle.
For the fallback mechanism to work properly, a Thaana OTL font should contain a glyph
for the dotted circle (U+25CC). In case this glyph is missing from the font, the invalid
signs will be displayed on the missing glyph shape (white box).
In addition to the 'dotted circle', other Unicode code points recommended for inclusion
in any Thaana font are LTR (left to right mark; U+200E) and RTL (right to left mark;
U+200F).

If an invalid combination is found, like two 'aba filis' on the same base character, the
diacritic that causes the invalid state is placed on a dotted circle to indicate to the user
the invalid combination. The shaping engine for non-OpenType fonts will cause invalid
mark combinations to overstrike. This is the problem that inserting the dotted circle for
the invalid base solves. It should also be noted that the dotted circle is not inserted into
the application's backing store. This is a run-time insertion into the glyph array that is
returned from the ScriptShape function.
The invalid diacritic logic for Thaana is based on the rule that only one fili can be placed
on a base glyph.

Features
The features listed below have been defined to create the basic forms for the languages
that are supported on Thaana systems. Regardless of the model an application chooses
for supporting layout of complex scripts, Uniscribe requires a fixed order for executing
features within a run of text to consistently obtain the proper basic form. This is
achieved by calling features one-by-one in the standard order listed below.
The order of the lookups within each feature is also very important. For more
information on lookups and defining features in OpenType fonts, see the Encoding
section of the OpenType Font Development document.
The standard order for applying Thaana features encoded in OpenType fonts:
Feature

Feature function

Layout
operation

Required

Positioning features:
kern

Pair kerning

GPOS

mark

Mark to base positioning

GPOS

X

[GSUB = glyph substitution, GPOS = glyph positioning]

Feature examples
Kerning
Feature Tag: "kern"
The 'kern' feature is used to adjust amount of space between glyphs, generally to
provide optically consistent spacing between glyphs. Although a well-designed typeface
has consistent inter-glyph spacing overall, some glyph combinations require adjustment
for improved legibility. Besides standard adjustment in either horizontal or vertical
direction, this feature can supply size-dependent kerning data via device tables, "crossstream" kerning in the Y text direction, and adjustment of glyph placement independent
of the advance adjustment. Note that this feature would not be used in monospaced
fonts.
The font stores a set of adjustments for pairs of glyphs (GPOS lookup type 2 or 8). These
may be stored as one or more tables matching left and right classes, and/or as
individual pairs. If both forms are used, the classes should be listed last, so as to provide

a means to replace any non-ideal values that may result from the class tables. Additional
adjustments may be provided for larger sets of glyphs (e.g., triplets, quadruplets, etc.) to
overwrite the results of pair kerns in particular combinations. These should precede the
pairs.

Creating OTL kern feature with Microsoft VOLT

Mark to base positioning
Feature Tag: "mark"
The 'mark' feature positions mark glyphs in relation to a base glyph, or a ligature glyph.
This feature may be implemented as a MarkToBase Attachment lookup (GPOS
LookupType = 4) or a MarkToLigature Attachment lookup (GPOS LookupType = 5).

Positioning mark to base using Microsoft VOLT

Appendices
Appendix A: Writing System Tags
Appendix B: MVBoli.TTF (sample font)

Appendix A: Writing System Tags
Features are encoded according to both a designated script and language system. The
language system tag specifies a typographic convention associated with a language or
linguistic subgroup.
Currently, the Uniscribe engine only supports the "default" language for each script.
However, font developers may want to build language specific features which are
supported in other applications and will be supported in future Microsoft OpenType
implementations.
NOTE: It is strongly recommended to include the "dflt" language tag in all
OpenType fonts because it defines the basic script handling for a font. The "dflt"
language system is used as the default if no other language specific features are
defined or if the application does not support that particular language. If the "dflt"
tag is not present for the script being used, the font may not work in some
applications.
The following tables list the registered tag names for scripts and language systems.

Registered tags for the Thaana script

Registered tags for Thaana language
systems

Script tag

Script

Language
system tag

Language

"thaa"

Thaana

"dflt"

*default script handling

"DIV "

Dhivehi

Note: both the script and language tags are case sensitive (script tags should be
lowercase, language tags are all caps) and must contain four characters (ie. you must
add a space to the three character language tags).

Appendix B: MVBoli.TTF (sample font)
The MVBoli font will be distributed with Microsoft Visual OpenType Layout Tool (VOLT)
and is provided under the terms of the VOLT supplemental files end user license
agreement. It is provided for illustration only, and may not be altered or redistributed.
MVBoli contains layout information and glyphs to support all of the required features for
the languages supported. Each font should be designed as the font creator desires.
Some shaped glyph forms (such as ligatures) have no Unicode encoding. These glyphs
have id's in the font, and applications can access these glyphs by "running" the layout
features which depend on these glyphs. An application can also identify non-Unicode
glyphs contained in the font by traversing the OpenType layout tables, or using the
layout services for purely informational purposes.

Developing OpenType Fonts for Thai
Script
Article • 06/16/2022

This document presents information that will help font developers create or support
OpenType fonts for all Thai script languages covered by the Unicode Standard. Thai script
is used to write Thai, as well as other Southeast Asian languages such as Pali and Sanskrit.

Introduction
Font developers will learn how to encode complex script features in their fonts, choose
character sets, organize font information, and use existing tools to produce Thai fonts.
Registered features of the Thai script are defined and illustrated, encodings are listed,
and templates are included for compiling Thai layout tables for OpenType fonts.
This document also presents information about the Thai OpenType shaping engine of
Uniscribe, the Windows component responsible for text layout.
In addition to being a primer and specification for the creation and support of Thai
fonts, this document is intended to more broadly illustrate the OpenType Layout
architecture, feature schemes, and operating system support for shaping and
positioning text.

Glossary
The following terms are useful for understanding the layout features and script rules
discussed in this document.
Base Glyph - Any glyph that can have a diacritic mark above or below it. Layout
operations are defined in terms of a base glyph, not a base character, as a ligature may
act as the base.
Character - Each character represents a Unicode character code point. For example, the
'ko kai' character is U+0E01.
Combining Mark - A vowel sign or tone mark, positioned above or below a character to
provide pronunciation guidance.
Cluster - The effective "unit" of Thai writing systems, consisting of a consonant, vowel
signs, combining tone marks, and independent vowel letters.

Glyph - A glyph represents a form of one or more characters.

Shaping Engine
Analyze Characters
Shape Glyphs with OTLS
Position Glyphs with OTLS
Invalid Combining Marks
The Uniscribe Thai shaping engine processes text in stages. The stages are:
1. Analyze characters for valid diacritic combinations
2. Shape (substitute) glyphs with OTLS (OpenType Library Services)
3. Position glyphs with OTLS
The descriptions which follow will help font developers understand the rationale for the
Thai feature encoding model, and help application developers better understand how
layout clients can divide responsibilities with operating system functions.

Analyze Characters
The unit that the shaping engine receives for the purpose of shaping is a string of
Unicode characters, in a sequence. The contextual analysis engine verifies valid diacritic
combinations. For additional information, see Invalid Combining Marks.

Shape Glyphs with OTLS
The first step Uniscribe takes in shaping the character string is to map all characters to
their nominal form glyphs.
Next, Uniscribe calls OTLS to apply the features. All OTL processing is divided into a set
of predefined features (described and illustrated in the Features section). Each feature is
applied, one by one, to the appropriate glyphs in the syllable and OTLS processes them.
Uniscribe makes as many calls to the OTL Services as there are features. This ensures
that the features are executed in the desired order.
The steps of the shaping process are outlined below. Not all of the features listed apply
to all Thai script languages.

Shaping features:

1. Language forms
a. Apply feature 'ccmp' to preprocess any glyphs that require composition or
decomposition.

Position Glyphs with OTLS
Uniscribe next applies features concerned with positioning, calling functions of OTLS to
position glyphs.

Positioning features:
1. Kerning
a. Apply feature 'kern' to provide pair kerning between base glyphs requiring
adjustment for better typographical quality.
2. Mark to base
a. Apply feature 'mark' to position diacritic glyphs to the base glyph.
3. Mark to mark
a. Apply feature 'mkmk' to position diacritic glyphs to other diacritic glyphs.

Invalid Combining Marks
Combining marks and signs that appear in text not in conjunction with a valid
consonant base are considered invalid. Uniscribe displays these marks using the fallback
rendering mechanism defined in the Unicode Standard (section 5.12, 'Rendering NonSpacing Marks' of the Unicode Standard 3.1), i.e. positioned on a dotted circle.
Please note that to render a sign standalone (in apparent isolation from any base) one
should apply it on a space (see section 2.5 'Combining Marks' of Unicode Standard 3.1).
Uniscribe requires a ZWJ to be placed between the space and a mark for them to
combine into a standalone sign.
For the fallback mechanism to work properly, a Thai OTL font should contain a glyph for
the dotted circle (U+25CC). In case this glyph is missing from the font, the invalid signs
will be displayed on the missing glyph shape (white box).

In addition to the 'dotted circle' other Unicode code points that are recommended for
inclusion in any Thai font isthe ZWSP (zero width space; U+200B). Thai words are not
separated by spaces, therefore the ZWSP can be used for word boundaries since its
width will 'grow' when justifying text.
If an invalid combination is found, the diacritic that causes the invalid state is placed on
a dotted circle to indicate to the user the invalid combination. The shaping engine for
non-OpenType fonts will cause invalid mark combinations to overstrike. This is the
problem that inserting the dotted circle for the invalid base solves. It should also be
noted that the dotted circle is not inserted into the application's backing store. This is a
run-time insertion into the glyph array that is returned from the ScriptShape function.
The invalid diacritic logic for Thai is based on the classes listed below. There is a check to
make sure more than one mark of a class is not placed on the same base.
Class

Description

Code points

ABOVE1

Above mark closest to base

U+0E31, U+0E34, U+0E35,
U+0E36, U+0E37

ABOVE2

Second level above mark

U+0E47, U+0E4D

ABOVE 3

Third level above mark

U+0E48, U+0E49, U+0E4A,
U+0E4B

ABOVE 4

Fourth level above mark

U+0E4C, U+0E4E

BELOW1

Below mark closest to base

U+0E38, U+0E39

BELOW2

Second level below mark

U+0E3A

AM

The AM character needs to be broken into two
glyphs and some reordering might be required

U+0E33

so that the ring is the base glyph

Features
The features listed below have been defined to create the basic forms for the languages
that are supported on Thai systems. Regardless of the model an application chooses for
supporting layout of complex scripts, Uniscribe requires a fixed order for executing
features within a run of text to consistently obtain the proper basic form. This is
achieved by calling features one-by-one in the standard order listed below.
The order of the lookups within each feature is also very important. For more
information on lookups and defining features in OpenType fonts, see the Encoding

section of the OpenType Font Development document.
The standard order for applying Thai features encoded in OpenType fonts:
Not all of the features listed below apply to all Thai script languages.
Feature

Feature function

Layout
operation

Required

Language based forms:
ccmp

Character composition/decomposition substitution

GSUB

Positioning features:
kern

Pair kerning

GPOS

mark

Mark to base positioning

GPOS

X

mkmk

Mark to mark positioning

GPOS

X

[GSUB = glyph substitution, GPOS = glyph positioning]

Feature examples
Character composition (and decomposition)
Feature Tag: "ccmp"
The 'ccmp' feature is used to compose a number of glyphs into one glyph, or
decompose one glyph into a number of glyphs. This feature is implemented before any
other features because there may be times when a font vender wants to control certain
shaping of glyphs. An example of using this table is seen below. The 'ccmp' table maps
default alphabetic forms to both a composed form (essentially a ligature, GSUB lookup
type 4), and decomposed forms (GSUB lookup type 2).

Example: Use the 'ccmp' feature to decompose the Sara Am for correct mark
positioning.

Example: Use the 'ccmp' feature to decompose (or remove) the below mark on the Yo
Ying character, when the Yo Ying is followed by a below combining vowel mark like the
Sara U or Saru UU. The 'mark' feature could then be used for correct positioning of the
below vowel mark.

Kerning
Feature Tag: "kern"
The 'kern' feature is used to adjust amount of space between glyphs, generally to
provide optically consistent spacing between glyphs. Although a well-designed typeface
has consistent inter-glyph spacing overall, some glyph combinations require adjustment
for improved legibility. Besides standard adjustment in either horizontal or vertical
direction, this feature can supply size-dependent kerning data via device tables, "crossstream" kerning in the Y text direction, and adjustment of glyph placement independent
of the advance adjustment. Note that this feature would not be used in monospaced
fonts.
The font stores a set of adjustments for pairs of glyphs (GPOS lookup type 2 or 8). These
may be stored as one or more tables matching left and right classes, and/or as
individual pairs. If both forms are used, the classes should be listed last, so as to provide
a means to replace any non-ideal values that may result from the class tables. Additional
adjustments may be provided for larger sets of glyphs (e.g., triplets, quadruplets, etc.) to
overwrite the results of pair kerns in particular combinations. These should precede the
pairs.

Mark to base positioning
Feature Tag: "mark"
The 'mark' feature positions mark glyphs in relation to a base glyph, or a ligature glyph.
This feature may be implemented as a MarkToBase Attachment lookup (GPOS
LookupType = 4) or a MarkToLigature Attachment lookup (GPOS LookupType = 5).

Positioning mark to base using Microsoft VOLT

Mark to mark positioning
Feature Tag: "mkmk"
The 'mkmk' feature feature positions mark glyphs in relation to another mark glyph. This
feature may be implemented as a MarkToMark Attachment lookup (GPOS LookupType =
6).

Positioning mark to mark using Microsoft VOLT

Appendix
Appendix A: Writing System Tags
Features are encoded according to both a designated script and language system. The
language system tag specifies a typographic convention associated with a language or
linguistic subgroup. For example, there are different language systems defined for the
Thai script, such as Thai, Kuy, Pali, and Sanskrit.
Currently, the Uniscribe engine only supports the "default" language for each script.
However, font developers may want to build language specific features which are
supported in other applications and will be supported in future Microsoft OpenType
implementations.
NOTE: It is strongly recommended to include the "dflt" language tag in all
OpenType fonts because it defines the basic script handling for a font. The "dflt"
language system is used as the default if no other language specific features are
defined or if the application does not support that particular language. If the "dflt"

tag is not present for the script being used, the font may not work in some
applications.
The following tables list the registered tag names for scripts and language systems.
Registered tags for the Thai script

Registered tags for Thai language systems

Script tag

Script

Language
system tag

Language

"thai"

Thai

"dflt"

*default script handling

"KUY "

Kuy

"PAL "

Pali

"SAN "

Sanskrit

"THA "

Thai

Note: both the script and language tags are case sensitive (script tags should be
lowercase, language tags are all caps) and must contain four characters (ie. you must
add a space to the three character language tags).

Creating and Supporting OpenType
Fonts for Tibetan Script
Article • 06/16/2022

Introduction
This document presents information that will assist font developers in creating fonts for
the Tibetan scripts covered by the Unicode Standard 6.0. The Tibetan script is used for
writing Tibetan in several countries and regions throughout the Himalayas. It is also
used to write Balti, Bumthangkha, Khengkha, and other languages. It has also been used
to transliterate Sanskrit and Chinese. The Tibetan writing system was based on a North
Indian form of the Brahmi script and is said to have been developed to bring Buddhism
from India to Tibet. Two distinctive styles have emerged: a formal style used for books
and inscriptions (called dbu can ‘with a head’) and a cursive or calligraphic style (dbu
med ‘acephalous’) commonly used in hand-written contexts. Tibetan script is a parent
script of Phags-pa, Limbu, and Lepcha, which have separate encodings and shaping
requirements.
NOTE: Starting in Windows 10, Tibetan will be supported by the Universal Shaping
Engine rather than a stand-alone shaping engine. Moving forward, developers should
refer to this new specification.
An example of Tibetan in the dbu-can style:

An example of Tibetan in the dbu-med style:

Font developers will learn how to encode complex script features in their fonts, choose
character sets, organize font information, and use existing tools to produce Tibetan
fonts. Registered features of the Tibetan script are defined and illustrated, encodings are
listed, and templates are included for compiling Tibetan layout tables for OpenType
fonts.

This document also presents information about the Tibetan OpenType shaping engine
of Uniscribe, an operating system component responsible for text layout.
In addition to being a primer and specification for the creation and support of Tibetan
fonts, this document is intended to more broadly illustrate the OpenType Layout
architecture, feature schemes, and operating system support for shaping and
positioning text.

Syllable structure
Tibetan script is written in units which mostly correspond to single syllables. Such units
are delimited by a dot or other punctuation mark. For text-rendering purposes Tibetan
script is divided into stacks, being the horizontal blocks of such syllables consisting of
one or more graphical units. A minimal syllable will consist of a single stack and
containing only a base consonant. This would normally be followed by the punctuation
dot. For example, pa:

A complex syllable may consist of multiple stacks. For example, bsgrubs:
The topmost consonant (1) in a stack is encoded as a full letter (U+0F40–U+0F6A). All
subjoined consonants (4) are encoded as subjoined letters (U+0F90–U+0FBC). In this
way, what is from a collation point of view, the main consonant in a syllable may be
encoded as a subjoined letter when it takes a head consonant. The encoding sequence
stores stacks in logical order from left to right. Within a stack, consonants are encoded
first from top to bottom; then vowels, vowel modifiers and finally marks. The encoding
for the above example is:

[Stack
A]

U+0F56 TIBETAN LETTER BA

[Stack

U+0F66 TIBETAN LETTER SA U+0F92 TIBETAN SUBJOINED LETTER GA U+0FB2 TIBETAN

B]

SUBJOINED LETTER RA U+0F74 TIBETAN VOWEL SIGN U

[Stack

U+0F56 TIBETAN LETTER BA

C]
[Stack

U+0F66 TIBETAN LETTER SA

D]
[End of

U+0F0B TIBETAN MARK INTERSYLLABIC TSHEG

cluster]

Terms
The following terms are useful for understanding the layout features and script rules
discussed in this document.
Head glyph - (the topmost consonant in a stack) the only consonant or consonant
conjunct in a stack that is written in its "full" (nominal) form. Layout operations are
defined in terms of a head glyph, not a head character, since the topmost glyph can be a
ligature.
Consonant - each represents a single consonant sound. The vowel carrier, Tibetan Letter
A (U+0F68), and its subjoined form (U+0FB8) function as consonants. Consonants may
exist in different contextual forms. When occurring as the main consonant they have the
inherent vowel "a".
Conjunct Consonant – a ligature of two or more consonants.
Sub-joined consonant - a consonant in any position in the stack below a head glyph.
Tibetan syllable - the effective orthographic unit of the Tibetan writing system;
composed of consonant letters, vowels, and marks. Transformations discussed in this
document do not cross syllable boundaries.
Vowels - used to represent a vowel sound that is not inherent to the consonant. In the
Tibetan script there are four basic vowel marks as well as several compound vowels for
use in Sanskrit transliteration. Vowel marks are non-spacing and are used above or
below a standalone consonant or a stack of consonants. Some of the compound vowels
have components that go both above and below the stack. Normally a syllable will only
have one vowel sign, but there are special cases when multiple vowel signs are used.
Stack – a single horizontal segment of a Tibetan syllable consisting of one or more subcomponents arranged in a vertical column.

Shaping Engine
Analyzing the text
Reordering characters
Shaping with OTLS
Positioning Glyphs with OTLS
The Tibetan shaping engine of Uniscribe processes text in stages. The stages are:
1. Analyzing the text sequence.
2. Map characters to default glyphs.
3. Reordering characters.
4. Shape glyph sequences with OTLS (OpenType Layout Services; i.e., apply GSUB
features).
5. Positioning glyphs with OTLS (i.e., apply GPOS features).
The descriptions which follow will help font developers understand the rationale for the
Tibetan feature encoding model, and help application developers better understand
how layout clients can divide responsibilities with operating system functions.

Analyzing the text
The unit that the shaping engine receives for the purpose of shaping is a string of
Unicode characters, in a sequence. These are not necessarily positioned within the
sequence as they appear when composed into a syllable for display. The head
consonant of the stack is identified. All other elements are classified by their relative
positions.

Character classifications
Cluster analysis and shaping are based on the following character classifications:
Class

Sub-class

Members

Letters (L)

Head letters (Lh)

0F40–0F6C, 0F88–
0F8C

Subjoined letters (Ls)

0F8D–0F8F, 0F90–
0FBC

Above-base (Va)

0F72, 0F7A–D,
0F80

Below-base (Vb)

0F71, 0F74,

Vowel marks (V)

Comment

Compound vowels

0F73, 0F75–0F79,

Use of these characters is

(Vc)

0F81

discouraged in favor of
their decomposed
equivalents.

Tibetan Digits (D)
Modifiers (M)

0F20–0F33
Letter modifiers (Ml)

0F35, 0F37, 0F39,
0F7E–0F7F, 0F82–
0F84, 0F86–0F87,
0FC6

Digit modifiers (Md)

Syllable delimiter (SD)

0F18–0F19, 0F3E–
0F3F
0F0B–0F0C, 0F34,
0FD2

Brackets

0F3C–0F3D

Generic base
character (GB)

00A0, 00D7, 2012,
2013, 2014, 2022,
25CC, and 25FB–
25FE

ZWJ/ZWNJ (ZJ)

200C, 200D

Tibetan Other (O)

0F00–0F0A, 0F0D–

All other chars from the

0F17, 0F1A–0F1F,
0F36, 0F38, 0F3A–
0F3B, 0FBE–0FC5,

Tibetan block

0FC7–0FD1, 0FD3–
0FDA

Schemas and rules for cluster analysis and syllable analysis use the following additional
symbols:
X*

sequence of zero or more occurrences of X

X+

sequence of one or more occurrences of X

< X |Y
>

disjunction of elements: X or Y

[X]

optional (zero or one) occurrence of X

¬X

not X (any character not in class defined by X)

#

occurrence of a boundary

×

no boundary allowed at indicated position

÷

boundary allowed at indicated position

Cluster analysis
Cluster analysis is performed on a Tibetan text run to identify valid cluster sequences,
which are used to identify valid caret positions. Tibetan clusters are written as vertical
stacks. Caret stops exist between stacks, not within them even though a stack may
consist of many elements.
A single Tibetan stack is defined as follows:
Letters: Lh [Ls*] <[Va*] | [Vb] | [Vc] > [Ml]
Digits: D [Md]
An invalid cluster results when a combining sign occurs without a base. In such cases the
dotted circle glyph (U+25CC) is inserted as a placeholder. A set of generic base
characters is be defined so that combining marks may be shown independently from a
Tibetan letter or digit. Lookups for these bases need to be defined so that they may
combine with either letter marks or digit marks.
Other signs from the Tibetan block do not form clusters, but occur singly as spacing
glyphs. They require no special shaping but may be operated on by the locl and ccmp
features.

Word analysis
In Tibetan text syllables are written in units delimited by marks called tsheg (U+0F0B).
Transliteration of Sanskrit and other foreign words may be written in units longer than
one syllable without tsheg. Words comprising more than one syllable may use the nonbreaking tsheg (U+0F0C). There are two other forms of tseg having special functions
(U+0F34, U+oFD2). Syllable boundaries occur after any tsheg or non-word-forming
character (character ∉ L). A syllable boundary is also a word boundary, except in case
that the tsheg or other character non-breaking:
U+00A0 NO-BREAK SPACE
U+0F0C TIBETAN MARK DELIMITER TSHEG BSTAR
U+202F NARROW NO-BREAK SPACE
U+2060 WORD JOINER
U+FEFF ZERO WIDTH NO-BREAK SPACE

Line Breaks

Line breaks within Tibetan text are determined by tsheg characters. Line breaks should
come after a tsheg and are not permitted after letters or after a non-breaking tsheg.
Thus, line break opportunities essentially correspond to word-stop positions.
Generalizing, Unicode line-breaking properties apply to all characters, and the rules
specified in the Unicode line breaking algorithm [UAX14] apply.

Justification
For Tibetan, justification opportunities occur primarily when there is white space within
in a line of text. Text without spaces may be justified by adding space after tsheg glyphs.
An alternative method for justification that has been used traditionally in Tibetan books
and continues in some modern publications is to pad the end of a line with extra tsheg
characters to take up the white space.

Reordering characters
Uniscribe creates and manages a buffer of appropriately reordered character codes,
delineated as "clusters." Uniscribe reorders character codes within clusters according to
several rules (described below). Then, Uniscribe obtains the corresponding glyph string
by passing the reordered character string to the glyph substitution function of the OTLS.
Because glyph strings are obtained from reordered character strings, the features in a
Tibetan font must be encoded to map reordered characters (and combinations of
characters) to their corresponding glyphs.
There are specific rules when determining stacking order in the Tibetan language. In
languages other than Tibetan, these rules do not always apply, therefore the shaping
engine allows for any consonants to be stacked with any sub-joined consonants.
The correct coding order for a stream of text is as follows:
head position consonant
first sub-joined consonant
....intermediate sub-joined consonants (if any)
last sub-joined consonant
sub-joined vowel (a-chung U+0F71)
standard or compound vowel sign (including virama U+0F84 in the case of Sanskrit
transliteration)
additional vowel signs (if any)
vowel modifier signs (rjes su nga ro U+0F7E, rnam bcad U+0F7F)

Shaping with OTLS
The first step Uniscribe takes in shaping the character string is to map all characters to
their nominal form glyphs. Then, Uniscribe applies contextual shape features to the
glyph string.
Next, Uniscribe calls the OTLS to shape the Tibetan stack. All OTL processing is divided
into a set of predefined features (described and illustrated in the Feature section of this
document). Each feature is applied, one by one, to the appropriate glyphs in the stack
and OTLS processes them. Uniscribe makes as many calls to OTLS as there are features.
This ensures that the features are executed in the desired order.
The steps of the shaping process are outlined below.

Shaping features:
1. Language forms
a. Apply feature ‘locl’ to select language-specific forms.
b. Apply feature 'ccmp' to preprocess any glyphs that require composition or
decomposition.
2. Conjuncts and Typographical forms
a. Apply feature 'abvs' to do any above-base substitutions required.
b. Apply feature 'blws' to do any below-base substitutions required.
c. Apply feature ‘calt’ to invoke any contextual alternates.
d. Apply feature ‘liga’ to invoke any standard ligatures.

Positioning Glyphs with OTLS
Uniscribe next applies features concerned with positioning, calling functions of OTLS to
position glyphs.

Positioning features:
1. Typographical positioning
a. Apply feature ‘kern’ to adjust horizontal spacing of items.
b. Apply feature 'abvm' to position above-base marks.
c. Apply feature 'blwm' to position below-base marks.
d. Apply feature ‘mkmk’ to position following marks relative to preceding marks.

Features

The features listed below have been defined to create the basic forms for the scripts and
languages that are supported on Tibetan systems. Regardless of the model an
application chooses for supporting layout of complex scripts, Uniscribe requires a fixed
order for executing features within a run of text to consistently obtain the proper basic
form. This is achieved by calling features one-by-one in the standard order listed below.
The order of the lookups within each feature is also very important. For more
information on lookups and defining features in OpenType fonts, see Encoding feature
information in the OpenType font development section.
The standard order for applying Tibetan features encoded in OpenType fonts:
Feature

Feature function

Layout

Required

operation
Language based forms:
ccmp

Character composition/decomposition
substitution

GSUB

Conjuncts & typographical forms:
abvs

Above-base substitution

GSUB

X

blws

Below-base substitution

GSUB

X

calt

Contextual alternates

GSUB

liga

Standard ligatures

GSUB

Positioning features:
kern

Kerning

GPOS

abvm

Above-base mark positioning

GPOS

X

blwm

Below-base mark positioning

GPOS

X

mkmk

Mark to mark positioning

GPOS

[GSUB = glyph substitution, GPOS = glyph positioning]

Descriptions and examples of above features
Character composition (and decomposition)
Feature Tag: "ccmp"

The 'ccmp' feature is used to compose multiple glyphs into one glyph, or decompose
one glyph into multiple glyphs. This feature is implemented before any other features
because there may be times when a font vender wants to control certain shaping
actions. An example of using this table is seen below. The 'ccmp' table maps default
alphabetic forms to both a composed form (essentially a ligature, GSUB lookup type 4),
and decomposed forms (GSUB lookup type 2).
The 'ccmp' feature applied:
Composing multiple glyphs into a single glyph:

Decomposing a single glyph into multiple glyphs:

Conjuncts and typographical forms
Feature Tag: "abvs", "blws";
All previous features have dealt with language features only, dedicated to forming glyph
shapes dictated by the languages. The remaining shaping features cover optional
features.
These optional features range from those that will exist in every font to rare
typographical ornaments. It is important to stress that all features operate only within
one orthographic syllable.
Since the language features do not limit typographical processing, Uniscribe passes the
entire syllable to OTLS. Uniscribe does not strictly specify the format of lookup tables to
use or their inputs, allowing for context-dependent processing of any of the conjuncts
and forms below.
OTLS processes the syllable "left to right", executing lookups in the order that they are
specified in the font. First, above-base substitutions will be handled, then below-base
substitutions.

Therefore a font developer should first take care of all ligatures to the left of the head
glyph and then working to the right, substitute above-base, then below-base elements.
The lookups in the font should be ordered in the same way.
With every new element and feature, the following operations should be considered, as
appropriate, in this order:
Ligatures with the head glyph
Ligatures with preceding subjoined elements, and
Contextual forms of the element
At every feature step, one should take into account all results that may be produced by
previous steps.

Above-base substitutions
Feature Tag: "abvs"
Above-base substitutions are
This feature substitutes one or more mark glyphs in the context of certain head glyphs.
(GSUB lookup type 4)

The 'abvs' feature applied:

For example, TIBETAN LETTER TSA (U+0F59) belongs to a class of letters that have a flag
which extends above the top line <FlagGlyphs>. Without adjustment, the VOWEL SIGN I
(U+0F72) would overlap with this flag. Therefore the vowel sign glyph is substituted for
a narrower version by the ShiftTopSignsForFlagGlyphs1 lookup that is triggered by the
'abvs' feature.

Below-base substitutions
Feature Tag: "blws"
This feature substitutes a ligature for a base glyph and a below base form. (GSUB lookup
type 4)

The 'blws' feature applied:

For example, TIBETAN LETTER RA (U+0F62) takes a special reduced form when it is the
topmost member in a stack of consonants. To accomplish this, the full form (tibRa) is
substituted for the reduced form (tibRaGo) when it precedes one of the base letters
which invoke this form, which may be referred to as a group
<BelowBaseLettersForRaGo>.

Above-base marks
Feature Tag: "abvm"
This feature positions all above-base marks on the base glyph.

"Above-base marks" feature applied:

This feature is needed for special cases in which more than one above-base vowel mark
is applied to a single stack. Such forms typically occur as abbreviations in the dbu-med
form of the script but should also be supported in dbu-can fonts. For example:

In dbu-med style

corresponds to

abbreviation for Rinpoche

in dbu-can, and is an

. The VowelAnchors

feature positions any above-base vowel on top of any other above-base vowel. A
sequence of such vowels can be positioned using this feature. This feature could equally
be applied with the Mark to Mark Positioning feature 'mkmk'.

Below-base marks
Feature Tag: "blwm"
This feature positions all below-base marks on the base glyph.
"Below-base marks" feature applied:

For example, when TIBETAN LETTER NGA (U+0FFF) combines with a subjoined letter, the
position of the subjoined letters needs to be raised very slightly so that it touches the
base of NGA.

Interaction between below-base, post-base and
above-base elements

Commonly, a feature is required for dealing with the base glyph and one of the postbase, pre-base or above-base elements. Since it is not possible to reorder ALL of these
elements next to the base glyph, we need to skip over the elements "in the middle"
(reordering-wise).
The solution is to assign different mark attachment classes to different elements of the
syllable and positional forms, and in any given lookup work with one mark type only. For
example, in above-base substitutions we need only consider above-base elements most
of the time.
Generally, it is good practice to label as "mark" glyphs that are denoted as marks in the
Unicode Standard as well as below-base/above-base forms of consonants. Then,
different attachment classes should be assigned to different marks depending on their
position with respect to the base.

Handling invalid combining marks
Combining marks and signs that appear in text not in conjunction with a valid
consonant base are considered invalid. Uniscribe displays these marks using the fallback
rendering mechanism defined in the Unicode Standard (section 5.12, 'Rendering NonSpacing Marks' of the Unicode Standard 3.1), i.e., positioned on a dotted circle.
Please note that to render a sign standalone (in apparent isolation from any base) one
should apply it on a space (see section 2.5 'Combining Marks' of the Unicode Standard).
Uniscribe requires a ZWJ to be placed between the space and a mark for them to
combine into a standalone sign. (i.e., to get a shape of I-matra without the dotted circle
one should type + ZWJ + I-matra).
For the fallback mechanism to work properly, a Tibetan OTL font should contain a glyph
for the dotted circle (U+25CC). In case this glyph is missing from the font, the invalid
signs will be displayed on the missing glyph shape (white box).

In addition to the 'dotted circle' other Unicode code points that are recommended for
inclusion in any Tibetan font are the ZWJ (zero width joiner; U+200C), the ZWNJ (zero
width non-joiner; U+200D) and the ZWSP (zero width space; U+200B).

Examples of Tibetan
The following examples show how Tibetan runs are formed using OpenType features.
A sequence of Tibetan code points is entered:

Before shaping, below-base signs overlap:

The blws lookup Leading­Glyphs­Followed­By­Three­‐
Marks replaces the topmost letter in the stack
with a shortened form in the context of a stack
consisting of three or more below-base marks.
The blws lookup Marks­To­One­Fourth­Lower
replaces the below base marks with shortened
forms in the context of the shortened top letter.
The blws lookup Stack­Ligatures replaces the
entire stack with a single ligature glyph.

A sequence is entered for a Tibetan abbreviation:

Before shaping, above-base vowel marks overlap:

The ccmp lookup Drengbo­And­Naro­Pre­‐
Composition substitutes sequences of two
identical above-base vowels with a
corresponding ligature. Note that the oddnumber of vowels leaves one single vowel after
the substitution.
The abvm lookup Vowel­Anchors stacks the
sequence of vowels one on top of another.

Appendix
Appendix: Writing system and language tags
Features are encoded according to both a designated script and language system.
Currently, the Uniscribe engine only supports the "default" language for each script.
However, font developers may want to build language specific features which are
supported in other applications and will be supported in future Microsoft OpenType
implementations.
NOTE: It is strongly recommended to include the "dflt" language tag in all
OpenType fonts because it defines the basic script handling for a font. The "dflt"
language system is used as the default if no other language specific features are
defined or if the application does not support that particular language. If the "dflt"
tag is not present for the script being used, the font may not work in some
applications.
The following tables list the registered tag names for scripts and language systems.
Registered tags for the Tibetan script

Registered tags for Tibetan language
systems

Script tag

Script

Language system

Language

tag
"tibt"

Tibetan

"dflt"

*default script handling

"TIB "

Tibetan

"SAN "

Sanskrit

"TSJ "

Tshangla

"XKF "

Khengkha

"KJZ "

Bumthangkha

"BLT "

Balti

"DZN"

Bhutanese

Note: both the script and language tags are case sensitive (script tags should be
lowercase, language tags are all caps) and must contain four characters (ie. you must
add a space to the three character language tags).

Microsoft ClearType overview
Article • 06/09/2022

ClearType is a software technology developed by Microsoft that improves the readability
of text on existing LCDs (Liquid Crystal Displays), such as laptop screens, Pocket PC
screens, and flat panel monitors. With ClearType font technology, the words on your
computer screen look almost as sharp and clear as those printed on a piece of paper.
ClearType works by accessing the individual vertical color stripe elements in every pixel
of an LCD screen. Before ClearType, the smallest level of detail that a computer could
display was a single pixel, but with ClearType running on an LCD monitor, we can now
display features of text as small as a fraction of a pixel in width. The extra resolution
increases the sharpness of the tiny details in text display, making it much easier to read
over long durations.

How did Microsoft come to develop ClearType?
ClearType builds upon a tradition of dedication to high-quality font technology at
Microsoft. Since the early nineties, Microsoft has continued to improve its display and
font capabilities, including the further development of TrueType font technology
originally licensed from Apple. Looking to further improve Microsoft's font rendering
technology, Microsoft researchers spent more than two years sifting through a large
amount of research related to both typography and the psychology of reading. They
concluded that reading is a form of pattern recognition. People become immersed in
reading only when word recognition is a subconscious task and the conscious mind is
free to read the text for meaning.
What was discovered is that word recognition is only subconscious when typographical
elements such as the shape and weight of letterforms, and the spacing between letters
work together to present words as easily recognized patterns. With these findings in
mind, Microsoft began taking a closer look literally at how type was being rendered on
screens.

How does ClearType display technology work?
To understand how ClearType works, one first has to understand what makes an LCD
screen different from other types of displays. Most screens created images made up of
pixels, which when magnified look like single squares. The equivalent of one pixel on an
LCD screen is actually composed of three sub-pixels: one red, one green, and one blue

(R-G-B). Seen together, these sub-pixel triplets combine to be seen by the human eye as
a single pixel.

If we were to look at a single pixel, our eye would see it as in the illustration above.
However, if we were to magnify the image, we would see that each pixel is actually
made up of three separate subpixels. And so, if when we see white on an LCD screen, we
are really looking at red, green and blue stripes.

How does this help improve the quality of
digital type display?
Traditional computer font rendering assumes that each pixel is either 'on' or 'off',
appearing as tiny black squares. Letters appear jagged on the computer screen because
they are formed from many of these tiny squares or pixels. Traditional grayscaling
assumes that each pixel has no internal structure, so it smooths the jagged edges but
sacrifices edge sharpness. ClearType knows that LCDs are made up of colored subpixels. ClearType uses a model of the human visual system to choose the brightness
values of the sub-pixels. With ClearType, letters on the computer screen appear smooth,
not jagged, yet the edges remain sharp.

ClearType font rendering

1. This is how the lowercase 'm' looks in the original typeface outline.
2. This is a close-up of the 'm' when rendered on screen without ClearType. Notice
how the 'm' has hard, jagged stair-steps or 'jaggies' in the stems, or 'legs' of the
'm'.
3. This is a close-up of the 'm' when rendered on screen with ClearType. Notice how
the 'jaggies' are much more subtle and the letter is rendered more smoothly.

Frequently asked questions about ClearType

How does ClearType work?
ClearType is a form of sub-pixel font rendering that draws text using a pixel's red-greenblue (RGB) components separately instead of using the entire pixel. When the pixel is
used in this way, horizontal resolution theoretically increases 300 percent.
Picture elements on an LCD screen are actually comprised of individual horizontallyoriented red, green and blue sub-pixels. For instance, an LCD screen that has a display
resolution of 800x600 pixels actually has 2400x600 individual sub-pixels. The human eye
is not capable of differentiating colors on such a small scale, so a combination of these
three primary colors can emulate any intermediate color. Sub-pixel font rendering takes
advantage of this by antialiasing at the sub-pixel level instead of at the pixel level.

Why should I tune my display?
No two screens are exactly the same and everyone perceives color in a slightly different
way.

How can I tell if my laptop or flat panel display is set to
its native resolution?
To see if your screen is set to its native resolution, try looking at the following eye test
image. The image is made up of many vertical black lines. If you see alternating bands of
white running vertically through this image, you are probably running at a non-native
resolution.

I'm a type designer. How can I see how my fonts will
render under ClearType without installing Windows?
Type designers can license our Visual TrueType (VTT) font hinting tool. VTT was updated
to let designers proof their fonts under ClearType. See VTT for more information.

Backwards compatibility of TrueType
instructions with Microsoft ClearType
Article • 03/22/2022

The release of Microsoft Windows XP with support for ClearType coincided with our
second generation of the ClearType technology. The first generation shipped with the
Microsoft Reader for Windows and the Microsoft PocketPC a year prior to the Windows
XP release. The second generation of ClearType brought a much richer filtering
algorithm as well as better support for the wide variety of existing TrueType™ fonts.
(A good description of this filtering can be found in Bétrisey C, Blinn JF, Dresevic B, Hill
B, Hitchcock G, Keely B, et al. Displaced Filtering for Patterned Displays. Society for
Information Display International Symposium Digest of Technical Papers 2000:1-4.
Available for download at research.microsoft.com/apps/pubs/?id=68631

.)

Although there is a clear architectural distinction between the TrueType rasterizer and
the ClearType filtering in the Microsoft Windows implementation, there is significant
interaction between these components, as there also is between TrueType and
traditional anti-aliasing technology. The bulk of the interaction involves the accuracy of
information coming from the TrueType rasterizer, especially as it relates to the
asymmetric nature of ClearType.
One of the primary design goals for adding ClearType into Microsoft Windows was to
maintain support for existing fonts without having to make modifications to these fonts.
Our initial investigations revealed that there were three key issues that impact this
compatibility issue. First, in a relatively few number of cases, hinted instructions at
smaller sizes would cause what we referred to as “point explosions”—where a point
would move off to a random distant location in the pixel grid. The second issue was the
difference in advance widths between fonts hinted with ClearType and fonts hinted with
the previous rendering technologies of bi-level or font smoothing. Finally, the third issue
involved hints, mostly in fonts that were “super-hinted,” that in an attempt to clean up
extraneous pixels, ended up causing aesthetic issues when displayed with ClearType.
The second generation of ClearType addresses these backwards compatibility issues.
The first issue of “exploding glyphs” is resolved by a technique called asymmetric supersampling, which will be discussed briefly a little later in this paper. The second issue of
incompatible widths is addressed with a technique called compatible widths, which is
not related to the issues being discussed in this paper.
The third issue and the goal of this white paper is to describe the techniques used in the
interpreter of the Microsoft Windows TrueType rasterizer that improve the display of

hinted glyphs when rasterized by Microsoft ClearType.
The target audience for this white paper is a font designer who would be proofing
existing fonts being displayed in ClearType or font designers adding or updating
instructions or hints to new or existing fonts. It is expected that the reader has some
familiarity with the TrueType instruction set and its nomenclature. The paper is not
targeted to implementers of font rasterizers.
A quick note on some terminology used in this document. Microsoft prefers to call the
TrueType engine a rasterizer while Apple® uses the term scaler. I’ll use the rasterizer
term in this document. Apple also generally refers to the concept of applying the
TrueType instruction set as “instructing fonts” while Microsoft will often use the term
“hinting fonts.” Both terms have the same meaning in this document. Also, since there
are differences between the Apple Macintosh® TrueType implementation and the
Microsoft TrueType implementation, unless otherwise mentioned, all references will be
to the Microsoft Windows TrueType rasterizer.

TrueType Fonts and ClearType
The Microsoft Windows implementation of ClearType takes the output of the TrueType
rasterizer in the form of overscaled bitmaps and applies filtering to create an image of
alpha values. The TrueType rasterizer takes as input the TrueType font, which consists of
contour outlines and a set of instructions as well as relevant information describing the
size to be displayed, the resolution of the display, and additional miscellaneous input
like character codes and scaling transforms.
The instructions provided by the TrueType interpreter are designed to allow designers to
specify how character features should be rendered. Because of the richness of the
instruction set, there can be significant interaction between the original outline provided
in the font and the outputted bitmap from the TrueType rasterizer. This interaction
cascades and impacts rendering methods like ClearType.

Bi-Level Rendering
The original design of TrueType corresponded to an era where the most common form
of rendering was bi-level, or one pixel color for the background and one pixel color for
the foreground. This is often called black and white rendering. There are several
common techniques for applying instructions to improve the glyph shapes, especially at
lower sizes, where the size of the glyph features is close to the size of a pixel. Most of
these techniques, though, usually apply some level of “delta” hints to improve glyph
shapes.

Delta Hints
Delta hints are a class of hinting techniques that get their name from the TrueType
DELTAC or DELTAP instructions. Delta instructions move a point by a limited amount
along the freedom vector in the case of DELTAP or adjust the value of a CVT by a limited
amount in the case of DELTAC. The key thing about delta instructions is that they only
work at a set of given sizes. Because the distance of a delta is limited and it is difficult to
have a delta execute over a simple range of sizes, it is common to have TrueType
functions that can move points under additional conditions.
Delta hints are typically implemented while proofing the quality of hints in a font. If at a
given size or range of sizes, a particular pixel was either on or off when that was deemed
incorrect, a point or points would be moved by an arbitrary amount in order to make
the correct pixel pattern occur. Because there is a lot of slack in the relatively large
pixels, there was not much accuracy in the values used for deltas.

ClearType Interaction with TrueType
Instructions

The TrueType interpreter works very well with ClearType. Microsoft worked with Apple
Computer on the original design to include support for non-square pixels, which were
still common on the Microsoft Windows platform when TrueType was first released. The
implementation of ClearType is also asymmetric, leading to non-square virtual pixels.
Because the sub-pixel arrangement on an LCD panel is composed of vertically oriented
colored elements, the resolution is at least three times higher along the x-axis while
along the y-axis the resolution is the same as with no ClearType solution. In fact, the
actual horizontal resolution for TrueType is sixteen times greater than the y-axis.
This asymmetry, though, leads to problems when implemented with the traditional
overscaling techniques used for anti-aliasing. A typical problem involves the freedom
and project vectors used by the hinting instructions.

In the example above, the diagonal stem of the lowercase ‘k’ is set up in the left image
with the freedom vector and projection vector in the typical manner for controlling the
weight of diagonal stems. In the right image, when the ‘k’ is asymmetrically overscaled
by a large factor, such as sixteen along the x-axis, the freedom vector and projection
vector become almost perpendicular. This leads to the “point explosions’ previously
described. To address this issue, we moved from traditional overscaling to ClearType
asymmetric super-sampling.

ClearType Asymmetric Super-sampling

For ClearType, you can imagine a grid with sixteen closely spaced grid lines per pixel in
the x-direction, and one gridline per pixel in the y-direction. Rounding instructions
(RTDG[], RDTG[], RUTG[], RTG[], RTHG[], and ROFF[]) now apply to this virtual grid as do
MDAP[R], MIAP[R], MDRP[…R…], and ROUND[…]. Instructions that don’t round, such as
SHP[], IP[], IUP[X], ALIGNRP[], ISECT[] work the same as without ClearType. Similarly, with
ClearType in the x-direction, SCVTCI[] reduces CVT cut-in to one sixteenth of its actual
value, matching the extra virtual resolution gained by rounding to one sixteenth of grid.
SMD[] reduces minimum distance to ½ of its actual value, roughly matching the extra
visual resolution gained by ClearType. (Theory says the visual gain is between 1.7 to 3
times, hence we used 2 for efficiency.)
Other benefits from this approach are the MPPEM[] and MD[] instructions measure
meaningful PPEms (Pixels per Em, a device dependant way for measuring type size) and
distances and the aspect ratio remains essentially square, eliminating problems where
the projection vector and freedom vector become near perpendicular.
This behavior of some TrueType instructions, though, is asymmetric so when the vectors
are set to the y-direction, the behavior is exactly how it was with bi-level—rounding is
on the actual pixel grid and not the virtual pixel grid.
In all of these examples we refer to extra resolution along the x-direction (along the xaxis) but from the Microsoft Windows TrueType rasterizer point of view we call this the

“ClearType Direction.” The “ClearType Direction” can be either the x-direction or the ydirection. If it were the case that the extra subpixel resolution was in the y-direction, the
virtual grid would change directions and the extra precision would only take place along
the y-direction.

Backwards Compatible ClearType
In general this technique of asymmetric super-sampling works very well, but some
legacy fonts hinted for bi-level rendering can create some issues. Specifically, fonts that
were “super hinted” for bi-level with many delta-like instructions and highly constrained
hints are most likely to be impacted with ClearType.
One example of a problem area involves legacy delta instructions. With the extra
resolution along the x-axis, delta instructions that were executed when the freedom
vector is set to the ClearType direction have the potential for much higher accuracy, but
previous usage with bi-level rendering was relatively sloppy leading to extreme
exaggeration of delta like instructions.
To address this situation, we needed to create a backward compatible mode for
ClearType when dealing with instructions using the ClearType direction for the freedom
vector. Here is how we handle various instructions in the backward compatible mode for
ClearType. It should be noted that these are the compatibility techniques addressed at
the time of this document, additional compatibility techniques could be added in the
future.

DELTAP and SHPIX
Many fonts use DELTAPs or SHPIX to fix unfortunate pixel patterns. Although problems
with delta-like instructions have shown up in font smoothing anti-aliasing, they are even
more problematic for ClearType. Therefore, all DELTAPs are skipped, except DELTAPs on
previously touched points in the non-ClearType direction and DELTACs. Deltas are also
skipped in composite glyphs if they are in the ClearType direction for the proper
centering and vertical positioning of diacritical marks. Inline deltas are sometimes used
to adjust the position of horizontal strokes, and CVT deltas do not always have the
vectors set properly, hence they are kept to avoid un-correcting weights in the ydirection (weights in x are taken care of by tightened CVT cut-ins.)
(An inline delta is a delta that occurs before the IUP instruction on a previously touched
point. A post-IUP delta occurs after the IUP instruction, while a pre-IUP delta occurs
prior to the IUP instruction.)

In the TrueType rasterizer, we assume that if we are doing a SHPIX instruction, we are in
the context of a function that implements delta instructions for a range of PPEM sizes. If
such a delta occurs on an untouched point, regardless of whether it is in the ClearType
direction or not, it creates a dent in the outline. While for bi-level this is intended to flip
one or more pixels, it distorts the stroke in ClearType. If such a delta occurs on a
touched point, it moves along the entire outline, such as to place strokes differently. If
this happens in the ClearType direction, this distorts the natural spacing of the stroke(s).
Therefore we keep only deltas on touched points in the non-ClearType direction.
As mentioned earlier, for composites, the touched/untouched rule does not apply the
same way. A point that is flagged as untouched may have been previously touched
while executing the code for the respective component. Yet a subsequent SHPIX or
possibly DELTAP applied to that point will not create another dent in the outline, but
move the entire outline instead. This is used in bi-level to reposition diacritics to ensure
a minimal distance of one pixel between the base character and the diacritic. Hence we
also keep deltas in composites.
Some deltas are implemented as functions in various fonts and they do not always have
the same function number across fonts. To detect this situation, we look for signature
code at the beginning of the function. There are two common signatures we are looking
for to indicate inline deltas.

MPPEM[]
GTEQ[]
SWAP[]
MPPEM[]
LTEQ[]
AND[]
IF[]
SHPIX[]
ELSE[]
POP[]
POP[]
EIF[]
ENDF[]

MPPEM[]
EQ[]
IF[]
SHPIX[]
ELSE[]
POP[]

POP[]
EIF[]
ENDF[]

TypeMan Talk DiagEndCtrl
Some fonts use the old TypeMan Talk DiagEndCtrl (Diagonal End Control) command,
which in turn calls a support function that calculates an inline delta in x-direction to
undo the side-effects of “cross-over” strokes. Therefore, as an exception to the
exception, these inline deltas in the ClearType direction are not skipped.
(TypeMan Talk is a high level TrueType hinting language designed for the tool TypeMan.
This tool was originally written by Sampo Kaasila of Type Solutions, Inc., now a whollyowned subsidiary of Bitstream® Inc. Microsoft has updated the TypeMan Talk language
in the Visual TrueType Product.)

RDTG
In some fonts, points were aligned using MDRP with RDTG preceded by SPVTL (not
SDPVTL.) For this to align properly, RDTG rounds down to the physical grid in these
cases.
Historically, if a point to be aligned was away by 1.5° or more from the line to which to
align, the TypeMan Talk Align has translated to SPVTL, followed by RDTG and MDRP.
This has a major problem: The MDRP instruction uses the set projection vector to
measure the original distance on the uninstructed outline. This gives us an “original”
distance which is more or less wrong, depending on how far the reference point has
moved already. (Notice that it is most likely that the reference point has moved
somewhat in x and in y before the alignee gets to be aligned.) Subsequently, when
MDRP gets to move the point, it uses the same projection vector again, but this time
around on the instructed outline, in order to determine how far the point has to be
moved in the end. Luckily, this is used in connection with RDTG, which is applied to the
“original” distance, and thereby often reduces the “original” distance to zero, which
often is closer to the correct original distance than the one obtained by using the
project vector on the uninstructed outline.
In the ClearType direction, however, these erroneous “original” distances would be
rounded down to the nearest sixteenth of a pixel, and with that become highly visible (a
distance of just under one pixel, which is what gets rounded down to zero in bi-level, is

too large a distance to be ignored in ClearType. Therefore, we have to make an
exception here.

ROUND in PreProgram
In some East Asian fonts, numbers were calculated and ROUNDed in the pre-program,
without properly setting the vectors, which vertically misplaced horizontal strokes (offgrid, resulting in drop-outs.) Therefore all rounding is done to the physical grid while in
the pre-program.

Unrounded MIRP and CVT Cut-In
In some fonts fractional stroke weights were calculated and used in MIRP[…r…]. While
this provides some extra granularity in font smoothing, it unnecessarily quantizes stroke
weights in ClearType, because un-rounded MIRPs now respect CVT cut-in.
Our goal is to avoid fractional font-smoothing targeted CVTs and unrounded MIRP (little
r) which bypasses CVT cut-in. Here we may honor a CVT cut-in even though the roundoff flag would require not doing so. We assume that the context is a stroke weight that
has been tweaked for use with font smoothing, and the only way to force MIRP to use a
particular distance is to round the CVT “by hand” and then turn off the rounding flag,
which is quite what we don't want to do in ClearType, i.e. to enforce an unnatural
weight.
To summarize, with ClearType on, do CVT cut-in always.

MSIRP and CVT Cut-In
Some fonts pre-calculate stroke weights and subsequently use MSIRP[.], which involves
neither rounding nor CVT cut-ins. Therefore MSIRP[.] now respects the CVT cut-in.
Similar to the unrounded MIRP problem previously discussed, for this issue we honor a
CVT cut-in in case there is a non-trivial outline distance between the parent (reference)
and the child (target) point involved, in which case we assume the context is a stroke
weight, else we assume the context is an accent placement function, in which case we
use the actual distance as before.

TypeMan Talk DStroke and IStroke

Some legacy fonts use the old TypeMan Talk DStroke and IStroke commands, which
apparently were not meant to work with non-square aspect ratios. Therefore, while in
the respective support functions, the rasterizer pretends to be in non-square aspect
ratio, even though in reality it is not.
We need to avoid collapsing strokes in (partly) auto-hinted fonts using the TypeMan Talk
DStroke and IStroke commands. Here we are assuming that FDEF functions 64 through
66 are support functions for the TypeMan Talk DStroke and IStroke commands, which
may make strokes collapse in ClearType. To determine whether we have actually run into
the context of these functions, we look at the first couple of bytes only, as the exact
implementation of these functions may have changed over time, but hopefully, the
preamble (to look at storage location 22) has not. The signature for the function is:

#PUSH 22
RS[]
IF[]

The easiest way to by-pass these functions is to flag storage location 22 with zero,
indicating not to use DStroke or IStroke, otherwise we would have to clean up the stack.
The reason that DStroke does not work, is the following. DStroke brings pairs of points
to the same y (or x), MIRP[…r…] the floating point, and then moves it back to the old y
(or x.) Now that we re-interpret no round on the MIRP, CVT cut-in actually gets to cut in,
the original distance gets to apply, just that the original distance is taken prior to
bringing points to the same y (or x), meaning it is likely to be way off. As a result, the
diagonal stroke weight (in x) starts to depend heavily on the distance (in y) of the
control points involved, which is not what we want. Not that for non-square aspect
ratios, the DStroke is a NOP, therefore was a NOP with sixteen times the resolution of
ClearType, and hence we are not doing any major harm here by skipping it in ClearType.

Spacing Functions
Similar to the DStroke and IStroke, there are some spacing functions which also are not
meant to work with non-square aspect ratios. Therefore the rasterizer pretends to be in
non-square aspect ratio in these cases as well.
To avoid bloated characters, we are avoiding some specific functions for spacing. We are
assuming that functions 0, 1, 2, 4, 7, and 8 are support functions for this spacing code,
which may squish characters or pull them left or right or in both directions at the same
time. This has to do amongst other things with using the twilight zone. The spacing
algorithm is meant to be turned off above a certain size, such as 30 PPEm, hence we

may argue that with the extra visual resolution we should turn it off at a considerably
smaller PPEm size, or altogether. Storage location 24 is used to bypass the function. The
signature for the function is one of the following:

SVTCA[X]
#PUSH 24
RS[]
IF[]

SVTCA[X]
RTG[]
#PUSH 24
RS[]
IF[]

Diagonal Stroke Function
Some fonts use a diagonal stroke method which made some italic fonts upright or backslanted under ClearType. Therefore, the interpreter identifies the respective support
function and pretends an alternative CVT cut-in value.
We are assuming that function 58 handles the diagonal stroke. If the signature matches
the following code we will change the CVT cut-in value.

DUP[]
DUP[]
#PUSH[], 1
ADD[]
GC[N]
#PUSH[], 64
SWAP[]
WS[]

TypeMan Talk VacuFormRound
Some fonts used the old TypeMan Talk VacuFormRound command, which may work on
certain bi-level pixel patterns, but which invariably creates diamonds in ClearType.
Therefore, the interpreter attempts to skip all related code.

We are expecting function 0 to contain the signature:

RCVT[]
SWAP[]
GC[N]
ADD[]
DUP[]
#PUSH, 38

With this signature, we confirm that that IUP[X] and IUP[Y] have already been executed.
Storage location 8 will return zero to stop most VacuFormRounds. In the case of a Type
2 VacuFormRound, the MD instruction, while in the VacuFormRound, will slightly
increment the projection vector by the smallest possible amount (1) to throw off Type 2
VacuForms which are keyed off a distance being exactly 1 pixel.

Using TrueType Instructions with ClearType
As previously mentioned, the precision of ClearType rasterization can integrate quite
naturally with the TrueType interpreter. When fonts are hinted with ClearType in mind,
they can be proofed to verify that the hints work appropriately with ClearType and other
rasterization techniques. There is additional support in the TrueType instruction set to
help fonts optimize for ClearType and to help prevent other types of problems as we
have discussed with backwards compatibility.

GETINFO
The GETINFO[] instruction, among other things, can be used to query what type of
rasterization is being used for the current glyph. The instruction is used by setting one
or more selector bits and the return value on the stack is a bit or group of bits based on
which selector bits were set. These selector bits and return value bits are fully
documented in the TrueType instruction specification, but it is worthwhile describing the
ClearType related values.

ClearType (Selector bit 6, Return bit 13)
This flag is requested by setting selector bit six. If the return bit thirteen is set it indicates
that the glyphs for this size will be rendered with ClearType rendering. If the return bit
thirteen is cleared, one can only assume that it is not ClearType being rendered; it
doesn’t imply which type of rendering is being performed.

Compatible Width ClearType (Selector bit 7, Return bit 14)
This flag is requested by setting selector bit seven. If the return bit fourteen is set, this
indicates that the glyphs for this font size will be adjusted post hinting in order to return
advance widths that are exactly the same as bi-level rendering. If the return bit fourteen
is not set, then the advanced widths will be either returned as integers rounded to the
nearest pixel or rounded to the nearest sixteenth of a pixel. The former is referred to as
natural widths ClearType and the later as sub-pixel positioned ClearType.

Symmetrically Smoothed ClearType (Selector bit 8, Return
bit 15)
At larger sizes ClearType performs better with a symmetrical rendering solution.
Standard ClearType which is used exclusively by some graphics systems and at lower
sizes in others uses a 6×1 filtering technique—with six times the resolution along the xaxis and no resolution change along the y-axis. With symmetrically smoothed ClearType,
a 6×5 filtering technique is used—with six times the resolution along the x-axis and five
times the resolution along the y-axis. This later solution tends to create more blur at
lower sizes but prevents aliasing at higher sizes.
This flag is requested by setting selector bit eight. If the return bit fifteen is set, this
indicates that symmetrically smoothed ClearType is enabled for this font size. If the
return bit fifteen is not set, then the symmetrically smoothed ClearType is not enabled
and the 6×1 filtering technique is being used.

BGR ClearType (Selector bit 9, Return bit 16)
The primary environment for ClearType is with displays that are similar to Liquid Crystal
Displays (LCD) that implement color with vertical stripes. In most cases these displays
have the red color filter, followed by green and then blue from left to right. In some
cases it is possible for this ordering to be reversed. This can be due to the creation of
the display filter or by having the display text inverted on the screen.
The BGR status can be requested by setting selector bit nine. If the return bit sixteen is
set, this indicates that ClearType is processing the LCD stripes in BGR (Blue, Green, Red)
order. If it is clear then ClearType is processing the LCD stripes in RGB (Red, Blue, Green)
order.

GETINFO Usage with ClearType

The ClearType information returned by the GETINFO instruction is useful for both
existing fonts that wish to be made compatible with ClearType and new fonts that need
to use different hinting techniques for ClearType and other methods of rendering.
Before using the GETINFO instruction with ClearType, one should query the rasterizer
version, which is also done with the GETINFO instruction by setting selector bit one and
examining the result in bits 0 through 7 (first byte) of the return result. The ClearType
selector can be used if the version number is 35 or greater. The rest of the ClearType
selectors discussed above can be used if the version number is 37 or greater.
If information from GETINFO will be used often in the instructions, it is quite common to
save the status of the flag in a storage location.
For instructions where compatibility is needed for existing bi-level hints, the code that
has impact on ClearType (e.g. delta like instructions or functions) can be surrounded by
a conditional IF that is only executed if ClearType is not enabled. Likewise, additional
instructions that may improve the rendering of ClearType may also be surrounded by a
conditional IF that is executed only if ClearType is enabled. These techniques can be
used both in the CVT program (pre-program) and glyph programs and if some of the
hinting techniques are implemented in functions, the conditional code can be
implemented in that function.

INSTCTRL
The INSTCTRL instruction with selector flag three and a value of TRUE (4) should be used
in new fonts and existing instructed fonts that have been verified to work correctly in
the ClearType environment. Typically this instruction would be placed at the beginning
of the CVT program, with a selector of three and a value of four on the stack. Although
the other selector flags associated with INSTCTRL are limited to the CVT Program,
selector three can be used in either the CVT Program or the glyph program.
(This is contrary to the current OpenType specification but intended in the design of this
selector. To make sure that one glyph does not change the settings for another glyph, if
the instruction selector is set at the beginning of a glyph, it should be cleared at the end
of the glyph. This is not required if the instruction selector is used exclusively in the CVT
program.)
If INSTRCTRL with selector flag two and a value of TRUE (2) is used in the CVT Program,
it will disable the effects of selector flag three and each glyph will have to control this
independently.
As most of this document describes, significant effort has been made to allow ClearType
to work with existing fonts. In a few cases existing instruction behavior, as documented

in the TrueType instruction specification, had to be modified to maintain backwards
compatibility. When the INSTCTRL ClearType instruction is used it returns instructions to
the behavior as described in the TrueType instruction specification.
Conclusion Significant effort has been taken to make ClearType perform optimally for
Microsoft Windows. Continued support from font hinters is necessary in order that fonts
will continue to be the most readable and legible on many types of displays and many
types of rendering environments. This paper has described the techniques used to make
existing, unmodified fonts work correctly with ClearType, but more importantly it
provides the information to developers of new fonts on how to assure the consistent
behavior of the TrueType interpreter for fonts by using the INSTCTRL instruction.
Microsoft recommends that new fonts which have code to instruct glyphs include the
following sequence at the beginning of the CVT Program:

#PUSH 4,3
INSTCTRL[]

With this code, as always, quality assurance should be verified with ClearType, traditional
font smoothing, and bi-level rendering.

ClearType Font Collection
Article • 06/10/2020

The ClearType Font Collection is the result of a successful collaboration of both
designers and engineers working together with respect, flexibility, and curiosity.
ClearType fonts were conceived from the outset as a marriage of technology and the
best in design expertise! This improves the appearance of text on certain types of
monitors through the use of subpixel rendering technology.
The ClearType Font Collection listed below were first shipped with both Windows Vista
and Office 2007 and have been part of Windows ever since.
Constantia
Corbel
Calibri
Cambria
Candara
Consolas

Now Read This:

English: Now Read This: The Microsoft ClearType Font Collection - .pdf - 15,896KB
Download
Japanese: Now Read This: The Microsoft ClearType Font Collection - .pdf - 4,716KB
Download
In 2003, Microsoft brought together a team in Redmond to brainstorm, to learn
about ClearType, and to kick-off a new project; to create a new set of Typefaces
designed specifically to work with ClearType. We are pleased to offer a
download of the book that tells the story of how these fonts were created.

Cambria Math:

Cambria Math - .pdf - 2,144KB Download

This book focuses on the Cambria Math font implementation for mathematical
typesetting, rather than on the math layout engine software, and is intended as
an introduction for mathematicians and scientists as users of the font, and for
designers and font developers interested in understanding the general
principles of Microsoft’s approach to mathematical typesetting and the features
of the Cambria Math font.

Type Samples:
Type Samples - .pdf - 3,507KB Download

Sample Layouts:
Constantia - .pdf - 216KB Download
Corbel - .pdf - 108KB Download
Calibri - .pdf - 242KB Download
Cambria - .pdf - 225KB Download
Candara - .pdf - 108KB Download
Consolas - .pdf - 65KB Download

Legacy Arabic Font Encodings
Article • 11/13/2021

There is a class of legacy fonts for Arabic that use not-well-documented mechanisms
and legacy shaping implementations in Windows. This topic provides some details
regarding this class of fonts.
These fonts date to the 1990s. These are TrueType fonts, in the sense that they are .ttf
files that, in general, follow the TrueType spec. However, they make use of
undocumented details not defined in the TrueType or OpenType specs, and do not
conform to current specifications for how to implement Unicode fonts for Arabic.

Font encoding and character set declarations
These fonts use Windows Symbol encoding — that is, they have a cmap subtable for
platform ID 3, encoding ID 0. By itself, the Windows Symbol encoding implies no
interoperable character semantics, but rather implies font-specific semantics. Arabic
character semantics are not established in the cmap subtable, as would be expected.
Rather, this is done using special values within the OS/2 table that are not documented
in the TrueType or OpenType specification.
Note that some of these fonts may also include cmap subtables for other platforms and
encodings. Those should not be used, however. The fonts were created in an era in
which single-byte encodings were used, and these alternate cmap subtables are likely to
be redefinitions of the declared encodings. For example, the Royal Arabic font includes a
Mac Roman cmap subtable, but the glyphs that are mapped do not match the Mac
Roman character set.
These fonts include a version 0 OS/2 table. Version 0 includes the fsSelection field, which
is a uint16 value with various bits defined as flags. Only a limited set of bits — bits 0 to 6
— are defined; remaining bits are documented as reserved and to be set to 0. In this
class of fonts, however, values are set in the reserved, upper word of the fsSelection
field. These non-standardized values are how the character semantics are declared.
The values set in the upper word of the fsSelection field are not bit flags, as otherwise
used for the fsSelection field. Instead, the upper byte is set to one of the following
constant values:
C

#define ARABIC_CHARSET_SIMPLIFIED
#define ARABIC_CHARSET_TRADITIONAL

178
179

The first of these corresponds to the ARABIC_CHARSET constant defined in gdi32.h for
use in the lfCharset member of the LOGFONT structure. The second is used in some
fonts, but is not defined in gdi32.h.
Note: There is a correspondence between CHARSET values in Windows GDI and
code pages, and code pages are referenced in the ulCodePageRange fields of the
OS/2 table (version 1 and later). However, the ulCodePageRange fields are used to
indicate logical character sets that are supported in the font, but say nothing about
actual character encodings used in the font. For this class of fonts, the
ulCodePageRange fields are not relevant.
Note: Similar use of the upper word of the fsSelection field is known to have been
used for legacy Hebrew and Thai fonts as well.

The nature of the font encodings
In terms of Unicode characters, the Arabic characters supported by this class of fonts is a
subset from the range U+0620 to U+065F.
Each of these legacy font encodings is a presentation-form encoding. That is, all
presentation-form glyphs are mapped directly by some character code in the cmap
table. The presentation forms will include the basic contextual shapes of Arabic letters:
isolate, initial, medial, final. In addition, there are other presentation forms for certain
ligatures; these are not documented here in detail.
Note: There is nothing in the fonts themselves that determines the encoded nature
of text data that might be displayed with these fonts. Some legacy applications
might generate documents using these fonts with contextual forms of Arabic letters
represented directly in the documents. Some legacy applications might generate
documents with Arabic text encoded in visual rather than logical order. Other legacy
applications might encode Arabic text in logical order using one character code for
Arabic letters, with the software resolving visual order and selecting contextual
forms and ligatures from the font using character codes of the presentation-form
encoding.
As noted above, the fonts use Windows Symbol cmap subtables. In most fonts that use
Windows Symbol encoding, the character index values are in the range 0xF020 to
0xF0FF. In this class of fonts, however, different ranges are assumed for the two
encoding declarations:

ARABIC_CHARSET_SIMPLIFIED: 0xF100 to 0xF1FF
ARABIC_CHARSET_TRADITIONAL: 0xF200 to 0xF2FF
These ranges are reflected in the usFirstCharIndex and usLastCharIndex fields of the
fonts’ OS/2 tables.
Note: In legacy, single-byte applications, these 16-bit ranges would be mapped to a
single-byte code point range 0x20 to 0xFF in documents. For example, when
ARABIC_CHARSET_SIMPLIFIED is set in the font’s OS/2 table, the code 0x45 in a
document would be mapped to 0xF145 when searching in the font’s cmap table.

Legacy encoding details
This section documents the semantic interpretation of code points in these legacy
encodings. This is expressed as a mapping from Unicode characters to corresponding
legacy codes for different contextual forms (if relevant).

Legacy Traditional Arabic encoding
The mapping from Unicode to the legacy Traditional Arabic encoding is provided in two
tables:
The first table covers Arabic letters, which have joining presentation form variants.
The legacy encoding includes ligature forms for certain Arabic letter sequences as
separate characters; separate rows are included in the table for each letter
sequence. The column headings indicate whether there are left or right connecting
strokes: "initial" implies a left connection, "medial" implies left and right
connections, "final" implies a right connection, and "isolate" implies no
connections.
The second table covers other Arabic-script characters and joining controls. This
includes Arabic combining marks. The legacy encoding includes ligature forms for
certain mark combinations as separate characters; separate rows are included for
each mark combination.
For most marks or mark combinations, the legacy encoding has high and low positional
variants encoded as separate characters. (This is similar to use of the 'mset' OpenType
feature to substitute positional-variant glyphs, except in the legacy encoding the
substitution is done for pre-determined cases and handled by character codes.) In the
second table, these positional-variant characters are listed in the same row.
Arabic letters and letter sequences (ligatures)

Unicode

Legacy encoding
Initial

Medial

Final

0621 hamza

Isolate
F2D5

0622 alef with madda above

F246

F245

0623 alef with hamza above

F244

F243

0624 waw with hamza above

F2DB

F2DA

0625 alef with hamza below

F248

F247

F2D8

F2D9

F242

F241

F24B

F24C

0626 yeh with hamza above

F2D6

F2D7

0627 alef
0628 beh

F249

0628 + 062C beh jeem

F280

0628 + 062D beh hah

F281

0628 + 062E beh khah

F282

F24A

0628 + 0631 beh reh
0628 + 0645 beh meem

F215
F296

F202

0628 + 0646 beh noon

F292

0628 + 064A beh yeh

F21D

0629 teh marbuta

F2D2

F2D1

F24F

F250

062A teh

F24D

062A + 062C teh jeem

F283

062A + 062D teh hah

F284

062A + 062E teh khah

F285

F24E

062A + 0631 teh reh
062A + 0645 teh meem

F216
F297

F203

062A + 0646 teh noon

F293

062A + 064A teh yeh

F21E

062B theh

F251

F252

F253

F254

062B + 0645 theh meem

F204

062C jeem

F255

062C + 0645 jeem meem

F29A

062D hah

F259

062D + 0645 hah meem

F29B

062E khah

F261

062E + 0645 khah meem

F29C

F256

F257

F258

F25A

F25C

F260

F262

F263

F264

062F dal

F266

F265

0630 thal

F268

F267

0631 reh

F26A

F269

0632 zain

F26C

F26B

F26E

F26F

F270

F272

F273

F274

0633 seen

F26D

0633 + 0645 seen meem

F218

0634 sheen

F271

0634 + 0645 sheen meem

F219

0635 sad

F275

F276

F277

F278

0636 dad

F279

F27A

F27C

F27E

0637 tah

F27F

F2F1

F2A1

F2A2

0638 zah

F2A3

F2A4

F2A5

F2A6

0639 ain

F2A7

F2A8

F2A9

F2AA

063A ghain

F2AB

F2AC

F2AD

F2AE

0641 feh

F2AF

F2B0

F2B1

F2B2

0641 + 064A feh yeh

F29F

0642 qaf

F2B3

F2B4

F2B5

F2B6

0643 kaf

F2B7

F2B8

F2B9

F2BA

0644 lam

F2BB

F2BC

F2BD

F2BE

0644 + 0622 lam alef madda above

F2E1

F2E0

0644 + 0623 lam alef hamza above

F2DF

F2DE

0644 + 0625 lam alef hamza below

F2E3

F2

0644 + 0627 lam alef

F2DD

F2DC

0644 + 062C lam jeem

F286

F212

0644 + 062D lam hah

F287

F213

0644 + 062E lam khah

F288

F214

0644 + 0644 + 0647 lam lam heh

F201

0644 + 0645 lam meem

F29D

0644 + 0645 + 062C lam meem jeem

F211

0644 + 0645 + 062D lam meem hah

F210

0644 + 0647 lam heh

F21A

F205

0644 + 0649 lam alef maksura

F295

0644 + 064A lam yeh

F21C

0645 meem

F2BF

0645 + 062C meem jeem

F289

0645 + 062D meem hah

F28A

0645 + 062E meem khah

F28B

0645 + 0645 meem meem

F29E

0646 noon

F2C3

0646 + 062C noon jeem

F28C

0646 + 062D noon hah

F28D

0646 + 062E noon khah

F28E

0646 + 0645 noon meem

F298

F2C0

F2C1

F2C2

F2C4

F2C5

F2C6

F206

0646 + 064A noon yeh
0647 heh

F21F
F2C9

F2CA

0648 waw

F2CC

F2CB

0649 alef maksura

F2D3

F2D4

F2CF

F2D0

064A yeh

F2C7

F2CD

F2C8

F2CE

064A + 062C yeh jeem

F28F

064A + 062D yeh hah

F290

064A + 062E yeh khah

F291

064A + 0631 yeh reh
064A + 0645 yeh meem

F217
F299

064A + 0646 yeh noon

F294

Other characters and character sequences (ligatures)
Unicode

Legacy encoding

060C Arabic comma

F20C

061B Arabic semicolon

F23B

061F Arabic question mark

F23F

0640 tatweel

F25F

064B fathatan

F2E7 (high) or F2F5 (extra high)

064C dammatan

F2E8 (high) or F2F6 (extra high)

064D kasratan

F2EB (low) or F2F9 (extra low)

064E fatha

F2E4 (high) or F2F2 (extra high)

064F damma

F2E5 (high) or F2F3 (extra high)

0650 kasra

F2EA (low) or F2F8 (extra low)

0651 shadda

F2E9 (high) or F2F7 (extra high)

0651 + 064B shadda fathatan

F2EE (high) or F2FC (extra high)

0651 + 064C shadda dammatan

F2EF (high) or F2FD (extra high)

0651 + 064D shadda kasratan

F2FF

0651 + 064E shadda fatha

F2EC (high) or F2FA (extra high)

0651 + 064F shadda damma

F2ED (high) or F2FB (extra high)

0651 + 0650 shadda kasra

F2F0 (high) or F2FE (extra high)

0652 sukun

F2E6 (high) or F2F4 (extra high)

0660 Arabic-Indic digit zero

F230

Unicode

Legacy encoding

0661 Arabic-Indic digit one

F231

0662 Arabic-Indic digit two

F232

0663 Arabic-Indic digit three

F233

0664 Arabic-Indic digit four

F234

0665 Arabic-Indic digit five

F235

0666 Arabic-Indic digit six

F236

0667 Arabic-Indic digit seven

F237

0668 Arabic-Indic digit eight

F238

0669 Arabic-Indic digit nine

F239

066B Arabic decimal separator

F25E

200C zero width non-joiner

F20C

200D zero width joiner

F20D

200E left-to-right mark

F20E

200F right-to-left mark

F20F

Legacy Simplified Arabic encoding
The mapping from Unicode to the legacy Simplified Arabic encoding is presented by
means of a code snippet. Four arrays are used for isolate, initial, medial and final forms.
This mapping logically assumes four different contextual shapes for every Arabic
character, though in some cases the same presentation-form code point is mapped for
more than one context — for example, one legacy presentation form code point for
both isolate and initial contexts.
Note: This mapping data does not reflect ligatures for Arabic letter combinations
that are directly encoded in the legacy Simplified Arabic encoding.

C

#define NUM_ARABIC_LETTER_TABLES
#define U_ARABIC_SCRIPT_COUNT

0x0004
0x40

/***************************************************************************

*********
S I M P L I F I E D
A R A B I C
****************************************************************************
*********/
// index for invalid glyph is 0x00
// These are based on starting index 0xF100
const USHORT cpOldTTFSimpArabicShapes[NUM_ARABIC_LETTER_TABLES]
[U_ARABIC_SCRIPT_COUNT] =
{
// Isolate Shapes
{
0x00 , 0xad , 0x45 , 0x43 , 0xbb , 0x47 , 0xba , 0x41 , // 0x620
0x4a , 0xa9 , 0x4c , 0x4e , 0x51 , 0x54 , 0x57 , 0x58,
0x59 , 0x5a , 0x60 , 0x62 , 0x64 , 0x66 , 0x68 , 0x69 ,
0x6a , 0x6e , 0x72 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00,

// 0x630

0x5f , 0x75 , 0x78 , 0x7a , 0x7c , 0x7e , 0xe1 , 0xa4 ,
0xa5 , 0xac , 0xa8 , 0xc7 , 0xc8 , 0xcb , 0xc4 , 0xc5,

// 0x640

0xca , 0xc9 , 0xc6 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 ,
0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00,
},

// 0x650

// Initial shapes
{
0x00 , 0xad , 0x45 , 0x43 , 0xbb , 0x47 , 0xae , 0x41 ,
0x49 , 0xa9 , 0x4b , 0x4d , 0x4f , 0x52 , 0x55 , 0x58,

// 0x620

0x59 , 0x5a , 0x60 , 0x61 , 0x63 , 0x65 , 0x67 , 0x69 ,
0x6a , 0x6b , 0x6f , 0x00 , 0x00 , 0x00 , 0x00 , 0x00,

// 0x630

0x5f , 0x73 , 0x76 , 0x79 , 0x7b , 0x7d , 0x7f , 0xa1 ,
0xa5 , 0xac , 0xa6 , 0xc7 , 0xc8 , 0xcb , 0xc4 , 0xc5,

// 0x640

0xca , 0xc9 , 0xc6 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 ,
0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00,
},

// 0x650

// Medial shapes
{
0x00 , 0xad , 0x46 , 0x44 , 0xbb , 0x48 , 0xae , 0x42 ,
0x49 , 0xa9 , 0x4b , 0x4d , 0x4f , 0x52 , 0x55 , 0x58,

// 0x620

0x59 , 0x5a , 0x60 , 0x61 , 0x63 , 0x65 , 0x67 , 0x69 ,
0x6a , 0x6c , 0x70 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00,

// 0x630

0x5f , 0x74 , 0x77 , 0x79 , 0x7b , 0x7d , 0x7f , 0xa2 ,
0xa5 , 0xac , 0xa6 , 0xc7 , 0xc8 , 0xcb , 0xc4 , 0xc5,

// 0x640

0xca , 0xc9 , 0xc6 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 ,
0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00,
},

// 0x650

// Final shapes
{
0x00 , 0xad , 0x46 , 0x44 , 0xbb , 0x48 , 0xaf , 0x42 ,
0x4a , 0xaa , 0x4c , 0x4e , 0x50 , 0x53 , 0x56 , 0x58,

// 0x620

// 0x630

0x5f , 0x75 , 0x78 , 0x7a , 0x7c , 0x7e , 0xe1 , 0xa3 ,
0xa5 , 0xab , 0xa7 , 0xc7 , 0xc8 , 0xcb , 0xc4 , 0xc5,

// 0x640

0xca , 0xc9 , 0xc6 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 ,
0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00,
},

// 0x650

};

0x59 , 0x5a , 0x60 , 0x62 , 0x64 , 0x66 , 0x68 , 0x69 ,
0x6a , 0x6d , 0x71 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00,

TrueType overview
Article • 06/10/2020

TrueType is a digital font technology designed by Apple Computer, and now used by
both Apple and Microsoft in their operating systems. Microsoft has distributed millions
of quality TrueType fonts in hundreds of different styles, including them in its range of
products and the popular TrueType Font Packs.
TrueType fonts offer the highest possible quality on computer screens and printers, and
include a range of features which make them easy to use.
The history of TrueType's development is discussed briefly in our History of TrueType
document, which explains the various incarnations of the technology, as well as some of
the reasons TrueType exists at all.

What do I need in order to use TrueType?
The TrueType font technology consists of two components: the TrueType fonts
themselves, which come in many thousands of different styles, and can be purchased
individually or in collections from font manufacturers; and the TrueType rasterizer, a
piece of software built into System 7.x on the Apple Macintosh range of computers, and
also into Microsoft's Windows family of operating systems.
Both components - the font and the rasterizer, are necessary to display and print
TrueType fonts on a computer system. It is the interaction between the TrueType fonts,
the TrueType rasterizer and the software program in which the TrueType font is used that
determines the appearance of the letterforms in the font.

Where can I get TrueType from?
If you're using a Mac or a Windows machine, the chances are that you're already using
the TrueType rasterizer and the TrueType fonts both Apple and Microsoft include with
the basic operating system.
If you're using Apple Macintosh or Windows based computers, all you need to do is
purchase the fonts you want to use.

The TrueType rasterizer

The TrueType font technology consists of two parts: the description of the fonts
themselves (the TrueType font files), and the program which reads the font description
and generates the bitmaps (the TrueType Rasterizer).
The TrueType Rasterizer is a computer program which is typically incorporated as part of
an operating system or printer control software. With this in mind, it has been written
with a well defined client interface, and a clean modular structure in portable C.
The job of the TrueType Rasterizer is to generate character bitmaps for screens and
printers (otherwise known as raster devices). It accomplishes this by performing the
following tasks:
Reading the outline description of the character (lines and splines) from the
TrueType font file.
Scaling the outline description of the character to the requested size and device
resolution.
Adjusting the outline description to the pixel grid (based on hinting information).
Filling the adjusted outline with pixels (scan conversion).

What's in a TrueType font?
A digital font contains much more than just the characters associated with a given
alphabet or script. A TrueType font file includes many different kinds of information used
by the TrueType rasterizer and the operating system software to ensure that characters
display on the computer screen or print out exactly as the font designer intended them
to. All of the information in a TrueType font is arranged in a series of tables. For technical
information about these tables, you can see our TrueType specification.
In addition to the shapes of each character, a TrueType font includes information about
how the characters should be spaced vertically and horizontally within a block of text,
character mapping details (governing the variety of characters included in the font and
the keystrokes needed to access them), and much more besides. The fonts also include
manufacturer's details, such as copyrights, names and licensing permissions.

Description of characters
One of the more obvious things TrueType fonts include is the shape of each character.
Each and every letterform contained in a TrueType font is stored as an outline, or more
accurately, as a mathematical description of the character constructed from a series of
points. For this reason, TrueType is known as an outline font format.

Probably the greatest thing about storing characters as outlines is that only one outline
per character is needed to produce all the sizes of that character you'll ever need. A
single outline can be scaled to an enormous range of different sizes, some of which are
illustrated below. This enables the same character to be displayed on monitors of
different resolutions, and to be printed out at a large number of different sizes.To scale a
character outline is a simple mathematical operation, as indeed are other
transformations such as rotation and reflections.

The user never actually sees the outlines stored in an outline font, because before a
character can be displayed on the screen or the printer, a bitmap has to be produced, by
the TrueType rasterizer. This is because screen displays and printers both use dot
patterns to represent images (sufficiently magnify any screen image or print-out, and
you'll notice the pixel pattern). The character outlines contained in the TrueType font are
scaled to the requested size, and are converted into bitmaps by turning on the pixels
encompassed by the outline. This process is known as scan conversion or rasterization.

Character sets and mapping
TrueType fonts also contain character maps - information concerning the types and
quantity of characters included in the font, and details as to how these characters are
accessed from the keyboard.

TrueType fonts on the PC and the Mac
Although TrueType fonts can be used on both the Macintosh and Windows platforms,
slight differences in the way each operating system handles the fonts lead vendors to
produce separate versions of the font for each platform. Some vendors will provide you
with both Mac and Windows format TrueType files, while others may treat them as
different products. Contact individual vendors for specific details.
This oddity arises because of the different file system used on the two platforms.
Information can be included in the font to determine whether the font can be used on
both kinds of system, or one or the other.
On a Macintosh, the TrueType font file is sometimes referred to as an SFNT and, under
Windows as a .TTF. The information contained in the fonts is the same, and making the

necessary adjustments to allow the font to run on both platforms is a relatively
straightforward task.

A brief history of TrueType
Article • 06/10/2020

The TrueType digital font format was originally designed by Apple Computer, Inc. It was
a means of avoiding per-font royalty payments to the owners of other font
technologies, and a solution to some of the technical limitations of Adobe's Type 1
format.
Originally code named "Bass" (because these were scalable fonts and you can scale a
fish), and later "Royal", the TrueType format was designed to be efficient in storage and
processing, and extensible. It was also built to allow the use of hinting approaches
already in use in the font industry as well as the development of new hinting techniques,
enabling the easy conversion of already existing fonts to the TrueType format. This
degree of flexibility in TrueType's implementation of hinting makes it extremely powerful
when designing characters for display on the screen. Microsoft had also been looking
for an outline format to solve similar problems, and Apple agreed to license TrueType to
Microsoft.
Apple included full TrueType support in its Macintosh operating system, System 7, in
May 1991. Its more recent development efforts include TrueType GX, which extends the
TrueType format as part of the new graphics architecture QuickDraw GX for the MacOS.
TrueType GX includes some Apple-only extensions to the font format, supporting Style
Variations and the Line Layout Manager.
Microsoft first included TrueType in Windows 3.1, in April 1992. Soon afterwards,
Microsoft began rewriting the TrueType rasterizer to improve its efficiency and
performance and remove some bugs (while maintaining compatibility with the earlier
version). The new TrueType rasterizer, version 1.5, first shipped in Windows NT 3.1. There
have since been some minor revisions, and the version in Windows 95 and NT 3.51 is
version 1.66. The new capabilities include enhanced features such as font smoothing (or
more technically, grayscale rasterization).
Microsoft's ongoing development effort includes the TrueType Open specification.
TrueType Open will work on any Microsoft platform and Apple Macintosh machine, and
includes features to allow multi-lingual typesetting and fine typographic control.
The next extension to the TrueType Open format is to be TrueType Open version 2, a
collaborative effort with Adobe Systems to produce a format capable of containing both
TrueType (and Open) and PostScript data.

Recommendation for TrueType Outlines
of Cursive Script Typefaces
Article • 06/10/2020

An issue with fonts that have connecting characters, like Arabic language fonts, is that
an overlap of a minimal size is required. This overlap is necessary to avoid issues where
rounding causes a column of pixels not to render, leaving a small gap in connection.
This break between characters can be seen in Figure 1 below.

Figure 1 - Pixel dropout caused by rounding
The purpose of this document is to recommend guidelines for font vendors to make
fonts that avoid this issue.

Glyph Design
When designing connecting glyphs to avoid pixel dropout caused by rounding, it is
necessary to provide for a minimum of a 70 font unit overlap when a 2048 em square
(recommended value) is used for TrueType outlines. The amount of 70 units will allow for
at least the width of the character to be maintained during the rasterization process at
all PPEM sizes.
To make the overlap most effective, the overlap should be totally on either the left side
of the glyph or the right side of the glyph. My recommendation would be that the
overlap would be on the trailing side of the glyph. Thus, for a cursive English font, the
overlap would be on the right side (see Figure 2). The overlap for a right-to-left
language would be on the left side (see Figure 3).

Figure 2 - Left to right language letters overlap on right side

Figure 3 - Right to left language letters overlap on the left side
Splitting the overlap to both sides of the font does not correctly resolve all situations
where rounding is occurring, as each side may round down and cause a column of pixels
to not render.

Fixing rasterization issues at low
resolutions
Article • 06/16/2022

From outlines to pixels
The outline of a glyph is a mathematical description of the glyph's shape using lines and
curves (Béziers).

The particular choice of curve is irrelevant. Both quadratic and cubic Bézier curves will
do, as long as we have control points. The control points are needed to scale the glyph
to the desired type size and resolution (or ppem size for short).
The screen is a regularly spaced grid of black and white dots (pixels).
To rasterize the glyph essentially means to turn on all pixels inside the scaled outline.

Doing so naïvely results in the above raster tragedy: disjoined arches, unequal stems,
missing serifs, etc.

What went wrong?
Control point coordinates are integers. There are no decimal places or fractional
numbers.
In TrueType, the design grid (em-square) is typically 2048 by 2048 font units.
In Type 1, the design grid is 1000 by 1000 font units. Type 1 allows decimal places.
But: 253.7 out of 1000 units is the same as 2537 out of 10000. Hence, for the sake
of the argument, there are no decimal places.
The pixel grid is integer as well, there are no fractional pixels either. E.g., at 12 pt
and 96 dpi, the em-square is 16 by 16 pixels. If the pixel grid were not integer, we
would simply round it. On screen, we can't tell 12.2 pt from 12 anyhow.

Scaling the font
What's left to do to scale the outline is to multiply all coordinates by 16/2048, i.e., first
multiply them by 16, then divide them by 2048.
The only thing that can (and will) go wrong is the division. Most integers don't divide.
Therefore, the computer will have to round some numbers. This is the same as to decide
for pixels. As a consequence of rounding, "things don't add up anymore." Something
always has to give way. Some things (distances, proportions) must not give way.

Notice that if we were to use fractional coordinates and/or allow fractional point sizes,
the computer still would have to decide for pixels. In the end, the problem with
fractional numbers is the same, it is merely more difficult to understand.

Hinting, grid-fitting, instructing
The computer has to be told, which things must not give way. This is what is colloquially
called hinting. More precisely, it is called grid-fitting or instructing, since we give the
computer precise instructions how to fit the outlines to the grid before turning on the
pixels. The purpose of hinting is to...
Preserve regularity of locations and distances
Preserve near-regularity of locations and distances
Preserve proportions
Control digitized appearance

Can't have the cake and eat it, too
We cannot have both the left and right edge of stem in the right place and have the
correct stem weight (correct in terms of pixels). We have to make a trade-off chosing
one of the following:
leftEdge + stemWeight = rightEdge
rightEdge - stemWeight = leftEdge
rightEdge - leftEdge = stemWeight
The trade-offs are the variables on the right. They will have to give way.

Control points galore
In TrueType, there is no concept of edges and stems. There are just control points.

There are on-curve points ( ) and off-curve points ( ). Both on- and off-curve points are
called control points.

VTT's "Show fewer points" hides the off-curve points.
We have to choose which control points we want to define the edge ( ).
x- and y-directions

A pair of control points defines a pair of edges, which in turn delimits a stem.

The "horizontal portion" of the distance (= the distance in x-direction, or dx)
between these control points defines the weight of a vertical stem
The "vertical portion" of the distance (= the distance in y-direction, or dy) between
these control points defines the weight of a horizontal stem

VTT's "Measuring Tool"shows measurements for both distances, in x- and in ydirections.

Vertical is x, horizontal is y?
This may be a bit confusing:

For a vertical stem, the relevant distance is in x (i.e. horizontal). We move the point in xdirection to fit it to the grid.

For a horizontal stem, the relevant distance is in y (i.e. vertical). We move the point in ydirection to fit it to the grid.

"Touched" points will be followed
"accordingly"

Suppose we have grid-fitted ("touched") the above points in y-direction to control the
horizontal stems. Now what about the other ("untouched") points?

They follow "accordingly," due to a pair of IUP instructions ("interpolate-untouchedpoints") in x-and y-direction that VTT adds at the end of the other instructions.

Always touch the "extremes":

If we don't "touch" all extremes, IUP can't interpolate all the "untouched" points
between pairs of "touched" points, only shift them along with the "touched" points.

This is probably not what we want. But we may still see this intermediate stage while
we're linking with "grid-fitting" turned on. Just turn it off, as desired.

A link to preserve regular distances:
So, the left and right edge of a stem is just a pair of control points. If we move these
points, the other points will follow "accordingly". Now then, let's give priority to the left
edge and the stem weight.
This is what the link tool is for. It defines a relationship between:
a parent point (on the edge from which we start out) and
a child point (on the edge which has to give way in the trade-off).

Linking across the stems preserves the weights of the stems.

Linking across the serifs preserves the weight of the serifs.

A link across a black distance keeps a minimum distance of one pixel.

bottomOfSerif + serifWeight = topOfSerif

Linking across the arches (and more):

prevents arches from "drop-outs".

The trouble with the outlines:

Notice the two links in x-direction across the left stem. We can see a stem, but the
computer cannot. It merely sees a bunch of unrelated control points. We have to relate
these control points by links or shifts, even though they are on the same edge of the
stem.
But why are there two links, rather than four? IUP[X] will take care of the others if there
is no gap between them.
Compare this to the vstem or hstem hints in Type 1.
There are really no stems, just control points:
How many links for the "Croatian d"?

Fortunately, this case is rare.

Also, there are different ways to do it.
Linking across the counters:

regularly spaces the stems. A link can entail another link, which in turn can entail a third
one etc.

A perfect 'm'?
The chain of links goes from the left to the right sidebearing in 7 steps. Each step may
be off by ½ pixel. Therefore, the right sidebearing may be off by 3½ pixels.
Trade-off: proportion (width vs. height), advance width, wysiwyg.
At 96 dpi, 3½ pixels is 50% of the x-height (of 7 pixels). In contrast, at 600 dpi, 3½ pixels
is only 8% of the x-height. How is that going to "line up" such as to see what you get?

Other linking strategies
We can link the left edges of the stems, rather than the counters, reducing the
chain to 4 steps.
Trade-off: counters, wysiwyg to a lesser degree.
We can link outside-in, not left-to-right, for unconditional wysiwyg. Trade-off:
spacing of stems for an odd number of pixels.
For an extra bold m we may wish to reduce the middle stem to 1 pixel.
etc.
Compare this to the vstem3 hint in Type 1. We don't have to know what it does,
nor can we do anything if it doesn't do what we want it to.

Other ways to go "too far"

A link too many would create a circular chain of links. This means that nothing can give
way. But we can't keep passing the buck around in a circle. Something always has to
give way.
An interpolation to preserve proportions:

This looks fairly acceptable at 12 pt and 96 dpi.
Proportions of the counters or location of the middle crossbar:

It is still fine at 10, but not at 8 and 6 pt. At 8 and 6 pt, the cap height must have
rounded down, while the location of the middle bar appears to have rounded up. The
proportions don't add up to the capheight.
An interpolation to place the crossbar:

The interpolation doesn't preserve a distance from a parent to a child. The interpolation
preserves the proportion of the distance from parent #1 to a child, relative to the total
distance from parent #1 to parent #2. It does so in terms of pixels.
The crossbars are all set:

We can interpolate the bottom edge of the middle crossbar and link to its top
edge.
Trade-off: This tends to push the crossbar up (but works fine for the B).
We can interpolate the top edge of the crossbar and link down.
Trade-off: This tends to push the crossbar down (which may be better for the A).
Compare this to the hstem3 hint in Type 1.
While we're interpolating:

One way to horizontally align the top bowl with the bottom one.
Proportionally placing strokes

This works fine with an interpolation. But we might just as well link them. A link across a
white or grey distance does not keep a minimum distance. Eventually, the distance
rounds down to 0 pixels, and remains 0 for smaller sizes (consistency).
A bad interpolation:

The interpolation doesn't work the other way round. We cannot extrapolate the position
of the bottom bowl relative to the top bowl. The child point has to be between the
parent points.
Placing children between parents:

At 8 and 6 pt, the point at the crotch between the two bowls is roughly in the center of
the middle crossbar, while at 7 pt it isn't.
A good interpolation:

Extremal points don't know where to go. We have to tell them. What were parent and
child for the link become parents for the interpolation.
Interpolations to keep children inside:

What a difference a pixel makes. Notice that this last interpolation is relevant to many
point sizes, although we're merely looking at one of them. The fact that the 6 pt B has
rather odd bowls is another problem, quite specific to that point size.
Control value table entries to control near regularities:

The B at 12, 11, and 10 pt: By design, the round vertical strokes are a bit wider than the
straight ones. We can't see this at 12 and 10 pt. In contrast, at 11 pt we can see a bit too
much.

The role of the control value table
The round stroke is just over 1½ pixels, which rounds up to 2 pixels. The straight stroke
is just under 1½ pixels, which rounds down to 1 pixel.
We need a common reference distance that both strokes can refer to. A control value is
a dominant width or length of a group of features such as the stem width or the serif
length. Control values are tabulated in the control value table (cvt). You'll have to
populate the cvt by measuring the character's features.
Compare this to blue values and dictionaries in Type 1.

How do control values work?
The pre-program (prep) scales the control values for the desired ppem size. In the prep,
we can adjust, at and below which ppem size the scaled cvt values for straight and
round strokes should be the same, and similar. Links can then use the respective values
from the cvt, rather than using the actual distance between the two control points. As a
result, we have

leftEdge + stemWeightFromCvtForRoundStrokes = rightEdge
leftEdge + stemWeightFromCvtForStraightStrokes = rightEdge

yielding the same stem weights for the set ppem size and below.

Which cvts to use?

Cvts are attributed by:
Character group (UC, LC, ...)
Link color (black, white, grey)
Link Direction (x, y, diagonal)
Feature (distance, straight or round stroke, left or right sidebearing, absolute or
relative height, ...)
VTT will pick the best match for a given attribute and the actual distance. We can
override this choice.

Using cvts

Compare this to hint replacement commands in Type 1.
We just put the right cvts in the right places, but we have to put them there at all. Then
we can override at what size a 1 pixel stem becomes 2 pixels. We can also override
whether e.g. the round strokes should be tied to the straight ones or vice versa for more
contrast at smaller sizes.

Other reason for cvts
Even strokes that appear to have the same weight sometimes don't.
Outlines may have been scanned in from hand-drawings.
Outlines may have been converted from other outline formats. For example, cubic
Bézier curves (Type 1) don't convert to quadratic Bézier curves (TrueType)
identically. The math can only approximate them, at the expense of the total
number of control points (and font size).
Straight lines are still a problem. For example, going from Type 1 to TrueType, the
conversion must scale from a 1000 by 1000 grid to a 2048 by 2048 grid. To do so it
has to multiply all coordinates by 2048/1000. The problem is the division, again.
We'll use average stroke weight for actual cvt value.

Other places for cvts

The O looks fairly straightforward to do. The question mark merely indicates VTT didn't
find a cvt for UC White X LSB.

Cvts for height guidelines

Cvts for height guidelines are a bit tricky. We have to store the absolute value (base line,
cap height) for the squares (like the H), and relative value (over- and undershoot) for the
rounds (like the O). We would like to link from the cap height to the cap height
overshoot and from the base line to the base line undershoot, using the same cvt both
times. But the O has no control points on the cap height or on the base line. Therefore,
we have to simulate this behaviour.

Anchoring control points on height guidelines

VTT will pick a cvt for the height if it is attributed as "Grey-Y-Absolute (or Relative)
Height" We can override this choice.
The 'O' with anchors and cvt numbers:

In daily font production, you may start with the heights and then go from there with
links and interpolates. But we first had to learn about things not adding up and how
links and cvts can fix this.
We use cvts for squares as well. Like this we can tweak the cap height for coordination
of the roman with the italic or the bold.
Compare this to the blue lines in Type 1.

Deltas for digitised appearance

Grid-fitting is
ppem size independent
pixel size independent
Links round strokes to the nearest number of pixels at any ppem size, and using cvts
makes them come out the same width. Links do not specify a number of pixels nor
address a specific pixel.
But after linking, we may be left with knees or elbows and other unfortunate pixel
patterns. First, we should make sure no link with round-to-halfgrid etc. can control this
pattern.
The final O:

A delta can e.g. at 12 pt/96 dpi (16 ppem) move the off-curve point at the top 1/8 pixel
to the left and another delta can move a point at the bottom 1/8 pixel to the right.
These deltas apply to
a specific ppem size
a specific pixel amount
We'll have to check and fix all sizes likely to be displayed on screen. We can insert a
delta between links and interpolates or add a bitmap for a particular size if this saves
many deltas.

Hand hinting vs. auto-hinting
Hand hinting requires a lot of work. While VTT makes it easier to learn and faster to do
the work, we still have to learn all the various hinting strategies and do the work.
Auto-hinting would be nice to have, but would you trust a computer to have enough
"taste" to make the right trade-offs, always?

What is the "right" trade-off, anyway?
Are the trade-offs always the same ones? Or are they different for different fonts,
usages, or customers?

The future of VTT may look into more computer assistance in cases where it can make
logical decisions or crunch numbers.

Summa summarum
The main difference between Type 1 and TrueType is:
A lot of situations you need not worry about in Type 1
A lot of situations you can't do anything about in Type 1
Which of the two should you put into an OpenType font? This depends on what
you'll use it for.

From typeface to font file
Article • 03/13/2021

Preparing a Typeface for TrueType
All typefaces and font sources need to be prepared before a TrueType hinting project
can be started.
Today two of the most common ways typefaces have been stored as sources are in an
Ikarus or a PostScript format. Many typefaces are drawn with bézier drawing programs
or commercial bézier based font programs and made into PostScript font files.
Acceptable print quality can be achieved with a bézier font program without the use of
standardized marking procedures required by professional type foundries. Often
designers mark béziers without paying attention to how exact the bézier point markings
are positioned. A higher quality process is necessary to prepare a font file for hinting to
insure that the minimum amounts of instructions are used in the final font file. An
example of a problem is if, a glyph is suppose to be on the baseline and it is not or if a
stem is suppose to be exactly straight and it is not, extra hints would be needed to make
them correct. Always keep in mind that if you start with bad outlines, you can't improve
them later.

Designing the outlines for Trebuchet
The current TrueType production process is split: with the design and hinting process
done on a Macintosh, and the testing of the font file on Windows.
Trebuchet was a project intended to be a clean screen reading font, as well as a scalable
printing outline font.
After working through drawings and individual images, I started the outlines using
Macromedia Fontographer 4.1 for the Macintosh. Starting with outlines I created for a
previous project, which was an unreleased grotesque style design.
Trebuchet is a sans serif typeface with modern geometric features. I used consistent
stem distances, accurate group height alignments and zero tolerances for straight
strokes and point alignments. This is not always the case in the design of all fonts,
especially less modern designs.
The methods I used in the design process for Trebuchet made it easy for me to also hint
the final font file.

After I completed the outlines, I used a method similar to the one described in the next
section. The only difference was I also used two additional professional tools: one an
outline conversion tool and the other a TrueType table tool. You can obtain similar
results with the method described below.

Preparing a Font with Fontographer 4.1
In this section, we'll discuss using Macromedia Fontographer 4.1 for the Macintosh to
create a TrueType file that can be used with Visual TrueType.
For information about how to draw using Fontographer and more indepth aspects of
the program, see the Fontographer User's Manual or an excellent book "Fontographer:
Type by Design" by Stephen Moye, Published by MIS Press (1995) ISBN: 1558284478.
Working with Fontographer, there are several settings and procedures you should be
aware of.
Launch Fontographer 4.1. Then from the 'File' menu select 'New Font...' A window is
displayed for an Untitled-1 font.
NOTE: The original versions of Fontographer were made to create PostScript fonts. The
initial default settings are for a Macintosh PostScript font.
Selecting the 'Element' menu and 'Font Info...' displays the Font Information dialog. Here
you can name this font, set the style, encoding, metrics and insert a copyright notice.
The name will be used to create a Fontographer file when a new Fontographer file is
saved. This name is also used when a font is generated from this Fontographer file for
font file names and font format table information. The style is used when creating a
family and Fontographer uses this field similarly to the name field. "Font Metrics" set the
font units for this font file. Font Metrics (or Units per Em) are by default 1000 and is the
standard setting for a PostScript font. In TrueType, for best performance, it is strongly
recommended that a TrueType font file be 2048 Units Per Em (UPEM).

Exercise 1: Setting font information and font metrics.
If you have not done so already, select 'New Font...' from the 'File' menu. Then select
'Font Info...' from the 'Element' menu. You should now have the Font Information dialog
displayed. Name the font by typing a name (ex: MyFont) in the Name:FamilyName field.
The default "Plain" style is set for the Name:Style name field. The field currently appears
blank, but by selecting the Style Name pop-up menu, the 'Plain' menu item is already
checked and selected. For the Encoding field we will keep the default encoding set to
Macintosh. The next fields are the Font metrics fields. We will scale all values in the Font

metrics field by 2.048. This sets the font's metrics to be at 2048 units per em. Set the
fields as follows:

Ascent = 1638, Descent = 410, Em Square = 2048, Leading = 0, Underline Position =
-272, Underline Width = 41. Click the 'OK' button.
You now have a font in 2048 UPEM. Next double-click the 'A' character (decimal # 65). In
the 'A' character window, draw an image. If you are familiar with Fontographer and
working in 1000 units you will notice the units displayed for point coordinates are
approximately twice as large as you might expect. (Actually 2.048 times as large.) Any
glyph copied from a 1000 unit font to this file will be automatically scaled to 2048 units.

Exercise 1-1a: Working from your Existing Typefaces
In the next exercise we will open an existing PostScript printer font, scale the font
metrics, create a TrueType font with Fontographer and discuss some other TrueType
tools.
IMPORTANT: Fonts are copyrighted software. It is a violation of most User License
Agreements to make a derivative work from such copyrighted software. Use only fonts,
which you have drawn or created and are the property of you or your company.
From the File menu select 'Open Font...' The dialog displays files based on the items
checked at the bottom of the dialog. Select one of your PostScript printer fonts. You
should now have a window displaying all the glyphs in the PostScript printer font. Next,
perform the steps we followed in Exercise 1 to scale the font metrics. Start by selecting
'Font Info...' from the Elements menu. Note that the values for Ascent and Descent when

added equal the Em Square. As we did in Exercise 1, scale all values in the Font Metrics
by multiplying them by 2.048. Click 'OK' and the font file is now in 2048 units.
It is common for Macintosh PostScript fonts to not contain some symbol characters as
outlines. If this is the case with your printer font you should create outlines or use a set
of standard symbol characters from your library. Select 'Save' from the 'File' menu to
create a Fontographer file.
Before we can output a TrueType font it is advisable to use composite glyphs for glyphs
that are built from one or more already existing glyphs. The 'Aacute' is an example that
should be made from the uppercase A and the acute diacritic.
To build an 'Aacute' composite glyph with Fontographer:
Select uppercase A glyph in the main character window.
From the 'Edit' menu select 'Copy Reference' (cmd-G)
Select the 'Aacute' character in the main window. Select 'Paste' (cmd-V) from the
'Edit' menu.
Select the 'acute' diacritic in the main window and select 'Copy Reference' (cmd-G)
from the 'Edit' menu.
Open the 'Aacute' glyph by double clicking on the 'Aacute' in the main window.
In the 'Aacute' window 'Paste' (cmd-V) the acute glyph.
Position the diacritic over the base glyph.
I have found the most effective way to create a composite in Fontographer, is to
get/paste the base glyph first, then get/paste the diacritic second. This is important
when it comes to working in TrueType later in the production process.
You are now ready to generate a TrueType font from the bézier outlines in
Fontographer.
Select 'Generate Font Files...' from the File menu. In the 'Generate Font Files' dialog you
can choose to select from the 'Easy' dialog items or the 'Advanced' dialog items. In the
'Easy' dialog items you can generate a Macintosh font or a PC font. In this example I use
and recommend using the 'Easy' dialog items and generating a Macintosh TrueType font
file.
Note: What is the difference between Macintosh and PC fonts? The Macintosh uses two
types of file formats: resource files and data files. Fonts on a Macintosh need to be
resource files. The basic TrueType font on a Macintosh contains a 'FOND' resource and
an 'sfnt' resource. The information in the 'FOND' resource is additional information
necessary for the Mac OS. The 'sfnt' is the TrueType font. TrueType data files are used by
Visual TrueType and are generated by either creating a PC font in Fontographer or by

converting the 'sfnt' resource into a data file. Additionally, the Mac OS uses information
on files called 'Finder Information' to identify file types. Fontographer outputs PC
TrueType fonts with different 'Finder Information' necessary for Visual TrueType.
The 'Finder Information' should be:
Type = sfnt
Creator = 'mdos', 'bass' or 'Bass' are common but not required.
A creator code is required and must be 4 characters.
You can change the 'Finder Information' with several applications including ResEdit.

Macintosh suitcase and binary data file.
Before generating a font file there are a few additional steps we need to take. The first
step is: By selecting 'Computer: Macintosh' Fontographer will generate a Macintosh
auto-hinted TrueType font suitcase. Since this is a resource file, Visual TrueType can not
open the file. Visual TrueType only opens data files. You will need to use an application
that can convert this Macintosh TrueType font resource to a data or PC TrueType font.
TrueEdit from Apple Computer is such a program. Apple font tools are available from
[fonts.apple.com](http://fonts.apple.com/).
The other step with generating a Macintosh font in the 'Easy' mode is a bug that does
not generate the 'yacute' and the 'multiply' glyphs. The work around for this problem is
the following:
1. Open the Element: 'Font Info...' dialog and increase the 'number of characters
allowed in font:' by two numbers.
2. Then copy and paste the 'yacute' and 'multiply' glyphs to the last two spaces.
3. Select the new 'yactue' (one click) and then 'Element: Selection Info...'(cmd-I). In the
'Character Information' dialog, enter 'yacute' in the 'Character name:' field. Then
click the 'Set Unicode' button. This should set the 'Unicode' field to $00FD (Note: In
Fontographer the dollar sign represents the value is expressed in hexadecimal.
Another common method is by using a preceding 0x or x.)
4. Click the 'OK' button and you should see an alert dialog. 'There are multiple glyphs
with that name. Do you want to swap the names of the two glyphs?' Click OK.
5. Now when you output a Macintosh font these glyphs will be generated and placed
at the end of the glyph order.

This method places the glyphs in a sensible order. This order is similar to the original
recommended order published by Apple Computer in the original TrueType spec. 1.0.
In item 3 above, by setting the 'Character name' and 'Unicode'; hex number we
accomplish two things. Fontographer uses this information when writing two tables in a
TrueType font file. The 'post' table contains a glyph index and is paired with a PostScript
name. The 'Character name' sets the glyph's PostScript name in the 'post' table. The
'Unicode' number is used when writing the Windows version of the 'cmap' (Character
Mapping table.) In the Windows 'cmap' the mapping is a glyph index to Unicode
number.
You can use this method of adding glyphs and glyph information to create large fonts
that cover more than one Windows code page (such as the WGL4 character set.)
Finally once you have output a Macintosh TrueType font suitcase, you can use the tool
TrueEdit. TrueEdit will convert a TrueType font suitcase to a TrueType data file that can be
used in Visual TrueType or on a PC running Microsoft Windows.

Exercise 1-1b. Creating the Data File for Visual TrueType
Launch TrueEdit. Open the suitcase file from the 'File menu'. Select 'Save as...' the 'Save
as...' dialog appears. Change the 'File type' to 'Bass file'. I use different file names and
extensions during different stages of the production cycle. When saving 'Myfont.suit' I
prefer to rename the file 'MyFont.fog.ttf'.
Note: Bassomatic and .bass were the original names given by Apple computer to some
of the early TrueType software. RoyalT was the first TrueType instruction editor and is still
available from Apple Computer. As Visual TrueType and RoyalT originally only opened
data files of the type 'sfnt'. The name Bassomatic comes from the TV comedy series
Saturday Night live. TrueType's original name was Apple Royal. RoyalT was a pun on the
word 'royalty.' Royalties were a common font licensing practice at the time.

Using Visual TrueType
Now that we have created a TrueType data file we can now start the hinting process.
In the next sections I will discuss hint preparation. I would suggest reading the text first,
then using your .ttf file you created in the previous section, follow the steps to measure
and hint your font.
To start off, I've used a sans serif font for the measurements because of its simple
design. Then when discussing hinting I use a more common serif example. The hinting

structures and philosophies for the serif can be easily transferred to a sans serif design,
by not including the hints for the serifs.
The method we used for generating TrueType from Fontographer created a TrueType
font file that is already 'hinted.' The hints were automatically generated by Fontographer
and are not of the quality of a well hinted font done by a trained Typographic
Engineer/Designer. Human intervention is essential in achieving a font that is clean on
the screen as well as from a laser printer.
Using Visual TrueType we will remove these automatic hints and replace them with well
thought out manual hints specifically designed for the current font.

Exercise 2-1a: Hint preparation.
Launch Visual TrueType. From the 'File' menu select 'Open...' and open your font. By
selecting from the menu, 'Views: Character Set' (cmd-9) and with your file preferences
set to 'glyph index based' you will see all glyphs in your font.
Next select 'Prepare Font...' from the 'File' menu. In the 'Prepare Font' dialog all boxes
should be checked. By clicking 'OK' 'Prepare Font' will remove the auto-generated hints
and import three templates to build three important tables. VTT builds a template 'Cvt'
table that we can later fill in with more font specific data. The two other tables that are
created are the 'Pre-Program' and the 'Font Program'. For an explanation of the 'Cvt',
'prep' and 'fpgm' See the appendix at the end of this document or see this document.

Creating the Control Value Table Entries
Before we can begin hinting individual glyphs we need to organize some data about the
entire typeface and the entire family.
In the Trebuchet family I have four fonts. A regular, bold, italic and bold italic. At low
resolution, I must keep the x-height, Cap, height, and all other heights constant across
the family. I need to keep the color of the regular and italic weights the same and the
bold and bold italic the same. I finally need to control the relationship between the bold
weights and the regular weight to show their weight difference at all sizes. To control all
these conditions there are several methods that can be used. One method is to insure
that if the original outlines are similar between fonts that their control values are the
same. It is common for the all fonts in the typeface to contain the same major group's
height Cvt values. In actual outlines, the stem weights of an italic font are often lighter
than the regular font.

NOTE: At printer resolution and high screen resolution, Cvt values will be unused and
the original distances will be used.
In cases where there are differences between fonts, a more robust approach could be
used. Some TrueType hints use a hinting method referred to in VTT as 'inheritance'.
Inheritance uses functions to copy values from a main Cvt to other dependent Cvts. The
method is employed for small ppem sizes and is not used above a defined ppem size.
We will use a simple method of inheritance later when we discuss the pre-program.
The general procedure is to compile control value information by measuring the
outlines in VTT. Then, when all four fonts are measured, compare the data. You may
need to average some of the values to make the family cohesive.

Measuring Outline Features
Visual TrueType uses four main character groups when using control values. Uppercase,
Lowercase, Figures and Other. Typographically the Other group consists of sub groups,
such as math or punctuation glyphs.
In Visual TrueType open the Cvt window from the 'Views: Control values' (cmd-4) menu
item. 'Prepare Font' has imported templates for Cvt, Font program, and Pre-program.
The first 28 entries in the Cvt are grouped in pairs. This is a hinting method Visual
TrueType uses for modifying heights to keep two values the same at low sizes. In this
hinting method the first Cvt value is usually the flat or base value, the second value is
the overshoot (distance from the base value.)
Example: In a font I'll call 'MyFont', if Cvt #2 is set to 1465. This is the vertical distance
the uppercase glyphs are from the baseline. The next value, Cvt #3 would be 25. This is
the distance from the baseline to the top of all round uppercase glyphs, minus the flat
glyph's distances. UC round distance = 1490, UC flat distance = 1465. Difference = 25.
This is a high level method of TrueType hinting that keeps round glyphs consistent with
flat glyphs unit there is enough pixels to display a round overshoot.
How this works...An Uppercase round glyph uses Cvt #3 as its height. Through a
function call made from the Pre-Program (/*Modify Double-Specified Heights: */) the
function reads in the value from Cvt #2. It then rounds that value from font units to
pixels. Next it reads Cvt #3 and rounds that value. Then it adds the two together and
finally writes Cvt #3 with that value.
In Visual TrueType we use some high level hinting concepts. Because of this, some Cvts
have been reserved for specific uses. It is important to not alter or change of these Cvts
or Visual TrueType will not behave as it was intended.

Cvts 0..36 are used for heights, Cvts 40..64 are reserved by the program's compiler and
Cvts 65..156 can be used for major group features. Cvts 157 and 158 are reserved for
flares and cups and are used by a portion of the Pre-program that will control flares at
small sizes. Reserved Cvts should not be removed. User defined Cvts can be added
beginning at Cvt #159.
Now we can begin the process of manually measuring individual glyphs.

Measuring heights
The first measurements are the vertical (Y) heights for groups of glyphs.

Measuring the Uppercase Top for Overshoot calculations.
The following guidelines can be used for calculating the font heights.
Cvt#0 is the ASCENDER_HEIGHT and is obtain by measuring the height of the
lowercase b, d, h, k, and l.
Cvt#1 is the overshoot amount for the ascenders. This maybe the lowercase 'f'
height if the height is actually taller than the other ascenders.
Cvt#2 (CAP_HEIGHT) is measured from the baseline to the visual top of the
uppercase 'flat' glyphs. Examples are: B, D, E, F, H, I, J, K, L, M, N, P, R, T, U, V, W, X,
Y, and Z. The value should be the point where hinting will originate from. Similar to
the baseline. This may not be the value at the top most of the glyph.
Cvt#3 is the top overshoot of the uppercase round glyphs. This value is calculated
by using the most common or average value from the uppercase round glyphs (ex:

C, G, O, and Q.) Measured from the baseline to the top of the glyph. Subtracting
the value by Cvt #2.
Cvt #4 (FIGURE_HEIGHT) is the value from the baseline to the top of the flat figure
glyphs. (ex: 5 ,7)
Cvt #5 is the figure top overshoot value.
Cvt #6 (X_HEIGHT) is the lowercase flat top value. Similar to the CAP_HEIGHT, this
is not necessarily the top of the lowercase x, but the visual top of the lowercase flat
glyphs.
Cvt #7 is the lowercase top overshoot value.
Cvt #8 (UC_BASELINE) this value is usually zero.
Cvt #9 this is the bottom uppercase overshoot. This value is usually negative and
the same absolute value as Cvt #3.
Cvt #10 (LC_BASE_HEIGHT) this value is usually zero.
Cvt #11 is the bottom lowercase overshoot. This value is usually negative and the
same absolute value as Cvt #7.
Cvt #12 (FIGURE_BASE_HEIGHT) this value is usually zero.
Cvt #13 is the bottom figure overshoot. This value is usually negative and the same
absolute value as Cvt #5.
Cvt #14 (DESCENDER_HEIGHT) this value is the flat descender value often
measured from the lowercase p and q. The lowercase g and j may or may not be
the same.
Cvt #15 is the descender overshoot value. Used if the round descenders (g or j) are
lower than the flat descenders.
Cvt #16 (PARENTHESIS_TOP) is the top of the parenthesis, brackets, and braces.
These glyphs are generally aligned to the lowercase ascender value. This value is
often the same as Cvt #0.
Cvt #17 could be used for a design where the one of the pairs of brackets or
braces overshoots the parenthesis height. Commonly this value is left as zero.
Cvt #18 (PARENTHESIS_BOTTOM) this is the bottom of the parenthesis. The value is
negative and often the same as Cvt #14.
Cvt #19 is the overshoot for the parenthesis. If an overshoot is used this value is
negative.
Cvt #20 (SUP_ao_BOTTOM) this value is for the 'a', 'o' ordinals and is often the
same as Cvt #24.
Cvt #21 this is the ordinal's overshoot amount and usually the same as Cvt# 25.
Cvt #22 (SUP_ao_TOP) this value is for the 'a', 'o' ordinals and is often the same as
Cvt #26.
Cvt #23 this is the ordinal's overshoot amount and usually the same as Cvt# 27
Cvt #24 (SUP_12_BOTTOM) this is the bottom of the flat superiors (superior one or
two.)

Cvt #25 is the round overshoot value of the superior three.
Cvt #26 (SUP_12_TOP) this is the flat top of the superior numerals. ( in a full set of
superiors the value is the top of the superior 5 and 7.)
Cvt #27 is the superior top overshoot value.
The Cvts from 28..35 were used by earlier versions of Visual TrueType for serif fonts.
These earlier versions used one Cvt entry for only vertical serif distances. Then a function
for hinting the horizontal direction of a serif.
The method I describe for hinting serifs requires Cvt entries for the horizontal direction
as well as the vertical direction. I've predefined Cvts for X and Y serif distances in each
main glyph group. I measure serifs usually by measuring horizontally from the right side
of the main stem to the right extreme of the right serif, from the left side to the left
extreme of the left serif. Vertically from the glyphs base to the top most extreme of the
serif.

Measuring the left outside serif.
The last Cvt in this section is number 36. This Cvt is used by a high level function for
italic strokes. In upright fonts this value is '0'. Later when we measure the italic fonts I
will explain how this is measured.
In italic fonts this value is the horizontal distance from the left extreme of an uppercase
stroke to the uppercase flat height. In mathematics, this distance is the 'run', hence the
comment '/ITALIC_RUN/.' The uppercase flat height would be mathematically called the
'rise'.

Regularizing actual distances to create a
consistent Cvt table
When you have measured the distances for the Cvt values, the actual common or
average values need to be coordinated for the entire font.
In MyFont, Cvt# 3 ,5 ,7 ,9 ,11 , and 13 are overshoot values. (The difference between the
round height and the flat heights.) The measurements of actual overshoot distances in
MyFont produced:
Cvt #3=27, #5=21, #7=21, #9=-25, #11=-20, and #13=-20.
It is a matter of personal preference as to how much you would like to regularize your
values. I find it easier, cleaner and a fundamental job of 'hinting' to regularize as much
as possible.
If we were to leave Cvt # 7 (lowercase top round) as 21 units and Cvt #11 as 20 units
(lowercase bottom round) the tops of the lowercase would be greater than the bottom
at least at one size.
In MyFont the difference between the largest value in a groups overshoot and the
smallest is very small. Comparing the three most important character groups,
(Uppercase, Lowercase, and Figures) the Uppercase average is 26 units, the lowercase is
20.5 units, and the figures are 20.
The values I used for the uppercase overshoot are 25 units, for lowercase and figures I
used 20. The difference of 5 units is not a great difference but at medium resolution this
is a significant amount for this font.
Note: Between character groups, values of 5 or greater units should be considered large
enough to make different from other values. Within a character group and on a major
feature such as an uppercase stem distance, a larger value (~10 units) should be
considered.
Now that we have looked at the height values we can compile the information for
MyFont.
0. 1509 /* ASCENDER_HEIGHT */
1. 0
2. 1465 /* CAP_HEIGHT */
3. 25
4. 1465 /* FIGURE_HEIGHT */
5. 25

6. 1071 /* X_HEIGHT */
7. 20
8. /* UC_BASE_HEIGHT */
9. -25
10. /* LC_BASE_HEIGHT */
11. -20
12. /* FIGURE_BASE_HEIGHT */
13. -20
14. -420 /* DESCENDER_HEIGHT */
15. 0
16. 1465 /* PARENTHESIS_TOP
17. 0
18. -420 /* PARENTHESIS_BOTTOM */
19. 0
20. 595 /* SUPERIOR_ao_BOTTOM */
21. -10
22. 1480 /* SUPERIOR_ao_TOP */
23. 10
24. 595 /* SUPERIOR_12-BOTTOM */
25. -10
26. 1480 /* SUPERIOR_12_TOP
27. 10
When measuring the top of the uppercase and figure heights, I found the round glyphs
such as the 'O' and the 'zero' were at the same height values. But the flat glyphs, the 'H'
and the '5' were different slightly. The 'H' was 1464 units and the '5' was 1470 units. This
is a discrepancy that may or may not have been intended in the original design. If I were
to leave the CAP_HEIGHT as 1464 and the FIGURE_HEIGHT at 1470 then the figures
would be one pixel taller at some sizes and the round figures would be force to be too
tall by the hints. I decided the figures and uppercase should be made the same. I
rounded the CAP_HEIGHT up to 1465 and brought the FIGURE_HEIGHT down by 5 to
1465. Then with the 25-unit overshoot these groups will align at low sizes. This type of
discrepancy is common and this is a good example of the kind of decisions involved in
hinting outlines. Other values, which may not be clear, are Cvt #22 and 26. In this font
there are no flat superiors to measure. The value was calculated by subtracting the
superior overshoot in Cvt#25 from the measured top of the superior three.

Measuring Stems and Strokes
The last major measurements we need to take for the Cvt is the groups' stem distances.
These distances are commonly:

Straight features, Round features, Diagonal distances and Serif distances. These can be
further divided into horizontal (X) and Vertical (Y), uppercase, lowercase, figures,
punctuation, superior figures, math and possibly many others.
The Cvt template that was imported by 'Prepare Font' contains some common
predefined Cvt values for a Latin font. Descriptions of the use of each predefined Cvt are
noted in the comments to the left of the Cvt and hex Cvt Attribute numbers.
We will measure the font distance in character groups, Uppercase, lowercase, figures,
other, punctuation, superiors, math and diacritics.
Starting with uppercase in the horizontal or 'x' direction we will measure the uppercase
H left and right stem. This is the UC, X, Straight or stem distance. Continue measuring
other uppercase stems and note their distance. Next measure the round uppercase
glyphs (B, C, D, G, O, P, Q, R, S.) Note their values. Measure diagonal glyphs (K, M, N, R,
V, W, X, Y, Z.). Measure diagonal strokes in horizontally perpendicular to the baseline (as
you would a straight stroke.)
In serif fonts measure the horizontal serif length from the uppercase stem out to the
most extreme point on the serif. Two Cvt are predefined, one for the shorter distance
and one for a longer distance. If all serif lengths are approximately the same, use only
on value.

Uppercase H left stem measurement.
The next group of Cvts are for vertical or 'y' distances. Measure straight stem distances.
Measure round 'y' distance, diagonal and serif. The 'y' serif distance is often measured
up from a point on the baseline to the top of a serif and from the CAP_HEIGHT to the
bottom of a serif.
Do the same for lowercase and figures. In the lowercase Cvt group, Cvts are predefined
for the i,j dot distances. The X distance is the horizontal dot distance, the first Y distance
is the vertical dot distance and the second Y distance is the white space from the top of
the i/j to the bottom of the dot.

Continue and measure distances as defined by the template's comments. For straight or
round features there is an alternate Cvt. This will be used if there are two major
distances. Initially only one measurement is needed.
Now that we have measured all major glyph distances, we can create some actual Cvt
values. The value used should be the most common distance, similar to but not
necessarily the mathematical average. When creating this Cvt value the distance for a
group's feature may be very similar or may contain two main distances. If this is the
case, it may be necessary to divide the distances into two or more groups. A simple
example is if a font has serifs of two basic lengths there are two Cvts used, one for the
shorter distance and one for the longer distance. A distance of 25 font units is a large
enough distance to require a new Cvt, but there is no 'golden rule' in preparing a Cvt.
Specific decisions need to be made on a per typeface basis.
In MyFont the distance measurements for the uppercase main glyphs are:

X_straight X_round
B = 200/211/198
C = 211
D = 200/209
E = 200
F = 200
G = 201/211
H = 200
I = 201
J = 198
K = 200
L = 200
N = 190
O = 210/211
P = 200/207
Q = 210/211
R = 200/211
S = 201/200
T = 201
U = 200/199

If we were to use the mathematical average for the uppercase x_straight distances the
value would be 199. But looking at the values the most common value is 200. Generally
it is best and easiest to use the most common and rounded value. Looking at the
x_rounds values, 210 would be a good common, rounded value. You should note the
uppercase N and S deviate from their group's main distance a considerable amount of
10 units. It is up to your discretion to use the larger common value or another closer
value for a glyph such as the uppercase N. At this stage there are not enough features
that deviate in this font to warrant an additional Cvt. When hinting a glyph such as the

uppercase S, you may decide it is best to use the smaller straight value instead of the
larger round value. In this font I would use the common, larger value for these glyphs
since the difference is not that great, I want to keep these features the same at small
sizes and actual distances will eventually be used at the larger printout sizes.
After you have measured and decided the value for each pre-defined Cvt from the Cvt
template, fill the values in the appropriate Cvt. Once you have completed filling in the
values compile the Cvt table by selecting 'Compile: Compile Selected Window...'
With experience measuring distances to build a Cvt will be much clearer when you know
how you will use these Cvts for hinting. Always keep in mind and as you hint more
glyphs in the font, you could add local glyph distances. Add these if two or more
features need to be kept the same pixel size. If a feature only appears once on a glyph,
consider this a unique feature and a control value is not needed.
Before we can hint we need to fill in three additional Cvts that are used in a more global
manner. Cvts 65, 66, and 67 are font wide inheritance Cvts. Inheritance is used to
globally control stem thickness by using one main Cvt for many Cvts. Cvt 65 is the main
Cvt and will be used to keep all stems at one pixel. Cvt 66 is used for controlling the X
direction above this one pixel size. Cvt 67 is used to control the Y direction
independently from the X direction above the one pixel size. Then at larger sizes,
approximately 30PPEM and above we use more specific group Cvts.
The general method of selecting values for these control values is:
Use the thinnest stem distance from the Cvt 65. Commonly the lowercase 'o' Y distance
is used. This is the distance that is meant to be one pixel. This will force larger distances
to stay at one pixel till we want to break away from this type of control. In MyFont the
value for Cvt 65 is the same as Cvt 72, lowercase, Y, straight.
For Cvt 66, the X direction, I use the dominant X distance. This is often the uppercase
stem. If that appears to heavy of a stem to use as a dominant control value another
common Cvt could be the lowercase X stem Cvt.
Cvt 67 is used for the Y direction and is often the same as Cvt 65 and the lowercase Y
distance.
Fill out Cvts 65, 66, and 67. Compile the Cvt window.

Without inheritance round stems are heavier than straight stems at small sizes.

Cvt Attributes

Most distance Cvts have a hexadecimal numeral and comment to the right of the Cvt
number and Cvt value. The hexadecimal number is call a 'Cvt Attribute'. The Cvt
Attribute helps the VTT compiler select an appropriate Cvt.
You can view the Cvt Attribute by selecting the hexadecimal number in the Cvt. Then
from the 'Edit' menu 'select Edit Cvt Attribute...' Example: The number 0x1241 attribute is
a lowercase, black color, X direction, stroke.
When links are made on a lowercase glyph, with the settings, straight stroke and use a
Cvt, the compiler would use a Cvt with this Cvt Attribute. The Cvt Attributes have been
set in the Cvt template and can be changed by using this 'Edit Cvt Attribute...' dialog.
Select various Cvt Attributes and notice the settings and how they relate to the
comment for the Cvt.

Hinting and Cvt Attributes
Here we are going to see how these Cvt Attributes are used. In the Main Window of VTT
we will enter a hint that should select an appropriate Cvt.
In a text font that has been measured and a Cvt created, display the uppercase O. (for
this exercise. If you don't have a fully filled out Cvt you can use Prepare Font and add
Cvt values for the uppercase X straight Cvt #68 and X round Cvt #70.)
From the 'Visual TrueType' menu, enable the menu item 'Show X Direction'.
The menu item, 'Show Y Direction' should be unselected.
Items 'Gridfit' and 'Pixels' from the 'Display' menu should be unselected.
Select 'Show Fewer Points' from the 'Display' menu.
In the Hinting Tool Icon bar, X direction tools should be enabled. Select the Xlink tool.
From the left most curve of the uppercase O, drag the Xlink tool to the other inner most
point.
Shift-click on the arrowhead. Select the round, Cvt, minimum distance tool from the
pop-up menu.
You should see Cvt #70 displayed in the Cvt Xlink symbol. Shift-Click on the symbol and
a Cvt pop-up will appear showing Cvt 70 with an attribute of (UpperCase Black X
Round.) Link from the right most outside of the uppercase O and the round Xlink Cvt
tool should remain as the default and Cvt #70 should also be automatically selected.

The VTT compiler used the attribute to select Cvt 70. The compiler also used the glyph's
group data of UPPERCASE. Imported when we ran 'Prepare Font', from the character
group data file (CharGrp.txt.) This group data appears in the top of every glyph's main
window.
Next shift-click on the arrowhead and change one of the Xlinks to a stroke/with Cvt. The
Cvt displayed should have changed to 68 and the arrow will change to a square icon.
This shows how the compiler uses the type of Xlink to select the appropriate type of
stroke. Next change the arrow again to a distance/with Cvt arrow (pointed arrowhead.)
The Cvt icon should contain a question mark indicating the compiler couldn't find an
appropriate Cvt for this link. If we had defined a Cvt with a Cvt Attribute of uppercase,
Black, X, distance, the compiler would have chosen that Cvt.
With a fully filled out Cvt, display the lowercase o in the main window. Again, select the
Xlink tool and link across the left round stroke of the o. Select the round arrowhead by
Shift-click on the arrowhead. Change the arrow to round/with Cvt. Cvt 83 should be
selected. Change the arrowhead to a stroke/straight/with Cvt and Cvt 81 should be
selected. And finally, select the distance arrow/with Cvt. Unlike the uppercase where no
Cvt was selected, Cvt 94 was selected. Cvt 94 is the distance on the lowercase i,j dot, and
has an attribute of X lowercase black distance. It was selected since this is the only Cvt
with the correct attributes for the Xlink we used. If there are two Cvts with the same
attributes, the compiler will pick the Cvt whose value is closest to the actual distance
between the two points in the link.

Begin Hinting
When hinting for the typeface family, It is usually best to start with the regular or normal
upright weight. Decisions made for stem thickness, overshoots and font heights are
most critical to the normal upright weight. All other weights and styles should be based
on the decisions made for the normal font. Common decisions are, when will the stems
turn from one pixel to two pixels. If the stems are two pixels too early for the normal
weight it may be difficult to hint the bold font so it appears bold. It would also be
confusing for the user if a normal weight font is too bold at a small size such as 12
point.
We will begin hinting by starting with the most important glyphs in the normal weight
font, the control characters. The control characters are the characters used for spacing
all others in the font and for deciding stem thickness' and breakpoints. In the uppercase
group the control characters most commonly used are the uppercase O for a round
control character and the uppercase H or uppercase I for a straight control character
and uppercase V for diagonals. All uppercase glyphs are spaced between both round

and straight control characters. In the lowercase the 'o' is used for the round and the 'n'
is used for the straight and the lowercase 'v' for diagonals. Figures are spaced between
the zero.
I start by hinting the control characters in the main three groups, uppercase, lowercase,
and figures. When those are complete, I then decide how to control when stems break
and how each group works with the other groups. After weight is decided, I then start
hinting the rest of the glyphs in the main three groups. When all main group's glyphs
have the main hints. I move on to spacing. I space the three main group's glyphs to a
finished quality.
Then I move on to the remainder of the font. All other glyphs are spaced between the
glyphs they are most commonly used with. For example, spacing math signs we use the
zeros. Punctuation such as the quotes or parentheses, use a combination of lowercase
control characters, other lowercase ascender characters and/or uppercase characters.
The 'T' is useful for spacing the ©, ®, and 'trademark' because it is usually the first glyph
that would hit on the right side during spacing.
When beginning hinting, first put the hint structure for the glyph so that it will control
the majority of sizes as best as possible. Then after you have hinted the main control
characters, look more specific to each PPEM size pixel shape and spacing at each PPEM
size. This specific hinting for specific sizes is done with changes to the main hints or by
adding exceptions with Delta hints.

Hinting the first glyph
I will use a serif text font of regular weight in the hinting example. This is a simple
common design and shows the use of serifs. Hinting a sans serif font is similar, minus
the links for the serifs. We'll begin hinting with the uppercase, starting with the 'O'.
The first thing to do is to control the vertical direction. We'll begin by controlling the
heights. In VTT with the uppercase O in the main window, show the Y direction, turn off
the X direction from the 'Visual TrueType' menu. Turn off gridfitting and pixels and select
Show Fewer Points from the 'Display' menu. Select the Ylink tool from the tool bar. Shiftclick on the top most point of the O, then select the round to grid icon. You should see
an empty Cvt icon with an anchor symbol on the point you have selected. Shift-Click the
Cvt icon and select Cvt #3 (UC, top, overshoot). Next select the bottom most point and
to the same as you have done to the top, except this time select Cvt #9 (UC, bottom,
undershoot). Compile these hints by selecting 'Compile this Window' (cmd-R) from the
'Compile' menu. Next we will control the top and bottom round stroke with a link and
Cvt. With the Ylink tool still selected, click and drag from the bottom most point to the
inner most point defining the round stroke. Shift-Click on the arrowhead and select a

round stroke, with Cvt and minimum distance. Cvt # 74 should have been automatically
selected. Use the same steps for controlling the top round stroke by linking from the
top most point to the inner most point defining the top round stroke. Cvt #74 should
also have been automatically selected. Compile the hints.
Now we will add the hints for the horizontal direction. Turn off 'Show Y Direction' and
turn on 'Show X Direction'. Before we can begin hinting the X direction, we must decide
what hint strategy we will take. The strategy will effect spacing and the width of the
bitmaps generated by the hints. We have several choices. Let's try hinting with each one
to see how it changes the image.

The first method of hinting the uppercase O
The first method is using the sidebearing points to link in to the main glyph from both
sides. This will keep the glyph from expanding outside the advance width and control
spacing most effectively. The problem with this method is, the glyphs will be
compressed or expanded as the advance width compresses or expands. Any rounding of
values will effect the width of the bitmap. This method is most effective if the font is
wide or expanded in style.
Start by selecting the Xlink tool from the toolbar. Link from the left sidebearing point to
the left most portion of the O. Shift-Click on the arrowhead and change it to a distance,
with no Cvt, and don't maintain minimum distance. This will not force a pixel of white
when the distance is too small. Now link across the left round stroke and change the
arrowhead to round, Cvt, and maintain minimum distance. Cvt #70 should be chosen.
Link from the right sidebearing to the left most of the O. Change the arrowhead to a
distance, no Cvt, and don't maintain minimum distance. Link from the right most point
on the glyph to the inner most right point defining the right X round stroke. Change the
arrowhead to a round, Cvt, and maintain minimum distance. Cvt#70 should be chosen.
Compile the hints.
Turn on 'Gridfit', 'Pixels, Show size run' and 'Show text string' from the 'Display' menu.
Notice when you turn off and on gridfit how the pixel pattern changes. Now from the
'Size' menu select '9pt'. Using the up arrow key move up in point sizes and pay special
attention to the relationship between the outside of the bitmap and the right and left
sidebearing points. When the sidebearing points and the outside of the bitmap are in
the same X location, there is no white space between that side and the next character's
origin point. Reset the size to 9pt or a lower size so there is no white space on either
side of the glyph. Notice how in the Text string on top, the repeated uppercase O is
touching. This is considered bad spacing. Select the Xlink tool. Shift-Click on the
arrowhead for right sidebearing link and change its properties to distance, no Cvt and

maintain minimum distance. The bitmap should compression one pixel and the text
string should now not crash together when the uppercase O is repeated.

The second method of hinting the uppercase O
A second method is to link from the right and across the glyph to the left. This method
will push all bitmaps to the left if any rounding causes values to increase. It is advisable
to have bitmaps pull to left if there is a choice of pulling left or right. In most
applications a blinking cursor will overlap the end of the last character typed. If a bitmap
is pulling to the right in its cell, the blinking cursor will eliminate the right portion of the
bitmap. The user would find it difficult to read those characters when they are typing.

The third method of hinting the uppercase O
The third method is to link from the left sidebearing and across the glyph to the right.
As with the previous method this will have the tendency to push the bitmaps to the
right.

The fourth method of hinting the uppercase O
A fourth method is to not use the sidebearings but just hint starting from a starting
point on the glyph. This is the least forceful method that will have the effect of rounding
a start point and that start point will control the origin of the bitmap. This is most useful
when a font has plenty of sidebearing space. The method also would require some
manual exceptions to the spacing at some sizes. But this is a good method of
maintaining the original position of the glyph.
I have decided for this current font, I will use the first method of hinting I described
above. Hinting from the sidebearings with the initial hint on the right side maintaining
minimum distance.
I will continue to use this method for all other glyphs. This will maintain some type of
consistency across the entire font. I may need to make exceptions for specific glyphs
and specific sizes.
After putting the initial hints on the uppercase O, select the uppercase H. We will return
to the O later.
As we did for the uppercase O, set the Y direction in the main window, turn off the X,
then turn off pixels and gridfitting.

Note: it is not a requirement in Visual TrueType to hint one direction first before hinting
the other. You may find it more intuitive to start hinting in the X direction.
Select the Ylink tool from the toolbar. Shift click on the bottom of the H in the Y
direction and select 'round to grid' from the floating palette. Next shift click on the Cvt
sign and select Cvt 8 for UC_BASE_HEIGHT. Repeat these steps for the other side of the
stem. Next shift-click on the top of the H and repeat the previous steps, but this time
select Cvt #2 for CAP_HEIGHT.
The next series of links will start off these points and will control the serifs. Link up from
the base point (Cvt 8) and link across the serif on the left side. Do the same for the right
side starting from this same base point.
Note: We do not need to touch all points when hinting. If two points are at the same
position and make an unbroken straight line, we can use either point for hinting and the
other point will travel with the hinted point. Because when the hints are compiled, an
instruction called 'Interpolate Unused Points' keeps these two points moving together.
Link from the top CAP_HEIGHT point across to the other side of the serif on the left side.
Then do the same for the right side. In all serif links Cvt 80 should have been chosen. If
not, Shift click on the Cvt sign and change the Cvt to the one you have set for UC, Y
serifs. When linking tight areas it may be necessary to zoom in to select or link to points.
The final two links in the Y direction will control the bar on the H. Select the YInterpolate
tool from the toolbar. Like from the top of the serif link to the serif link at the top of the
glyph. Next stretch the interpolation to the bottom of the bar. Now select the Ylink tool
from the toolbar and selected link to the top of the bar. Shift-click on the arrowhead
and change the arrow to a stroke. Cvt 72 or a Cvt appropriate for this bar should be
chosen.
You may now have a few questions.

Why did we link from the top of the serifs to control the
bar?
Linking from the top of the serifs will keep the position of the bar relative to how the
serifs expand or contract. The other method could have been use from baseline point
and the top of the cap height point as parents for the bar. Either method is acceptable.
You can try either method and pick the best method based on the pixel pattern you see.
When changing the links make sure you select the base point link and not a point that
hasn't been used. If you do you will create a new start point.

We also could have not interpolated the bar at all. Another method could have been to
shift-click on a point at the bottom of the bar, round that point to grid, then link up to
the top of the bar from there. This would make the bar have no relation to the other
hinted points. The bar would round to a location close to its original outline coordinate.
The effect would be that the bar would sometimes be high and sometimes be low and
generally its position would be inconsistent.

Why did we interpolate and round the bottom point and
not the top point on the bar?
If we use the top point as the child point in the interpolation, the bar would have a
tendency to round down and may cause the bar to be low. It is better visually for the bar
to be high as opposed to low, so I use the bottom point and if the bar can not be
centered it will be pushed up.
Compile the Y direction hints.
Now turn off the Y direction and turn on the X direction.
We are going to continue hinting the X direction in the same manner we hinted the
uppercase O, hinting from the sidebearings. Select the Xlink tool from the toolbar. Link
from the right sidebearing point to the right outside of the stem. Shift-click on the
arrowhead and change it to distance, no Cvt and maintain minimum distance. Link from
the left sidebearing to the outside of the left stem. This link will have the same settings
as the right sidebearing link. (the links remain at the last setting.) Now Xlink from the left
side of the left stem to the other side that defines the left stem bottom. Shift-click on
the arrowhead and select the stroke, Cvt, minimum distance arrowhead. Cvt 68 should
be auto-selected. Now do the same to the right side stroke. Select the point you just
linked to and link up to the point that is at the same location in the X direction and is on
the other side of the H bar. Shift-click on the arrowhead and change the settings to
directon, don't maintain minimum distance and no Cvt. This will keep the top of the
stem equal with the bottom of the stem. This link is necessary since the outline does not
continue up to the stem as it would for an uppercase I. Do the same for the other side's
stroke. Now we are going to control the serif's length from the left and right stems. Link
from the left side of the left stem and out to the top serif. Cvt 78 or 79 should have been
selected. Link out to the bottom serif and you should have the same Cvt selected.
If at any time a Cvt is not selected (?) then select the proper Cvt you have defined in
your Cvt table. A Cvt is not selected when one of the attributes of the current link does
not match any of the attributes defined in the Cvt table. Xlinks for the inside top serif
link may cross over the outline defining the bar of the H. This type of link would be a
gray and no Cvt will be found. The Cvt for serifs have attributes whose colour is white. It

is possible to define Cvts for serifs that are black, white or gray. I find this repetitive. I
just simply manually choose the correct Cvt.
Link from the other Xlink that defines this left stem to the top serif length. You may have
to manually select the Cvt. Xlink across for the bottom serif. Do the same for the serifs
on the right stem. Compile the hints.
Next we'll hint the main diagonal glyph. Select the uppercase 'V'.
Hinting diagonals are considered one of the toughest images to control. For the
uppercase 'V' in MyFont will use a Visual TrueType link called the 'stroke'. The stroke is a
high level hinting instruction that moves points in both the horizontal and vertical
direction. The basic concept of a stroke hint consists of two pairs of points that make up
the diagonal stroke. The pairs are the points across the bottom of the stroke and the
second pair is across the top of the stroke. Similar to an Xlink across a straight stroke,
but with a link for the bottom and the top.
For hinting the 'V' enable the X and Y directions. (You need to enable both directions
because the diagonal stroke works in both X and Y.) Drag across the left stroke from the
bottom outside point to the inner point at the crotch of the 'V'. Then drag across the
top of the stroke from the last on curve point along the straight portion of the outline,
to the other side to an on curve point which is the last point on the straight portion of
the diagonal's outline. The diagonal stroke link should have selected Cvt 76
automatically. If not select the Cvt for the uppercase diagonal stroke. Now for the other
diagonal start from the inner crotch point (which will be controlled by the first stroke)
and link across to the lower outside point across the diagonal. Then link across the top
of the stroke to the other side's last point along the outline's diagonal. The Cvt selected
should be the uppercase diagonal Cvt or the Cvt for the smaller uppercase X diagonal
Cvt.
Now select the Xshift tool and link to the serif from the left diagonal point (that has
been controlled by the diagonal stroke) to the serif end. Shift-click on the serif point you
have linked to and select round to grid.
The reason we used an Xshift instead of an Xlink is because on this diagonal we are
linking from a diagonal stroke. All the diagonal stroke's points will not be put exactly on
grid boundaries. If we use an Xlink from one of these points not on a grid boundary, the
point we link to will be rounded to a position similarly off the grid boundary. This is true
even if we use the link setting of round to grid. (What we call 'round to grid' is more
truthfully a round the distance setting.) This would cause unwanted results at higher
resolution when gray scale is applied.

Xshift and round the distance the same for the inside of the stroke and the other right
diagonal. And lastly X shift the point at the extrema at the center of the bracketed serif
and round this to grid. Now turn off the X direction. And begin hinting the Y direction.

X direction of the Uppercase V.
Shift-click on the bottom point and select round to grid and the Cvt for either the
uppercase baseline or overshoot. In my case I use the overshoot Cvt 9. Ylink up to the
point defining the crotch, with a distance, no Cvt and maintain minimum distance link.
Shift-click on the top right point and select round to grid and Cvt 2. Do the same for the
left side. YLink to both side of the serif and select the 'Y' serif Cvt 80. Do this for both
sides.
Finally we need to interpolate the points in the Y direction that were used in the Stroke
command. This not necessary but highly advised since it will create a much smoother
pixel pattern. In the Y direction, with the Y interpolate tool, select the top point we used
to anchor the top of the V to Cvt 2 and the bottom point we anchored to Cvt 9. These
are the parents of the Y interpolation. For the points to be interpolated (or child points)
select the points on both strokes that were used in the stroke command and are
between the parent points. We do not need to interpolate the point that is at the same
Y location as the bottom parent point of our interpolation.
Compile the hints.

Y direction of the Uppercase V.
Now we have hints on all three major glyphs in the uppercase, we will start hinting the
lowercase and the figure's main glyphs. Select the lowercase 'o' and use the same hint
structure as we used for the Uppercase 'o'. This time lowercase Cvt values should be
selected. After compiling the hints for the 'o' move to the lowercase 'n'. In the X
direction link inward as we did on the other glyphs and link across the left stem. Link up
to the point across the intersection of the top transition from the inside Xlink point. This
is similar to the link we used on the uppercase H to control the top of either stem. Link
into the right side from the sidebearing and then across the right stem. Now control the
serifs from the left and right side stems. Use the Cvt for the lowercase X serif, Cvt 91
and/or 92. Compile the hints.
Select the Y direction and have the X direction off. Shift-click to round the top and
bottom portions of the n as we did with others. Select the lowercase baseline Cvt 10 for
the bottom points and Cvt 7 for the top round point and if the left stem's top is on the
x-height select Cvt 6. (If the top of the left stem is not aligning to either the round or xheight you could link to it from the round top portion.) Use Ylinks with serif Cvt (93) for
the bottom serifs, as we did previously for the uppercase. Ylink across from the round
top portion to the inner point that defines the top stroke. Ylink from the top of the
round, to the top of the stroke that intersects the left stem. Here will maintain minimum
distance for this point and use no Cvt. Ylink across the stem to the other side. Select a
Cvt that is for an alternate or secondary feature. I have defined Cvt 85 as a thin alternate
straight stroke. I will use this same Cvt for the lowercase h, m, b, d, q, and r. Next we'll
control the top left serif. Here I have an extrema at the inside of the serif. I want to

round extremas to the grid in most cases. These extremas are the points that are at the
peak of an arch or straight stroke. The stem points we selected for the uppercase H in
the X direction were extremas. Here in the Y direction point 15 is an extrema. This point
should be used as a reference point for the other surrounding points. Ylink down from
the top of the serif point, which we used previously and rounded to the x-height, to the
extrema point 15. Use a distance, Cvt and maintain minimum distance link.
This is the first instance where we did not define a Cvt for a feature that should be used
in other glyphs. The top serif feature is repeated in several glyphs and we should control
them in exactly the same manner.

Detail of the top of the lowercase n.
Stop here. We should use a Cvt for the link from the top of the serif to the extrema point
15. This feature is repeated in other glyphs (b, d, h, I, j, k, l, m, p, and r.) Since we did not
see this when we were creating the Cvt we can add this new Cvt at number 157. (157 is
the next available Cvt.) Measure the distance in Y from the top of the serif to the
extrema in all the glyphs. Find a good average and create the new Cvt entry for Cvt 157.
To create a new Cvt. Open the Cvt window. Type the new Cvt number (157) followed by
a colon. Add a few spaces then type the Cvt value. After the value you can add a Cvt
attribute. By typing 'zero' and 'x' Visual TrueType will interpret this as a Cvt attribute.
Highlight the '0x' then from the 'Edit' menu select the 'Edit Cvt attributes...' menu item.
Set the attributes for this Cvt.
After compiling the Cvt window, we can resume hinting. Shift-Click on the Cvt symbol
and select the new Cvt 157.
Link across to point 17 with a distance, no Cvt and don't maintain minimum distance.
Link up to point 18 and use a distance, Cvt (93) and maintain minimum distance.

Compile the hints for the lowercase n.
Now hint the lowercase 'v' as we did the uppercase 'V' using the lowercase Cvts.
Move on to the final main glyph group, the figures. Open the figure zero and hint this in
the same manner as we did for the uppercase O and lowercase o, using figure Cvt
values. Hint next the figure 1. The hinting structure for the 1 is similar to the left side of
the lowercase n but without the break from the left transitional stroke. You can also use
the Cvt 157 for the top serif Y distance. Once you have completed the zero and one I will
move on to the next section, which is making the groups work together and controlling
stem thickness.

Controlling stem thickness, breakpoints and making the
font consistent
We only hinted three glyphs in the uppercase and lowercase and two in the figures
groups so we could compare all major features before hinting the rest of the glyphs.
Here we will be concerned with breakpoints and stem thickness. The items to look for
and questions to ask are:
Do the uppercase, lowercase and figures break evenly from one pixel to two, etc. If the
uppercase breaks before the others, for example, this would be a visual problem.
At what PPEM do the stems go from one pixel to two? If it is too soon (15PPEM) the font
will appear bold when it is actually lighter weight. 20PPEM is a good time for most
regular weight fonts to turn to two pixels.
When is it visually acceptable to have the rounds be heavier than the straight stems?
When do the overshoots appear? Are they always larger than flats once they first
appear? Are they consistent between groups? Should they be or is it ok for the
Uppercase to act differently than the lowercase?
Look at the font with gridfitting turned on and the text and size run displays on. In the
'File' menu select the 'Preferences...' menu item. In the dialog, type sample text in the
'Extra Text' dialog field, using the O, H, V, o ,v ,n, 0, and 1. Starting at 9PPEM look at the
thickness of all glyphs in the text string. Do not be concerned with odd pixel patterns,
here we are only concerned with thickness and breakpoints.
In MyFont the stems are turning to two pixels at 17PPEM. This is controlled by a section
of the Pre-program using Cvt inheritance set for below 17PPEM.
The Pre-program was imported when we ran Prepare Font. The inheritance portion will
use main Cvt for other Cvts to make them all the same distance until a specified size.

This is how we are controlling all to be the same till 17PPEM. We can alter the thickness
of all stems in the font by changing this main Cvt value or by using exceptions called
Delta hints that will expand or reduce this main Cvts value at specific sizes. To find the
inheritance section, Select 'Pre-program' (cmd-3) from the 'Views' menu. In the Preprogram window select 'Find' (cmd-F) from the 'Edit' menu. Search for the words 'use of
inheritance.'
You should see a description of inheritance that is followed by a comment for inserting
DeltaC instructions (see TrueType spec for the syntax on Delta hint instructions) to alter
the main Cvt 65. After that comment are two function calls to function 31 in the 'fpgm'
table.

CALL[], 66, 65, 8, 31

The first function call copies the value from Cvt 65 into Cvt 66 till 8PPEM. This '8' should
be changed to the PPEM size you want the stems to break to two pixels. I would suggest
starting at 17PPEM.
In the template Pre-program, the third value from the left in these function calls is set to
8PPEM. This value should be changed to a higher value for inheritance to invoked.

CALL[], 67, 65, 8, 31

The second function call copies Cvt 65 to Cvt 66 till 8PPEM.
This is the first use of inheritance in the Pre-program. Here we are starting the process
that will keep all stems one pixel till a size we want them to turn to two.
We finish the process with the next list of function calls for each group and the groups
Cvts.
The first group of function calls are for the uppercase. The first section of calls in the
uppercase group is for copying the X main Cvt66 to the other X uppercase Cvts till a
specified size

CALL[], 68, 66, 8, 3
.
.

From 0..16PPEM Cvt 66's value is the same as Cvt 65. Therefore copying Cvt 66 into Cvts
68, 69, 70, 71, 76, and 77 will make them the same as 65.
Above 16PPEM Cvt 66 is no longer equal to Cvt 65 but all the other X UC Cvts remain
set equal to 66.
Then above 31PPEM all the X UC Cvts are now back to their set values. This has the
effect of keeping all stems in all groups the same below 17PPEM and all X distances in
all groups the same between 17 and 30PPEM.
The next section controls the Y Cvts and copies Cvt 67, the Y main Cvt to all uppercase Y
Cvts. Above 16PPEM all Y stems use their own set values. These threshold values should
be tailored to each individual font.
To recap the weight control by using inheritance:
We first hint the control characters in the main groups.
View the font and decide at what PPEM the stems will remain one pixel.
Set the inheritance PPEM value in the first function call in the Pre-program from the
default 8 to the value the font will turn to two pixels. The value is often 17PPEM.
Decide at what PPEM size the groups can use there own Cvts and not the main
directional X or Y Cvt. Usually the X direction needs to be controlled to a higher PPEM
size than the Y.

Making Exceptions to the Hints with Deltas and Spacing
Now that we have set the inheritance values in the Pre-program to control the weights
we can now finalize the main portion of our font.
Begin with the uppercase control characters O, H, and V. For most text fonts, cleaning
up hinting can begin at 9PPEM. If we have a good solid set of hints our glyphs should
be finished for larger sizes above the 28PPEM. More ornate designs may require some
refinement at larger sizes than the more common text designs.
All fonts no matter how intelligent the hints usually need some type of conditional
statement to control hints differently at one size than at another. In TrueType, Delta
hints are used to make these exceptions.
Start by selecting the uppercase O. Select 9PPEM. That is the smallest size we will likely
be able to make the screen bitmaps clean. In my serif font the main hints are
maintaining one pixel on the right. My inheritance settings are insuring the stems are all
one pixel and luckily the bitmap pattern is symmetrical. The O is pulling left in its cell. At

this low resolution, this is a good bitmap. The width is faithful to the scaled original
width (not manually altered) and there is a pixel of white so it will not crash when it is
repeated.
I then will select the uppercase H to check to see if this is also pulling left or if it is
centering. If one control character pulls one way and the other centers then there is a
spacing problem. In the uppercase H there is zero sidebearings from the end of the
serifs. Visually it centers. I need to decide if I want to shift the right portion of the H over
one pixel or shift the left of the O over one pixel. I can shift these sections by using the
Visual TrueType XDelta tool.
To test which looks visually better, select the O in the main window, and then select the
XDelta tool from the toolbar. Shift-click on the left point which has an Xlink from the left
sidebearing and a pop-up dialog appears. Drag the cursor to the +1 value on the popup Delta ruler. The glyph and bitmap should compress one pixel. With the text string
displayed at the top of the window, you can compare the UC H and the UC O. Now the
spacing in the lower string of text should center. If you find the UC O to appear too
condensed then reverse the process for adding the XDelta. Shift-click on the point and
return the Delta ruler to the value of zero. This removed the XDelta and returns the
glyph's bitmap to the original position.
Next select the uppercase H. Use the same XDelta process. But this time move the point
with the Xlink from the right sidebearing, we can compress the uppercase H and space it
like the uppercase O. Look in the text string again and see if visually the H is now too
compressed for the font. Decide which image you would be most happy with, the O or
the H. Before we can finalize our decision, we should look at the way other like glyphs
space. View all the other uppercase glyphs and see if more center or more pull. If more
center than pull, it would be best to compress the uppercase O. If more glyphs pull left
then if would be best to force the uppercase H to pull left. Once you have a decision
verify how the lowercase spaces. If you original font is spaced properly the lowercase
should be behaving in the same manner as the uppercase. The goal is to select the
method that will produce the least amount of work. Sometimes there are half pulling
and half centering. In this case you have to choose one.
In my case my lowercase pulls left. I am happy with the image of the compressed H.
Also the H was a bit expanded at that size and making it one pixel narrower would not
hurt its readability.
After inserting an XDelta on the right side of the H, I will then move up the size to
10PPEM.
I will continue the process for 10PPEM the same way as I did for 9PPEM. Deciding
whether to position the control characters left or center. During this process I look at the

bitmap pattern after I have moved the glyph or made any changes to its spacing. I find it
easiest to correct this PPEM size for spacing and at the same time the visual bitmap
pattern.
In my font the bitmap pattern for 15PPEM of the uppercase O is not acceptable. It is
symmetrical but not smooth. In all four corners there are extra pixels which are causing
an heavy, blobby appearance. I can correct this by moving some of the hinted points
with Delta Hints.
By looking at the outline and bitmap pattern, if the outline were to move up at the top
and down at the bottom of the inner outline, this may be enough to remove the extra
pixels. By selecting the Y direction and the YDelta tool from the toolbar, shift-click on
the top inner outline point that is linked to controlling the top round portion of the O. A
pop-up ruler should appear. Slide the cursor to +4/8. This will move the Ylink point up
one half a pixel in the Y direction. The outline should now clear some of the pixels and
give a different, better pattern. The value of +4/8 should be enough to do the job. You
can test different amounts by increasing or decreasing this amount of movement.
The points that weren't touched by any hints move up as well due to a lower level
TrueType instruction. You can see this Visual TrueType Talk instruction in the VTT Talk
window (cmd-5). At the end of the commands is a 'Smooth[]' command. This command
is then compiled into a IUP[X] and IUP[Y] TrueType instructions (cmd-2). These
instructions move the points that haven't been hinted with the points that have been
hinted. The effect smoothes out the outline. The Delta tool can shift points individually
or with neighboring points. By shift-clicking we are moving the point and its neighbors
that smoothes the outline. This moves the point inline with the other hints and not after.
Moving points individually is useful only if a stray pixel is near a point and it can be
removed by moving the one point. It is more efficient to move points with Delta hints by
using the shift-click method.
Doing the same to the lower inner outline we now have a single pixel width image. In
my case I have a better image than without the Delta hints but my image is now not
symmetrical. I find that by moving the right inner and outer hinted outline points with a
shift-click in the X direction and the outer left hinted point +2/8 on the right and -2/8
on the left I now have a finished symmetrical image. This size is now complete for this
glyph.
Continue moving through the sizes till there are not spacing or image problems. Move
and reference other control characters as we did for the 9PPEM size. After completing
the uppercase O move to the uppercase H, then the uppercase V. Once the Uppercase is
complete use the same processes for the lowercase, figures and eventually the
remaining glyphs.

After all control characters are spaced and complete begin completing the rest of the
uppercase glyphs starting with the uppercase A through the Z. Reference the hinting
examples in the font MyFont.fog.ttf.source for sample hinting patterns on the remainder
of the uppercase, lowercase and figure glyphs.

Composite Glyphs
After all glyphs are spaced properly and the images have been improved we can finalize
the composite glyphs. These glyphs do not have Visual TrueType tools. We need to edit
the TrueType ('glyf' program) (cmd-2) instructions.
Fontographer built the composite instructions, if the font file used composites in the
original Fontographer file. Using the Get Reference menu item in Fontographer did this.
Select the 'Aacute' in the character/glyph set (cmd-9). Select the TrueType window (cmd2). The window is blank. (the instructions are in a binary form and not a readable form).
To view the instructions, compile (cmd-R) the window. Visible instructions are created
from the binary of the instructions. In MyFont the instructions that were written by
Fontographer are:

OVERLAP[]
OFFSET[R], 36, 0, 0
OVERLAP[]
OFFSET[R], 141, 399, 334

The first instruction is OVERLAP[]. This is a instruction intended to be informative and
labeling all glyphs because there is suppose to be an overlapping composite (a
composite glyph who's component's outlines overlap.) All forms of Microsoft Windows
do not support this OVERLAP[] instruction. We do not recommend overlapping contours
in TrueType fonts because on some PostScript devices these areas appear white and not
black as intended. If you have a glyph which has a diacritic that joins the base glyph it is
best to join these outlines and not to make a composite glyph. The 'Ccedilla' glyph often
is a joined C with cedilla. This should not be a composite.
Remove the OVERLAP[R] instructions in the composite glyph. Compile (cmd-R) the
TrueType window. You should now have:

OFFSET[R], 36, 0, 0
OFFSET[R], 141, 399, 334

Next before the first OFFSET[R] instruction insert the following command:

USEMYMETRICS[]

Compile (cmd-R) the TrueType window. You should now have:

USEMYMETRICS[]
OFFSET[R], 36, 0, 0
OFFSET[R], 141, 399, 334

The USEMYMETRICS instruction forces this glyph to take the metrics (advance width)
from the glyph specified in the first OFFSET instruction. The OFFSET instruction is made
of 3 arguments and one Boolean flag. The Boolean flag is set so the bitmap of the
composite matches the original bitmap shape. This is set with the syntax of 'R'. The first
argument is the glyph index for the component. The next value is the X offset amount in
units per em. The final value is the Y offset. Base glyphs should always be first and
usually have zero offset amounts for both X and Y. The second OFFSET is the diacritic.
The X offset is for centering the diacritic, and the Y is usually constantly the same for all
Y distances in all composite glyphs. Since the diacritics are positioned for the lowercase
they need to be shifted up. If the diacritics are all properly aligned, they can use the
same Y offset.
The values for positioning the diacritics are set for high resolution and when properly
set give good results at most sizes. At small sizes rounding can effect the position of the
bitmap. We use a high level TrueType function which will help keep the diacritic
centering over the base glyph in X and a second that will make sure the diacritic does
not round down into the top of the base glyph.
Open the Font Program (cmd-7) window from the Views menu. Find (cmd-F) 'Function
79'. This is the function used for insuring a glyph is not touching the top of a base glyph.
The next function #80 is used for positioning the diacritic in the X direction.
To use these functions we need to add a CALL instruction in each composite glyph's
local TrueType instructions (cmd-2). In each function there is a comment showing a
sample of the syntax for the CALL instruction.
First well add the call for the X direction. For correct results we need to use the function
for the X direction first. Function 80 uses 5 arguments. The first is an offset value that
can be applied to the diacritic. This is usually unnecessary and set to zero. The next two

values are point numbers from the outline of the diacritic. The four and fifth values are
two point numbers on the diacritic. The final value is the function number.
The syntax for CALL 80 is:

CALL[], 0 , A1, A2, B1, B2, 80
SHC[2], 2

A1 and A2 should be points from the diacritic. B1 and B2 should be points from the base
glyph. The next instruction shifts the contour number 2 (the diacritic) if it is not already
between the base glyphs two defined points. It is acceptable to repeat the point number
from one or both sets of point values. To use one point on the diacritic and one on the
base glyph you would set the arguments to A1, A1, B1, B1. (In MyFont the actual values
would be 33, 33, 17, 17.)
The instructions for MyFont for the X direction are:

USEMYMETRICS[]
OFFSET[], 36, 0, 0
OFFSET[], 141, 399, 334
CALL[], 0 , 33, 36, 17, 18, 80
SHC[2], 2

Now we can add the Y function. For this direction we need to know a point number at
the top of the base glyph and a point number at the bottom of the diacritic. In MyFont
the point 18 is one of the points at the top of the A. Point 33 is a point at the bottom of
the acute.
The syntax for CALL 79 is:

CALL[], 2, B1, A1, 79

The first number '2' is the contour number to be shifted. The first and second contours
are the base glyph 'A'. Contour numbering starts at zero. (In this glyph there are
contours 0,1, and 2) The third contour is the acute and is referred to by number 2. The
next number is the point at the top of the base glyph and the second the point at the
bottom of the acute. The last number is the function to be called.

The final instructions for the 'Aacute' are:

USEMYMETRICS[]
OFFSET[], 36, 0, 0
OFFSET[], 141, 399, 334
CALL[], 0 , 33, 36, 17, 18, 80
SHC[2], 2
CALL[], 2 , 18, 33, 79

After adding the two calls to the TrueType window, compile them (cmd-R).
You will need to repeat these stems in all your composite glyphs. In glyphs that have
diacritics below the base glyph the Y function should not be used. An example of this
glyph is a sans serif 'Ccdeilla'. The Y function does not ship diacritics down, only up.
Other problems that could arise are usually caused by some syntax or manual change to
a diacritics position. An example of a problem is, if the diacritics are poorly positioned
vertically and the composites vertical positioning in the uppercase is poor, then you may
mistakenly alter the height in the main diacritic. When the lowercase composites
diacritics are vertically high and the uppercase are fine, some hinters have manually
added Delta hints to lower the diacritic in the base glyph. Then when the uppercase
composites are using this same glyph the diacritic is actually now below the top of the
base glyph at this PPEM size. When the Y positioning function is called it does not shift
this diacritic because the distance is not equal to zero but it is a full pixel less than zero.
The Y positioning function only works when the diacritic is above and the distance is
zero between the diacritic and base glyph.
If the Y function is called before the X function the X positioning maybe unpredictable.
Always call the X function first.
In composite glyphs with diacritics that contain more than one outline, (bollé and
dieresis) to calls are necessary for the Y direction and two shift contour calls are required
for the X direction.
In Trebuchet Bold, the instructions for the 'Adieresis' are:

USEMYMETRICS[]
OFFSET[R], 36, 0, 0
OFFSET[R], 142, 44, 370
CALL[], 0, 14, 32, 5, 6, 80
SHC[2], 2

SHC[2], 3
CALL[], 2, 5, 17, 79
CALL[], 3, 5, 29, 79

The first line sets the metrics from the first OFFSET glyph's metrics.
The second line calls the base glyph 'A' who's glyph index is decimal 36.
The third line calls the diacritic 'dieresis' glyph index 142 and shifts it over 44 in X and up
370 units in Y.
The next line is a function call for positioning in 'X'. It positions the point 14, that is the
left dot's inner point and point 32, that is the right dot's left inner point, Between the
two top points of the base glyph, points 5 and 6.
The next two lines shift contour number 2 (left dot of the dieresis) and contour 3 (right
dot of the dieresis).
The final two lines are for Y positioning. The first call checks to see if the left dot of the
dieresis is touching the base glyph and the second call checks the right dot of the
dieresis. The first set argument in the CALL is for contour 2, the left dot and contour 3,
the right dot. Point 5 is a point at the top of the base glyph and is used in both calls.
Point 17 is at the bottom of the left dot of the dieresis. Point number 29 is at the bottom
of the right dot of the dieresis.

Begin Finalizing the Font File
After we have corrected any problems with composite instructs and added functions to
correct any spacing errors, we can tidy up any remaining glyphs.
During the hinting process values in the font files may have changed. The first process
after hinting is to update the font files values that are stored in the 'maxp' table. To
update this table select the menu item 'Recalc 'maxp' table...' from the 'File' menu. In the
alert dialog click the yes button.
The next feature in the font we will set is for control of when a gray scale device such as
the Windows rasterizer displays gray-scaled images. Setting values in the 'gasp' table
can control gray scale. In the 'File' menu, select 'Edit 'gasp' table...' In the gasp table
dialog, the values are set to default amounts. On the left are the entries for the
maximum size the settings on the right will be employed. With the default values when
glyphs are displayed below 8 PPEM they will not use hints and will use gray-scaled
images. From 9 PPEM to 15 PPEM hints will be used (Grid fit) and gray scale will not

resulting in black or white images only. Above 15 PPEM both hints (Grid fit) and gray
scaled images will be displayed. To set this table in your current font, I would
recommend using gray scale, without grid fit below 8 PPEM. I would use "grid fitting,
without gray scale" from 9 PPEM to when the stems turn from one pixel to two pixels.
Then from the two pixel PPEM and up "use grid fit and gray scale" for all other sizes.
In the main window select the uppercase O. Note the PPEM size that the first image is
two pixels in stem thickness. In MyFont it is 17 PPEM. Then select from the 'File' menu,
'Edit 'gasp' table...' Change the second default setting from 15 PPEM to 16 PPEM. Click
on the 'Set' button. This sets the 'gasp' table so on a gray scale device, gray scale should
be used above 16 PPEM.
Next, from the 'Display' menu, enable the 'Gray scale' menu item (the 'MS Rasterizer 1.7'
will automatically be checked.) With pixels and grid fit turned on, view several of the
lowercase and uppercase glyphs in the font. In Visual TrueType the 'gasp' table will not
be read. When Gray scale is turned on in VTT it will be on for all sizes. View the glyphs at
sizes that have gray scale and the images are one pixel in thickness. Notice how
diagonal and round images that are not fully covering pixels are now gray. In some
areas such as on a lowercase v, the thin diagonal strokes appear fuzzy and faint. This is
the reason we suggest turning gray scale on only when you have enough thickness to
show two pixels. If you find even when the font is two pixels some features appear faint
or poorly defined. Try viewing them with out gray scale turned on in VTT. If you find the
non-gray image clearer, reset the value in the 'gasp' table to above the recommended
value.
To view images at the default value (4 times over scale set in the VTT Preferences), your
monitor setting needs to be set for 16 colors (or grays) or higher. If your monitor setting
is less than 16 colors you may see unexpected results or what would appear to be
missing pixels. These missing pixels are actually gray values that can not be displayed in
the black and white mode.
After setting the 'gasp' table we can now begin the final steps before shipping the font.
Last major step is verifying your work, commonly called 'proofing' the font.
The proofing stage of font production is a large part in creating a good TrueType font.
The two main stages of the proofing parts of font production are for esthetic evaluation
and technical font file verification. The first stage should be the esthetic evaluation of
300 dpi printout and low resolution screen proofing. After the esthetic evaluation is
finished the font files technical stability should be tested.
The esthetic evaluation stage should be done more than once before the font is
finalized. More correctly this evaluation is done in stages during the hinting production
cycle and completely at the end of the hinting cycle. The first time esthetic proofing

should begin is when there are sufficient glyphs with hints. These hints can be checked
to see if they are controlling the glyphs properly at 300dpi printer resolution. You should
check to see if the hints are too strong or have errors that were not apparent at screen
resolution but now deform the outlines at printer resolution. Proofing of the entire font
should be done also before the font is shipped.
Proofing and testing of font files at Microsoft is done by installing the font file in
Windows 95 and later in testing on Windows NT, Windows 3.1 and the Macintosh OS.
Before we can move the font to Windows we need to create a usable binary version
from our Visual TrueType source file. As we have added hints in Visual TrueType,
additional source information has been added to the file. This text information allows us
to view the hints and instructions in a human readable manner. The text information is
necessary when editing or revising the hints in Visual TrueType. This file format is similar
in concept to the way software engineers use source code to write applications and then
compile this source code into machine language.
Before we install the TrueType font in Windows, we will remove the extra source code. In
Visual TrueType, select 'Ship font...' from the 'File' menu. When you select 'Ship font...',
you will be warned in the dialog that it is advisable to rename the font file so you don't
overwrite the source data. If you do overwrite the source file you have been working on
in Visual TrueType, you will not be able to edit or append the hint information in the
font.

Do not overwrite your source file when running
'Ship font'
This additional source text information is required to make corrections. It is common
practice when hinting with Visual TrueType to name the source file 'MyFile.ttf.source'. It
is also common to rename this file to 'MyFile.ttf' or 'MyFile.ttf.stripped' when you are
complete and ready to strip a copy of the font file.
After you have renamed your font and run 'Ship font...', you need to move the file over
to a server that can be read by both Macintosh or Windows. Windows NT Server
supports both operating systems. You also can use a diskette formatted for a 1.44Mb or
720k PC drive and a Macintosh that can read PC diskettes.

Font Testing Tools
There are several steps to prepare the font for testing and several tools to run.

The first step is to calculate some new tables based on the new hinting information.
With the tool 'Cachet.exe', a Windows console tool, we can calculate the 'VDMX', 'LTSH',
and 'hdmx' tables. These tables help performance and the visual appearance of the
images in the font.
For full explanations of the 'VDMX', 'LTSH', and 'hdmx' tables, see the OpenType
Specification.
Copy the .ttf font file from the diskette or server to a directory with the cachet.exe tool.
Double-click on 'dosprmpt' in the c:win95 directory. This will display an MS-DOS console
window either full screen or in a tiled mode (tip: with ALT + Enter the console window
will toggle between maximize and tile.)

Some basic MS-DOS commands.
CD
will change the directory to a specified directory.
Ex: 'CD win95' will make the current directory win95
CD..
will change the directory one level up.
Ex: If at the prompt the current directory displayed is C:win95system , CD.. will make the
current directory C:win95
DIR
displays the contents of the current directory.
DIR .
Displays the sub directories in the current directory.
.*
mean all files. '*.ttf' means all file with the extension .ttf
DEL
deletes files
DEL *.ttf
deletes all files in the current directory with the extension .ttf.
The structure of a hinting and testing cycle is the following:
1. a source file contains all editable information and is the master file.
2. Run 'Recalc "maxp" table' from the VTT 'File' menu on the source file after all
hinting is complete.
3. Create a second stripped file from the source file by selecting 'Ship Font...' from the
VTT 'File' menu to strip out extra information used by the editor.

4. Copy the file to Windows and run CacheTT to generate some new tables.
5. Load the font into Windows and print and view the font with WordPad.
6. Run Flint to validate all instructions and tables.
The first tool we will use is cachett.exe. CacheTT is a NT Console and Windows 95 DOS
application. It creates and or modifies the VDMX, hdmx, and LTSH tables by calculating
values from the TrueType rasterizer.
After the font is hinted it is necessary to calculate the current metrics information at
specific sizes. If the hints are controlling the advance width by moving sidebearing
points the values for the advanced width when scaled will not match the actual hinted
version at a specific size. CacheTT uses the rasterizer to calculate the actual width in
pixels and store it in the 'hdmx' table.
Vertically, hints may cause glyph bitmaps to be one or more pixels less or greater than if
there were no hints and the outlines values were just scaled. In Windows, these bitmaps
images if not calculated and the original metric information is used by Windows, will be
clipped if they exceed the known cell height. The VDMX table stores the actual height in
pixels after hinting for specific sizes so bitmaps are not clipped.
The LTSH table is calculated to help performance by telling the rasterizer when it can
expect the font not to have hinted widths.
For a full explanation of these tables, refer to the Microsoft OpenType Specification

.

Change the current directory to the directory with the cachet.exe tool. In my example,
My current directory is C:win95. At the prompt I type CD toolscachett . My cachet.exe
resides in a sub directory of a directory on the same level as the win95 directory.
Run cacheTT by typing:

cachett myfile.ttf myfile2.ttf

at the DOS prompt. Cachett will recalculate or create by default a VDMX, hdmx and
LTSH table. For a full explanation on the default settings and how to customize cacheTT
see the CacheTT user guide 'cachettug.doc' supplied with the tool.
After you have created the new file with the cacheTT you can now use this font in
Windows applications. Copy the file into the Fonts folder in Windows 95. I create test
documents with Microsoft WordPad. WordPad is a simple word processor that is useful
for proofing fonts. I use these documents to check color, recheck spacing and generate
higher resolution printout on a laser printer.

If you find problems that you wish to correct, make those corrections to the original
sources file. Then rerun Ship Font and Cachett on this corrected file.
After you are completely happy with the estectic look of your hinted font file you are
now ready to being the final test on the TrueType font file information.
The tool Flint is a Windows 95 application that uses the rasterizer and reports if there
are any warning or errors with any of the instructions or tables in the .ttf file. Examples
of warning or errors are that an instruction is referencing a Cvt value that does not exist.
This would be considered an error which should be corrected.
Lauch Flint. From the File menu select 'Choose Font...'. Select your .ttf file. From the
Settings menu select Size. Leave the resolution at 72x72. Set the size to the desired
point sizes. I would suggest 4-500 point. To select how Flint will report errors, select the
Output menu item from the Settings menu. By checking 'Output results to file' you can
elect to have results saved in a .txt file. You also can set the tolerance Flint will use to
test hints. If a hint moves an outline point more than this set value a warning is given.
This is to check that any hints that are not intended are found. Or it is possible to
mistakenly move the wrong point or Cvt and cause distortion of the outline. The default
setting is 5.000. The value is in pixels.
After you have selected the output method you are ready to process your font. Select
Run from the Test menu and the font will be processed.
After you have corrected any errors in the font by fixing them in the source file it is
important to re-run all steps.

Prepare the Remaining Family Members
After completing the testing and corrections for the regular weight font. The next font
we will process will be the italic font. The italic font's height distances should be the
same as the regular weight font. Italic font's stem widths are generally smaller than their
upright family members are.
When measuring the stem distances we will not try to match the regular distances and
falsely force the stems to be the same. Use the correct distances for each font. Then
during hinting we will make sure through inheritance and hint controls that break points
for stem distances are keep consistent between styles.
Create a .ttf file of the italic font with the same steps we used in processing the regular
font. Once the .tff is created open the file in Visual TrueType. Next run 'Prepare font...'
Measure the italic groups as we did for the regular font and create a Cvt table.

In creating the Cvt table we need to measure one additional value. This value is called
the 'Italic Run' and is used by the stroke command. It is found at Cvt #36.
In Visual TrueType, open an italic font. Select the measure tool from the toolbar.
Measure the italic angle, which best represents, the angle of the typeface. Usually this
can be done from the UC I, UC H, or LC l.
If the design is serif and it is difficult to find two points that are from the baseline to the
Cap height, place the measure tool at an imaginary line that is parallel to and extends
from one side of the italic stem to the baseline. From the baseline measure to the top of
the uppercase glyph and along the italic stem. The value displayed in VTT as 'dx' is the x
distance or the italic run. In my case the value is 399. Add this value to the Cvt table in
Cvt #36. Compile the Cvt window.

Measuring the italic run.
Before we begin measuring stem distances, we should add the Cvt font wide inheritance
values. We want the stems to be consistent with the regular weight so we will use the
values for inheritance from the regular weight. The values I used in the regular weight
were 74 for the thinnest single pixel control, 193 for the main X control taken from the
uppercase stem, and 74 for the main Y control taken from the Y stem distance of the
lowercase. Enter your values in Cvts 65, 66, and 67.
Now we can begin measuring the X and Y stems. Begin in groups as we did with the
regular weight. When measuring X stems in an italic we will measure diagonal stroke
distances. The measurement is taken from the left side of the main stroke to the right
side, parallel to the baseline.

Measuring an italic stem.
For Y stroke measurements there are few Y diagonal strokes. The only possible Y
diagonal strokes may be on a lowercase and uppercase K. The Y measurement is taken
perpendicular to the baseline from one side of a diagonal stroke to the other.
The measure tool will snap to the outline if there is no point near the area that you have
selected. The line of the arrow will be straight when the cursor is dragged parallel to the
baseline for X measurements or dragged perpendicular for Y measurements. X distances
may be slightly thinner than the stem measurements of the upright style font of the
same weight. In my italic font my distances were averaging 178 units. The regular weight
was 200 units.
When measuring round distances select the extrema points you will use for the X links.
In my italic font the measurements were consistently 210 units. (Comparatively the
regular weight was 210 units.)
In X straight distances there are no straight stems in the italic. The Cvt value for straight
stems can be set the same value as the groups major X diagonal distance or used as an
alternate manually selected Cvt for larger or smaller diagonals.
For serif X distances we will not use a Cvt. The serifs protrude in X from a diagonal
stroke and are not consistent distances from the main stroke of the diagonal. In the
hinting stage we will use an X shift and round to grid (anchor) method of controlling the
serifs.
Continue to measure the remaining values for X and Y. Finish by adding the averaged
group values to the Cvt table and compile the Cvt window.

Hinting the Italic
Now that we have set up the Cvt table we will begin hinting with control characters and
in groups.
Begin with the uppercase group. Select the uppercase O. Even though this is an italic
glyph the hint structure will be the same as the regular upright font. Turn on the pixels
(cmd-B.) Notice how the extrema points on the outline are the only points in either the
X or Y direction that are parallel to the grid lines. In hinting these points will be moved
to grid boundaries in the same way the regular font's points are moved. The points in
between will be smoothed/interpolated between these points.
We again need to decide a hint strategy for spacing the glyphs. The method used in the
regular weight was to link in form the sidebearings and maintaining minimum distance
on the left side.
I will use a method of hinting in from the sidebearings and not maintaining minimum
distance or by not using a control value. I will use Delta hints to control spacing when
there are problems. You could experiment with other hinting methods described in
Section 3. "Hinting the First Glyph."
In my italic font the left side of the uppercase O is almost on the right sidebearing. If we
were maintaining minimum distance on the right side we would falsely be pushing the
glyph to the left.
Select the X link tool from the toolbar and link from the right sidebearing to the outside
right extrema of the O. Shift-click and change the link to a distance, no Cvt, and don't
maintain minimum distance. Next link in form the left side with the same link settings. X
link across the left stem with a round, Cvt, and maintain minimum distance link. Link in
from the right extrema to control the right stroke and finish the X direction.

Uppercase O, X direction links.
Select the Y direction and turn of the X direction. As with the regular uppercase O, shiftclick with the Y link tool on the top and bottom points. Select, round to grid then shiftclick on the highway sign to add Cvt #3 for the top overshoot point and Cvt #9 for the
bottom overshoot point. Y link with a round link, with Cvt, and maintain minimum
distance on the top and bottom round stroke. Compile the uppercase O's hints.
Now we can begin hinting the first of several diagonal strokes. Select the uppercase H in
the main window. In hinting the italic glyphs that have a main diagonal stroke we need
to add an additional step. We need to set an italic angle for the stroke. Enable both the
X and Y directions. Select the angle tool from the toolbar. From the bottom of an italic
stroke in the uppercase H, click and drag up and along the angle of the diagonal stroke.
You will see a black line displayed that will rotate as you move the cursor up, down, left
or right from the origin point of the cursor. When the mouse is released the line will turn
gray and the italic angle for this glyph has been set. To rest the angle, reselect a new
origin point and repeat the process.
Enable both the X and Y directions. For the hints on the H we will use a similar type of
hint structure as we used for the uppercase V diagonal stems in the regular font. The
main stems of the H are hinted with a Stroke command. The serifs will be hinted in X
with an X shift from the main diagonal stroke and then rounded to grid.
As with other glyphs we need to decide how to start the glyphs origin point or first hint.
This can effect spacing and centering of the glyph. Since the outlines of the glyphs in an
italic font are almost always to the right of the advance width, I have a preference of
linking in from the right sidebearing and hinting from right to left in the X direction.
Linking in from the left side would cause the glyphs generally to be pushed to the right
even more than they are now.

I also prefer hinting in the X direction first when using the stroke tool. The stroke tool
requires you display both X and Y directions. If I hint the Y direction first there are to
much information on the screen for me to clearly see the glyph when adding the stroke
links.
With the X and Y directions on link from the right sidebearing point X link to a point at
the top of the right diagonal stroke of the H. This point should be the final on curve
point of the diagonal stroke. On a bracketed serif the point selected will be the last on
curve point at the transition to the curve of the serif and the last point in the straight
part of the diagonal.
Select the Stroke tool from the toolbar. Link from the top of the diagonal across the
stem for the first Stroke pair and across the bottom for the final Stroke pair. Select the X
shift tool and link to the farthest point on the serif from each side of the stroke using
the closest Stroke point to the serif. After linking with the X shift tool round this point to
grid.
Now add the Y hints starting by anchoring the top of both sides of the H to Cvt 2. Y link
to control the serif distances on both sides of the stem with Cvt 80 (the serif height.)
After the top hints are finished, do the bottom portion of the H. Anchor both bottom
points and select Cvt 8. Y link with Cvt 80 to control all serif heights.
Finally select the Y interpolate tool. First select the parents, on of the bottom anchored
points and one of the top anchored points. Control the bar by selecting a bottom point
on the bar as a child point and round that point to grid. Next we need to control the
points we used in the stroke command. Select all points used on both strokes as child
points for the interpolation. Select the Y link tool and link up across the bar with a
straight, Cvt and maintain minimum distance Y link. The Cvt that should have been
selected is the thin Y straight stroke Cvt. In my font it was Cvt 72. Compile the hints.
The next main glyph for hinting is the uppercase V. Its hint structure will be the same as
the regular font's V.

Other Hinting Methods
As you look at other glyph shapes it may not seem obvious how to start hinting more
complicated shapes. The methods we used above can be applied to most all other
shapes.
Looking at a lowercase serif 'a' we can break it into sections and see how similar it is to
glyphs we have already hinted.

Lowercase a Main Features.
The illustration above should help you see the major features and strokes. The vertical
lines are showing areas that will use X hints. The horizontal lines are Y hints and the
diagonal lines show the main diagonal stroke.
On the left side of the 'a' in the X direction, the round stroke is the same as the left side
of the uppercase or lowercase 'o'. We would use a round X link with a Cvt for that
feature. The right stroke and tail can be treated the same as other diagonal strokes
we've encountered on the uppercase 'H'. First we would do the stroke on the diagonal.
Look at the diagonal and see how the drawn two parallel lines along the diagonal of this
stroke show the full stroke feature. How the inner countour and round strokes intersect
the diagonal stroke. Compare this stroke to the stroke of the uppercase 'H'. The
intersecting bar's points were interpolated between the inner stroke on either side of
the H. On the 'a' we have several points that interrupt the inner stroke of the right side
of the a. We can use a stroke using the two points at the transition where the stroke
turns back and into the tail. In the illustration these points are numbered, 28 on the left
and 19 on the right. The second pair of points used for this stroke are the two top points
of the stroke, points 15 and 16. Then in X, we will interpolate the points along the inner
diagonal stroke that are at the intersection points, points 0, 14, and 32. Point 32 is
controlling the counter and needs to stay along the diagonal for the left side to remain
a consistent weight. If we don't control this point it will move left and right and cause
the center section to be thin or fat. (note: in this outline, two points are used to define
the intersection areas of the round and diagonal strokes. This was a method of marking
outlines that is common but not always essential. In hinting these points used are the
ones along the area to be controlled. In this example they are points 0 and 14 are along
the diagonal.)

Detail of Two Points at a Diagonal Stroke Intersection.
After controlling the main diagonal the tail can be treated the same as we did for a serif
and use an X shift, rounding the farthest point on the tail to grid. Point 24 in the
previous illustration of the lowercase a features.
The complete hints for the 'a' would be, hint in from the left sidebearing to the left most
point on the a (#7) with an X link, using a distance, no Cvt and don't maintain minimum
distance. X link across the round stroke with a Cvt (to #38.) Xlink with a distance link
from the inside of the bowl to the top inside point of the right diagonal stroke (#15.)
Using the Stroke tool select the top two pints as the first pair (15 and 16) and the
bottom two points which are the last two points on contour before the curve starts (28
and 19.) X interpolate the points along the left diagonal at points 0, 32, and 15. X shift
the farthest point on the tail in X and round that to grid (#24.)
In Y select the top point (#11) and round that to grid with a Cvt 7 (lowercase top
overshoot.) Do the same to the bottom (#3) with Cvt 11 (lowercase baseline overshoot.)
Y link across the bottom (#42) with a round Cvt link. Round the top point (#16) of the
right diagonal to grid and use Cvt 6 (x-height.) Y shift to the point, which slants the top
of the stroke down (#15) and don't round this point. Round the bottom of the stroke to
grid (#26) and use Cvt 11. Then Y link across the round stroke of the tail (#21.) Y link up
to the top of the tail (#23) with a distance link, maintain minimum distance and no Cvt.
(note: if this tail is a repetitive feature on other lowercase glyphs you should define a Cvt
for this feature and use it on all other tails.) Finally Y shift (no round) from the top of the
round stroke (#11) to the point of the round (#3) to the bottom point that intersects the
diagonal and round strokes (#0) using a Y shift. Compile the hints.

Hinting flared stems and cupped serifs

When stems of some typefaces are flared they appear as slab serifs at small screen sizes
because there is not a high enough amount of pixels to represent the flare. Cupped
serifs sometimes have one large pixel showing the cup when the stem is a small as two
pixels. In both cases we would like to not show these flares when there is not enough
resolution to show them as a slight feature. In the Pre-program and Cvt program we
have set up a test that will make a stem stay straight when hints are applied to flares. It
uses Cvt #157 and #158 that are set aside to be used for the distance the flare or cup is
away from the main stem.

Measuring a flare.
When hinting a flared uppercase I, we want to control the middle of the stem in X with
an X link and a Cvt. Then from both sides of the X link we will X link with a distance, Cvt,
and don't maintain minimum distance Cvt. We will use either Cvt 157 or 158. The Preprogram will test if the distance is large enough so two pixels will be displayed. If the
distance is too small to show two pixels Cvt 157 and 158 will be set to zero font units
and the flare will not appear.
These are the X hints for the flared uppercase I. The flare distance was measured and the
value of 50 was place in Cvt 157. In the X direction, X link across with a straight link
using Cvt 68 and maintain minimum distance. From the first link point X link to the top
flare with a distance, Cvt 157, and don't maintain minimum distance. Do the same for
the bottom flare. From the right side of the stem, link out to the top and bottom right
flare points with the same settings as the left side flare (with Cvt 157.) Compile the hints.
With the Display: Show size run menu item enabled you should see that the stem
remains straight until there are two pixels for the flare. To test this you can change one
of the flares so it does not use a Cvt. You should see that the flare appears as a single

pixel in the X direction and has the effect of making the design appear to be a typeface
with a slab serif.

X Links for a Flared Uppercase I.

Appendix
The Appendix is based on an introductory TrueType hinting page from the Microsoft
Typography web site.
Basic global tables
Basic TrueType hinting involves three tables that are global to the entire font: the
Control Value Table, the Preprogram Table and the Font Program Table.
Control Value Table ('Cvt')
TrueType allows control over the regularity of features through the use of values stored
in the 'Cvt' table. Control values are measurements of features, such as lowercase stem
widths. These stems, although similar to one another, may have slightly different outline
distances. With Cvts the distances can be controlled so they are the same pixel width at
a low resolution. At a higher resolution the control value won't be used but the natural
distance will display in the stems. The Control Value table doesn't require these values to
be glyph feature distances. The values are an integer and can be accessed from many
TrueType instructions. The table also can be written to as well as read from other tables.

Other examples of glyph and font features that can be stored in the control value table
are: cap heights, x-heights, overshoot distances, ascender heights, baselines, figure
heights, serif lengths and heights, italic angle, group (uppercase, lowercase, etc.) stem
distances, group round distances. Other features might be: smaller group distances such
as a math sign stem distance, braces, brackets, or parentheses distances.

Figure 1. Features of a lowercase 'b'.
_Preprogram ('prep')_
In every font there are certain conditions that will always apply. In TrueType we control
these conditions through code placed in the preprogram. The 'prep' table is executed
each time a glyph size or resolution is changed and before the glyph's local instruction
are executed. This is a good place to control global conditions for all glyphs. Some
examples of what to put in a 'prep' are...
Controlling when hinting instructions are used and when they are not. In Microsoft
fonts we turn off hints below 8ppem and above 2048ppem. We feel it unnecessary
to use hints below 8ppem or above 2048ppem. This also prevents some technical
issues from arising.
Turning on control to check for missing pixels in continuous strokes. In some cases
the outline may pass between pixel centers and would result in holes in the
bitmap. This control checks for these conditions and adds pixel/s where these
'dropouts' occur.
Altering values in the 'Cvt' used to control group features such as uppercase stems
and rounds. Here you can control the size at which a stem breaks from one pixel to
two, etc. It is common to force round and straight features to be equal until a
desired size.
Setting the 'Cvt' cut-in limit. This is a threshold (or thresholds) which are used to
determine if a 'Cvt' value will be used or the actual distance will be used. I use
three threshold settings: one for small ppem sizes set so the 'Cvt' will most always
be used; one for medium ppem sizes where a more reasonable threshold is set;

and a high ppem threshold set to always use the actual distance and not the 'Cvt'
value. You'll see below how some instructions are set to look at this 'Cvt' cut-in
limit.
Setting minimum distance. Sometimes it is necessary to maintain a minimum of
one pixel between one outline point and another (in the case of hinting across the
stem of a glyph, for example). I always set the minimum distance to be one pixel. If
I then hint across a stem and the actual distance is less than a half a pixel, the stem
width is always forced to be one pixel.
Font Program ('fpgm')
This table stores functions that can be called from the 'prep' or from the glyph's
instructions. Functions are used to eliminate repetitive code from being used in multiple
glyphs. A common example is to control the placement of a diacritic over a base glyph.
TrueType supports composite glyphs (glyphs made up of other glyphs). In composite
glyphs the bitmaps of these already hinted glyphs may not be placed in the same way
as the original unhinted outline position in the horizontal and vertical direction. A
function is often used to insure the diacritic centers over a base glyph and the diacritic
does not touch the top of the base glyph.
II. Glossary of Terms
Advance Width - A glyph's horizontal distance including the white space on either
side.
Bitmap - An image made of pixels. In this document a bitmap refers to the
displayed characters after the glyph's hints are processed. This is not to be
confused with a 'bitmap font file'.
Code Page - a predefined set of characters. Hardware manufacturers, software
manufacturers and standards organizations have defined sets of characters for
specific uses and devices. Also called a 'character set'. The US English version of
Windows 95 uses the 1252 Windows Latin 1 (ANSI) code page. For a list of code
pages used by Microsoft Windows see the book "Developing International
Software" by Nadine Kano, published by Microsoft Press, ISBN 1-55615-840-8.
Composite glyph - a glyph made up of one or more other glyphs and use all the
data from these original glyphs. Composite glyphs in TrueType contain pointers to
the original glyphs with some additional positioning information. This method of
glyph construction saves file space and maintains quality by using the same
images for all glyphs with the same parts. Examples of composite glyphs are Latin
1 characters such as the 'Aacute' and 'Eacute'.
Character - in computer terms refers to a position in a code page or keyboard
layout. The lowercase a is a character in the ASCII code page. See "glyph".

Diacritic - A mark normally used in conjunction with another glyph. In Latin fonts
these are sometimes called 'accents'. In Hebrew and Arabic these are marks that
denote vowels.
Features - These can be heights of the letter groups, stems or rounds of a group,
and serifs.
Font - A member of a typeface. Traditionally a specific point size of a specific style.
The modern interpretation for a specific outline font file. Times New Roman Italic is
a font or font file in the Times New Roman typeface family.
Function - A general term in computer programming for a particular kind of
subroutine.
Glyph - An image in a font file. For comparison a lowercase 'a' is a character. In the
latest font file technologies (OpenType and TrueType GX) there can be several
glyphs that are a lowercase 'a' in a font file.
Glyph Index - Glyphs are given numbers starting at zero. Tables and instructions to
access the glyphs use these numbers.
High Level Language - the farther a language is from the binary computer
language and is more human readable. Visual TrueType links are a high level
hinting language. TrueType is a lower level hinting language.
Hinting - a simple set of font instructions used for scalable fonts that helps
computers display bitmaps more consistently. Often the term is a general term
used for all font technologies. TrueType font information is more correctly called
instructions since they strongly control the bitmap image.
Interpolate - Moving points between two moved key points and keeping the
relation the same as the original positions of all points.
Latin - Languages based on the Latin alphabet. Examples are English, French,
German, Spanish and Italian.
Low Level Language - the closer a language is to the binary computer language.
TrueType is considered a low level hinting language. Computer Assembly Language
is a lower level language and Pascal is a higher level language.
Mapping - matching a glyph with a character. In TrueType fonts the 'character
mapping table' matches glyphs with character codes for the Macintosh operating
system and Unicode numbers for Microsoft Windows.
Outline - A series of curves and straight lines that are filled with pixels to make an
image.
Overshoot - The difference between the round and flat glyph heights and
baselines in a group. Round characters need to project higher and lower to give
the appearance of equal height.
PPEM - An acronym for pixel per em. Pixels per em are a non resolution dependent
unit of measure. PPEM are calculated by the equation: PPEM = pt size *
resolution/72.

Rasterizer - software that takes information from scalable fonts and displays
bitmaps at specific size and resolution. Microsoft Windows and the Macintosh
operating system contain a TrueType rasterizer for displaying TrueType fonts on the
screen as well as the printer. PostScript fonts are displayed by a PostScript
rasterizer as part of Adobe Type Manager and/or PostScript printers.
Rounded - Distances and values when converted to pixels are usually in fractions
of pixels. These fractions of pixels are converted into whole, half or specified
fractions of pixels. Example: a distance is 1.4 pixels. When this distance is rounded
to grid, it would equal 1 pixel.
Scalable fonts - font files that do not necessarily contain predefined images
specific to a resolution and size. These font files use one source to display all
possible point sizes and resolutions.
Sidebearing - The distance from the leftmost portion of a glyph and its origin or
the rightmost portion and the end of the glyph's advance width, which is the total
space occupied by the glyph itself and its two sidebearings.
Tables - TrueType font files are separated into sections of similar data called tables.
Typeface - A collection of fonts within a family. Times New Roman is a typeface,
Times New Roman Italic is a font.
Units - TrueType fonts use a 2048 Unit Per EM measurement system. In comparison
PostScript uses a 1000 unit system.
III. Further Information on TrueType and Font Design
Internet resources
Adobe Systems Incorporated
Apple font/tools group
Typeface copyright and type design issues at TypeRight.Org
Books
Fontographer: Type by Design, Stephen Moye, MIS Press (1995) ISBN: 1558284478
Developing International Software (Microsoft Windows code pages), Nadine Kano,
Microsoft Press, ISBN: 1556158408

TrueType hinting
Article • 03/28/2022

Hinting is an essential part of the production of a quality font. It is indispensable in every
font intended to be legible at small sizes on low resolution output devices. A well-hinted
font offers the quality only provided in the past by hand-tuned bitmaps - but with all
the speed and reduced memory requirements which characterize outline font formats.
Moreover, because the bitmaps are still produced by an outline font, text can be
rotated, scaled and viewed at different sizes, and even printed out while maintaining
high image quality.
The TrueType font format offers far more power and flexibility in its hinting capabilities
than other font formats. Well-hinted TrueType fonts are consequently the best fonts
when it comes to displaying text on the screen.
This paper explains exactly what hinting is, why it is necessary, and how the TrueType
approach to hinting differs from the approaches adopted by other font formats. As a
means of demonstrating the power of the TrueType format, several examples are shown
here which compare TrueType fonts side-by-side with equivalent PostScript Type 1 fonts
rendered by the ATM rasterizer.

What is Hinting?
At its most basic level hinting (or, more accurately, instructing) a font is a method of
defining exactly which pixels are turned on in order to create the best possible character
bitmap shape at small sizes and low resolutions. Since it is a glyph's outline that
determines which pixels will constitute a character bitmap at a given size, it is often
necessary to modify the outline to create a good bitmap image; in effect modifying the
outline until the desired combination of pixels is turned on. A hint is a mathematical
instruction added to the font to distort a character's outline at particular sizes.
Technically, hints result in operations which modify a contours' scaled control point coordinates before the outline is scan converted. In TrueType a combination of these hints,
and the resulting distortions, affords a very fine degree of control over the bitmap shape
produced.
Modifying an outline in this manner results in what is known as a grid-fit. On the basis of
the instructions contained in the individual font file, the TrueType rasterizer adjusts the
glyph outlines to fit the bitmap grid appropriate for whichever size the text is to be
displayed at. This outline adjustment is carried out on a case-by-case basis and is
illustrated in figure 1 below.

Figure 1a. An outline that hasn't been grid-fitted.

Figure 1b. The same outline grid-fitted. Now

Note how poorly the outline corresponds to the
pixel pattern, and above all how awkward the
bitmap of the M is.

the outline has been adjusted to fit snugly
around each pixel, ensuring that the correct
pixels are turned on.

Grid-fitting explicitly ensures that certain features of the glyphs are regularized, and
allows us to overcome many of the problems traditionally associated with displaying
text at low resolutions. Because the outlines are only distorted at a specified number of
small sizes, the contours of the letterforms at higher resolutions remain unchanged, and
undistorted.
Although many font formats and applications offer some hinting facilities, these hints
typically consist of a few global parameters that are only capable of specifying distances
that should be kept the same. TrueType enables the designer to stipulate exactly how
the glyphs and their spacing will appear at low resolutions in isolation as well as within a
textsetting.

Why is Hinting Necessary?
Scaling an unmodified outline's control point co-ordinates to the small sizes of a
computer screen can result in severe quality control problems. At low resolutions, with
few pixels available to describe the character shapes, features such as stem weights,
crossbar widths and serif details can become irregular, inconsistent or even missed
completely. These irregularities detract substantially from the legibility and overall
attractiveness of a textsetting.
These problems are a result of the absolute and finite size of the pixel. Mathematically
scaling a character outline presents no problem until the pixel grid of the output device
is introduced; at this point it is possible that parts of the outline will pass through only a
fraction of a pixel, rather than containing the pixel completely. If the pixel is turned on in
such a case, that part of the curve will be wider than the original outline; if it is left off, it
will be narrower.

The decision whether or not to turn such a pixel on or to leave it off is a crucial one. On
systems and displays utilizing the capabilities of a grayscale rasterizer, the difficulty is
lessened somewhat by the possibility of using different levels of gray, but when the text
is displayed as a monochrome bitmap, the rasterizer can only make a binary choice (on
or off, black or white, 1 or 0). In this case, if the outline has not been grid-fitted by hints,
the bitmap will be produced by the results of point co-ordinates being mathematically
rounded up or down. The introduction of the 'chance' effects of rounding up and down
can significantly impair the quality of type at low resolutions. As figure 2 below shows,
rounding can have some unpleasant side effects.

Figure 2a. Note how heavy the upper serif

Figure 2b. Here, rounding of points has resulted in

has become in comparison with the stem

uneven vertical stem weights and missing serif

weights.

details.

Figure 2c. This lowercase 'm' has uneven stems and arches.

How Does Hinting Help?
Since hinting is fundamentally about improving the appearance of text at small sizes
and low resolutions, many of our concerns when hinting a font are the same as when
drawing a font. At Microsoft we take great pains to ensure that all of the fonts we ship
are hinted to very high levels. The issues we attempt to address through hinting fall into
the following seven categories: color, readability, spacing, weight, alignment, symmetry
and 'local aesthetics' (the actual bitmap shapes for eachcharacter).

Color
Color is arguably the most striking aspect of a text setting. This is no less true at screen
sizes than at high resolution or on the printed page. Abrupt and uneven changes in the
color of a word or line are likely to distract the reader. If text is to be legible, an even
color isessential.
In the context of typography, the word 'color' refers to the balance of black and white
on the page or screen. The black character shapes and white background of the page
combine to produce 'color'. Regardless of how bold or light that color is, it should at
least be even andconsistent.
The color of words is determined and complicated by a number of issues - such as the
contrast between thick and thin stem weights, the size of the characters' internal spaces,
the amounts of intercharacter spacing and interlinear spacing, the jaggedness of
diagonal strokes, and the overall thickness of a stroke. Excessively patchy, dark or light
areas tend to attract the reader's eye too much for the reading process to be a smooth
and efficientone.
Maintaining an even text color means that the type remains as unobtrusive for the
reader as possible. Figure 3 below demonstrates the difference between even and
uneven color in different fonts used to set the text.

Figure 3a. Uneven color in a text setting. Note how
unevenly distributed the stroke weight is, and how
the bowls of the lowercase a and e are very tight

Figure 3b. Even color in a text setting. Stroke
weight is consistent, diagonals and curves
are controlled, and the overall effect is much

in comparison with the open round characters.

more appealing than the example at left.

Readability
Readability is a second critical attribute of a well-hinted font. Every glyph should be
identifiable as a particular character. If this is not the case, it will be difficult to attain the
desired standard of legibility with the font. At very low resolutions it can become quite
difficult to represent a character adequately. This is where an element of compromise
comes into play; making an 'm' look like an 'm' at 9 ppem may require some playing
with the bitmap. Figure 4 below shows some particularly unreadable glyphs.

Spacing
Another contributor to poor legibility at low resolutions is inconsistent intercharacter
spacing. This irregular spacing occurs as the result of two things: the rounding up or
down in width of the bitmap to fit the character outline, and the difference between the
width of the bitmap in pixels and the set width of the character on a high resolution
printer. In reality, the space between characters and between words should appear as a
regular interval to the eye. Making sure that glyphs do not run into one another at small
sizes is vital to maintain even color across thefont.
Spacing characters at low resolutions can be extremely difficult. What should be done,
for example, when the lowercase 'i' occupies a total width of four pixels and has a one
pixel stem width? Placing one pixel of space on either side creates problems with the
remaining pixel. Adding it to the right or left will affect the spacing of characters that
precede or follow the letter 'i' in a word, while adding to the stem width will normally
make it too heavy for the rest of the characters in the font. These are important
considerations, for as the illustrations below show, intercharacter spacing can have a
profound effect on the legibility of a font. With the control TrueType offers for adjusting
the space around characters as well as the actual letterforms themselves, it is relatively
easy to ensure a text setting such as the one shown on the right below. (We'll provide
more info on how TrueType makes spacing issues easier to deal with later in this article.)

Figure 5a. Spacing. Uneven spacing in a text sample. Notice how
some of the characters bump up against each other, while others
create excessive space between themselves. Together these things

Even spacing. Each
character spaces well
between others and the

can dramatically alter the 'color' of a setting.

overall effect is much more
appealing.

Figure 5b. Spacing. The spacing produced by ATM v3.01 Helvetica
Bold (at 12 ppem / 9 points). Enlarged.

TrueType Arial Bold,
rendered at 12 ppem (9
points) by the Microsoft
TrueType rasterizer v1.66.
Enlarged.

Weight
In a well-hinted font the weight of the strokes of the characters is controlled. This is
important not just within a given font, but also in relation to other fonts in the same
typeface family. It makes little sense to deem a weight bold if at the same size the
roman or italic weights are just as heavy or even heavier. The following are specific
considerations addressed by good qualityhinting:
At which ppem sizes do character's stem widths widen to two, three, four and five
pixel stems? Is this suitable for the weight and appearance of the font, or is it too
late, or toosoon?
How do the weights of the regular characters compare with the bold and italic of
the same typeface family? It should be possible to control the stem widening (to
more pixels) sufficiently to produce a weight difference at everysize.
Do the uppercase glyphs widen in the stems before the lower caseglyphs?
Do the weights of the numerals follow the uppercase or lowercase characters? Or
neither?
Do round character features become wider before straight and square features? Or
viceversa?
Are the overshoots consistent? Do they happen too early or too late? Do they work
with fonts in the samefamily?
Each of these issues is important in aiding legibility on the screen. If there isn't a
discernible difference between two weights of a font on the screen, it can be difficult to

tell headings from text. If uppercase glyphs appear much bolder than lowercase ones,
they will draw too much attention to themselves. And if round characters widen too
early, they can affect both the spacing and the color of a textsetting.

Figure 6. Weight across a font family.
PostScript versions of Times and Times
Bold rendered by Adobe Type Manager
v3.01 at 11 ppem (8 point). Enlarged.

TrueType Times New Roman rendered by the
Microsoft TrueType rasterizer 1.66 at 11 ppem (8
point). Enlarged. Here the weight relationship
between the two fonts is much more apparent.

Alignment
Another important consideration when hinting a font is the control of various
alignments, both within the font, and in the wider font family. Generally, similar
elements should be kept the same at small sizes, where a one or two pixel difference is
much more noticeable than it would be over a height of 24 pixels, for example. In
practice this means forcing uppercase characters to align to the same height, and doing
the same with lowercase characters at both descender level, ascender level and x height.
Cap heights need to align properly when a word is set in uppercase characters. But even
more than this, these same elements need to align properly across the different variants
of the same typeface family. It will normally be important to ensure that x-heights, for
example, align exactly when an entire sentence is set in a regular weight except for one

word which is set in either italic or bold. Figure 7 compares an example of proper
alignment with one of improper alignment.

Figure 7a. Alignment across a font. An example
of poor alignment across a line of text. Note
how the round characters appear taller than
those with flat tops, and how unsettling it is to
follow the line.

The same font as shown at left, but with
improved alignment. Although the round
characters actually have slightly greater outline
size than the flat characters, they are forced to
the same height at this size.

Figure 7b. Alignment across a family. PostScript versions of Helvetica, Helvetica Italic, Helvetica
Bold and Helvetica Bold Italic rendered by Adobe Type Manager v3.01 at 12 ppem (9 point).
Enlarged.

TrueType versions of Arial, Arial Italic, Arial Bold and Arial Bold Italic rendered by the Microsoft
TrueType rasterizer v1.66 at 12 ppem (9 point). Enlarged.

Symmetry
Although symmetry could easily be subsumed under the following category (local
aesthetics) it is discussed here separately because it is generally something which needs
to be controlled across the entire font. Despite the subtleties often present in the
outlines of characters with diagonal strokes, one of the cleanest methods of dealing
with diagonals is to treat them symmetrically at small sizes. This ensures that 'jaggies'
are regularized and minimized. The illustrations below show how treating the diagonal
strokes symmetrically can improve the appearance of the localshape.

Figure 8a. Symmetry in a character. The uppercase
'M' (13 ppem/10 point) and lowercase 'w' (15
ppem/11 point) of Helvetica, rendered by Adobe
Type Manager v3.01. Enlarged.

TrueType Arial's uppercase 'M' (13
ppem/10 point) and lowercase 'w' (15
ppem/11 point) rendered by the
Microsoft TrueType rasterizer v1.66.

It makes little sense for nearly symmetrical characters to be treated non-symmetrically
with only a few pixels. In lines of text, such as those shown below, symmetrical bitmaps
can substantially improve the general appearance:

Figure 8b. Symmetry across a font. In this text
sample set at 36 ppem, the diagonals have not

Here the diagonals are symmetrical,
helping lend the sample a much more even

been treated symmetrically. Notice how this
adversely affects the textual color.

color, despite the weight problems
apparent in the lowercase r.

Local aesthetics
The categories discussed above have been those that affect the look of the font as a
whole. Of course it is also important to consider local aesthetics - the individual bitmap
shapes themselves. Hinting can be particularly useful in helping the avoidance of
individual pixel spurs and flat runs, for example. It can also help ensure that specific
bitmaps are not deformed, remain readable, and that bowls and counters have not
closedup.

Hinting vs. Other Methods
Shape modification
TrueType affords the designer or engineer more flexibility and control over the final
bitmap appearance than any other font format in use today. Through the use of the
extensive range of commands in the TrueType instruction set, the designer is able to
move any point on a glyph's outline as little or as much as necessary to turn on or off
any pixel on the bitmap grid. This provides as much control as a simple bitmap editor.

Commands can be used not only to improve legibility of fonts at small sizes, but also to
fundamentally alter the appearance of any bitmap at any size - enabling the production,
for example, of a font where different sizes will produce a different shape. Because
TrueType is a programming language (at the assembly level), the format offers font
designers and engineers an amazing degree of versatility. The sizes affected by the
hinting commands can also be determined by setting low and high size thresholds, or
cut-ins.
A practical example of this flexibility was demonstrated recently in a Microsoft font
designed specifically for display on television under the NTSC signal. During preliminary
work it became clear that at small sizes it would be impossible to render certain
character features satisfactorily - such as the diagonal bar of the uppercase N. The
designer, conscious of making every glyph as individual as possible, established a
threshold below which he programmed certain characters to change shape. Illustrated
below are the outlines and resulting bitmaps from 21 and22ppem.

Figure 9. The outlines and resulting bitmaps at sizes of 21 ppem and 22 ppem. Despite the
differences in shape, these bitmaps are produced by the same font. By adjusting the outline
sufficiently, the designer has managed to ensure that each bitmap remains individual and
identifiable.

Optical scaling
Since TrueType enables the designer or programmer to alter a letterform at every single
size, it follows that optical scaling can be built into the TrueType font, allowing the subtle
adjustment of characters at different sizes to ensure their correctappearance.
The designing of bitmap letterforms has always involved a degree of optical scaling,
with each and every size having to be rasterized - and often designed - separately.
Unfortunately, these modifications have always involved, even been determined by, an
element of compromise; this pixel or that pixel? In a TrueType font, the ability to create
optically correct letterforms is extended up to very large sizes (up to 2048 ppem) and by

the capabilities of TrueType Open, a new extension to the TrueType specification
(EDITOR: This eventually evolved into the OpenType initiative).

Non-linear scaling
Non-linear scaling is often (understandably) confused with optical scaling. Whereas the
concept of optical scaling involves altering the shapes of characters in order to ensure a
correct appearance at particular sizes, non-linear scaling in TrueType simply enables the
widening or narrowing of the widths of a glyph and its side-bearings at sizes where,
were the widths to scale in a linear fashion (for example, increasing in a regular pattern
from small to large sizes) we might encounter spacing or weight problems. In a situation
where, for example, the lowercase 'i' would normally scale to occupy an advance width
of four pixels, we might elect to force it to fit within three pixels, placing one pixel of
white space on either side of a one pixel black stem. In such cases, we are clearly forcing
the font to scale in a non-linear fashion.
In effect, non-linear scaling means that TrueType hinting is not limited merely to
controlling the shape of each character. The type designer is able to adjust the inter
character spacing by varying the amount of white space to either side of a letterform.
This facility is critical in helping maintain an even, consistent color across lines of text,
and is a highlight of TrueType hinting not available in other fontformats.

Diagonal control
Diagonal control is another feature of TrueType hinting that helps lead to better visual
quality in a font. Keeping diagonal strkes as symmetrical as possible helps to avoid
unnecessary jaggedness or 'stepping'. The use of separate vectors for measuring
distances and moving points on a glyph's outline enables a very fine degree of control
over point positioning in a diagonal stroke element. In the example shown below it can
be seen that the distance a point must be moved to ensure a correct bitmap stroke is
measured in one direction, while it is actually moved in a slightly different direction. This
feature allows us to measure the true width of an element such as a diagonal stroke, and
to maintain it, rather than basing our judgments inaccurately on a straight horizontal
measure. Attaining stroke weight consistency with this feature can also aid the color,
spacing and symmetry of a font at small sizes and low resolutions.

Figure 10a. TrueType enables the measurement of a distance such as

...enabling the exact

a diagonal stroke weight along the projection vector, while the
movement of the point to be shifted can take place completely

positioning of the outline
in order to create a perfect

independently...

pixel pattern.

Controlling diagonals in this manner enables TrueType fonts to represent italic and
oblique letterforms with much greater fidelity than other font formats. The illustration
below shows how much more even TrueType diagonal control can make asetting.

Figure 10b. Diagonal control in an italic font. ATM Times
Italic at 11 ppem (8 points).

TrueType Times New Roman Italic at
11 ppem (8 points).

Intelligence in the hints
With TrueType, the intelligence is in the hints rather than in the rasterizer. That is, all
alterations to the original outline description are performed through instructions
contained in the font rather than by the rasterizer acting on its own. This approach has
three important implications.
First, it means that the bulk of the calculations takes place during font production rather
than at runtime. In this sense, TrueType is similar to a compiled language, while outline
font technologies that perform most of their work during execution are more like
interpreters.

Second, having the intelligence in the hints means that font vendors can precisely
control the final appearance of the fonts - because they apply the hints. In contrast, with
approaches that rely on the rasterizer to apply hints or perform other outline
adjustments, font vendors have less control over the final appearance of thefonts.
Finally, having the intelligence in the hints allows tool vendors to improve their hinting
technology without requiring users to buy a new rasterizer or additional printer ROM.
This means that end users can upgrade their fonts for just the price of the fonts
themselves, without incurring any other hardware or softwarecosts.

TrueType hinting tutorial - Intro
Article • 06/10/2020

Basic hinting philosophies and TrueType instructions
When discussing TrueType hinting it is best to think of TrueType as a programming
language. Font companies who produce TrueType all use different approaches.
Individual typographic engineers in a font company may also use different hinting
philosophies. A single type engineer may use a different overall strategy from typeface
to typeface.
(A typeface is a collection of fonts within a family. Times New Roman is a typeface,
Times New Roman Italic is a font.)
In this document I begin by discussing the hinting process in a general, high level
manner, and then convert that high level description into actual TrueType code.

A note about hinting tools
Tools used to produce professional fonts are not necessarily commercially available.
Software and font companies have developed specific software for their development
needs. In this document the syntax used for all TrueType instructions should be
considered specific to this document and / or a specific TrueType development tool. For
a full explanation of TrueType instructions and their syntax see the Microsoft TrueType
spec Version 1.66 (or later) or the manual of a specific TrueType editor. In addition to
proprietary tools the known TrueType editors are currently: RoyalT from Apple Computer
and TypeSolution's TypeMan and StingRay.

Starting out
If you have ever painted a picture you know you start with a blank surface and sketch
out the basic shapes. Then you add the tones. After that you get more and more specific
until you decide the painting is complete. In general every painting is done the same
way. But the details are always different. The edges are sharpened differently. Highlights
are either added or not. Perhaps you will use the classic red line, perhaps not. This is
what hinting is about. Decisions.
The first thing you must consider is the kind of fonts you are hinting and how the
separate fonts relate to the whole typeface. When the core fonts from the typeface
Times New Roman were hinted, the type engineers compared all fonts to be included in

the family (regular, italic, bold and bold italic). They measured each font and determined
if values such as heights or stem values should be consistent through the family or
specific to the font.

Next section
Basic global tables

TrueType hinting tutorial - Basic global
tables
Article • 06/10/2020

Basic TrueType hinting involves three tables that are global to the entire font: the
Control Value Table, the Preprogram Table and the Font Program Table.

Control Value Table ('cvt')
TrueType allows control over the regularity of features through the use of values stored
in the 'cvt' table. Control values are measurements of features, such as lowercase stems
widths. These stems, although similar to one another, may have slightly different outline
distances. With cvts the distances can be controlled so they are the same pixel width at
a low resolution. At a higher resolution the control value won't be used but the natural
distance will display in the stems. The Control Value table doesn't require these values to
be glyph feature distances. The values are an integer and can be accessed from many
TrueType instructions. The table also can be written to as well as read from other tables.
Other examples of glyph and font features that can be stored in the control value table
are: cap heights, x-heights, overshoot distances, ascender heights, baselines, figure
heights, serif lengths and heights, italic angle, group (uppercase, lowercase, etc.) stem
distances, group round distances. Other features might be: smaller group distances such
as a math sign stem distance, braces, brackets, or parentheses distances.

Figure 1. Features of a lowercase 'b'.

Preprogram ('prep')
In every font there are certain conditions that will always apply. In TrueType we control
these conditions through code placed in the preprogram. The 'prep' table is executed
each time a glyph size or resolution is changed and before the glyph's local instruction
are executed. This is a good place to control global conditions for all glyphs. Some
examples of what to put in a 'prep' are...
Controlling when hinting instructions are used and when they are not. In Microsoft
fonts we turn off hints below 8ppem and above 2048ppem. We feel it unnecessary
to use hints below 8ppem or above 2048ppem. This also prevents some technical
issues from arising.
Turning on control to check for missing pixels in continuous strokes. In some cases
the outline may pass between pixel centers and would result in holes in the
bitmap8. This control checks for these conditions and adds pixel/s where these
'dropouts' occur.
Altering values in the 'cvt' used to control group features such as uppercase stems
and rounds. Here you can control the size at which a stem breaks from one pixel to
two, etc. It is common to force round and straight features to be equal until a
desired size.
Setting the 'cvt' cut-in limit. This is a threshold (or thresholds) which are used to
determine if a 'cvt' value will be used or the actual distance will be used. I use three
threshold settings: one for small ppem sizes set so the 'cvt' will most always be
used; one for medium ppem sizes where a more reasonable threshold is set; and a
high ppem threshold set to always use the actual distance and not the 'cvt' value.
You'll see below how some instructions are set to look at this 'cvt' cut-in limit.
Setting minimum distance. Sometimes it is necessary to maintain a minimum of
one pixel between one outline point and another (in the case of hinting across the
stem of a glyph, for example). I always set the minimum distance to be one pixel. If
I then hint across a stem and the actual distance is less than a half a pixel, the stem
width is always forced to be one pixel.

Font Program ('fpgm')
This table stores functions that can be called from the 'prep' or from the glyph's
instructions. Functions are used to eliminate repetitive code from being used in multiple
glyphs. A common example is to control the placement of a diacritic over a base glyph.
TrueType supports composite glyphs (glyphs made up of other glyphs). In composite
glyphs the bitmaps of these already hinted glyphs may not be placed in the same way
as the original unhinted outline position in the horizontal and vertical direction. A

function is often used to insure the diacritic centers over a base glyph and the diacritic
does not touch the top of the base glyph.

Next section
Hinting and TrueType instructions

TrueType hinting tutorial - Basic hinting
philosophies and TrueType instructions
Article • 03/13/2021

In this section we will look at goals of hinting, hinting with TrueType and individual glyph
hinting. This section contains some of what is stored in the TrueType glyph table ('glyf').

Goals of hinting
The ultimate goal of hinting is to best represent the font at all the resolutions at which it
will be displayed. PCs use several different resolutions and aspect ratios. The most
common are the VGA at 96 dots per inch, SVGA at 120 dpi and the Macintosh at 72 dpi.
All these devices have a 1:1 aspect ratio. When a font is hinted, the type engineer
determines the lowest pixel per em size to which they will hint and retain satisfactory
results. Commonly the lowest ppem size hinted is 9. This is the equivalent of 7 point on
a VGA screen, 5.5 point on an SVGA and 9 point on a Macintosh. Some PC screens and
some printers have a non square aspect ratio. Microsoft Core fonts have code in the
preprogram to check for the current aspect ratio.
Some of our goals will already have been solved in the 'prep' program controlling global
issues. In preparation we've looked at whether all fonts can use the same height values
in the 'cvt' for the tops of the uppercase, lowercase, xheight, ascenders, etc, whether the
overshoots are the same and when they turn on.

Basic hinting of a glyph
The first example we'll look at is the hinting of an italic uppercase 'O'.

Figure 2a. TrueType outline of an UC O.
High level hinting strategy for hinting the uppercase O in figure 2

1. Control the top and bottom to be consistent with other uppercase glyphs.
2. Control the top curve and bottom curve to be the same and consistent with other
uc curves.
3. Control the left curve and right curve to be the same and consistent with other uc
curves.
4. Fix all points not instructed by moving them to smooth the outline.
A lower level hinting strategy for figure 2
In writing the code for hinting, it is more efficient to hint in one direction fully before
switching to the other direction. This is not a requirement in TrueType. I begin by
controlling the Y (vertical) direction and the height. Then I process the X (horizontal)
direction.
1. Set the hinting direction to Y.
2. Move pt 3 to the control value that corresponds to the "uc top round height" and
round this to a grid line. (Distances and values when converted to pixels are usually
in fractions of pixels. These fractions of pixels are converted into whole, half or
specified fractions of pixels. Example: a distance is 1.4 pixels. When this distance is
rounded to grid, it would equal 1 pixel.)
3. Move pt 9 to the control value that corresponds to the "uc bottom round height"
and round this to a grid line.
4. Control the distance between pt3 and pt20 to a control value for "uc Y round" or
its actual distance and round pt 20 to a grid boundary.
5. Control the distance between pt9 and pt15 to a control value for "uc Y round" or
its actual distance and round pt 15 to a grid boundary.
6. Set the direction to X
7. Put pt 0 on a grid boundary.
8. Control the distance between pt0 and pt12 to a control value for "uc X round" or
its actual distance and round pt 12 to a grid boundary.
9. Put pt 6 on a grid boundary.
10. Control the distance between pt6 and pt18 to a control value for "uc X round" or
its actual distance and round pt 18 to a grid boundary.
11. Interpolate all points that were untouched between points that were touched in
the X and Y direction. (Moving points between two moved key points and keeping
the relation the same as the original positions of all points.)
TrueType instructions for figure 2
Hinting instructions move key points on a glyph. When these key points are moved their
X,Y coordinates are converted to pixels and fractions of pixels. When these pixel
amounts are rounded by instructions they are dependent on the setting of the

'round_state' variable. The default setting is 'round to grid'. The other possible settings
are: round to half grid, round to the closest grid or half grid, round up to grid, round
down to grid, rounding off (don't round) and finally finer control of the round_state. The
round_state setting in our example is 'round to grid'.

SVTCA[Y]
/* set the hint direction to Y */
MIAP[R], 3,3 /* move pt 3 to the value of cvt 3 and rounding the value*/
MIAP[R], 9,9 /* move pt 9 to the value of cvt 9 and rounding the value*/
SRP0[], 3
/* set the current reference point to pt 3 */
MIRP[m>RBl], 20, 73 /* control the top round feature */
SRP0[], 9
/* set the current reference point to pt 9 */
MIRP[m>RBl], 15, 73 /* control the bottom round feature */
SVTCA[X]
/*set the direction to X */
SRP0[], 23
/*hinting from the left sidebearing point */
MDRP[MRBl], 12, 69 /*controlling the left round distance */
SRP0[], 24
/*hinting from the right sidebearing point */
MDRP[MRBl], 18, 69 /* controlling the right round distance */
IUP[X] /* interpolating all unused points in the X direction */
IUP[Y] /* interpolating all unused points in the Y direction */

(Sidebearing: The distance from the leftmost portion of a glyph and its origin or the
rightmost portion and the end of the glyph's advance width, which is the total space
occupied by the glyph itself and its two sidebearings. )
Let's look at each line more specifically:
SVTCA[Y]
Sets the hinting direction to the vertical or Y direction. Translated: Set the Vectors
to Control Axis Y. Vectors are straight line segments. There are three vectors in the
"graphic state": one called the 'projection vector', one called the 'freedom vector'
and another called the 'dual projection vector' . The projection vector is how
distances are measured. The freedom vector is the direction in which points are
moved (X,Y or diagonal). The dual projection vector is used by some instructions
for measuring between points from their original ungrid-fitted position.
MIAP[R], 3,3
Move Indirect Absolute Point. Moves point 3 to the value of CVT 3 and rounded.
Indirect refers to the use of a CVT as opposed to directly using the actual
coordinate distance. The direct method of rounding a point would be coded as:
MDAP[R], 3
MIAP[R], 9,9
Same as MIAP[R], 3,3 but uses point 9 and CVT 9.
SRP0[], 3
Set Reference Point Zero to point 3. Sets the current reference point to pt3. Later

when we code an instruction with a 'relative' point it needs a 'reference' point. If pt
'b' is a relative point it is dependent on the position of pt 'a', a point of reference
or "reference" point.
MIRP[m>RBl], 20, 73
Move Indirect Relative Point. Moves and rounds pt20. Outline point 20 is a relative
point and is moving in relation to the reference point 3 which was set in the
previous instruction SRP0. It is an Indirect point because we are using a cvt to
control its distance. A MIRP instruction takes four arguments. The first three
arguments are boolean values. Here we are using symbols that correspond to our
TrueType editor.
The first argument can be set to make the MIRP point the next reference point, such as
is done with the SRP0 instruction or it can not be set. This case 'm' represents it is not
set.
The second argument can be set to keep the distance greater than or equal to the
minimum distance or it can not keep the distance. Here since this is across a round
stroke we want to maintain the distance so it is set here with a '>' symbol.
The third boolean argument does two things: rounds the distance to a grid boundary
and looks at the 'cvt' cut-in limit set in by the 'prep' table. Or don't round the distance
and don't look at the 'cvt' cut-in limit.
The last argument is for defining whether this distance is across a black feature, a white
feature or a gray feature. An example of a black feature is across the stem of the
uppercase 'I' in the X direction. An example of a white feature is across a counter (the
white space) in an 'O' or from a sidebearing. A gray feature is when this hint crosses a
black feature and a white feature.
SRP0[], 9
Sets outline point 9 as the current reference point.
MIRP[m>RBl], 15, 73
Moves pt15 to a grid boundary. Controls the bottom round feature the same as we
controlled the top. Uses the same 'cvt' 73 that corresponds to the uc Y Round cvt.
SVTCA[X]
Sets the direction to X.
SRP0[], 23
Sets pt23 as the current reference point. Point 23 and 24 are not points that are on
the outline. They are called 'Phantom' points. These points are showing the left
sidebearing and the advance width on the baseline. (A glyph's horizontal distance
including the white space on either side.) The Phantom points can be controlled by
instructions. Here we are hinting from these Phantom points inward to the glyph.

We don't need to use an instruction to move the point since Phantom points are
always on a grid boundary.
MDRP[M>RWh], 0
Move Direct Relative Point. Moves and rounds pt0. Similar to a MIRP but this
instruction does not use a control value. Argument 1 ('M') is set so pt0 becomes
the current reference point . The second argument is set not to maintain minimum
distance. We're rounding the point and this is a white feature. Uses the actual
distance from pt23 to pt0 when moving pt0.
MIRP[m>RBl], 12, 69
Moves pt12 to a grid boundary. Uses cvt 69 for uc X Round features and controls
the left round of the glyph. The arguments are set the same as for the Y round
features.
SRP0[], 24
Sets pt24 as the current reference point. We are starting to hint the right side of
the glyph. Coming in from the Phantom point 24.
MDRP[M>RWh], 6
Moves pt6 to a grid boundary. Same hints as on the left side. We're moving point 6
by its actual distance from point 24 and not using a cvt value. By hinting in from
the sidebearings we can preserve the relationship of the glyph and its sidebearings
and preserve spacing.
MIRP[m>RBl], 18, 69
Moves pt18 to a grid boundary. Using the same cvt 69, for controlling the right X
Round feature.
IUP[X]
Interpolate Unused Points. Smooths the outline by moving points in the X direction
in relation to points which have been hinted in the X direction.
IUP[Y]
Smooths out the Y direction.

Next section
Functions and Delta Hints

TrueType hinting tutorial - Functions
and delta hints
Article • 03/13/2021

The high level description and the TrueType hints of the uppercase 'O' described in part
3 did not include additional instructions such as delta hints or additional function calls
for specific sizes. To fine tune the font for specific low resolution sizes we can use special
functions or delta hints. I will not discuss functions in detail since they are pieces of
TrueType code written by a software or type engineer for their specific needs. There are
very few functions used consistently by all font companies.

Delta hints
Delta hints are special hints that make exceptions at specific ppem sizes. They allow a
point to be moved in fractions of pixels so the bitmaps can be altered. This is useful for
removing and adding pixels or shifting all or part of a bitmap.
There are two types of delta hints: ones that move outline points (DeltaP); and ones that
alter 'cvt' values (DeltaC). Both deltas take three arguments: outline point or cvt #, the
ppem size and the amount of movement.
DeltaP
Let's return to our example uppercase 'O'.

If we want to move pt0 one pixel to the right at 14ppem we could use a DeltaP hint to
move the point. Smart placement of delta hints allows whole sections or whole glyphs
to be shifted the amount of the delta hint. Since instructions are processed from the top
down, a DeltaP that is moving a reference point will effect any relative points that use
this reference point. In the next example I want to condense the uc O glyph one pixel to
the right. By placing a DeltaP after the instruction for pt0, the point is moved the

amount specified. Since pt12 uses pt0 as a reference point it will also be shifted. If the
DeltaP was placed after the instruction for pt12, only pt0 would be affected.

SVTCA[Y]
MIAP[R], 3,3
MIAP[R], 9,9
SRP0[], 3
MIRP[m>RWh], 20, 73
SRP0[], 9
MIRP[m>RBl], 15, 73
SVTCA[X]
SRP0[], 23
MDRP[MRBl], 12, 69
SRP0[], 24
MDRP[M>RWh], 6
MIRP[m>RBl], 18, 69
IUP[X]
IUP[Y]

DeltaC
One of the important situations to control when fine-tuning a font is the point at which
its stem widths increase from one pixel to two or two to three. When working with a
medium or regular weight font and a bold font, the bold font needs to be a minimum of
two pixels. Often its natural weight is less than two pixels and would round down to one
pixel. With a DeltaC in the 'prep' we can alter the size at which this cvt increases and all
glyphs using this cvt will be affected with one command. This gives the type engineer
control of the weight of the family.

TrueType italic hinting examples
Article • 03/13/2021

As far as hinting is concerned, the most difficult feature of an italic glyph is its slanted
strokes. An italic "O" can be hinted just like a roman "O", and likewise for a "V". For this
reason, the following examples use an UC "H".
The italic stroke is hinted using the "Diagonal" command or tool in VTT, which works
equally well for general diagonal strokes and for italic strokes. Accordingly, for hinting
italics, we need to know how to properly use the diagonal stroke.
A diagonal stroke command takes two parent points and two child points, along with a
CVT. The two parent points are anchored to the grid, and then the two child points are
controlled relative to the parent points by the diagonal stroke command. This is similar
to the Link command or tool, where a child point is controlled relative to a parent point,
except that we have two of each. The reason for having two is basic geometry: For
example, an "XLink" across a vertical stroke fully defines the direction in which the width
of the stroke is controlled, simply because it is an "_X_Link", as opposed to a "_Y_Link".
For a diagonal stroke, we need to specify the direction of that diagonal, and the only
way we can do so is by specifying two parent points. In geometry, two points define a
straight line.
To properly use the diagonal stroke, we also have to keep in mind that the final
"Smooth" command will adjust all "unhinted" or "untouched" points in both the x- and
y-directions. While the smooth command can do a perfect job when only x- or ycommands are present, it may not do what we want with diagonal commands, such as
"Diagonal" or "DAlign". For example, if we wanted to use a diagonal command to hint
an italic stroke, and if we hinted the parent points in x-direction only, the final smooth
command might adjust the parent points in y-direction in a way we may not approve of.
Therefore, we will need to hint both parent points in both directions before we can use
the diagonal command. The diagonal command, in turn, will hint the child points in a
direction perpendicular to the line defined by the two parent points. The keyword here
is a direction, as opposed to two directions. As with parent points, the child points might
get adjusted by the final smooth in a disagreeable way. Accordingly, for italic strokes, we
should hint the child points in y-direction before using the diagonal stroke command.
Last-but-not-least, there is a mechanism built into the VTT templates that permits some
global control of the "italicness" of the italic strokes. For black-and-white rendering, as
opposed to ClearType rendering, an italic stroke will render as a "stepping pattern" of
pixels, going x pixels across and y pixels up. Like with many other raster tragedies, this

stepping pattern may be "too italic" (i.e. too many pixels across for the given number of
pixels up) or "not italic enough" (i.e. not enough pixels across). Worse still, it may look
too italic on one character, while not italic enough on another, even though the
characters have been designed with a similar or identical italic angle.
To use this mechanism, we'll have to define CVTs for the italic run and rise, as explained
in "Hinting italics using Visual TrueType", and use the GlyphStrokeAngle command or
tool. Then we'll link from the bottom parent point to the top parent point using the
XDist command or tool, i.e. a link in x-direction but without CVT. Finally, we choose the
italic angle rounding method for the child point, which is a "forward slash" when typing
the command (i.e. "XDist/[0, 1]"), or the slash with the dot in the middle when using the
link tool (i.e. right-click the control point and choose the slash with the dot in the
middle).
Example: Arial UC "H"

The VTTTalk for this example looks like this (with line numbers added for further
comments below):

1: /* VTTTalk glyph 43, char 0x48 (H) */
2: /* GUI generated Tue Aug 24 17:00:37 2004 */
3:
4: GlyphStrokeAngle(21,20)

5: SetItalicStrokePhase()
6: SetItalicStrokeAngle()
7:
8: /* Y direction */
9: YAnchor(0,2)
10: YDist(0,7)
11: YDist(0,8)
12: YDist(0,11)
13: YAnchor(1,8)
14: YDist(1,2)
15: YDist(1,5)
16: YDist(1,6)
17: YIPAnchor(0,10,1)
18: YDist(10,9)
19: YLink(10,3,72,>=)
20: YDist(3,4)
21:
22: /* X direction */
23: XIPAnchor(13,7,0,12)
24: XDist/(7,6)
25: Diagonal>>(6,5,7,8,76)
26: DAlign(8,9,4,5)
27: XDist/(0,1)
28: Diagonal>>(0,11,1,2,76)
29: DAlign(11,10,3,2)
30:
31: Smooth()

Comments:
Lines 4 to 6: Generated by the use of the 'GlyphStrokeAngle' tool; italic run is CVT
#20, italic rise is CVT #21
Line 9: Hint bottom (left) parent point #0 of left stroke in y-direction
Line 13: Hint top (left) parent point #1 of left stroke in y-direction
Lines 10 to 12 and 14 to 16: Hint the parent points of the right stroke (#6 and #7),
along with all the strokes' child points (#2, #5, #8, and #11), in y-direction. Using
'YDist' instead of 'YAnchor' simply creates smaller code.
Lines 17 to 20: Hint points of the crossbar in y-direction (#10, #9, #3, and #4).
Line 23: Hint bottom parent points (#0 and #7) in x-direction. At the same time,
this defines the spacing of the character, hence this is the point to set about when
having to improve the spacing.
Line 24: Hint top right parent of right stroke (#6) relative to bottom right parent
(#7). Notice the "/" between "XDist" and "(". This will use the glyph stroke angle
previously established by the 'GlyphStrokeAngle' command.
Line 25: At this point, both parents of the right stroke have been hinted in both xand y-direction, and further more, both children have been hinted in y-direction,
hence the diagonal command can be properly applied. In this example, it uses CVT

#76 to control the weight of the diagonal stroke with parents #6 and #7, and with
children #5 and #8.
Line 26: At this point, both children of the right italic stroke have been hinted in
both x- and y-direction, hence the diagonal align command can be properly
applied, to align points #4 and #9 with the previously hinted points #5 and #8.
Lines 27 to 29: Analogous to lines 24 to 26 for the left stroke.
Notice that both the 'Diagonal' and the 'DAlign' command can have an extra (optional)
parameter that specifies, at and above which ppem size the geometrically strict "grip"
they exert can be "loosened" up somewhat. In the above example, this may not be
necessary, but e.g. for slightly tapered strokes it may be useful to completely
"parallelize" the stroke's sides for small ppem sizes, while trying to render that tapering
if the ppem size is high enough to permit doing so. Likewise, the strokes may be flared,
in which case the strict "grip" may be useful at small ppem sizes but not at large ones.
To use this feature when typing the commands add a ppem size at the end of the list of
parameters, like so:

Diagonal>>(6,5,7,8,76,@42)
DAlign(8,9,4,5,@42)

This will "loosen" the strict "grip" at and above ppem size 42. When using the diagonal
and align tools, refer to the "ppem limits" tool ("padlock tool") explained in "Hinting
italics using Visual TrueType" and "Visual TrueType 4.2 release notes".
The above example assumes the CVTs for italic run and rise to be present in the control
program, like so (see "ItalicRun" and "ItalicRise" below):

InstructionsOn @8..2047
DropOutCtrlOff @144
CvtCutIn = 4, 2.5@29, 0@128
/* Heights */
UpperCase
Grey
Y
SquareHeight
2: 1466
8: 0
/* Glyph Stroke Angle */
UpperCase
Grey

X
ItalicRun
20: 307
Y
ItalicRise
21: 1466
/* Strokes */
UpperCase
Black
Y
StraightStroke
72: 166
Diag
StraightStroke
76: 191

If we wanted to change the "italicness" of all uppercase italic strokes at a particular
ppem size, all we'd have to do is to add a "Delta" to CVT #20, like so:

UpperCase
Grey
X
ItalicRun
20: 307 Delta(1@13)

This would increase the italic run by 1 pixel at ppem size 13. Likewise, by putting -1
instead of 1, we could decrease the italic run by 1 pixel. We may want to do so only for
black-and-white rendering, in which case we'd use "BDelta" instead of "Delta".
The above method in general does a fairly good job at normalizing stepping patterns of
italic strokes, rendering italic fonts in a systematic way, which hopefully makes it easier
to read. But there may be "outlier" pixels, for technical reasons that go way beyond the
scope of this example. In these cases, the easiest remedy is to apply "XBDelta" or
possibly "YBDelta" on individual glyphs at individual ppem sizes, as appropriate.
Serif fonts pose an added difficulty because the strokes' parent and child points likely
are not on the base or capsline, as is typically the case with sans-serif fonts. A practical
solution to this problem is to interpolate the parent and child points, as opposed to
anchoring and linking them.
Example: Times New Roman UC "H"

The VTTTalk for this example looks like this:

/* VTTTalk glyph 43, char 0x48 (H) */
/* GUI generated Tue Aug 24 21:19:21 2004 */
1: GlyphStrokeAngle(21,20)
2: SetItalicStrokePhase()
3: SetItalicStrokeAngle()
4:
5: /* Y direction */
6: YAnchor(42,8)
7: YDist(42,24)
8: YDist(24,23)
9: YDist(42,25)
10: YDist(25,26)
11: YDist(42,41)
12: YDist(41,40)
13: YDist(42,43)
14: YAnchor(57,2)
15: YDist(57,9)
16: YDist(9,8)
17: YDist(57,10)
18: YDist(10,11)
19: YInterpolate(11,17,18,23)
20: YIPAnchor(57,34,42)
21: YLink(34,0,72)
22: YDist(0,1)
23: YInterpolate(1,2,8)
24: YDist(34,33)
25: YInterpolate(33,32,26)

26: YInterpolate(34,35,40)
27: YDist(57,56)
28: YInterpolate(43,49,50,56)
29: YDist(57,58)
30: YDist(58,59)
31: YInterpolate(0,65,59)
32:
33: /* X direction */
34: XInterpolate(67,18,49,66)
35: XNoRound(17)
36: XDist/(18,17)
37: Diagonal>>(17,2,18,32,76)
38: DAlign(32,33,1,2)
39: XNoRound(50)
40: XDist/(49,50)
41: Diagonal>>(49,35,50,65,76)
42: DAlign(35,34,0,65)
43:
44: Smooth()

At first glance, this looks a lot more complicated than the sans-serif "H", and it is not
even finished yet (for instance, the lengths of the serifs have not been hinted in xdirection). But on closer inspection we'll find that it is pretty much the same. For the left
diagonal stroke, the parent points are #49 and #50, and the child points are #35 and
#65, which in turn are hinted as further explained in the following comments:
Comments:
Line 28: Hint the parent points #49 and #50 in y-direction, by y-interpolating them
between points #43 and #56.
Lines 13 and 27: Hint points #43 and #56 in y-direction by y-dist from points #42
and #57, respectively. This y-dist at the same time establishes the "thickness" of
the serifs, hence we may want to use a CVT for the serif thickness and replace the
"YDist" by a "YLink".
Lines 6 and 14: Hint points #42 and #57 in y-direction y-anchoring them to base
and capsline, respectively, much like in the sans-serif case.
Lines 26 and 31: Hint the child points #35 and #65 in y-direction, again by yinterpolating them.
#35 is y-interpolated between #34 and #40
Line 12: y-dist point #40 from point #41
Line 11: y-dist point #41 from point #42, which in turn was y-anchored to the
baseline.
Line 20: y-interpolates #34 between the base and capsline
#65 is y-interpolated between #0 and #59, which in turn are y-disted and y-linked
similarly to points #34 and #40.

Line 34: Hint bottom parent points (#18 and #49) in x-direction, similar to the
sans-serif case, but notice the absence of rounding; it is usually better not to force
these points on the nearest grid line in x-direction.
Lines 39 and 40: Hint top left parent (#50) relative to bottom left parent (#49).
Again, notice the "/", and also notice the "XNoRound" to turn-off rounding for the
same reasons as above.
Line 41: At this point, both parents of the left stroke have been hinted in both xand y-direction, and moreover, both children have been hinted in y-direction,
hence the diagonal command can be properly applied.
So, the long and the short of it: with serifs, the parent and child points of the italic
strokes are hinted "via" the serifs. This leads to a relatively smooth outline, even at small
ppem sizes, which is advantageous for ClearType rendering, while typically it also leads
to a reasonable pixel pattern for black-and-white rendering. As with the sans-serif
example, there may be "outlier" pixels, for which the remedy again is to apply "XBDelta"
or "YBDelta", as appropriate.
The same assumptions with respect to the presence of "ItalicRun" and "ItalicRise" apply,
and as with the sans-serif example, the italic run of the serif case can be "delta-ed" as
well.
Lowercase characters and figures in general can be hinted in a similar way, keeping in
mind that they use separate sets of CVTs for "ItalicRun" and "ItalicRise". Since the italic
run and rise are defined using CVTs, "CVT inheritance" may be used to equalize different
italic angles between upper and lowercase, or between different groups of lowercase
characters. Last but not least, it should be mentioned that these two examples merely
represent one way to hint italic characters, and while this way has proven rather useful,
there may be other ways to achieve the same goal.

Font tools list
Article • 03/22/2022

Visual OpenType Layout Tool (VOLT) VOLT is a tool for adding OpenType layout
tables to fonts.

Microsoft Visual TrueType (VTT) A professional-level tool for graphically instructing
TrueType and OpenType TM fonts.
OpenType font signing tool A tool developed for use at Microsoft for signing font
files.

Visual OpenType Layout Tool
Article • 11/13/2021

The Microsoft Visual OpenType Layout Tool (VOLT) provides an easy-to-use graphical
user interface to add OpenType layout tables to fonts with TrueType outlines. It is
licensed free and can be downloaded from the link provided below.

VOLT supports a wide range of substitution and positioning types. It also contains a
proofing tool for reviewing the application of layout table lookups. It allows import and
export of glyph names, lookups, glyph groups and a full project.
The tool has been used by community members to add OpenType layout tables to
various fonts supporting scripts, including Arabic (Naskh and Nastaliq writing styles),
Bengali, Cyrillic, Devanagari, Greek, Gujarati, Gurmukhi, Kannada, Latin, Sinhala, Syriac,
Telugu, Thaana, and many more.

Get VOLT
Download VOLT 1.4.273 .

VOLT forums and community
VOLT forum
Archived forum

VOLT Training Video
Download Training Video

Using VOLT: Volt and InDesign tutorial
Article • 03/25/2022

One of the OpenType format's most important features is its ability to support increased
typographic complexity within a single font. From multiple styles of figures to complex
script-specific ligatures, OpenType allows for typographic richness that was previously
quite difficult to achieve. OpenType fonts do this by storing extra data that can be
exposed by OpenType-aware operating systems and applications. While OpenType fonts
are backward-compatible with pre-OpenType programs (OpenType supersets both
TrueType and Adobe Type 1 formats), the new layout features will not work with older
programs.

Step 1: Getting started
Opening a file
Before any layout features can be added to a font in VOLT, a few things must be taken
care of. When opening a font for the first time, the dialog box below may appear:

Adding scripts and languages

The next step is to add a script and language pair that will contain our OTL features. This
tutorial focuses on Latin-based fonts, so after clicking the 'Add Script' button at the
bottom of the window, specify the OpenType script name <latn> . VOLT then
automatically creates an associated 'default' language (see graphic above) — this is the
language we will be adding our OTL features to.

The 'Edit Glyphs' window
Now that we have our script and lanuguage created, it is useful to become familiar with
VOLT's 'Edit Glyphs' window (click on the 'Edit Glyphs' button). In this window, the user
is able to navigate and search through the font's complete set of glyphs. Each glyph has
its own box, which lists the VOLT glyph name (which you can change) and the code
point determined by the font's encoding. As you will see, this window will become
useful as we begin creating our OTL features.

Step 2: Adding ligatures
While certain basic ligatures have traditionally been included with most fonts, making
use of them in documents has rarely been easy. Most programs provide no easy way to
access the ligatures, often ligatures are not mapped in the font properly, or programs
that do offer support do so without abstracting the glyphs from the letters (causing
problems with tools like spell-checkers). But, by using a correctly constructed OpenType
font in InDesign, a typographer can properly and easily implement ligatures — whether
basic (like 'fi') or more specialized (like 'fj').
The first step is to create a <liga> feature under our 'Default' language. Select the
'Default' language with a single-click, and then click the 'Add Feature' button at the
bottom of the VOLT window. Type in <liga> and press ENTER. VOLT will then recognize
the command and label it 'Standard Ligatures' (see graphic below).

Next, we add a lookup in the pane to the right of the pane we've been working in, which
will become associated with the <liga> feature we've created. Clicking the 'Add
Subsitution' button at the bottom of the VOLT window will create a new subsitution
feature. The name you give this new lookup is not important, though it is always useful
to give things descriptive and concise labels. Since we will only be creating one ligature
lookup (which can hold multiple ligatures, as you'll see), we will simply name the lookup
'ligatures'. After typing the name and hitting ENTER, we must link the lookup to the
<liga> feature we created. This can be done by clicking on the 'ligatures' lookup and

dragging it to the <liga> feature labeled 'Standard Ligatures.' Once this is done, you
should see the 'ligatures' lookup listed below the 'Standard Ligatures' feature (see
graphic below).

Now we can begin adding the actual substitutions to our 'ligatures' lookup. Double-click
on the 'ligatures' lookup and the lookup editing window will pop up. This is where we
specify which letter combinations should have ligatures substituted in their place when
ligatures are turned on in InDesign. We can start by adding the most common ligature,
which almost all fonts support — 'fi'. To do this, we must determine the names of three
glyphs: f, i, and the 'fi' glyph. As you'll see, VOLT references glyphs by an associated
Glyph Name, which can be found in the 'Edit Glyphs' window as seen previously. Note
that Glyph Names will often differ from font to font.
Open the 'Edit Glyphs' window and scroll through your font until you've found all three
glyphs (as you go through, note their names — you can of course rename them if you'd
like). Here are the three glyphs from an example font:

Now that we know which glyphs to work with, we return to the editing window for the
'ligatures' lookup. Click in the box under the 'From Glyphs -> To Glyphs' column and
type the following, substituting in the proper glyph names for your font:
glyph_name_f glyph_name_i -> glyph_name_fi

and then hit ENTER. The 'fi' ligature will be added, and your window should look
something like this:

To add more ligatures to the same lookup, you add additional rows by hitting ENTER
after the current row. By keeping all of your ligatures in one lookup, the font will be
more efficient when it comes time to interpreting the substitutions. Other common
ligatures that your font may support include 'ffi', 'fl', 'ffl'. Some fonts support extra
ligatures such as 'Qu' or 'fj' or the anachronistic ligatures like 'st' or 'ct'. Here is how our
'ligatures' lookup appears after we've added more ligatures:

When you are done adding ligatures, close the 'ligatures' lookup-editing window and
return to the main VOLT window.

Step 3: Adding small caps
For features that process sets of multiple glyphs (such as small caps), VOLT provides the
ability to create "glyph groups." Once glyph groups are constructed, they allow the VOLT
user to perform certain tasks with more ease and speed. If a font designer is creating
features to add to multiple fonts, glyph groups can be exported from one font to
another, making it easier to add layout support to similar fonts. The same glyph groups
can also be used by different layout features within a font — another time saver.

Creating glyph groups
For a small caps substitution, we'll want to create two groups: one containing the
lowercase letters (which will be substituted when small caps are turned on) and one
containing the small capital letters (to be substituted in). To create the first group, click
the 'Add Glyph Group' button in the bottom right-hand corner of the main VOLT
window. Though the name need not be anything in particular, it helps to give the group
a descriptive name. We'll call this group 'latin_lower_case_group'. Hit ENTER and then
double-click on the new group you've created.
We can now specify the glyphs we'd like to include in the group in the editing window.
Click in the first row of the 'Names' column and type the name of the first glyph to add
— in this case, lowercase 'a'. Hitting ENTER should make the 'a' appear in the adjacent
'Shapes' column. Continue in sequence, adding each lowercase letter (giving each glyph
its own row in the group) until you've reached 'z'. Scrolling to the bottom, your window
should look something like this:

Now that we've done the lowercase, we need to create the small caps glyph group.
Repeat the steps above, but instead of adding lowercase letters, add your font's small
caps in sequence (from 'A' to 'Z'). Call this group something like "small_caps_group".
Adding the 'smcp' feature and associated lookup With our glyph groups in place, we
now must create the small caps lookup feature (smcp) in VOLT. In the script/language
pane, highlight the 'Default' language and click the 'Add Feature' button at the bottom
of the VOLT window. Type in <smcp> and hit ENTER. VOLT should then label the feature
'Small Capitals'.
Next, in the 'Lookups' pane to the right, we add a new substitution feature by clicking
the 'Add Substitution' button at the bottom of the window. Give this lookup a name like
'small_caps' and hit ENTER. Double-clicking on the new group will then bring up the
editing window; this is where we tell VOLT to substitute the small caps group for the
lowercase group. This is similar to how we did the 'fi' ligature substitution, with one
important difference: glyph groups are named using angle brackets ( < and > ). So, in
the 'From Glyphs -> To Glyphs' column, we type:

<latin_lower_case_group> -> <small_caps_group>

and hit ENTER. Your window should then look like this:

Now that the lookup is done, return to the main VOLT window. Highlight the
'small_caps' lookup we've created and drag it to the 'Small Capitals' feature in the
scripts/languages pane. It should then appear as a branch under the 'Small Capitals'
feature (see graphic below). The small caps substitution is now in place.

７ Note
The vertical ordering of lookups in VOLT's 'Lookups' pane does affect the way the
lookups execute in programs like InDesign. If a given lookup is higher up in the list
than another, it will take precedence (you can change the order by clicking on a
lookup and dragging it either up or down). This is important in fonts that have
features that perform layout operations on the same glyphs. An example of this in
our font is the small caps feature and the 'fi' ligature we'e created: both affect the
lowercase letters 'f' and 'i'. So, it is important that the small caps feature we've
created is above the ligature feature — this way, InDesign will know that the small
caps should supercede the ligatures and the 'fi' ligature will not appear in the small
caps word with 'f' and 'i' next to each other.

Step 4: Adding old style numerals
Old style numerals (or figures) — the more traditional sort of numerals which are
sometimes referred to as 'lowercase' — have long been a problem in digital typography.
Most fonts simply didn't provide the option of old style figures, while the ones that did
usually came with lining (full capital height) figures, with the old style in an auxillary (or
'expert') font. Though old style numerals are preferred in fine text typography for their
elegance and more harmonious appearance, with surrounding letters, easy access to
them has long been problematic.
Now, with a properly done OpenType font, typographers can have seamless access to
both lining and old style numerals (by simply toggling the 'Old Style' menu option in
InDesign). To add support for this feature, we will use the OpenType layout feature
<onum> .

Creating the glyph groups

As with small caps, creating glyph groups for this feature will be useful: again, we are
simply substituting one set of glyphs for another. However, since we're now familiar with
the glyph group concept, this time we can take a small short cut. Instead of specifying
each glyph in the group individually on its own line, we can use VOLT's ability to specify
a range of glyphs with square brackets ([ and ]).
First, we'll add the lining numerals group (which will be replaced by the old style group
when the 'Old Style Numerals' feature is turned on in InDesign). Add a new group, just
as we've done before, and name it something like 'lining_numerals'. Then, in the group
editing window, we'll input the range of glyphs for the group. In the 'Edit Glyphs'
window, find the glyph name of your first lining numeral ('0') and the glyph name of the
last one ('9'). Then, in the first line of group editing window, type:

[glyph_name_0 - glyph_name_9]

and replace the two glyph names with the corresponding names in your font. After
hitting ENTER, your window should look something like this:

Next, create another glyph group (named something like 'os_numerals') for the old style
figures, again specifying the 0 to 9 range. Creating the 'onum' feature and associated
lookup Once both groups are created, we can add the <onum> feature — highlight the
'Default' language and click the 'Add Feature' button. Type in <onum> and hit ENTER.
VOLT will label the new feature 'Old Style Numerals'. For the final step, we must create
the lookup that will perform the substitution, and then link it to the <onum> feature we
created. Click the 'Add Substitution' button and name the new lookup something like
'old_style'. In the edit window, type:

<lining_numerals> -> <os_numerals>

and hit ENTER. Returning to the main VOLT window, click the 'old_style' lookup we've
created and drag it to the 'Old Style Numerals' feature in the scripts/languages pane.
The old style numerals layout feature is now complete.

Step 5: Add case-sensitive features
One of the more frequently overlooked details of fine typography is the adjustment of
certain letter placements, based on their context. The most common situation is with
text set in ALL CAPS. When characters like square brackets and parentheses are used
with text set in all caps, they usually appear too low (since they are vertically aligned to
work with lower case letters).
Though desktop typographers can often manually adjust character baselines when
necessary, the task is somewhat daunting when confronted with many of these
situations (as might occur when setting the text of book). But, using a combination of
the OpenType layout feature <case> and InDesign's 'All Caps' menu option, these casesensitive adjustments can be done automatically. In this example, we'll create a <case>
lookup to substitute vertically-adjusted square brackets for normal square brackets
when 'All Caps' is turned on.

Creating the <case> feature and associated lookup
In the main VOLT window, highlight the 'Default' language and click the 'Add Feature'
button, then type in <case> and hit ENTER. VOLT will label the new feature 'CaseSensitive Forms'. Next, go to the 'Lookups' pane to the right and click 'Add Substitution'.
Give the new lookup a name like 'all_caps_brackets'. After finding and noting the glyph
names of the brackets to be replaced and the adjusted brackets (four glyphs total), enter
in two substitution lines in the edit window:

glyph_name_left_bracket -> glyph_name_left_bracket_adjusted

and

glyph_name_right_bracket -> glyph_name_right_bracket_adjusted

Once you've added these two lines to the lookup, go back to the main VOLT window
and drag the 'all_caps_brackets' lookup to the 'Case-Sensitive Forms' feature. You can, of

course, add as many adjustments to your <case> lookup as you'd like — parentheses
and certain punctuation marks can often benefit from being vertically adjusted in all
caps settings.

Step 6: Compile and test your font
Now that we've added all of our OpenType layout features, we can use VOLT to test, or
'proof,' the font. But testing can begin, VOLT must first compile the font: click the
'Compile' button on the toolbar. If there are any problems with the features you've
added, VOLT will notify you at this point. Once the font has been successfully compiled,
we can proceed to the proofing tool.
To access VOLT's built-in testing facility, click the 'Proofing Tool' button in the VOLT
toolbar. First select 'Latin' in the 'Script' drop-down box and then select 'Default' in the
'Language' drop-down box. We'll start off testing the first feature we added: the 'fi'
ligature. First, type in the name of your font's 'f' glyph, a space, and then the name of
the 'i' glyph. Here's how your Proofing Tool window should look:

To test the 'fi' ligature, highlight the glyph names you typed into proofing tool, click the
'Standard Ligatures' check box, and then click the 'Complete' button in the right-hand
pane. If you've created the lookup correctly, you should see your 'f' and 'i' turn into an
'fi' ligature.

Repeat this process with your other features, typing in the relevant glyph names,
selecting the appropriate 'Feature' check box, and hitting 'Complete'.

Compiling and installing your font
Once you've verified that the OpenType layout features are working correctly, do a final
'Compile' and 'Save', and then exit VOLT. Find the font file and install it in your Windows
Fonts folder in the Control Panel.

Step 7: Test your font in InDesign
Once the font is installed on your system, fire up InDesign and create a new document
with a blank text box. In the character palette, select your font and type some text.
Type 'fi' and highlight it (then select 'Ligatures'):

Small caps (select 'Small Caps'):

Old style numerals (select 'Old Style'):

The all caps-adjusted brackets (select 'All Caps'):

Now that your OpenType layout-enabled font appears to be ready, open it back up in
VOLT and choose 'Ship Font' from the 'File' menu. This will remove the private VOLT
data, making the font ready for distribution and use (be sure to save a pre-shipped
version of the font file so you can modify your layout features in the future).

Using VOLT: Menus and toolbars
Article • 03/25/2022

File menu
Open Font – Opens a font for use in VOLT. Only one file may be open at a time.
Save Font – Saves changes to the file that is open.
Save Font As – Saves font file under another name.
Ship Font – Compiles OpenType tables and removes VOLT working tables from the
font. This saves space in fonts that are shipped.
Most Recently Used File List – Open files that were recently worked on in VOLT.
Exit – Closes VOLT.

Project menu
Add Script – Adds a script node to the writing system tree.
Remove Script – Removes the currently selected script and its children from the
writing system tree.
Add Language – Adds a language node to the currently selected script node.
Remove Language – Removes the currently selected language and its children
from the writing system tree.
Add Feature – Adds a feature node to the currently selected language node.
Remove Feature – Removes the currently selected feature tag from the writing
system tree. No lookups assigned to the feature being deleted are deleted from
the lookup list (use Remove Lookup instead).
Add Substitution – Adds a substitution type lookup element to the lookup list.
Add Positioning – Adds a positioning type lookup element to the lookup list.
Remove Lookup – Removes the currently selected lookup element from the
lookup list.
Add Glyph Group – Adds a glyph group element to the group list.
Remove Glyph Group – Removes the currently selected glyph group element from
the group list.
７ Note
All of the Project menu commands can be accessed with buttons at the bottom of
the main VOLT window.

Tools menu
Compile – Starts the compilation process. Any errors or warnings reported during
compilation are shown in the Output window (brought up). Clicking on an error or
warning in there brings the user to the corresponding lookup or glyph group. At
the end of compilation a summary is reported. If the compilation was successful,
the compiled OpenType tables are inserted into the font and the font is saved.
Edit Glyphs – Allows glyph properties (name, type, Unicode values, number of
components) to be assigned to each glyph.
Edit Glyph Group – Opens the currently selected glyph group for editing.
Equivalent to double-clicking the desired glyph group entry in the group list.
Edit Lookup – Opens the currently selected substitution or positioning lookup for
editing. Equivalent to double-clicking the desired lookup entry in the lookup list.
Proofing Tool – Opens the Proofing Tool window so OpenType behavior can be
tested.
Options – Allows setting preferred glyph sizes and cmap types for the fonts. These
values are saved in the font.

Import menu
Import Glyph Data – Imports glyph data from a previously saved file (*.vtd). Data
can be imported for a Glyph Range or by Unicode Values.
Import Lookup – Imports a lookup element from a previously saved file (*.vtl).
Appends the new lookup to all currently defined lookups. Does not hook the new
lookups to any of the existing features. Errors may be reported later when the new
lookups are compiled.
Import Glyph Group – Imports a glyph group element from a previously saved file
(*.vtg). Appends the new group to currently defined ones resolving saved glyph
names to glyphs currently in the font. During compilation errors may be reported if
names referenced in the glyph group are not found.
Import PostScript Names – Imports names for glyphs from the “post” table of the
font. This is a simple way to match glyphs to user-friendly names from the font.
Import Project – Imports all VOLT data from a previously saved file (*.vtp). This
includes glyph data, writing system, lookups and glyph groups.

Export menu
Export Glyph Data – Saves the glyph data and writing system to a file (*.vtd).
Export Lookup – Exports the currently active lookup element’s data to a file (*.vtl).

Export Glyph Group – Exports the currently active glyph group element’s data to a
file (*.vtg).
Export Project – Exports all glyph data, lookups and glyph groups to a single file
(*.vtp).

Toolbars

Open – Opens a font.
Save – Saves the current font.
Edit Glyphs – Opens the Glyph Editor window.
Edit Lookup – Opens the currently selected substitution or positioning lookup for
editing. Equivalent to double-clicking the desired lookup entry in the lookup list.
Edit Group – Opens the currently selected glyph group for editing. Equivalent to
double-clicking the desired glyph group entry in the group list.
Compile – Compiles the VOLT tables into appropriate OpenType tables so they can
be used with the fonts.
Proofing Tool – Opens the Proofing Tool window so OpenType behavior can be
tested.

Dialogs and windows
Main VOLT window
The main VOLT window is described below in functional areas.

Writing system is displayed in a tree control format. The writing system tree displays
scripts, languages assigned to scripts, features assigned to languages, and lookups that
are referenced by features.
Add Script – Adds a new script. The Default language is automatically added with
each new script.
Remove Script – Deletes the currently selected script and its children nodes.
Add Language – Adds a language node to the currently selected script node.
Remove Language – Removes the currently selected language and its children
from the writing system tree.
Add Feature – Adds a new feature to the currently active language.
Remove Feature – Deletes the currently selected feature and the references
assigned to it. The lookups referenced are not deleted.

Lookup List

The lookup list is the list of lookups specified for the font, in the order that they will be
applied. To change the lookup order, select the lookup to be moved and drag it up or
down the list.
Add Substitution – Adds a substitution type lookup element to the lookup list.
Add Positioning – Adds a positioning type lookup element to the lookup list.
Remove Lookup – Removes the currently selected lookup element from the
lookup list.
To link a lookup to a feature, select the lookup and drag it over to the feature for the
writing system desired.

Glyph Group List

The glyph group list provides the glyph groups for the font.
Add Glyph Group – Adds a glyph group element to the group list.
Remove Glyph Group – Removes the currently selected glyph group element from
the group list.

Options Dialog

Glyph Size in Grids – Specify the point size of the glyphs that are displayed in the
grid controls.
Glyph Size for Presentation – Specify the point size of the currently selected glyph
preview in the Glyph Editor.
Glyph Size for Positioning – The size of glyphs for preview in the Positioning
Lookup window.
Gray Scale – Display preview windows with gray scale enabled.
CMAP Generation – Allows a user to specify various cmap formats for the font.

Glyph Editor Dialog

This dialog window is used for editing glyph properties.
Find – Find a glyph by name or value (shortcut is Ctrl+F).
Name - Change the glyph name used by VOLT.
Type - Set the mark type as simple, mark or ligature.
ID - Shows the glyph ID, which is editable.
Unicode - Change the glyph's Unicode value.
Components - Change the number of components of a glyph.
Glyphs - Each glyph occupies a single cell in the display grid. The cell contains a
preview of the glyph, the name, glyph ID, Unicode value(s), and the type and
number of components (if it is a ligature).

Proofing Tool Dialog

This dialog is used to proof the OpenType shaping functionality that has been specified.
Script – Set the script to use for selecting the writing system.
Language – Set the language to use for selecting the writing system.
Text Flow – Controls the layout order of the previewed text.
Alternate – Set the alternate number if an alternate substitution is used.
Edit string – Specify text to display, which must be a glyph name specified in the
font.
Features – Features available for the specified writing system. To set the value(s)
for each glyph, place the caret in the glyph name, or select one or more glyph
names for applying selected features.
Lookups – The lookup(s) that will be processed are highlighted. All processing is
done in lookup order.
Restart – Restart the glyph processing from the beginning.
Next Glyph – Moves processing to the next glyph.
Next Lookup – Moves processing to the next lookup.
Complete – Moves processing to the end. This is the final form of display.

Using VOLT: The project window
Article • 11/13/2021

The Main project window provides a bird's eye view of the OpenType Layout table
structure of the font you are working on. OTL table generation is a well-defined,
structured activity that makes use of a 'building block' concept. The individual panes
contain details at different levels.
The rightmost pane shows units called 'glyph groups'. The smallest unit of information
for generating glyph groups is the glyph. These units help string together glyphs. Glyph
groups are the building blocks for lookup generation. The lookup pane lists lookups
used by features. These lookups string together glyph groups and glyphs to enable
glyph substitutions and positioning.
The leftmost pane includes information from the lookup and glyph group panes, as well
as information about scripts, languages and features. It allows the font developer to see
the overall structure of the OTL tables constructed for the font.

Viewing glyphs
Selecting the 'Edit Glyphs' button launches the glyph grid, where you can view glyphs,
their names, CMAP entries and assigned types. For ligatures, you can also set the
number of components they have (which affects mark-to-ligature positioning lookups
and caret placement inside ligatures).

Creating the feature tree
From the main project window, you can create the Script / Language System / Feature /
Lookup tree. Input each item in the form 'name <tag> ' (with the tag in angular
brackets). You can input the tag only or name only and VOLT will deduce the other part
for all registered tags.

The list of registered tags is stored in the VOLT application directory in a file called
tags.txt . More updates will become available as we register more tags. In future

versions of VOLT, the mechanism will be changed to getting the localized names
through NLS+. The order that features are listed is for ease of locating applied features,
and does not imply nor affect lookup processing order.

Scripts, language systems and features are always sorted alphabetically. The order of
these does not affect the processing order in the font.
Language systems with tag <dflt> are marked by VOLT as default language systems.
Features with tag <dflt> are marked by VOLT as required features. Please note a
difference with raw OTL format here, where any feature or language system can be
designated as required or default.

Adding lookups
To add lookups to features, you must create them separately in the 'lookup list' and then
drag-and-drop them into corresponding features.
Lookups are not arranged alphabetically like the feature list. Lookups appear as they are
executed, each called only once. Therefore, it is important that the order is determined
in advance by the font developer.
To change the order of lookups, drag-and-drop them in the lookup list. This will change
their appearance order in the feature tree as well.

Adding glyph groups
You can add glyph groups in the main project window. Having glyph groups does not
have any effect on font functionality, but using predefined groups in lookups may really
speed things up. To reference a group in a substitution or positioning lookup, write the
group's name in angular brackets, e.g. <Capitals>.

Groups are always displayed in alphabetical order.

Names
Anything that has a tag (scripts, language systems and features) may have a name with
any kind of characters in it. These items are referenced by their tags. All names are case
sensitive. Glyph names can contain only letters and digits. With VOLT version 1.1, we
also allow '.' and '_' characters in glyph names.

Using VOLT: The glyph grid
Article • 03/22/2022

The glyph grid lists all glyphs in the font with their names, glyph IDs, corresponding
CMAP entries, assigned types and component numbers. All this information (except the
glyph IDs themselves) can be changed through the top part of the tool. Select
Tools/Options to set the size of the glyphs displayed in the grid.

Before working on a font, all glyphs contained within it should be named. This can be a
tedious and time-consuming process, especially for large fonts. VOLT includes several
options to help speed up this task and help you reuse glyph names used in other fonts.
These options are documented in the section on file options.

To change glyph information, select a glyph in the grid and change its data above.
Clicking somewhere else in the grid or otherwise changing focus commits your changes.

The 'Find' button (also accessible via Ctrl-F) allows you to search for glyphs by name or
Unicode value (the glyphs appear in ID order).

Glyph name
While editing glyph names, press ENTER to commit the name change and automatically
go to the next glyph. This is convenient for entering groups of glyph names. Glyph
names may contain latin letters and digits. In VOLT version 1.1, the characters '.' and '_'
are also valid for glyph names.

Glyph type
Valid options for glyph type are 'simple', 'ligature', 'mark' and 'component'. Glyph types
are defined in the Glyph Class Definition Table section of the OpenType specification. A
'simple' glyph is a single character, spacing glyph. A 'ligature' glyph is a multiple
character, spacing glyph. A 'mark' glyph is a non-spacing combining glyph, and
'component' glyph is part of a single character, spacing glyph.
Tip: Globally set all glyphs to 'simple' and change to other types as needed. To do this,
define a glyph group that contains all the glyphs (for example, [glyph1 - glyphxxxx]) and
then select 'Mark all as...' in the group tool.

Glyph ID
This field cannot be edited.

Unicode
VOLT lets you edit this field, offering basic 'cmap' editing functionality. VOLT version 1.0
did not allow one glyph to have multiple 'cmap' entries. With VOLT version 1.1, this
limitation is removed. You can enter one or more Unicode code points using U+xxxx, 0x
or &H for each glyph. A valid entry will be displayed as U+xxxx. To assign multiple
Unicode code points to a single glyph, use the format: 'U+xxxx,U+xxxx,...'. You may
substitute the comma with a semicolon.
With VOLT 1.1, we also added support for surrogate glyphs. To enter a surrogate
character code, use surrogate pairs such as 'U+D800DC00'.

Components
For glyphs defined as ligatures, this indicates the number of components and is used
later for defining caret placement.

Using VOLT: The glyph group tool
Article • 03/22/2022

Using the Glyph Group Tool, you can open the group's definition by double-clicking on
a group name in the main project window, or by selecting the 'Edit Group' button.

A group is a collection of glyphs or other groups put together. Glyphs and groups are
referenced by name and bound only at compilation time.

As shown above, the Glyph Group Tool displays a two-column table. On the right hand
side, the member glyphs/ groups/ ranges/ enumerations are listed. They are previewed
in the left column using actual glyphs from the font.
The valid entries in the right column are:
Valid glyph names, as specified in the glyph grid
References to other glyph groups, in angular brackets (there is a limit of 100 levels
of nesting): <OtherGroupName>
Continuous ranges of glyphs, in the format [StartingGlyphName - EndGlyphName]
Glyph enumerations, in curly brackets: {GlyphName1, ..., GlyphNameN}

The same syntax of entries can be used in the Substitution and Positioning Tools, and
generally anywhere a glyph name can be entered (with the exception of the Proofing
Tool). All glyphs in a group can be assigned the same type, via the menu option 'Mark
All Glyphs As...'. The group is bound to glyphs immediately when the menu option is
selected. This method of assigning glyph types is sometimes more convenient than
using the glyph grid.

Glyph names and shapes
The list of glyph names contains a list of editable glyph names, one name per line. VOLT
maintains the side column of actual glyph shapes corresponding to these names.

The shape appears next to a name as soon as the user has finished editing the line
(moved the caret away, pressed enter or changed the focus). If the line does not contain
a valid glyph name a red error sign appears instead of the shape. The user can correct
the problem by editing the name or changing glyph names in the Glyph Definition Tool.
If the error is not corrected it will be reported during compilation.

Adding and removing glyphs
To add or remove glyphs from the group, the user edits the glyph name list like if it was
a text window. Pressing enter at the end of line starts a new one and the backspace and
delete keys remove characters as well as line breaks. Cutting, copying, pasting and dragand-drop are also available. As soon as the user moves away from a line, the glyph
shape corresponding to the name in that line is displayed in the glyph shape column. If
the line does not contain a valid name, a red colored error symbol is displayed instead
of glyph shape. The glyph shape list is not editable.
One can also drag glyphs from the glyph definition tools to the glyph name list to add
their names to the group. The new glyphs appear on a new line (carriage return is
inserted) at the place where they were dragged.

Round-tripping
It is not necessary to preserve the order of glyphs in the group. When the Glyph Group
Tool is re-open the glyphs should appear in the order of their glyph IDs.

Compilation
The glyph groups are not compiled but are used to compile coverages and class
definitions of lookups that use them. For compilation, one can always consider glyph
groups to be sorted by glyph ID.

Using VOLT: The substitution tool
Article • 06/10/2020

A substitution lookup can be edited with the Substitution Tool one of 2 ways:
Double click on it in the main project window; or
Select it and press the 'Edit Lookup' button.

Lookup header
The lookup header occupies the top portion of the tool. The same kind of header is
used in the Positioning Tool to describe positioning lookups.

The Substitution tool
The header contains the following fields:
Lookup name
Lookup type, which is set automatically for substitutions (you must specify the
lookup type manually for positioning lookups); if substitutions entries have
inconsistent types, this field will change to 'Unknown substitution' to alert you;
attempts to compile such lookups will result in errors.
Process Marks, which define the lookup's behavior towards marks. Valid entries are:
ALL - all mark glyphs are processed

NONE - all mark glyphs are skipped by this lookup
Group name - only marks from this group will be processed, other marks are
skipped.
７ Note
All marks groups used in this way in lookup headers have to be mutually
exclusive. If you need to use this feature, it is advisable that you break the
marks down into several separate groups beforehand, and then use these
groups in lookup headers. The breaking into groups usually follows the
geometrical position of marks (marks above, marks below etc.) and is similar
to combining mark classes assigned by Unicode.
Process base glyphs - when off, all non-mark glyphs are skipped by the lookup.
Text Flow - valid entries are Left-To-Right (LTR) or Right-To-Left (RTL); affects the
display (preview) of substitution/positioning operations, and the way glyphs are
placed for positioning; set to RTL when working with languages such as Arabic or
Hebrew.

List of substitutions
The list of substitutions consists of two columns: descriptions on the right and previews
on the left. The descriptions use glyph names and groups to specify the substitution.
The preview column displays the glyphs involved in the substitution.
All substitutions are defined in the following format: LeftHandSide -> RightHandSide.
For example, 'Ampersand -> AlternativeAmpersand' could define a single or alternative
substitution, and 'LatinSmallLetterF LatinSmallLetterI -> LatinSmallLigatureFI' could
define a simple ligature.
A single menu option lets you order your substitutions, which is handy if you are dealing
with large glyph sets. Read the caveat though: ordering by the first glyph generally will
not change how the lookup is processed. But, if you are using groups in defining your
substitutions (see below), complete ordering is impossible (the groups are not broken
down), and the new ordering may have an effect on the lookup's behavior.

Use of groups in substitutions
Groups can be used in substitutions as a shorthand notation, meaning the substitution
should be performed with each element of the group. Any group notation (a reference

to a predefined group, a range or an enumeration) can be used (see the Group Tool
section). At most, one glyph group can be used on each side of a substitution. If groups
are used on each size of the substitution, their cardinalities have to match. Such
substitution compiled into a series of substitutions, with groups substituted by
subsequently the first, second and so on, members of the groups. For example, the
substitution:
'[LatinSmallLetterA - LatinSmallLetterZ] -> [LatinSmallCapZ - LatinSmallCapZ]'
will be compiled into the series:
'LatinSmallLetterA -> LatinSmallCapA', 'LatinSmallLetterB -> LatinSmallCapB'
and so on.
７ Note
Glyphs in groups are always ordered by their glyph IDs and not by the order
implied from the way a group is described.

Using contexts
The bottom part of the substitution is for describing contexts. By using contexts, you
declare that the substitutions above cannot happen anywhere the lookup is applied but
only if surrounded by the specified contexts.

Using VOLT: The positioning tool
Article • 06/10/2020

A positioning lookup can be edited in the Positioning Tool by double-clicking from the
main project window or selecting it and pressing the 'Edit Lookup' button. This is by far
the most complex tool in the box; what follows is only a general description.

Lookup header
See the Substitution tool section.

Lookup types
The lookup type must be chosen before any data can be entered into the Positioning
Tool. Below, very brief notes for each lookup type follow.

Glyph positioner
This is where you can specify positioning operation by drag-and-dropping glyph and
anchor images. You can also enter the adjustments or coordinates below in a little table,
for later display on the positioner.
For each operation, several images appear on the positioner, corresponding to the
glyphs and anchors you can position. The 'inactive' shapes that cannot be positioned are
shown in gray. Also, three lines indicate the font ascender, base line and descender. It is
advisable that positioning operations not cross ascender and descender boundaries.
In the left-bottom corner is a small 'preview', the result of positioning at a smaller size.
Choose the size right below the preview.

Single adjustment
The 'Single Adjustment' operation is for positioning of single glyphs, most useful when
used in a contextual fashion.
Glyphs: Enter names of glyphs to be positioned in the list on the right. Glyphs groups
can be used. All glyphs in the group (in one line) will receive the same treatment (the
same adjustments to their positions). You cannot repeat the same glyph twice in
different lines.
Positioning: Select a glyph or glyph group. In the positioner, drag the glyph image to
get the adjustment operation you need. Drag the tall 'width anchor' to enter
adjustments to the advance width. If multiple glyphs are entered on the simple line in
the glyph list, you can choose different shapes from the dropdown list below to see how
your positioning operation affects each glyph on the list.

Pair adjustment

Allows you to position pairs of glyphs. Similar to single adjustment, except that now
there are two lists of glyphs, the first glyphs and the second glyphs.
Each pair of entries (one from each glyph list) is adjusted individually. As with single
adjustment, if a glyph group is used, all glyphs from the group get the same treatment
and positioning.

Anchor attachment

This option allows you to define Mark-To-Base, Mark-To-Mark and Mark-To-Ligature
lookups. The actual lookup type is defined by the type of glyphs used. You cannot mix
different glyph types in one lookup.
Next to the mark, enter the anchor name that identifies the anchor to be positioned to.
One glyph can have any number of different anchors (with different names). If two
marks share the same position, relative to the base glyph, they can use the same anchor
name.
To define Mark-To-Base Lookups, enter a list of bases in the first glyph list, and a list of
marks in the second list. After selecting one entry from each list, position the mark and
anchor point in the positioner. When using glyph groups in the base or mark list, select
a glyph to work with from the drop-down boxes above the positioner. Please note that
glyphs in one groups do not share the same positioning values. However, you may
apply one anchor position to all glyphs in a group by selecting the 'all 1st same' or 'all
2nd same' button.
７ Note
Moving the anchor point affects both the base and mark anchors. To move only
one anchor, first lock the other anchor down (see below).

７ Note
Mark values are globally shared between lookups. For example, if two different
lookups use the same anchor named 'TopCenter' for positioning a top mark over
letter 'A', changing one lookup may affect another. You can lock a base anchor to
prevent it from changing, and then fine-tune the position with the mark anchor, or
vice versa.

Locking anchors: Below the positioner, an option is provided to lock either or both
anchors. A locked anchor cannot be (unintentionally) changed until it is explicitly
unlocked. If another lookup uses this same anchor (identified by glyph ID and anchor
name), it will be locked in that lookup as well.
Defining Mark-To-Mark and Mark-To-Ligature Lookups: This is similar to defining
mark-to-base lookups. The only difference is defining positions for many anchors per
ligature glyph instead of one per simple base glyph (one anchor per component). The
currently 'active' component is controlled by the component drop-down box above the
positioner. The 'inactive' component anchors and marks are grayed out.

Cursive attachment
Cursive attachment is similar to anchor attachment. The anchor name is fixed to 'entry'
for the second glyph, 'exit' for the first glyph. Used to define cursive positioning
lookups.

Caret positioning
Caret positioning does not compile in an OTL lookup and cannot be linked to a feature.
All data from caret positioning operations is gathered to produce GDEF data, which is
then used by OpenType Layout services for measuring operations and caret placement.
Glyph list: Defines what ligatures' caret positions are described. Only ligature glyphs can
be entered. Drag the tall 'caret' anchors to the right positions of carets inside ligatures.
A ligature will have one less caret anchors than it's number of components. Choose the
'active' anchor by manipulating the component field above the positioner.

Adding device corrections
Check the 'Adjustment Mode' box to enter the mode when all positioning changes
affect the currently selected size only. The 'Adjust at this Size' checkbox will expose
adjustments for the selected size. These adjustments are always shown on the little
preview. Check 'Adjustment Mode' to display them on the big positioner for additional
changes.
De-select the 'Adjust at this Size' checkbox to clear adjustments for this size. Select the
'Clear' button to clear them for all sizes.

Defining contextual positioning

See Using Contexts in the Substitution Tool section.

Using VOLT: The proofing tool
Article • 03/25/2022

The Proofing Tool is often used to test fonts with small runs of text.
To do that, do the following:
1. Open the Proofing Tool and select the Script and Language system you would like
to test. Selecting the language system will populate the feature list.
2. Select a writing direction (text flow).
3. Create a glyph run by either entering glyph names into the long text box above
the feature list, or by clicking on the picture below it and entering glyphs through
keystroke. Each keystroke will be translated into a glyph using the current Unicode
entries, and the resulting glyph name will be added to the names in the run.

4. Select features by highlighting some or all glyph names and checking the
corresponding feature boxes. On the right is the list of lookups enabled by these
features. You can cursor back and forth in the list of glyph names and see the
features change as you go from one glyph to another. If you simply need to apply
certain feature(s) to the whole run, highlight everything in the glyph name list and
then select the features you need.

5. Use the 'next glyph' and 'next lookup' buttons to apply your selections and see
how the OpenType engine processes your string. 'Restart' brings you to the
beginning of the processing and 'Complete' shows you the final result.

Using VOLT: File options
Article • 03/22/2022

To save your work, select 'Save Font' from the File menu or click the 'Save' button on the
toolbar.

VOLT saves its data in a temporary table inside the TTF. VOLT keeps more data around
(to make its interface more user-friendly), so the translation to OT assembly is not
reversible. As long as other tools preserve this table, it should be safe to open and save
the same font in different tools.
After completing work on a font, select 'Ship Font' from the File menu. When a font
ships, the temporary VOLT source code table is removed from the font.

７ Note
The VOLT source code table contains a serialized text presentation of your VOLT
data that is quite easy to understand. We don't want to encourage anyone to hack
this data, but if you look at what's in there, you'll immediately figure the format out.
The format is the same as that used to import and export lookups, glyph groups
and glyph definitions, as described in the following Samples section.

Import and export options
VOLT supports the import and export options shown in the composite screen capture
shown below.

Export glyph range

The glyph information is saved as a .VTD file. A code snippet is shown below.

DEF_GLYPH "halfSha" ID 230 END_GLYPH
DEF_GLYPH "halfSsa" ID 231 END_GLYPH
DEF_GLYPH "halfSa" ID 232 END_GLYPH
DEF_GLYPH "halfHa" ID 233 END_GLYPH
DEF_GLYPH "halfKaSsa" ID 234 END_GLYPH
DEF_GLYPH "halfJaNya" ID 235 END_GLYPH
DEF_GLYPH "halfKaNukta" ID 236 END_GLYPH
DEF_GLYPH "halfKhaNukta" ID 237 END_GLYPH

Many font developers map glyphs to glyph ID in a standardized way. If you do this,
name your glyphs once using the glyph editing tool, and then apply the exported .VTD
file across your library.

Export lookup

Lookup information is saved as a .VTL file. A code snippet is shown below.

DEF_GROUP "FullJaForms"
ENUM GLYPH "fullJa"
GLYPH "fullJaNukta"
GLYPH "fullJaRa"
GLYPH "fullJaNuktaRa" END_ENUM
END_GROUP

Export project
This option is particularly useful when adding glyphs to a font with a tool that
overwrites, deletes or corrupts OpenType layout tables or VOLT private tables.

Import options
Import options are for reusing glyph, lookup, group and project information. For
example, the Import PostScript Names option assigns the names stored in your font's
POST table to the glyph names used by VOLT.

Using VOLT: Samples
Article • 06/10/2020

Accessing supplemental files
To access VOLT's supplemental files, select the 'VOLT supplemental files setup' option
from the Windows Start menu (Start/All Programs/Microsoft VOLT).
The VOLT supplemental files EULA (End User License Agreement) appears first. After you
accept the EULA, you are asked where to install the supplemental files on your local
hard drive.

Mangal
This copy of Mangal contains OpenType layout tables and was constructed using VOLT.
We hope you find it useful.
Mangal was designed for Devanagari and supports complex typographic requirements
of the script. A non-exhaustive list of such requirements includes:
generating 'akhands'
substituting the appropriate Ra vattu forms
substituting half forms of consonants
selecting appropriate vowel signs to replace the default vowel signs that go with
consonants, conjuncts for syllable formation
positioning mark(s) and vowel signs with respect to base glyphs and ligatures
This font is a 'work in progress' and illustrates just one of the many ways to build
OpenType font tables with VOLT. One of our prime objectives in this illustration is to
represent as many features of VOLT as possible. To cite examples here: we have
classified glyphs in a large number of groups and provided mark-to-mark positioning
using pair-positioning tables. To achieve similar results, you might choose to classify
glyphs differently, with fewer groups, or use anchors for mark-to-mark positioning.
These tables provide a way of seeing and understanding the underlying thinking process
for building OpenType tables with VOLT. They are not the 'typical' way for creating
tables for Devanagari. VOLT provides the OpenType type designer a 'visual' tool with a
lot of flexibility and options to create OpenType layout tables!
The font itself has been designed with simple construction in outlines, for use as a Sans
Serif UI font. It is the font that is mentioned in Appendix C of the OpenType Indic

specification.
Mangal can be considered a flagship Indic font that has the full implementation of
OpenType, from glyph repertoire to tables. Mangal is provided under the terms of the
VOLT supplemental files EULA, and may not be redistributed.

Arabic Typesetting
The Arabic Typesetting font is distributed with VOLT, under the terms of the VOLT
supplemental files End User License Agreement (EULA). It is provided for illustration
only, and may not be altered or redistributed.
Arabic Typesetting supports all characters from the Unicode Arabic and Arabic Extended
blocks. As such, it can be used to produce documents in Arabic, Farsi, Urdu, Sindhi,
Malay, and Uighur. The font is the Arabic naskh style of calligraphy.
Arabic Typesetting contains layout information and glyphs to support all of the required
features for the supported scripts and languages, and contains over 1600 Arabic glyphs.
It is not necessary for all fonts to support this many glyphs or ligatures. Each font should
be designed as the font creator desires.
Many shaped glyph forms (such as ligatures) have no Unicode encoding. These glyphs
have ID's in the font, and applications can access these glyphs by "running" the layout
features that depend on these glyphs. An application can also identify non-Unicode
glyphs in the font by traversing the OpenType layout tables, or using the layout services
for purely informational purposes.
Arabic Typesetting contains three OpenType Layout tables: GSUB (glyph substitution),
GPOS (glyph positioning), and GDEF (glyph definition, distinguishing base glyphs,
ligatures, classes of mark glyphs, etc.).

Uniscribe
For testing your fonts, we've included an updated test version of Microsoft's Unicribe
(Unicode script processor). The .dll and installation instructions are included in the
usp.zip file.
Uniscribe is also provided under the terms of the VOLT supplemental files EULA, and
may not be redistributed.

VOLT release notes
Article • 06/10/2020

1.4
Since the last public Visual OpenType Layout Tool (VOLT) release, we have added various
features and made improvements across the product. Here is quick list of changes,
followed by a detailed description of each:
Compiler optimizations enabling significant savings in compiled table size
Compiler optimizations to support fonts containing extensive anchor or cursive
attachment lookups
Support for mark filtering sets in compiler and user interface
Speed improvements for project compilation, loading, and saving
User interface improvements
Multiple bug fixes across VOLT including the compiler, project import and export,
and across the UI

Compiler improvements
New optimizations towards reducing the size of generated layout tables, including
contextual and pair positioning lookups. Savings in size are significant especially with
fonts containing a large number of complex contextual lookups. In some cases, savings
allowed 4x reduction in compiled table size.
The compiler is now able to compile GPOS lookups with a large number of defined
attachment anchors. This was one of the most serious compiler limitations without any
workaround for font developers to overcome.
VOLT now implements mark filter glyph sets introduced in OpenType specification 1.6.
Using mark glyph sets is almost the same as mark attachment classes, except the user is
required to put '*' in front of mark group name in lookup editing window. This syntax is
intentional, to prevent a user from accidentally creating overlapping mark classes.
In addition to automatic optimizations, VOLT added ability to manually control format of
pair positioning lookups. User can specify format explicitly by adding _PPF1 or _PPF2 at
the end of lookup name.

User interface

Extended proofing tool to support fonts with more than 100 lookups. Fixed form layout
problems when content is obstructed by thick window borders. Fixed positioning lookup
window so position inside grids is preserved during window resize. Added menu item
for importing project ignoring glyph definitions.

Various fixes
Fixed project corruption when editing lookups with EXCEPT context. Fixed VOLT crash
involving caret attachment lookups in some situations. Fixed compilation error of
projects using very long anchor names. Other fixes in VOLT compiler and user interface.

1.3
Since the last public VOLT release two years ago, we have added various features and
made improvements across the entire product. Here is quick list of changes, followed by
detailed description:
Font Explorer, allowing users to quickly search for glyph references inside lookups.
Usability improvements, including lookup comments, new UI options and detailed
error messages.
Compilation improvements in quality, compatibility, and performance.
Overall performance improvements, including import, export, and font size.
Updated supplemental files and tags list.
Multiple bug fixes across VOLT including the compiler, project import and export
and across the UI.

Font Explorer
Font Explorer allows font designer to instantly search project lookups for any
appearance of the glyph, wherever it referenced directly or as part of glyph group. Users
may also search for a sequence of glyphs. Search can be controlled by several
parameters in the Explorer window.
From search results, a font developer can quickly jump to a particular line inside a
lookup input or context. This can be done by Ctrl-clicking on the corresponding line in
the search results. By Alt-clicking on a lookup or group name, user can open the
corresponding lookup or glyph group. When user clicks on glyph name, VOLT will jump
to glyph definition inside glyph editor. Same Alt-Click is also enabled in the lookup
window (inside both input or context fields).

Font Explorer can be accessed by clicking 'Explore' button on the toolbar or from Tools
menu.

Lookup comments
Font designers can now add comments to each lookup in font project. If one of
comment lines starts with "TODO:", it is considered special to-do item for this lookup.
Lookup comments can be added from lookup window menu.

Main window
Main window now supports view options allowing the display of detailed information
about lookups and glyph groups right inside main project window. Lookup list can also
display lookup content, comments, or to-do action items. Glyph group can show group
content. View options can be controlled from the redesigned options dialog.
VOLT now remembers main form size and position, view options, and font sizes used in
other VOLT windows. Overall form layout had changed, giving more space to lookup
and group lists. Feature tree opens in compact state, with lookup lists collapsed by
default.

Project improvements
Performance is significantly improved for project compilation, loading and saving. It is
now several times or even tens of times faster on complex fonts. Font file size is also
improved by avoiding keeping intermediate compilation tables.
Option had been added to avoid overwriting the cmap table from VOLT, allowing cmap
editing by other font tool like FontLab.
Support had been added for FontLab glyph syntax in lookups and the proofing tool. ‘/’
is now allowed as a separator between glyph along with space and comma, enabling
simple copy-paste from FontLab.
Detailed error messages for various problems with project import and editing have been
added.

Compilation
Detailed error messages added for some compilation errors and invalid project sources.
Maximum number of components per ligature is increased from 6 to 16.

Vertical form substitution features ‘vert’ and ‘vrt2’ are compiled in a way that is
compatible with GDI.

Other changes
Updated usp10.dll and sample fonts to versions shipped with Windows Vista SP1.
Tags.txt file updated, including recently added features and the new Indic v.2 tags.
Kern2Volt updated to support longer glyph names (up to 255 characters).
Multiple bug fixes.

1.2
Context exclusion syntax for contextual lookups
This is the new way of using contexts in VOLT lookups, allowing font developer to do
things that were not possible before and to implement lookups more efficiently. Inside
the lookup user can use 'EXCEPT' contexts and substitution or positioning will happen
only if input does not match excluded context. To do this, you simply type 'EXCEPT'
word (case sensitive) in the beginning of context you want to exclude. You can use both
normal and 'EXCEPT' context in one lookup. The only restriction is to put all 'EXCEPT'
contexts before normal ones.
Here are few simple examples of how context exceptions can be used:
First, in this example we’ll substitute letters with special forms at the end of the words.
Normally, you can't do this or can do with very unintuitive.
Letters -> EndOfWordForms In context: EXCEPT | Letters
The second example mixes normal and except contexts, making code more readable.
Before, you would need at least two lookups to do this and this would cause
unnecessary substitutions.
A -> A.1 In context: EXCEPT | x y | x

Export and import for multiple lookups and multiple
groups

You can now select multiple lookups and export them into single file. Same can be done
with groups.
This change required slight changes in export file syntax. This is important if you have
lookups or groups exported from older version and want to use them in the new VOLT.
Even if you have one lookup in the file, it should be appended with the 'END' keyword at
the very end. (You can use your favorite text editor for that). Please note: if you import
lookup from new VOLT into older version, only the first lookup will be imported.
If you have a positioning lookup that uses anchors, 'END_POSITION' keyword should be
moved before all anchors in the file. And, of course, do not forget the 'END'.

Main window improvements
You can now select and drag multiple lookups from lookup list into feature tree. You can
delete several lookups as well.
Feature tree is not refreshing and expanding after every change anymore. Also, if you
select a feature node in the tree, lookup list will automatically select all lookups
associated with this feature – a convenient way to check if some lookup is missing from
the feature.
Users may re-import cmap table from the font at any time. It is useful when font had
been modified outside VOLT with some other tools. You just should not forget to do this
first thing after you opened font in VOLT - otherwise cmap will be overwritten by data
stored in the VOLT project.

Proofing tool improved experience
Now, when you close the proofing tool window and open it again it restores all
parameters that you used to test your font – input glyphs, script and language system,
features applied.
Also, debugging your lookups is made easier. Instead of using lookup navigation
buttons, you can just use combobox above it and jump directly to the lookup you are
interested in.

Glyph properties window improvements
Character codes for surrogates can be entered as scalar values instead of surrogate
pairs. Surrogate pair format is still recognized but immediately converted into scalar

value. Please note that because of that change older versions of VOLT will not
understand fonts saved from this new version, but only if surrogate characters are used
in the project.
Search box had been added to glyph editor – at the very top, above glyph properties
text box with Find button. Button is the same as it used to be, but when you type into
the box VOLT will dynamically search for and select first glyph that has specified prefix.
Also, if you type U+xxxx it will search for the glyph which has this character mapped to
it, e.g. U+61 or U+0061 will select Small Latin ‘a’.

Positioning lookup editing
New, convenient model to restrict anchor movement added to positioning window.
When dragging an anchor with the mouse you can press Shift key to allow anchor only
move horizontally, and press Control key for vertical-only movement. If you press
Control/Shift in the middle of the dragging it will have the same effect as if it was
pressed from the very beginning - anchor will jump onto the original vertical or
horizontal position.

Compilation options
You may now control compilation by instructing VOLT to use extension lookups or
choose to use format 2 for pair positioning lookups (by default, format 1 is used). These
options are saved in the project and used every time project is compiled. Use this option
only when it is needed – when size of the tables in the font becomes too big to fit your
lookups.

Various bug fixes
Multiple minor and not so minor bugs fixed in VOLT.

Supplemental files updated
Supplemental files are updated. New Uniscribe is taken from a recent Windows Vista
build, integrating the latest changes to script shaping engines. Mangal font is also latest
Vista version. It is renamed to "Mangal Sample" and has hints stripped out.

1.1
Initial release

Microsoft Visual TrueType (VTT)
Article • 03/23/2022

Microsoft Visual TrueType (VTT) is a professional-level tool for graphically instructing
TrueType and OpenType TM fonts.

Download Visual TrueType
Download VTT from the Microsoft Download Center.
(Just follow the link and click the download button.)

Is Visual TrueType the right tool for you?
Although the graphical user-interface of VTT dramatically simplifies the task of font
hinting, the tool is not for the novice. The learning curve is fairly steep, simply because
hinting requires professional skills regardless of the tools. Even accomplished type
designers who have been using font editors for years to design fonts have evaluated
VTT and decided that professional hinting is not for them.

Instructions and tutorials
Hinting overview/Fixing rasterization issues
Indic hinting training video
Version 4.2 release notes and shortcuts list
Italic hinting examples

Release notes

Version 6.35 [July, 2021 release]
The following are changes since 6.34 [December, 2020 release]
VTTShell. Add option to compile range of glyphs.
Various bug fixes.
Fix windows scroll issue when editing CVT variations.
Fix VTTShell not compiling last glyph.
Fix issue with cvar table generation with CVT number greater than 256.
Fix issue with character set sync across views if sync charset with main is
disabled.

Version 6.34 [December, 2020 release]
The following are changes since 6.33 [November, 2019 release]
Per display DPI awareness. Support per display DPI when rendering visual
elements. This is noticeable when dragging VTT from one display to another on a
multi display system.
Various bug fixes.
Fix undo/redo that was not working in the main view.
Fix issue with composite detection change detection in variation font.
Fix issue where VTT was not opening on display where last closed.
Fix IDEF definition limit issue.
Fix issue with cvar table generation where tuple records have more than 63 CVT
entries.
Fix issue with Light Latin auto hinter on complex glyphs.

Version 6.33 [November, 2019 release]
The following are changes since 6.32 [October, 2019 release]
Bug fix in Variation CVT view preventing user editing of some instances.

Version 6.32 [October, 2019 release]
The following are changes since 6.31 [October, 2018 release]
Enhanced vertical accent placement. Update autohinter and hinting template files
for enhanced vertical accent placement. Positions marks in composites with greater
precision using logic similar to Res*() functions.

VTTShell command line tool updates. Enhance VTTShell with more complete error
reporting and ability to strip TSI tables from a font that has already been compiled.
Prevent composite glyph definition from changing. VTT will no longer overwrite
composite glyph definitions (i.e. OFFSET[] and USEMYMETRICS[] pseudoinstructions) that are inconsistent with VTT source. Instead, VTT will leave the
composite definition as is in the glyf table, and report an error.
User interface enhancements and bug fixes.
Fix point drawing problems in main view for coincident adjacent points.
Variation main view will now update after changing the CVT program and
compiling.
Change variation UI to allow scrolling the CVTs listed in the non-editable default
instance of a variation font.
Fix bug when opening a font in VTT after closing another font when sometimes
the default instance CVT data was editable when it should not have been.
Various bug fixes.
Fix reported autohinter crashing bug.
Create cvar from source when compiling all programs in both VTT and VTTShell.

Version 6.31 [October, 2018 release]
The following are changes since the 6.30 [August, 2018 release]
Introduction of “follow gasp” mode where text displayed in VTT can follow gasp
table settings. Previously, VTT supported editing of the gasp table but text
displayed in VTT would not follow gasp table settings. The “follow gasp” mode is
an optional mode where text displayed in the main windows, sample text view,
waterfall view and charset view will render according to appropriate gasp table
settings.
Various bug fixes. Bug fixes including fix bug when importing glyphs from a
“large” font, fix tag swap bug in TSIC table which is source table for cvar variation
table, fix autohinter bug.

Version 6.30 [August, 2018 release]
The following are the changes since the 6.20 [March, 2017 release] release of VTT:
Support for Open Type Font Variations including Intermediates. Previously, VTT
only supported varying CVTs at the extremes of axes in the design space. VTT now
can vary CVTs anywhere in the design space, including intermediate points
between axis masters, and the corners of the design space.

Updated UI in Variation CVT Windows. The Variation CVT window now clearly
shows you how CVTs change at the selected point in the design space: it tells you
which CVTs you have edited at that point, which CVTs are varying due to nearby
deltas, and which CVTs are unchanged. You can also add, edit and remove
instances represented in the cvar table. You can create temporary instances
without deltas so you can quickly switch between points in the design space to
proof your work. Finally, any can name any instance you create to make it easy to
keep track of them.
Visual TrueType and FontTools. Visual TrueType uses a port of the FontTools varLib
library when computing variation delta data for the cvar table.
Visual TrueType includes a command line utility vttshell.exe. This utility can be
used to compile and/or strip sources from a font containing Visual TrueType source
data. Usage options are available using the command vttshell.exe -? .

Version 6.20 [March, 2017 release]
The following are the changes since the 6.10 [February, 2016 release] release of VTT:
Support for Open Type Font Variations. You can use VTT to hint variable fonts
using the new Variation CVT and Variation Windows, described below. VTT will
generate a cvar table based on CVTs shown in the Variation CVT window. Currently,
VTT only supports varying CVTs for masters at the extrema of variable font axes.
Support for intermediate cvar variations (e.g. for named instances) is in the plans
for a future release. Documentation is forthcoming, but a blog post with workflow
and instructions is available at http://aka.ms/vtt-variations .
Variation CVT Window. You can use this window to select which variable font
instance you would like to proof in the Waterfall, Text Sample, and Variation
Windows (see below). When you select a master instance, you can adjust the CVTs
for that instance; just type a change and hit Ctrl-R to recompile. The Variation CVT
window will show you which CVTs vary across the font and how they differ from
the default instance. If you select an intermediate instance, you can inspect the
interpolated CVTs for that instance. VTT does not yet support editing intermediate
instance CVTs.
Variation Window. The Variation window shows you the current glyph outline and
hints, just like the Main window, for the instance selected variable font instance
(see above). With both the Main and Variation windows up, you can edit hints in
the Main window and see the impact on variations in the Variation window.
Because hints in a variable font are associated with the default instance and merely
follow interpolated CVTs for other instances, you can only edit hints in the Main
window.

Exporting Control Program to XML. VTT 6.01 added the ability to dump a fonts
hints to an XML file for import into other fonts. Unfortunately, this did not include
the Control Program. VTT 6.20 will now include the Control Program in XML export
and import.

Version 6.10 [February, 2016 release]
The following are the changes since the 6.01 [August 31, 2015 release] release of
VTT:
Autohinter for Latin and East Asian fonts. The new Autohinting modes makes use
of a new lightweight hinting strategy, that is best suited to today's rendering
environments, such as DirectWrite. Most Autohinters generate low level hinting
instructions that you cannot easily edit or improve. This new Autohinter generates
high-level hints that you can easily edit via VTT's graphical user interface.
Ability to automatically generate a "Control Value Table" for Latin fonts, saving
you time, so that you can begin adding "Visual hints" to your font straight away,
without the need to measure the font, and manually fill in the relevant CVT entries.
Error and Warnings Limit. When you open a font, VTT will show a list of errors and
warnings it detects in a font. If there are many errors and warnings in the font, this
may slow down the process of opening a font file. To speed up opening time, you
can set a limit on how many errors and warnings to display.
Legacy Compile. Set this option to ensure that your font will compile exactly the
same as it did in Versions 4 and below of VTT.
Check box added to allow future suppression of Import binary hints message
when opening a font with no source data.
Brand new Icon for VTT, & new icons for the Graphical Hinting interface.
Various bug fixes related to performance.

Version 6.01 [August 31, 2015 release]
Now available via the download center! This and future releases will be freely
available on the Microsoft Download Center . No more faxing in license
agreements
Color font support (COLR/CPAL tables). Glyphs with color layers defined in the
COLR and CPAL tables render in color throughout VTT so you can proof color
glyphs.
Updated rasterizer. The rasterizer has been updated to be even more accurate,
and now includes the ClearType Grey rendering mode used by default in Windows
8 and 10.

Export / Import hints from XML. Export or import VTTTalk and all low-level code
to/from an XLM file. Handy for doing global find and replace operations in a text
editor, or for moving hints to another point-for-point compatible font. See the
help file within VTT for more details.
Import binary font hints. When opening fonts without VTT source data, you can
import the binary data to low-level code you can edit.
Unicode sample text. Sample text and test strings now support Unicode
characters, including surrogates. You can also jump to any character by entering its
Unicode value in the Goto Character dialog, or by typing or pasting in the main
window.
New keyboard shortcuts. You can press Ctrl + Up arrow and Ctrl + Down arrow to
quickly change resolutions. We also added shortcuts to turn off many of the
rasterization options (e.g. Ctrl + Shift + G for ClearType Grey, Ctrl + Shift + F for
subpixel positioning, etc). For details, see the keyboard shortcut section of the
online help within VTT.
Use the space bar to pan. Like many other font design applications, you can now
hold down the space bar and drag the mouse cursor in order to pan the main
window. The left shift key continues to work for panning as in past versions of VTT.
Single test string. The main window now only shows one test string. This test
string shows text with hinted advance widths. The second test string, which
showed text with unhinted advance widths (i.e. metrics), has been removed.
PostScript names now visible. If present, the PostScript name for the current glyph
is shown in the status area at the top of the main window.
New pixel grid display. The Show Grid display option now shows a border around
all pixels, not just activated pixels
Support for high-dpi display. VTT renders everything without any operating
system display scaling, so that the rasterizations you see are exactly what you
would get.

Visual TrueType 4.2 release notes
Article • 03/23/2022

New features
VTT will install itself into the registry such that you can right-click a font and open
it in VTT, as soon as you have used VTT once.
The UI elements, and separately, the control point size, are now scalable in a range
of 50% to 200%. Choose Tools => Options => Appearance => Scale Visual
instructions. Recommended settings for 96 dpi W95: 100% for control points, 75%
for all other symbols. The smaller the symbols, the less space they use up on small
screens, but the harder they may be to grab.
Gray scaling now has a 4th option, NT-compatible, performing gamma correction
in much the same way Windows 2000 does.
VTT contains the TT Secure Rasterizer 1.7 as used in Windows 2000.
In collaboration with Monotype's Jelle Bosma and Thomas Rickner, new variants of
the Align and Stroke commands have been implemented. (For the TT savvy users:
The command's functioning is somewhat proprietary, but their behavior is much
more predictable and sensible, as far as the choice of the freedom vector is
concerned.) The UI will automatically generate the new align and stroke
commands, since we think they're superior to the old ones, but the old ones will
continue to work.
The new align and stroke commands come in two flavors, a strict one, and a
somewhat more relaxed one. The reason behind this is that at small ppem sizes we
cannot render ink traps and similar deviations from straight lines, hence we'd
prefer to strictly align the respective points for the benefit of a more regular pixel
pattern. At some (user-defined) ppem size, we'd rather unlock this strict grip for
the align command to render the ink trap more truthfully. To decide at which
ppem size this transition should happen, choose Tools => Options => Glyph
visuals => Ppem Limits. The align and stroke commands will appear with a padlock
on them. Go to the ppem size at which you'd like to unlock the strict grip, right
click the padlock, and choose the open padlock.

A padlock currently set to open at 27 ppem, giving the option to open it at 23
ppem (which happens to be the current ppem size of the main window) or to close

the padlock
If the padlock was already open, you can choose to lock it up again, or to open it at a
different ppem size. Note: To use this feature you will need to import the new
FpgmTmpl.txt, as it generates a call to function 82 that has been added recently.
The UI for the new stroke command will allow to "stroke" characters "outside in",
as depicted in the "v" below:

A "v" with the strokes "outside-in"
This method is sometimes preferred to "inside-out". For either case, there are tradeoffs.
"Outside-in" will faithfully render the "outside" of the "v" and let you control the joint of
the strokes, while it may fill in the ink trap too much at unfortunate sizes. "Inside-out"
will faithfully render the counter, not filling in the ink trap, but may result in the joint
being too wide or too narrow.
The aligns and particularly the strokes being somewhat bulky, as far as their
graphical representation is concerned, a short-cut has been added to quickly turn
them on or off. Choose Ctrl+Shift+A for toggling the aligns, Ctrl+Shift+S for the
strokes. Note that for the aligns and strokes to be visible at all, both x and y
directions must be turned on (short-cuts Ctrl+Shift+X and Ctrl+Shift+Y
respectively).
The delta commands have been optimized for the size of the code generated.
Note: To use this feature you will need to import the new FpgmTmpl.txt, as it
generates a call to functions 70 through 73 that have been added recently.

The delta tool has been enhanced to allow to apply deltas that are specific to
either black-and-white or grey-scale mode. To use a black-and-white specific delta,
make sure grey-scaling is turned off, and right-click the point to delta. You'll get a
slightly different panel indicating the fact that this delta will apply to "b/w only":

A 2/8 pixel inline black-and-white only delta
To use a grey-scaling only delta, make sure that grey-scaling is turned on, and right-click
the point to delta. Now the panel indicates that this delta will apply to "grey only":

A 6/8 pixel inline grey only delta
The size of the code is now displayed in the glyf, prep, and fpgm windows for your
reference. It may be illustrative to try out different linking strategies, which are
equivalent as to the pixel pattern yielded, but which differ in size. It may also be
illustrative to know, how much code is generated by possibly too many deltas, and
how that compares to the amount of code resulting from a smarter linking
strategy.
An option has been added to visualize the VDMX for the current glyph at the
current size. To use this option, choose Tools => Options => Glyph visuals =>
VDMX Heights. If present and in gridfit mode, the respective values will appear as
a pair of green lines.
An option has been added to visualize the instructed metrics for the current glyph
at the current size. Choose Tools => Options => Glyph visuals => instructed
metrics, and if in gridfit mode, the respective values will appear as a pair of green
lines.
An option has been added to fix the orientation of contours. TrueType expects
outer contours to run clockwise, and inner contours to run counter-clockwise.
When importing files produced by Fontographer, this may sometimes be wrong.
Choose Tools => Options => Glyph visuals => outline errors, and VTT will check
each glyph as it appears in the main window, alert if there is a problem, and ask for
permission to fix the orientation. If denied, the offending contour(s) will be
displayed in red. If granted, VTT will fix the orientation. VTT will preserve any hints
that may be present on that outline, if all the hints have been generated visually. If
some commands were entered into the VTT talk window manually, and if these
commands don't have a visual representation (such as ASM statements or function

CALLs), VTT will not be able to preserve the hints and ask for permission to remove
them on that particular glyph.
CVT categories have been added for absolute (square, flat) heights and relative
(round, overshoot) heights. This permits the UI to automatically choose a CVT for
control points that are rounded in y-direction. Note: to use this feature you will
need to import the new CvtTmpl.txt, as it is already set up with the appropriate
attributes. If you like to add the attributes to your own old template manually (cf.
below regarding the new control program), choose Edit => Edit CVT attributes, set
the link color to "grey", the link direction to "Y", and for the cvt category choose
either "Square Height" or "Round Height", depending on whether it's the actual
height or the overshoot.
Sometimes, you may wish to round a control point in y-direction without using a
CVT. To do so, right-click the anchor symbol, and choose no cvt.
Cvt (right) or not (left)?
VTT now supports an IntelliMouseTM as short-cut to certain navigational
operations. To use this device under Windows 95, the respective driver will have to
be installed. Windows NT supports it by default. Refer to the Quick Reference
Guide below for a description of the short-cuts.
Last but not least, the main window now has a 16 level undo/redo feature. It is
activated in "the usual way", i.e. Ctrl+Z undoes the previous modification, hitting
Ctrl+Z up to 16 times undoes up to 16 modifications, and likewise, Ctrl+Y redoes
them. This might come in handy in such situations where a newly added link or
interpolation has caused another link to be removed.
Control Program
A high-level language integrated control value and preparation program table has been
added. Its main goal is to simplify the definition of control values and the specification
of their behavior under scaling ("inheritance") by combining VTT's current private "cvt"
and "prep" tables into a single private table (named "control program", contracted from
"control values" and "preparation program") and avoid the typographers having to
program in an assembly language. The new control program replaces the current private
"cvt" and is compiled into the "prep" table. The control program is declarative in nature,
making it easier to learn for non-programmers since it avoids having to sequence
commands. Previous versions of the "cvt" will continue to work, but will not benefit from
automatic generation of the "prep" out of the control program. It is therefore strongly
recommended that users give it a try, as it comes with the following features:

It increases the range of cvt attributes by allowing user definable character groups
and feature categories, simply because in today's WGL-4 fonts (let alone expert
sets) not all glyphs fall into the 4 hard-wired categories "uppercase", "lowercase",
"figure", and "other". Further character groups and feature categories can be
added into the new control program, along with the sequence of glyphs needed to
visualize the spacing.
It increases the granularity level at which the glyphs' stroke angle can be declared
and used. Previously, this was declared on a per glyph basis in VTT Talk and used
on a per font basis in the cvt (hard-wired cvts 2 and 36). Now it is done in the
control program on a per character group basis, or on the basis of subgroups
within a character group that share the same stroke angle. Furthermore, the stroke
angle declaration now allows for regularizing varying stroke angles into a single
stroke angle at sufficiently small ppem sizes, since standard "inheritance" can be
used on the respective cvts for the italic runs.
Along with the increased granularity of the glyph stroke angle, the graphical userinterface has been adjusted. The stroke angle tool now produces a pair of arrows
as illustrated below:

Glyph stroke angle with italic run cvt 38 and rise cvt 39
Left click and drag the mouse to draw the angle, right click the cvts to change them. Be
sure to turn on both x and y direction, and to turn off grid-fitting and pixels.
The control program allows "relative" inheritance, as previously used for heights
and their overshoots only, on all other cvts, too. This permits e.g. to easily force a
round stroke to be at least 1 pixel thicker than a straight stroke, at and above a
given ppem size.
It uses the same high-level syntax for the cvt-deltas as is used for the regular
deltas in VTT Talk, making it easier to use and permitting the compiler to perform
the same optimizations it does already for the regular deltas.

It simplifies the management of global settings, such as cvt cut-ins, drop-out
control cut-off ppem size, and the range of ppem sizes within which to have
instructions turned on, as they are now done in 3 simple high-level language
statements.
It eliminates the need for the embarrassing hex numbers previously used to specify
cvt attributes.
Note: To use the new control program, you will need to import the new FpgmTmpl.txt, as it
generates calls to functions 83, 84, 85, and 88 that have been added recently. The
CvtTmpl.txt has been updated accordingly, along with the CharGrp.txt template. The
CvtTmpl.txt explains the syntax of the control program step-by-step, using real examples
and lots of comments. It will be easy to learn merely by extending the examples given. The
CharGrp.txt has been adapted slightly to match all other textual tables.

Quick Reference Guide to VTT's secret shortcuts for power users
Main Window
Shortcut

Description

Leftclick+Shift+drag
mouse

Pans main window

Left-click+Alt

Zooms in main window (zooming will continue in small increments while
mouse button and Alt key are depressed)

Left-click+Ctrl

Zooms out main window (zooming will continue in small increments while
mouse button and Alt key are depressed)

Left-click+Ctrl+Alt

Toggles between zoom-to-fUnit (zooms in main window enough such that
one fUnit equals one pixel) and zoom-to-fit (zooms out main window
enough such that font height will fit in window)

Left-click+Alt+drag
mouse

Zooms in and pans main window

Leftclick+Ctrl+drag

Zooms out and pans main window

mouse
Leftclick+Ctrl+Alt+drag
mouse

Toggles between zoom-to-fUnit and zoom-to-fit and pans main window

Shortcut

Description

Click wheel+drag
mouse

Pans main window

Rotate wheel

Zooms in main window

towards you
Rotate wheel away
from you

Zooms out main window

Click+rotate wheel
towards you+drag
mouse

Zooms in and pans main window

Click+rotate wheel

Zooms out and pans main window

away+drag mouse
Up arrow

Increase ppem size by 1

Down arrow

Decrease ppem size by 1

Shift+up arrow

Increase ppem size by 10

Shift+down arrow

Decrease ppem size by 10

Right arrow

Go to next glyph/character

Left arrow

Go to previous glyph/character

any character

Go to that character

While using the move control points tool
Shortcut

Description

Left click control
point

Selects control point for subsequent moving, deselecting any previously
selected control point

Right click
control point

Selects control point without deselecting any previously selected control
points

Left double-click
control point

Selects all control points of the contour, deselecting any previously selected
control point

Right double-

Selects all control points of the contour_ without_ deselecting any previously

click control
point

selected control points

Left click and
drag marquee

Selects all control points in marquee, deselecting any previously selected
control point

Shortcut

Description

Right click and
drag marquee

Selects all control points in marquee, without deselecting any previously
selected control points

Left, up, right, or

Moves the selected control points by 1 fUnit. This is used typically for cleanup

down arrow

up outlines after they have been converted from a different outline format

Shift+left, up,
right, or down
arrow

Moves the selected control point by 10 fUnits

While using the insert control points tool
Shortcut

Description

Left click

Inserts a control point into the closest contours; if "Show fewer points" is on, then
inserts an on-curve point, else an off-curve point

Right
click

Starts a new contour with a single control point. This will always create an on-curve
point and is used typically for adding an attachment point for composite glyphs

While using the link tool and while right mouse button is depressed on minimum distance
symbol
Shortcut

Description

Alt

Increase minimum distance resolution from 1/8 of a pixel, in turn, to 1/16,
1/32, and 1/64 of a pixel

Ctrl

Decrease minimum distance resolution from 1/8 of a pixel, in turn, to 1/4,
1/2, and 1/1 of a pixel

Rotate wheel
towards you

Increase minimum distance resolution from 1/8 of a pixel, in turn, to 1/16,
1/32, and 1/64 of a pixel

Rotate wheel away

Decrease minimum distance resolution from 1/8 of a pixel, in turn, to 1/4,

from you

1/2, and 1/1 of a pixel

While using the link, shift, interpolate, or stroke tool, and while the right mouse button is
depressed on the cvt symbol
Shortcut

Description

Shift

Toggles between the CVT numbers sorted in numerical order or sorted by CVT
attribute

Shortcut

Description

Click
wheel

Toggles between the CVT numbers sorted in numerical order or sorted by CVT
attribute

While using the delta or move tools and while left or right mouse button is depressed
Shortcut

Description

Alt

Increase delta or move resolution from 1/8 of a pixel, in turn, to 1/16,
1/32, and 1/64 of a pixel

Ctrl

Decrease delta or move resolution from 1/8 of a pixel, in turn, to 1/4, 1/2,
and 1/1 of a pixel

Shift

Change delta or move from post-IUP, in turn, to inline, pre-IUP, and back
to post-IUP

Rotate wheel towards

Increase delta or move resolution from 1/8 of a pixel, in turn, to 1/16,

you

1/32, and 1/64 of a pixel

Rotate wheel away
from you

Decrease delta or move resolution from 1/8 of a pixel, in turn, to 1/4, 1/2,
and 1/1 of a pixel

Click wheel

Change delta or move from post-IUP, in turn, to inline, pre-IUP, and back
to post-IUP

Bugs fixed
On W95 platforms, zooming in with pixels displayed occasionally would crash, this
has been tracked down to a restriction in a W95 API and a workaround was
implemented
VTT wouldn't let you open read-only fonts, now it will
Always forces integer ppem sizes in the HEAD table
Correctly updates the "modified" date in the HEAD table
Correctly handles larger format 4 CMAPs
Correctly handles format 6 CMAPs
Numerous other cosmetic issues have been fixed, all of which I don't remember

Hinting italics using Visual TrueType
Article • 03/23/2022

７ Note
For this explanation of italic hinting, a working knowledge of Microsoft Visual
TrueType graphical hinting is assumed.
There are many ways one could hint italic characters, the following is a quick and simple
guide using the graphical hinting tools available in the latest version of VTT. I am
assuming you have set up your font in VTT, and now have a Control Program. Make sure
you fill in the italic rise and run cvts for caps (cvt 20 and 21 in the standard template)
and lowercase (cvt 22 and 23), otherwise VTT will assume the font is upright and will not
give you the option to set the 'GlyphStrokeAngle'. (Likewise for figures and all other
character groups that have italics.)

Let us start with a sanserif, italic, capital letter 'I'. Make sure grid fit and pixels are off,
and 'x' and 'y' links are on. Select the 'GlyphStrokeAngle' tool (the one above the 'x-link'
tool). Select the bottom left corner of the stem and drag the cursor to the top left
corner. A pair of arrows appear, with cvts 20 (italic run) and 21 (italic rise). You can rightclick the interstate signs to change these cvts where necessary. VTT will look for:

UpperCase Grey X ItalicRun absolute
UpperCase Grey Y ItalicRise absolute

For characters with no italic stroke, such as an 'o', drag the tool from the origin in the
direction of the italic stroke.

For fonts with differing italic stroke angles (such as Garamond), you can introduce new
cvts for different italic runs. The rise (x-height for lowercase, cap height for Uppercase)
should be the same for any new runs. Now that you have several varying run cvts, you
may wish to make them all the same at smaller screen sizes. To do this you can overwrite
a run cvt with another run cvt until a specified size e.g. below 12 ppem all glyph stroke
angles become the same. This is 'inheritance', and can be controlled in the same way as
any other inheritance in the ControlProgram. Controlling italic angles with cvts will
become especially useful when attempting to delta the italic angle for a whole font or
range of characters.
Next, you can add your 'y' hints (I recommend always hinting the 'y' direction first).
Make sure that any points you intend to use in a stroke are touched in some way in the
'y' direction. In the case of the cap 'I', fix the bottom left corner to the grid in the 'x'
direction (if you don't, the stroke tool will do it for you). Select the diagonal stroke tool
and drag it from point 0 to 3, then point 1 to 2. An interstate sign will appear in the
middle of the stroke, which you can now edit. If the font you are working on has strokes
that taper, you can force them to stay straight until a specified size. Go to the (smallest)
size where you would like the stroke to taper, right click on the padlock in the middle of
your stroke (if you cannot see the padlock, choose ppem limits from the
Tools/Options/Glyph visuals menu). Select the open padlock.

For a sanserif italic character such as a cap 'H', hint the two stems and the horizontal bar
in the 'y' direction, then all that needs to be done in the 'x' direction is to hint the two
italic strokes, then diagonally align the points of the horizontal bar to the respective
sides of the strokes. Once again you will see a padlock, which allows you to switch off
the constraints of the align command at a chosen point, just as with the stroke. Notice
that with the padlock feature you can safely align points that belong to an 'inktrap',
since you can always open the padlock at the size at which there are enough pixels to
render the 'inktrap' (see also the VTT 4.2 release notes).

For an italic serifed capital 'I' the procedure is much the same. I would once again
recommend adding the 'y' hints first, being careful to make sure you touch the points in
'y' that you intend to use in the stroke ( a 'y' interpolate is generally best). As for which
points to use for the stroke, this is not always as obvious as one might think. I
recommend you use the off curve points at each end of the straights of the stroke (18 to
8 then 21 to 5 on the serifed cap) as this gives a nicer shape. Once the stroke is hinted,
you can then hint out to the end of the serifs using shifts, shifts and anchors, dists or
links as you see fit.

To space an italic character use the same methods as those used for upright fonts. Either
link from the sidebearing to a point on the character using a cvt, or simply anchor a
point. All other hinting is the same as that used for upright fonts.

Visual TrueType Private Table Formats
Article • 09/08/2021

The following tables are used by Visual TrueType to store hinting source data. These
tables should be removed from a font prior to shipping the font (e.g., using VTT’s “Ship
Font” option in the “Tools” menu).

TSI0 (Glyph Program Text Indices)
This table contains the information needed to access the glyph program text string data
(stored in table TSI1) for the individual glyphs, as well as for three tables used by Visual
TrueType (Pre-program, Font program, and CVT). This table should have the same size as
table TSI2.
Type

Name

Comments

uint16

glyphIndex

Glyph Index associated with this block of text (search via this field)

uint16

textLength

Length of text (or 0x8000 to indicate any value larger than 32767); does not
include null termination character.

uint16

textOffset

Offset from start of TSI1 table

uint32

textOffset

Offset from start of TSI1 table

For text with a length less than 32768, the actual length should be placed in the
textLength field. For text with a length greater than 32767, the value 0x8000 should be
placed in the textLength field.
This record is repeated once for each valid glyph index (“normal records”), and is then
followed by five more entries (“extra records”) at the end, as follows:
“Magic number” used to check for validity. For this entry, the glyphIndex field must
be set to 0xFFFE and the textOffset field is set to the magic number (0xABFC1F34).
Offset to Pre-program source data. Set the glyphIndex field to 0xFFFA.
Offset to CVT source data. Set the glyphIndex field to 0xFFFB.
Reserved. Set the glyphIndex field to 0xFFFC.
Offset to Font program source data. Set the glyphIndex field to 0xFFFD.
The table will then have the following structure:

glyphIndex

textLength

textOffset

Comment

0

length

actual offset

“normal” glyph index data

...

...

...

“normal” glyph index data

numGlyphs-1

length

actual offset

“normal” glyph index data

0xFFFE

0

0xABFC1F34

“extra” record (magic number)

0xFFFA

length

actual offset

“extra” record (ppgm data)

0xFFFB

length

actual offset

“extra” record (cvt data)

0xFFFC

length

actual offset

“extra” record (reserved)

0xFFFD

length

actual offset

“extra” record (fpgm data)

Because the actual length of a record may or may not be stored in the textLength field,
follow these rules to determine the actual length:
If the length stored in the record is less than 32768, then the actual length is the
length noted in the record.
If the length stored in the record is 32768 (0x8000), then the actual length is
computed as follows:
For the last “extra” record (the very last record of the table), the length is the
difference between the total length of the TSI1 table and the textOffset of the
final record.
For the last “normal” record (the last record just prior to the record containing
the “magic number”), the length is the difference between the textOffset of the
record following the “magic number” record and the textOffset of the last
“normal” record.
For all other records with a length of 0x8000, the length is the difference
between the textOffset of the record in question and the textOffset of the next
record.
The entries must be in glyphIndex order and textOffset order—except for the magic
number entry.
NOTE: VTT expects that glyph indices are contiguous with no gaps. (Thus, the
glyphIndex field is redundant for normal glyphs).
NOTE: VTT expects the "extra" records to be present, even if they are not used.

TSI1 (Glyph Program Text UTF-8 Text Dump)

This table contains straight text information: a series of glyph programs dumped endto-end with no delimiters. Table TSI0 provides the index and length data indicating the
text for each glyph. Text data should be UTF-8 encoded.

TSI2 (VTT Talk Text Indices)
This table contains the information needed to access the Text string data (stored in table
TSI3) for the individual glyphs’ VTT Talk information. The TSI2 table is organized similar
to the TSI0 table, and should have the same size as the TSI0 table.
Type

Name

Description

uint16

glyphIndex

Glyph Index associated with this block of text (search via this field)

uint16

textLength

Length of text (or 0x8000 to indicate any value larger than 32767)

uint32

textOffset

Offset from start of TSI3 table

For text with a length less than 32768, the actual length should be placed in the
textLength field.
For text with a length greater than 32767, the value 0x8000 should be placed in the
textLength field.
This record is repeated once for each valid glyph index, and is then followed by five
extra entries at the end, as follows:
“Magic number” used to check for validity. For this entry, the glyphIndex field must
be set to 0xFFFE and the textOffset field is set to the magic number (0xABFC1F34).
Reserved. Set the glyphIndex field to 0xFFFA.
Reserved. Set the glyphIndex field to 0xFFFB.
Reserved. Set the glyphIndex field to 0xFFFC.
Reserved. Set the glyphIndex field to 0xFFFD
The table will then have the following structure:
glyphIndex

textLength

textOffset

Comment*

0

length

actual offset

“normal” VTT Talk data

...

...

...

“normal” VTT Talk data

glyphIndex

textLength

textOffset

Comment*

numGlyphs-1

length

actual offset

“normal” VTT Talk data

0xFFFE

0

0xABFC1F34

“extra” record (magic number)

0xFFFA

length

actual offset

“extra” record (reserved)

0xFFFB

length

actual offset

“extra” record (reserved)

0xFFFC

length

actual offset

“extra” record (reserved)

0xFFFD

length

actual offset

“extra” record (reserved)

Because the actual length of a record may or may not be stored in the textLength field,
follow these rules to determine the actual length:
If the length stored in the record is less than 32768, then the actual length is the
length noted in the record.
If the length stored in the record is 32768 (0x8000), then the actual length is
computed as follows:
For the last “extra” record (the very last record of the table), the length is the
difference between the total length of the TSI3 table and the textOffset of the
final record.
For the last “normal” record (the last record just prior to the record containing
the “magic number”), the length is the difference between the textOffset of the
record following the “magic number” record and the textOffset of the last
normal record.
For all other records with a length of 0x8000, the length is the difference
between the textOffset of the record in question and the textOffset of the next
record.

TSI3 (VTT Talk UTF-8 Text Dump)
This table contains straight text information: a series of VTT Talk commands dumped
end-to-end with no delimiters. Table TSI2 provides the index and length data indicating
the text for each glyph. Text data should be UTF-8 encoded.

TSI4 Obsolete
TSI5 (VTT Character Group Flag)

This table contains character group information for each glyph. The table is a series of
records in glyph index order.
Type

Name

Description

uint16

charGroup

Character group flag

The character group flags are defined as follows:
Value

Description

1

Other (undefined)

2

Uppercase

3

Lowercase

4

Figure

5

Non-Latin

TSIC (VTT Variation CVT window source)
The TSIC table contains the "source" data for the Variation CVT window and thus the
cvar table that VTT generates. It includes a list of all the variation design space locations
that appear in this window, as well as any CVT values that vary at those locations.
The Variation CVT view in Visual TrueType contains a populated combo-box of locations
in variation space. Initially these locations are a union of locations found in named
instances, locations found in existing cvar, and locations found across the gvar table.
Users can also add locations to this list, either to add additional rows to the cvar table,
or to provide a location for proofing, by clicking the + button. All of the locations in the
list at save time appear as TSICRecords in the TSIC table. Each TSICRecord list the CVTs
and CVT values that the user varied at that location. Locations that were added by the
user merely for proofing will have no corresponding varied CVT values.

TSIC Header
Type

Name

Description

uint16

majorVersion

Major version – set to 1

uint16

minorVersion

Minor version – set to 1

uint16

flags

TSIC flags – set to 0

Type

Name

Description

uint16

axisCount

Must equal the axisCount field in the fvar table

uint16

recordCount

TSIC record count

uint16

reserved

Set to 0

Tag

AxisArray[axisCount]

Array of axis tags (must match fvar order)

F2Dot14

RecordLocations[recordCount]

Array of locations in variation space that

[axisCount]

correspond to each TSIC record; each location is an
array of axis values in the order specified in
AxisArray.

TSICRecords[recordCount]

Array of TSIC records

TSICRecord

AxisArray is an array of axis tags that specifies the order of axis values in the
RecordLocations array, and must match the tags and order defined in the fvar table.
Visual TrueType will invalidate data if axisCount and/or AxisArray do not agree with
corresponding data in the fvar table.
RecordLocations and TSICRecords are parallel arrays: RecordLocations provides the
coordinates in variation design space for each TSICRecord.

TSIC Record
Type

Name

Description

uint16

flags

Record flags - set to 0

uint16

numCVTEntries

Number of CVT number/value pairs (zero if location
only)

uint16

nameLength

Length of optional user record name (zero if no
name)

uint16

NameArray[nameLength]

Unicode 16 name

uint16

CVTArray[numCVTEntries]

CVT number array

FWORD

CVTValueArray[numCVTEntries]

CVT value

The TSICRecord lists the CVTs and CVT values that the user varied. CVTArray and
CVTValueArray are parallel arrays that specify CVT numbers and their corresponding
CVT values. The CVT number/value pairs will be the source data for the corresponding
location represented by the record. Note that the CVT values is a value, not a delta. If a
CVT does not have an entry it is assumed to be default.

Optionally, the TSICRecord can also supply a name for the location represented by the
record to be used in the location dropdown list in the Variation CVT window. When prepopulating this list, VTT will use names defined in named instances in the fvar table
whenever possible.

TSIS (VTT GSUB Table Text Source)
This table contains the text source for the GSUB layout table.
This table is obsolete and no longer used.

TSIP (VTT GPOS Table Text Source)
This table contains the text source for the GPOS layout table.
This table is obsolete and no longer used.

TSID (VTT GDEF Table Text Source)
This table contains the text source for the GDEF layout table.
This table is obsolete and no longer used.

TSIB (VTT BASE Table Text Source)
This table contains the text source for the BASE layout table.
This table is obsolete and no longer used.

TSIJ (VTT JSTF Table Text Source)
This table contains the text source for the JSTF layout table.
This table is obsolete and no longer used.

OpenType font signing tool
Article • 06/16/2022

This tool was developed for use at Microsoft, and is unsupported externally. Microsoft
makes no claims and holds no liability regarding the external use of this tool. This tool is
copyrighted. Redistribution is restricted. See the tool's End User License Agreement for
details.
Besides the tool provided, to sign a font file you will also need a
*.spc file and a *.pvk file.
You can create a test.spc and test.pvk for testing purposes with the tools provided in the
font signing tool, but when you want to sign a font file "for real" you need to obtain
these files from Certification Authority such as Verisign. When contacting a Certification
Authority apply for a 'Class 3 Authenticode digital signature'. Asking for a 'font-signing
certificate' is not a good idea, as the certificate you need is not specific to font signing.
The .spc file containing your public key and other information, resides on your hard
drive, and it can be distributed to others.
The .pvk file contains a private key that corresponds to the public key in the .spc file.
Once you have received a .pvk file from Certification Authority it is recommended that
the file should NEVER be stored on your hard drive and should always be stored on a
floppy disk and be used as needed.

Signing OpenType font files
Minimum system requirements:
Window 2000: Beta 3 or higher, or
Windows NT 4 + SP 4, or
Windows 9x + IE 5

Download the tool
download - Select one of the locations listed below and download disg.exe to your
computer in a folder such as C:\FontSign
Download Link

File Details - dsig.exe - 192KB self extracting file Windows 2000 and Windows NT users You must have administrator privileges to use this tool.

Step 1
Windows NT/2000: Move mssipotf.dll to winnt\system32
Windows 9x: Move mssipotf.dll to \windows\system

Step 2
Register the mssipotf.dll with Windows, by typing the following at the command
prompt,
regsvr32 mssipotf.dll

Step 3
To sign a font file eg. myfont.TTF, go to the folder where you downloaded the font
signing tool, and at the command prompt type,
signcode -spc my.spc -v my.pvk -j mssipotf.dll myfont.ttf
The -j mssipotf.dll option is reqired for successfully signing font files and therefore, must
be included in the command prompt. This option tells signcode that mssipotf.dll
contains code that will perform a series of checks on the font to determine glyph
integrity. This process may take a few seconds or many minutes, depending on how
many glyphs are in the font file. If the font does not pass this verification test, signing
will fail. Signcode has many other command line options and you can learn about them
by typing Signcode -? at the command prompt. Other recommended options to include
in the command line are,
-n "My Font name"
-i http://www.mycompany.com
-t http://timestamp.verisign.com/scripts/timstamp.dll
The three options above will add font's name, link it your site and add a time stamp to
the digital signatures certificate.

Step 4
A successfully signed font file can be verified using chktrust.exe:

chktrust myfont.otf
Another way to verify a signed file on Windows 2000 and Windows 98 is to 'right-click'
the font file and select 'properties'. A 'Digital Signatures' tab will be displayed that
provides more detail about the signature, including the timestamp (if it was used in
signing).
Note that in Windows 2000 the icon associated with a signed font file is the OpenType
logo (an O), rather than the TrueType logo (a TT). However, signed TTCs still have the TT
logo.

Recommendations
In general you should always test sign a font before signing it for real. You'll need to
create a dummy version of your own .cer and .pvk files by going to the directory where
you downloaded the font signing tool and type the following on the command line
makecert -n CN=JoeBob -sv test.pvk test.cer
cert2spc test.cer test.spc
setreg 1 TRUE
Makecert will create .cer and .pvk files, and the associated certificate will be called
"JoeBob". A dialog box will ask you to provide a password for the .pvk file and then ask
to confirm the password each time the .pvk file is used.
Finally, to test sign a font, at the command prompt type the following
signcode -spc test.spc -v test.pvk -j mssipotf.dll myfont.ttf
Note: In the above example we have used minimal signcode options as we are only test
signing a font file.
You can also modify the signdemo.bat provided with the font signing tool according to
your font and company then type
Signdemo MyFont.ttf
If you sign a file with a test certificate, the signed file should NOT be distributed for
official purposes.

Troubleshooting

Here are some frequently asked questions:
Q: I've downloaded the font tool but don't see the misipotf.dll.
A: You need to set the folder setting to view all files. See Windows
documentations on how to do that.
Q: I'm running out of space at the DOS prompt?
A: Windows 95 and 98 have by default a limit on how many characters can be
typed in at the command prompt. Therefore, depending on what options you
use and the length of some options (i.e. your font name, company's URL and
timestamp URL) you may not be able to type in all the options you want to use
to sign your fonts. In this case, you can edit the "Signdemo.bat" batch file to
include all the options you want to use. To open the file, right-click on
"Signdemo.bat" and choose the "Edit" option, then modify the options as
needed. Close the file and type "Signdemo MyFont.ttf" at the DOS prompt.
Q: I Can't sign the file because the file was read-only.
A: Signing alters the file, so it can't be read-only. Change the file attributes and
try signing again.
Q: It takes a long time to sign.
A: As the -j option invokes code that does glyph integrity checks, signing may
take a long time. Be patient.
Q: Will having other copies of mssipotf.dll on the system cause problems?
A: Older versions of mssipotf.dll may be invoked if they are in the execution
path. It is best to make sure there is only one mssipotf.dll in the entire system
(in the \winnt\system32 directory).
Q: I get an error during the signing process
A: This will probably be due to the font not meeting the signing criteria listed
below.

Font file criteria

As files other than font files are signed in different ways. To identify a file as a font file,
the file must meet certain criteria. The criteria are outlined below.
1. The magic number in the head table is correct.
2. Given the number of tables value in the offset table, the other values in the offset
table are consistent.
3. The tags in the table directory, which contains pointers to the beginning of each
table, must appear in alphabetical order and have no duplicates.
4. The offset of each table is a multiple of 4. (That is, tables are long word aligned.)
5. The first actual table in the file comes immediately after the directory of tables.
6. If the tables are sorted by offset, then for all tables i (where index 0 means the
table with the smallest offset),
Offset[i] + Length[i] <= Offset[i+1] and
Offset[i] + Length[i] >= Offset[i+1] - 3.
7. In other words, the tables do not overlap, and there are at most 3 bytes of padding
between tables.
8. The pad bytes between tables are all zeros.
9. The offset of the last table in the file plus its length is not greater than the size of
the file.
10. The checksums of all tables are correct.
11. The file checksum in the head table is correct.
Signcode will not sign and chktrust will not verify if the font file does not meet all of the
above criteria.
The philosophy behind these rules is that the more structure that is imposed on a font
file, the less likely a malicious entity will be able to disguise a bad font file to look like a
good one. This will become more important as other kinds of signatures are employed
to sign font files.

Uninstalling
You can disable font signing and verification by unregistering mssipotf.dll:

regsvr32 /u mssipotf.dll
Optionally, you can then delete mssipotf.dll.

END-USER LICENSE AGREEMENT FOR
MICROSOFT SOFTWARE
IMPORTANT-READ CAREFULLY: This Microsoft End-User License Agreement ("EULA") is a
legal agreement between you (either an individual or a single entity) and Microsoft
Corporation for the Microsoft software product identified above, which includes
computer software and may include associated media, printed materials, and "online" or
electronic documentation ("SOFTWARE PRODUCT"). The SOFTWARE PRODUCT also
includes any updates and supplements to the original SOFTWARE PRODUCT provided to
you by Microsoft. Any software provided along with the SOFTWARE PRODUCT that is
associated with a separate end-user license agreement is licensed to you under the
terms of that license agreement. By installing, copying, downloading, accessing or
otherwise using the SOFTWARE PRODUCT, you agree to be bound by the terms of this
EULA. If you do not agree to the terms of this EULA, do not install or use the SOFTWARE
PRODUCT.

SOFTWARE PRODUCT LICENSE
The SOFTWARE PRODUCT is protected by copyright laws and international copyright
treaties, as well as other intellectual property laws and treaties. The SOFTWARE
PRODUCT is licensed, not sold.
1. GRANT OF LICENSE. This EULA grants you the following rights:
Software Product. You may install and use the SOFTWARE PRODUCT on an
unlimited number of computers, including workstations, terminals or other digital
electronic devices ("COMPUTERS") residing on your premises for the sole purpose
of adding a digital signature to your TrueType or OpenType font.
2. DESCRIPTION OF OTHER RIGHTS AND LIMITATIONS.
Limitations on Reverse Engineering, Decompilation, and Disassembly. You may
not reverse engineer, decompile,. or disassemble the SOFTWARE PRODUCT, except
and only to the extent that such activity is expressly permitted by applicable law
notwithstanding this limitation.
Rental. You may not rent, lease or lend the SOFTWARE PRODUCT

Software Transfer. You may permanently transfer all of your rights under this EULA,
provided you retain no copies, you transfer all of the SOFTWARE PRODUCT
(including all component parts, the media and printed materials, any upgrades, this
EULA, and, if applicable, the Certificate of Authenticity) and the recipient agrees to
the terms of this EULA. If the SOFTWARE PRODUCT is an upgrade, any transfer
must include all prior versions of the SOFTWARE PRODUCT. You may not distribute
the SOFTWARE PRODUCT.
Termination. Without prejudice to any other rights, Microsoft may terminate this
EULA if you fail to comply with the terms and conditions of this EULA. In such
event, you must destroy all copies of the SOFTWARE PRODUCT and all of its
component parts.
3. COPYRIGHT. All title and intellectual property rights in and to the SOFTWARE
PRODUCT (including but not limited to any images, photographs, animations,
video, audio, music, text, and "applets" incorporated into the SOFTWARE
PRODUCT), the accompanying printed materials, and any copies of the SOFTWARE
PRODUCT are owned by Microsoft or its suppliers. All title and intellectual property
rights in and to the content which may be accessed through use of the SOFTWARE
PRODUCT is the property of the respective content owner and may be protected
by applicable copyright or other intellectual property laws and treaties. This EULA
grants you no rights to use such content. All rights not expressly granted are
reserved by Microsoft.
4. U.S. GOVERNMENT RESTRICTED RIGHTS. All SOFTWARE PRODUCT provided to the
U.S. Government pursuant to solicitations issued on or after December 1, 1995 is
provided with the commercial license rights and restrictions described elsewhere
herein. All SOFTWARE PRODUCT provided to the U. S. Government pursuant to
solicitations issued prior to December 1, 1995 is provided with "Restricted Rights"
as provided for in FAR, 48 CFR 52.227-14 (JUNE 1987) or DFAR, 48 CFR 252.2277013 (OCT 1988), as applicable.
5. EXPORT RESTRICTIONS. You agree that you will not export or re-export the
SOFTWARE PRODUCT, any part thereof, or any process or service that is the direct
product of the SOFTWARE PRODUCT (the foregoing collectively referred to as the
"Restricted Components"), to any country/region, person or entity subject to U.S.
export restrictions. You specifically agree not to export or re-export any of the
Restricted Components: (i) to any country/region to which the U.S. has embargoed
or restricted the export of goods or services, which currently include, but are not
necessarily limited to Cuba, Iran, Iraq, Libya, North Korea, Sudan, Syria, Bosnia and
Herzegovina, Croatia, North Macedonia, Serbia, and Slovenia, or to any national of
any such country/region, wherever located, who intends to transmit or transport
the Restricted Components back to such country/region; (ii) to any person or entity

who you know or have reason to know will utilize the Restricted Components in
the design, development or production of nuclear, chemical or biological weapons;
or (iii) to any person or entity who has been prohibited from participating in U.S.
export transactions by any federal agency of the U.S. government. You warrant and
represent that neither the BXA nor any other U.S. federal agency has suspended,
revoked or denied your export privileges.

MISCELLANEOUS
If you acquired this product in the United States, this EULA is governed by the laws of
the State of Washington.
If you acquired this product in Canada, this EULA is governed by the laws of the
Province of Ontario, Canada. Each of the parties hereto irrevocably attorns to the
jurisdiction of the courts of the Province of Ontario and further agrees to commence any
litigation which may arise hereunder in the courts located in the Judicial District of York,
Province of Ontario.
If this product was acquired outside the United States, then local law may apply.
Should you have any questions concerning this EULA, or if you desire to contact
Microsoft for any reason, please contact Microsoft, or write: Microsoft Sales Information
Center/One Microsoft Way/Redmond, WA 98052-6399.

NO WARRANTIES.
DISCLAIMER OF WARRANTIES. To the maximum extent permitted by applicable law,
Microsoft and its suppliers provide the SOFTWARE PRODUCT and any (if any) Support
Services AS IS AND WITH ALL FAULTS, and hereby disclaim all warranties and
conditions, either express, implied or statutory, including, but not limited to, any (if
any) implied warranties or conditions of merchantability, of fitness for a particular
purpose, of lack of viruses, of accuracy or completeness of responses, of results, and
of lack of negligence or lack of workmanlike effort, all with regard to the SOFTWARE
PRODUCT, and the provision of or failure to provide Support Services. ALSO, THERE IS
NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT, QUIET POSSESSION,
CORRESPONDENCE TO DESCRIPTION OR NON-INFRINGEMENT, WITH REGARD TO
THE SOFTWARE PRODUCT. THE ENTIRE RISK AS TO THE QUALITY OF OR ARISING
OUT OF USE OR PERFORMANCE OF THE SOFTWARE PRODUCT AND SUPPORT
SERVICES, IF ANY, REMAINS WITH YOU.

EXCLUSION OF INCIDENTAL, CONSEQUENTIAL AND CERTAIN OTHER DAMAGES. TO
THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, IN NO EVENT SHALL
MICROSOFT OR ITS SUPPLIERS BE LIABLE FOR ANY SPECIAL, INCIDENTAL, INDIRECT,
PUNITIVE OR CONSEQUENTIAL DAMAGES WHATSOEVER (INCLUDING, BUT NOT
LIMITED TO, DAMAGES FOR LOSS OF PROFITS OR CONFIDENTIAL OR OTHER
INFORMATION, FOR BUSINESS INTERRUPTION, FOR PERSONAL INJURY, FOR LOSS OF
PRIVACY, FOR FAILURE TO MEET ANY DUTY INCLUDING OF GOOD FAITH OR OF
REASONABLE CARE, FOR NEGLIGENCE, AND FOR ANY OTHER PECUNIARY OR OTHER
LOSS WHATSOEVER) ARISING OUT OF OR IN ANY WAY RELATED TO THE USE OF OR
INABILITY TO USE THE SOFTWARE PRODUCT, THE PROVISION OF OR FAILURE TO
PROVIDE SUPPORT SERVICES, OR OTHERWISE UNDER OR IN CONNECTION WITH
ANY PROVISION OF THIS EULA, EVEN IN THE EVENT OF THE FAULT, TORT
(INCLUDING NEGLIGENCE), STRICT LIABILITY, BREACH OF CONTRACT OR BREACH OF
WARRANTY OF MICROSOFT OR ANY SUPPLIER, AND EVEN IF MICROSOFT OR ANY
SUPPLIER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
LIMITATION OF LIABILITY AND REMEDIES. Notwithstanding any damages that you
might incur for any reason whatsoever (including, without limitation, all damages
referenced above and all direct or general damages), the entire liability of Microsoft
and any of its suppliers under any provision of this EULA and your exclusive remedy
for all of the foregoing shall be limited to the greater of the amount actually paid by
you for the SOFTWARE PRODUCT or U.S.$5.00. The foregoing limitations, exclusions
and disclaimers shall apply to the maximum extent permitted by applicable law, even
if any remedy fails its essential purpose.

